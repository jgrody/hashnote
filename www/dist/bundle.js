(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var pp = _state.Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
  var key = prop.key;var name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === _tokentype.types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();

  var validateDestructuring = false;
  if (!refDestructuringErrors) {
    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
    validateDestructuring = true;
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return left;
};

// Parse a ternary conditional (`?:`) operator.

pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  if (this.eat(_tokentype.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_tokentype.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

pp.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.left = left;
      node.operator = this.value;
      var op = this.type;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

pp.parseMaybeUnary = function (refDestructuringErrors) {
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === _tokentype.types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary();
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprSubscripts(refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  while (this.type.postfix && !this.canInsertSemicolon()) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.prefix = false;
    node.argument = expr;
    this.checkLVal(expr);
    this.next();
    expr = this.finishNode(node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

pp.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
  return this.parseSubscripts(expr, startPos, startLoc);
};

pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (this.eat(_tokentype.types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseIdent(true);
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.eat(_tokentype.types.bracketL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(_tokentype.types.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (this.type === _tokentype.types.backQuote) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp.parseExprAtom = function (refDestructuringErrors) {
  var node = undefined,
      canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
    case _tokentype.types._super:
      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");
    case _tokentype.types._this:
      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _tokentype.types._yield:
      if (this.inGenerator) this.unexpected();

    case _tokentype.types.name:
      var startPos = this.start,
          startLoc = this.startLoc;
      var id = this.parseIdent(this.type !== _tokentype.types.name);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
      return id;

    case _tokentype.types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case _tokentype.types.num:case _tokentype.types.string:
      return this.parseLiteral(this.value);

    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
      node = this.startNode();
      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _tokentype.types.parenL:
      return this.parseParenAndDistinguishExpression(canBeArrow);

    case _tokentype.types.bracketL:
      node = this.startNode();
      this.next();
      // check whether this is array comprehension or regular array
      if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
        return this.parseComprehension(node, false);
      }
      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case _tokentype.types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case _tokentype.types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _tokentype.types._class:
      return this.parseClass(this.startNode(), false);

    case _tokentype.types._new:
      return this.parseNew();

    case _tokentype.types.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(_tokentype.types.parenL);
  var val = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
    }

    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true;
    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== _tokentype.types.parenR) {
      first ? first = false : this.expect(_tokentype.types.comma);
      if (this.type === _tokentype.types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRest()));
        break;
      } else {
        if (this.type === _tokentype.types.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(_tokentype.types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, true);
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp.parseParenItem = function (item) {
  return item;
};

pp.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};

// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call — at
// least, not without wrapping it in parentheses. Thus, it uses the

var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction) this.raise(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === _tokentype.types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_tokentype.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_tokentype.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

pp.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var prop = this.startNode(),
        isGenerator = undefined,
        startPos = undefined,
        startLoc = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
    }
    this.parsePropertyName(prop);
    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
  if (this.eat(_tokentype.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
    if (isGenerator || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    prop.kind = "init";
    if (isPattern) {
      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_tokentype.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_tokentype.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
};

// Initialize empty function node.

pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};

// Parse object or class method.

pp.parseMethod = function (isGenerator) {
  var node = this.startNode();
  this.initFunction(node);
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
  this.parseFunctionBody(node, false);
  return this.finishNode(node, "FunctionExpression");
};

// Parse arrow function expression with given parameters.

pp.parseArrowExpression = function (node, params) {
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

// Parse function body and check parameters.

pp.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.inFunction,
        oldInGen = this.inGenerator,
        oldLabels = this.labels;
    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
  }

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction) {
    this.checkParams(node);
  }
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp.checkParams = function (node) {
  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) {
    this.checkLVal(node.params[i], true, nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
        refDestructuringErrors.trailingComma = this.lastTokStart;
      }
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    var elt = undefined;
    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
    elts.push(elt);
  }
  return elts;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === _tokentype.types.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};

// Parses yield expression inside generator.

pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_tokentype.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

// Parses array and generator comprehensions.

pp.parseComprehension = function (node, isGenerator) {
  node.blocks = [];
  while (this.type === _tokentype.types._for) {
    var block = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    block.left = this.parseBindingAtom();
    this.checkLVal(block.left, true);
    this.expectContextual("of");
    block.right = this.parseExpression();
    this.expect(_tokentype.types.parenR);
    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
  }
  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;
  node.body = this.parseExpression();
  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);
  node.generator = isGenerator;
  return this.finishNode(node, "ComprehensionExpression");
};

},{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){
// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

// Reserved word lists for various dialects of the language

"use strict";

exports.__esModule = true;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

exports.reservedWords = reservedWords;
// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " let const class extends export import yield super"
};

exports.keywords = keywords;
// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by tools/generate-identifier-regex.js
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  if (astral === false) return false;
  return isInAstralSet(code, astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  if (astral === false) return false;
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

},{}],3:[function(_dereq_,module,exports){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/ternjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/ternjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = _dereq_("./state");

_dereq_("./parseutil");

_dereq_("./statement");

_dereq_("./lval");

_dereq_("./expression");

_dereq_("./location");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;

var _options = _dereq_("./options");

exports.defaultOptions = _options.defaultOptions;

var _locutil = _dereq_("./locutil");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = _dereq_("./node");

exports.Node = _node.Node;

var _tokentype = _dereq_("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = _dereq_("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = _dereq_("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = _dereq_("./tokenize");

exports.Token = _tokenize.Token;

var _whitespace = _dereq_("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "2.6.4";

exports.version = version;
// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return new _state.Parser(options, input).parse();
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  var p = new _state.Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return new _state.Parser(options, input);
}

},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var pp = _state.Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp.raise = function (pos, message) {
  var loc = _locutil.getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.curPosition = function () {
  if (this.options.locations) {
    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
  }
};

},{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getLineInfo = getLineInfo;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _whitespace = _dereq_("./whitespace");

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = (function () {
  function Position(line, col) {
    _classCallCheck(this, Position);

    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };

  return Position;
})();

exports.Position = Position;

var SourceLocation = function SourceLocation(p, start, end) {
  _classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
}

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

;

exports.SourceLocation = SourceLocation;

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    _whitespace.lineBreakG.lastIndex = cur;
    var match = _whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

},{"./whitespace":16}],6:[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _util = _dereq_("./util");

var pp = _state.Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
          // falls through to AssignmentPattern
        } else {
            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            break;
          }

      case "AssignmentPattern":
        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
        break;

      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};

// Parses spread element.

pp.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function (allowNonIdent) {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement");
};

// Parses lvalue (assignable) atom.

pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case _tokentype.types.name:
      return this.parseIdent();

    case _tokentype.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case _tokentype.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(_tokentype.types.comma);
    if (allowEmpty && this.type === _tokentype.types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === _tokentype.types.ellipsis) {
      var rest = this.parseRest(allowNonIdent);
      this.parseBindingListItem(rest);
      elts.push(rest);
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};

pp.parseBindingListItem = function (param) {
  return param;
};

// Parses assignment pattern around given atom if possible.

pp.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval — something that can be assigned
// to.

pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (_util.has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var Node = function Node(parser, pos, loc) {
  _classCallCheck(this, Node);

  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges) this.range = [pos, 0];
}

// Start an AST node, attaching a start offset.

;

exports.Node = Node;
var pp = _state.Parser.prototype;

pp.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  return node;
}

pp.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};

// Finish node at given position

pp.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

},{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getOptions = getOptions;

var _util = _dereq_("./util");

var _locutil = _dereq_("./locutil");

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, or 5, or 6. This influences support for strict
  // mode, the set of reserved words, support for getters and
  // setters and other features.
  ecmaVersion: 5,
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};

exports.defaultOptions = defaultOptions;
// Interpret and default an options object

function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

  if (_util.isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? 'Block' : 'Line',
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;

// ## Parser utilities

// Test whether a statement node is the string literal `"use strict"`.

pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function (name) {
  return this.type === _tokentype.types.name && this.value === name;
};

// Consumes contextual keyword if possible.

pp.eatContextual = function (name) {
  return this.value === name && this.eat(_tokentype.types.name);
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function () {
  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function () {
  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var _options = _dereq_("./options");

// Registered plugins
var plugins = {};

exports.plugins = plugins;
function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser = (function () {
  function Parser(options, input, startPos) {
    _classCallCheck(this, Parser);

    this.options = options = _options.getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Load plugins
    this.loadPlugins(options.plugins);

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = _tokentype.types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.strict = this.inModule = options.sourceType === "module";

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;

    // Flags to track whether we are in a function, a generator.
    this.inFunction = this.inGenerator = false;
    // Labels in scope.
    this.labels = [];

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
  }

  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them

  Parser.prototype.isKeyword = function isKeyword(word) {
    return this.keywords.test(word);
  };

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    return this.reservedWords.test(word);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = plugins[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };

  return Parser;
})();

exports.Parser = Parser;

},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== _tokentype.types.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true);
      first = false;
    }
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case _tokentype.types._break:case _tokentype.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _tokentype.types._debugger:
      return this.parseDebuggerStatement(node);
    case _tokentype.types._do:
      return this.parseDoStatement(node);
    case _tokentype.types._for:
      return this.parseForStatement(node);
    case _tokentype.types._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case _tokentype.types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case _tokentype.types._if:
      return this.parseIfStatement(node);
    case _tokentype.types._return:
      return this.parseReturnStatement(node);
    case _tokentype.types._switch:
      return this.parseSwitchStatement(node);
    case _tokentype.types._throw:
      return this.parseThrowStatement(node);
    case _tokentype.types._try:
      return this.parseTryStatement(node);
    case _tokentype.types._let:case _tokentype.types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var
    case _tokentype.types._var:
      return this.parseVarStatement(node, starttype);
    case _tokentype.types._while:
      return this.parseWhileStatement(node);
    case _tokentype.types._with:
      return this.parseWithStatement(node);
    case _tokentype.types.braceL:
      return this.parseBlock();
    case _tokentype.types.semi:
      return this.parseEmptyStatement(node);
    case _tokentype.types._export:
    case _tokentype.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(_tokentype.types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(_tokentype.types.parenL);
  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {
    var _init = this.startNode(),
        varKind = this.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.checkPatternErrors(refDestructuringErrors, true);
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_tokentype.types.braceL);
  this.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
      var isCase = this.type === _tokentype.types._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_tokentype.types.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === _tokentype.types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(_tokentype.types.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label = this.labels[i];
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_tokentype.types.semi);
  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
  this.expect(_tokentype.types.semi);
  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp.parseForIn = function (node, init) {
  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl);
    if (this.eat(_tokentype.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_tokentype.types.comma)) break;
  }
  return node;
};

pp.parseVarId = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp.parseFunctionParams = function (node) {
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp.parseClass = function (node, isStatement) {
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (this.eat(_tokentype.types.semi)) continue;
    var method = this.startNode();
    var isGenerator = this.eat(_tokentype.types.star);
    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
    this.parsePropertyName(method);
    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
    if (method["static"]) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_tokentype.types.star);
      this.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;

      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }
      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }
    this.parseClassMethod(classBody, method, isGenerator);
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp.parseClassMethod = function (classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp.parseClassId = function (node, isStatement) {
  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.eat(_tokentype.types.star)) {
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_tokentype.types._default)) {
    // export default ...
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      // check for keywords used as local names
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp.shouldParseExportStatement = function () {
  return this.type.keyword;
};

// Parses a comma-separated list of module exports.

pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  // export { x, y as z } [from '...']
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === _tokentype.types._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};

// Parses import declaration.

pp.parseImport = function (node) {
  this.next();
  // import '...'
  if (this.type === _tokentype.types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === _tokentype.types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(_tokentype.types.comma)) return nodes;
  }
  if (this.type === _tokentype.types.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){
// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  _classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

exports.TokContext = TokContext;
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = _state.Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  if (prevType === _tokentype.types.colon) {
    var _parent = this.curContext();
    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
  }
  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};

// Token-specific context update code

_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

_tokentype.types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

_tokentype.types.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

_tokentype.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

_tokentype.types.incDec.updateContext = function () {
  // tokExprAllowed stays unchanged
};

_tokentype.types._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

_tokentype.types.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};

},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var _whitespace = _dereq_("./whitespace");

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  _classCallCheck(this, Token);

  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
}

// ## Tokenizer

;

exports.Token = Token;
var pp = _state.Parser.prototype;

// Are we running under Rhino?
var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

// Move to the next token

pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === _tokentype.types.eof,
        value: token
      };
    } };
};

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};

// Read a single token, updating the parser object's token-related
// properties.

pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    _whitespace.lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:case 160:
        // ' '
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:case 8232:case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            // '*'
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(_tokentype.types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(_tokentype.types.dot);
  }
};

pp.readToken_slash = function () {
  // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.slash, 1);
};

pp.readToken_mult_modulo = function (code) {
  // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);
};

pp.readToken_pipe_amp = function (code) {
  // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(_tokentype.types.incDec, 2);
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
    return this.finishOp(_tokentype.types.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
  return this.finishOp(_tokentype.types.relational, size);
};

pp.readToken_eq_excl = function (code) {
  // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    // '=>'
    this.pos += 2;
    return this.finishToken(_tokentype.types.arrow);
  }
  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      // '.'
      return this.readToken_dot();

    // Punctuation tokens.
    case 40:
      ++this.pos;return this.finishToken(_tokentype.types.parenL);
    case 41:
      ++this.pos;return this.finishToken(_tokentype.types.parenR);
    case 59:
      ++this.pos;return this.finishToken(_tokentype.types.semi);
    case 44:
      ++this.pos;return this.finishToken(_tokentype.types.comma);
    case 91:
      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
    case 93:
      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
    case 123:
      ++this.pos;return this.finishToken(_tokentype.types.braceL);
    case 125:
      ++this.pos;return this.finishToken(_tokentype.types.braceR);
    case 58:
      ++this.pos;return this.finishToken(_tokentype.types.colon);
    case 63:
      ++this.pos;return this.finishToken(_tokentype.types.question);

    case 96:
      // '`'
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(_tokentype.types.backQuote);

    case 48:
      // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      // 1-9
      return this.readNumber(false);

    // Quotes produce strings.
    case 34:case 39:
      // '"', "'"
      return this.readString(code);

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47:
      // '/'
      return this.readToken_slash();

    case 37:case 42:
      // '%*'
      return this.readToken_mult_modulo(code);

    case 124:case 38:
      // '|&'
      return this.readToken_pipe_amp(code);

    case 94:
      // '^'
      return this.readToken_caret();

    case 43:case 45:
      // '+-'
      return this.readToken_plus_min(code);

    case 60:case 62:
      // '<>'
      return this.readToken_lt_gt(code);

    case 61:case 33:
      // '=!'
      return this.readToken_eq_excl(code);

    case 126:
      // '~'
      return this.finishOp(_tokentype.types.prefix, 1);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

// Parse a regular expression. Some context-awareness is necessary,
// since a '/' inside a '[]' set does not end the expression.

function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e;
    }
  }
}

var regexpUnicodeSupport = !!tryCreateRegexp("￿", "u");

pp.readRegexp = function () {
  var _this = this;

  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  // Need to use `readWord1` because '\uXXXX' sequences are allowed
  // here (don't ask).
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gmsiy]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
      // Replace each astral symbol and every Unicode escape sequence that
      // possibly represents an astral symbol or a paired surrogate with a
      // single ASCII symbol to avoid throwing on regular expressions that
      // are only valid in combination with the `/u` flag.
      // Note: replacing with the ASCII symbol `x` might cause false
      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
      // be replaced by `[x-b]` which throws an error.
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
        code = Number("0x" + code);
        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
        return "x";
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  // Detect invalid regular expressions.
  var value = null;
  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
  // so don't do detection if we are running under Rhino
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn't support the flags it uses.
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10; // a
    else if (code >= 65) val = code - 65 + 10; // A
      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
        else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(_tokentype.types.num, val);
};

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  var next = this.input.charCodeAt(this.pos);
  if (next === 46) {
    // '.'
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if (next === 69 || next === 101) {
    // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(_tokentype.types.num, val);
};

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(_tokentype.types.string, out);
};

// Reads template string tokens.

pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      // '`', '${'
      if (this.pos === this.start && this.type === _tokentype.types.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(_tokentype.types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(_tokentype.types.template, out);
    }
    if (ch === 92) {
      // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (_whitespace.isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Used to read escaped characters

pp.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n"; // 'n' -> '\n'
    case 114:
      return "\r"; // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2)); // 'x'
    case 117:
      return codePointToString(this.readCodePoint()); // 'u'
    case 116:
      return "\t"; // 't' -> '\t'
    case 98:
      return "\b"; // 'b' -> '\b'
    case 118:
      return "\u000b"; // 'v' -> '\u000b'
    case 102:
      return "\f"; // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
    case 10:
      // ' \n'
      if (this.options.locations) {
        this.lineStart = this.pos;++this.curLine;
      }
      return "";
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        if (octal > 0 && (this.strict || inTemplate)) {
          this.raise(this.pos - 2, "Octal literal in strict mode");
        }
        this.pos += octalStr.length - 1;
        return String.fromCharCode(octal);
      }
      return String.fromCharCode(ch);
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n;
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (_identifier.isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function () {
  var word = this.readWord1();
  var type = _tokentype.types.name;
  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
  return this.finishToken(type, word);
};

},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){
// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  _classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10)
};

exports.types = types;
// Map keyword names to token types.

var keywords = {};

exports.keywords = keywords;
// Succinct definitions of keyword token types
function kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default", beforeExpr);
kw("do", { isLoop: true, beforeExpr: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function", startsExpr);
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("let");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("yield", { beforeExpr: true, startsExpr: true });
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],15:[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isArray = isArray;
exports.has = has;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}

// Checks if an object has a property.

function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],16:[function(_dereq_,module,exports){
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
exports.nonASCIIwhitespace = nonASCIIwhitespace;

},{}]},{},[3])(3)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
// alter.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013 Olov Lassus <olov.lassus@gmail.com>

var assert = require("assert");
var stableSort = require("stable");

// fragments is a list of {start: index, end: index, str: string to replace with}
function alter(str, fragments) {
    "use strict";

    var isArray = Array.isArray || function(v) {
        return Object.prototype.toString.call(v) === "[object Array]";
    };;

    assert(typeof str === "string");
    assert(isArray(fragments));

    // stableSort isn't in-place so no need to copy array first
    var sortedFragments = stableSort(fragments, function(a, b) {
        return a.start - b.start;
    });

    var outs = [];

    var pos = 0;
    for (var i = 0; i < sortedFragments.length; i++) {
        var frag = sortedFragments[i];

        assert(pos <= frag.start);
        assert(frag.start <= frag.end);
        outs.push(str.slice(pos, frag.start));
        outs.push(frag.str);
        pos = frag.end;
    }
    if (pos < str.length) {
        outs.push(str.slice(pos));
    }

    return outs.join("");
}

if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
    module.exports = alter;
}

},{"assert":4,"stable":38}],3:[function(require,module,exports){
/*!
 * AngularFire is the officially supported AngularJS binding for Firebase. Firebase
 * is a full backend so you don't need servers to build your Angular app. AngularFire
 * provides you with the $firebase service which allows you to easily keep your $scope
 * variables in sync with your Firebase backend.
 *
 * AngularFire 1.1.4
 * https://github.com/firebase/angularfire/
 * Date: 02/22/2016
 * License: MIT
 */
(function(exports) {
  "use strict";

// Define the `firebase` module under which all AngularFire
// services will live.
  angular.module("firebase", [])
    //todo use $window
    .value("Firebase", exports.Firebase);

})(window);
(function() {
  'use strict';
  /**
   * Creates and maintains a synchronized list of data. This is a pseudo-read-only array. One should
   * not call splice(), push(), pop(), et al directly on this array, but should instead use the
   * $remove and $add methods.
   *
   * It is acceptable to .sort() this array, but it is important to use this in conjunction with
   * $watch(), so that it will be re-sorted any time the server data changes. Examples of this are
   * included in the $watch documentation.
   *
   * Internally, the $firebase object depends on this class to provide several $$ (i.e. protected)
   * methods, which it invokes to notify the array whenever a change has been made at the server:
   *    $$added - called whenever a child_added event occurs
   *    $$updated - called whenever a child_changed event occurs
   *    $$moved - called whenever a child_moved event occurs
   *    $$removed - called whenever a child_removed event occurs
   *    $$error - called when listeners are canceled due to a security error
   *    $$process - called immediately after $$added/$$updated/$$moved/$$removed
   *                (assuming that these methods do not abort by returning false or null)
   *                to splice/manipulate the array and invoke $$notify
   *
   * Additionally, these methods may be of interest to devs extending this class:
   *    $$notify - triggers notifications to any $watch listeners, called by $$process
   *    $$getKey - determines how to look up a record's key (returns $id by default)
   *
   * Instead of directly modifying this class, one should generally use the $extend
   * method to add or change how methods behave. $extend modifies the prototype of
   * the array class by returning a clone of $firebaseArray.
   *
   * <pre><code>
   * var ExtendedArray = $firebaseArray.$extend({
   *    // add a new method to the prototype
   *    foo: function() { return 'bar'; },
   *
   *    // change how records are created
   *    $$added: function(snap, prevChild) {
   *       return new Widget(snap, prevChild);
   *    },
   *
   *    // change how records are updated
   *    $$updated: function(snap) {
   *      return this.$getRecord(snap.key()).update(snap);
   *    }
   * });
   *
   * var list = new ExtendedArray(ref);
   * </code></pre>
   */
  angular.module('firebase').factory('$firebaseArray', ["$log", "$firebaseUtils", "$q",
    function($log, $firebaseUtils, $q) {
      /**
       * This constructor should probably never be called manually. It is used internally by
       * <code>$firebase.$asArray()</code>.
       *
       * @param {Firebase} ref
       * @returns {Array}
       * @constructor
       */
      function FirebaseArray(ref) {
        if( !(this instanceof FirebaseArray) ) {
          return new FirebaseArray(ref);
        }
        var self = this;
        this._observers = [];
        this.$list = [];
        this._ref = ref;
        this._sync = new ArraySyncManager(this);

        $firebaseUtils.assertValidRef(ref, 'Must pass a valid Firebase reference ' +
        'to $firebaseArray (not a string or URL)');

        // indexCache is a weak hashmap (a lazy list) of keys to array indices,
        // items are not guaranteed to stay up to date in this list (since the data
        // array can be manually edited without calling the $ methods) and it should
        // always be used with skepticism regarding whether it is accurate
        // (see $indexFor() below for proper usage)
        this._indexCache = {};

        // Array.isArray will not work on objects which extend the Array class.
        // So instead of extending the Array class, we just return an actual array.
        // However, it's still possible to extend FirebaseArray and have the public methods
        // appear on the array object. We do this by iterating the prototype and binding
        // any method that is not prefixed with an underscore onto the final array.
        $firebaseUtils.getPublicMethods(self, function(fn, key) {
          self.$list[key] = fn.bind(self);
        });

        this._sync.init(this.$list);

        return this.$list;
      }

      FirebaseArray.prototype = {
        /**
         * Create a new record with a unique ID and add it to the end of the array.
         * This should be used instead of Array.prototype.push, since those changes will not be
         * synchronized with the server.
         *
         * Any value, including a primitive, can be added in this way. Note that when the record
         * is created, the primitive value would be stored in $value (records are always objects
         * by default).
         *
         * Returns a future which is resolved when the data has successfully saved to the server.
         * The resolve callback will be passed a Firebase ref representing the new data element.
         *
         * @param data
         * @returns a promise resolved after data is added
         */
        $add: function(data) {
          this._assertNotDestroyed('$add');
          var def = $firebaseUtils.defer();
          var ref = this.$ref().ref().push();
          ref.set($firebaseUtils.toJSON(data), $firebaseUtils.makeNodeResolver(def));
          return def.promise.then(function() {
            return ref;
          });
        },

        /**
         * Pass either an item in the array or the index of an item and it will be saved back
         * to Firebase. While the array is read-only and its structure should not be changed,
         * it is okay to modify properties on the objects it contains and then save those back
         * individually.
         *
         * Returns a future which is resolved when the data has successfully saved to the server.
         * The resolve callback will be passed a Firebase ref representing the saved element.
         * If passed an invalid index or an object which is not a record in this array,
         * the promise will be rejected.
         *
         * @param {int|object} indexOrItem
         * @returns a promise resolved after data is saved
         */
        $save: function(indexOrItem) {
          this._assertNotDestroyed('$save');
          var self = this;
          var item = self._resolveItem(indexOrItem);
          var key = self.$keyAt(item);
          if( key !== null ) {
            var ref = self.$ref().ref().child(key);
            var data = $firebaseUtils.toJSON(item);
            return $firebaseUtils.doSet(ref, data).then(function() {
              self.$$notify('child_changed', key);
              return ref;
            });
          }
          else {
            return $firebaseUtils.reject('Invalid record; could determine key for '+indexOrItem);
          }
        },

        /**
         * Pass either an existing item in this array or the index of that item and it will
         * be removed both locally and in Firebase. This should be used in place of
         * Array.prototype.splice for removing items out of the array, as calling splice
         * will not update the value on the server.
         *
         * Returns a future which is resolved when the data has successfully removed from the
         * server. The resolve callback will be passed a Firebase ref representing the deleted
         * element. If passed an invalid index or an object which is not a record in this array,
         * the promise will be rejected.
         *
         * @param {int|object} indexOrItem
         * @returns a promise which resolves after data is removed
         */
        $remove: function(indexOrItem) {
          this._assertNotDestroyed('$remove');
          var key = this.$keyAt(indexOrItem);
          if( key !== null ) {
            var ref = this.$ref().ref().child(key);
            return $firebaseUtils.doRemove(ref).then(function() {
              return ref;
            });
          }
          else {
            return $firebaseUtils.reject('Invalid record; could not determine key for '+indexOrItem);
          }
        },

        /**
         * Given an item in this array or the index of an item in the array, this returns the
         * Firebase key (record.$id) for that record. If passed an invalid key or an item which
         * does not exist in this array, it will return null.
         *
         * @param {int|object} indexOrItem
         * @returns {null|string}
         */
        $keyAt: function(indexOrItem) {
          var item = this._resolveItem(indexOrItem);
          return this.$$getKey(item);
        },

        /**
         * The inverse of $keyAt, this method takes a Firebase key (record.$id) and returns the
         * index in the array where that record is stored. If the record is not in the array,
         * this method returns -1.
         *
         * @param {String} key
         * @returns {int} -1 if not found
         */
        $indexFor: function(key) {
          var self = this;
          var cache = self._indexCache;
          // evaluate whether our key is cached and, if so, whether it is up to date
          if( !cache.hasOwnProperty(key) || self.$keyAt(cache[key]) !== key ) {
            // update the hashmap
            var pos = self.$list.findIndex(function(rec) { return self.$$getKey(rec) === key; });
            if( pos !== -1 ) {
              cache[key] = pos;
            }
          }
          return cache.hasOwnProperty(key)? cache[key] : -1;
        },

        /**
         * The loaded method is invoked after the initial batch of data arrives from the server.
         * When this resolves, all data which existed prior to calling $asArray() is now cached
         * locally in the array.
         *
         * As a shortcut is also possible to pass resolve/reject methods directly into this
         * method just as they would be passed to .then()
         *
         * @param {Function} [resolve]
         * @param {Function} [reject]
         * @returns a promise
         */
        $loaded: function(resolve, reject) {
          var promise = this._sync.ready();
          if( arguments.length ) {
            // allow this method to be called just like .then
            // by passing any arguments on to .then
            promise = promise.then.call(promise, resolve, reject);
          }
          return promise;
        },

        /**
         * @returns {Firebase} the original Firebase ref used to create this object.
         */
        $ref: function() { return this._ref; },

        /**
         * Listeners passed into this method are notified whenever a new change (add, updated,
         * move, remove) is received from the server. Each invocation is sent an object
         * containing <code>{ type: 'child_added|child_updated|child_moved|child_removed',
         * key: 'key_of_item_affected'}</code>
         *
         * Additionally, added and moved events receive a prevChild parameter, containing the
         * key of the item before this one in the array.
         *
         * This method returns a function which can be invoked to stop observing events.
         *
         * @param {Function} cb
         * @param {Object} [context]
         * @returns {Function} used to stop observing
         */
        $watch: function(cb, context) {
          var list = this._observers;
          list.push([cb, context]);
          // an off function for cancelling the listener
          return function() {
            var i = list.findIndex(function(parts) {
              return parts[0] === cb && parts[1] === context;
            });
            if( i > -1 ) {
              list.splice(i, 1);
            }
          };
        },

        /**
         * Informs $firebase to stop sending events and clears memory being used
         * by this array (delete's its local content).
         */
        $destroy: function(err) {
          if( !this._isDestroyed ) {
            this._isDestroyed = true;
            this._sync.destroy(err);
            this.$list.length = 0;
          }
        },

        /**
         * Returns the record for a given Firebase key (record.$id). If the record is not found
         * then returns null.
         *
         * @param {string} key
         * @returns {Object|null} a record in this array
         */
        $getRecord: function(key) {
          var i = this.$indexFor(key);
          return i > -1? this.$list[i] : null;
        },

        /**
         * Called to inform the array when a new item has been added at the server.
         * This method should return the record (an object) that will be passed into $$process
         * along with the add event. Alternately, the record will be skipped if this method returns
         * a falsey value.
         *
         * @param {object} snap a Firebase snapshot
         * @param {string} prevChild
         * @return {object} the record to be inserted into the array
         * @protected
         */
        $$added: function(snap/*, prevChild*/) {
          // check to make sure record does not exist
          var i = this.$indexFor($firebaseUtils.getKey(snap));
          if( i === -1 ) {
            // parse data and create record
            var rec = snap.val();
            if( !angular.isObject(rec) ) {
              rec = { $value: rec };
            }
            rec.$id = $firebaseUtils.getKey(snap);
            rec.$priority = snap.getPriority();
            $firebaseUtils.applyDefaults(rec, this.$$defaults);

            return rec;
          }
          return false;
        },

        /**
         * Called whenever an item is removed at the server.
         * This method does not physically remove the objects, but instead
         * returns a boolean indicating whether it should be removed (and
         * taking any other desired actions before the remove completes).
         *
         * @param {object} snap a Firebase snapshot
         * @return {boolean} true if item should be removed
         * @protected
         */
        $$removed: function(snap) {
          return this.$indexFor($firebaseUtils.getKey(snap)) > -1;
        },

        /**
         * Called whenever an item is changed at the server.
         * This method should apply the changes, including changes to data
         * and to $priority, and then return true if any changes were made.
         *
         * If this method returns false, then $$process will not be invoked,
         * which means that $$notify will not take place and no $watch events
         * will be triggered.
         *
         * @param {object} snap a Firebase snapshot
         * @return {boolean} true if any data changed
         * @protected
         */
        $$updated: function(snap) {
          var changed = false;
          var rec = this.$getRecord($firebaseUtils.getKey(snap));
          if( angular.isObject(rec) ) {
            // apply changes to the record
            changed = $firebaseUtils.updateRec(rec, snap);
            $firebaseUtils.applyDefaults(rec, this.$$defaults);
          }
          return changed;
        },

        /**
         * Called whenever an item changes order (moves) on the server.
         * This method should set $priority to the updated value and return true if
         * the record should actually be moved. It should not actually apply the move
         * operation.
         *
         * If this method returns false, then the record will not be moved in the array
         * and no $watch listeners will be notified. (When true, $$process is invoked
         * which invokes $$notify)
         *
         * @param {object} snap a Firebase snapshot
         * @param {string} prevChild
         * @protected
         */
        $$moved: function(snap/*, prevChild*/) {
          var rec = this.$getRecord($firebaseUtils.getKey(snap));
          if( angular.isObject(rec) ) {
            rec.$priority = snap.getPriority();
            return true;
          }
          return false;
        },

        /**
         * Called whenever a security error or other problem causes the listeners to become
         * invalid. This is generally an unrecoverable error.
         *
         * @param {Object} err which will have a `code` property and possibly a `message`
         * @protected
         */
        $$error: function(err) {
          $log.error(err);
          this.$destroy(err);
        },

        /**
         * Returns ID for a given record
         * @param {object} rec
         * @returns {string||null}
         * @protected
         */
        $$getKey: function(rec) {
          return angular.isObject(rec)? rec.$id : null;
        },

        /**
         * Handles placement of recs in the array, sending notifications,
         * and other internals. Called by the synchronization process
         * after $$added, $$updated, $$moved, and $$removed return a truthy value.
         *
         * @param {string} event one of child_added, child_removed, child_moved, or child_changed
         * @param {object} rec
         * @param {string} [prevChild]
         * @protected
         */
        $$process: function(event, rec, prevChild) {
          var key = this.$$getKey(rec);
          var changed = false;
          var curPos;
          switch(event) {
            case 'child_added':
              curPos = this.$indexFor(key);
              break;
            case 'child_moved':
              curPos = this.$indexFor(key);
              this._spliceOut(key);
              break;
            case 'child_removed':
              // remove record from the array
              changed = this._spliceOut(key) !== null;
              break;
            case 'child_changed':
              changed = true;
              break;
            default:
              throw new Error('Invalid event type: ' + event);
          }
          if( angular.isDefined(curPos) ) {
            // add it to the array
            changed = this._addAfter(rec, prevChild) !== curPos;
          }
          if( changed ) {
            // send notifications to anybody monitoring $watch
            this.$$notify(event, key, prevChild);
          }
          return changed;
        },

        /**
         * Used to trigger notifications for listeners registered using $watch. This method is
         * typically invoked internally by the $$process method.
         *
         * @param {string} event
         * @param {string} key
         * @param {string} [prevChild]
         * @protected
         */
        $$notify: function(event, key, prevChild) {
          var eventData = {event: event, key: key};
          if( angular.isDefined(prevChild) ) {
            eventData.prevChild = prevChild;
          }
          angular.forEach(this._observers, function(parts) {
            parts[0].call(parts[1], eventData);
          });
        },

        /**
         * Used to insert a new record into the array at a specific position. If prevChild is
         * null, is inserted first, if prevChild is not found, it is inserted last, otherwise,
         * it goes immediately after prevChild.
         *
         * @param {object} rec
         * @param {string|null} prevChild
         * @private
         */
        _addAfter: function(rec, prevChild) {
          var i;
          if( prevChild === null ) {
            i = 0;
          }
          else {
            i = this.$indexFor(prevChild)+1;
            if( i === 0 ) { i = this.$list.length; }
          }
          this.$list.splice(i, 0, rec);
          this._indexCache[this.$$getKey(rec)] = i;
          return i;
        },

        /**
         * Removes a record from the array by calling splice. If the item is found
         * this method returns it. Otherwise, this method returns null.
         *
         * @param {string} key
         * @returns {object|null}
         * @private
         */
        _spliceOut: function(key) {
          var i = this.$indexFor(key);
          if( i > -1 ) {
            delete this._indexCache[key];
            return this.$list.splice(i, 1)[0];
          }
          return null;
        },

        /**
         * Resolves a variable which may contain an integer or an item that exists in this array.
         * Returns the item or null if it does not exist.
         *
         * @param indexOrItem
         * @returns {*}
         * @private
         */
        _resolveItem: function(indexOrItem) {
          var list = this.$list;
          if( angular.isNumber(indexOrItem) && indexOrItem >= 0 && list.length >= indexOrItem ) {
            return list[indexOrItem];
          }
          else if( angular.isObject(indexOrItem) ) {
            // it must be an item in this array; it's not sufficient for it just to have
            // a $id or even a $id that is in the array, it must be an actual record
            // the fastest way to determine this is to use $getRecord (to avoid iterating all recs)
            // and compare the two
            var key = this.$$getKey(indexOrItem);
            var rec = this.$getRecord(key);
            return rec === indexOrItem? rec : null;
          }
          return null;
        },

        /**
         * Throws an error if $destroy has been called. Should be used for any function
         * which tries to write data back to $firebase.
         * @param {string} method
         * @private
         */
        _assertNotDestroyed: function(method) {
          if( this._isDestroyed ) {
            throw new Error('Cannot call ' + method + ' method on a destroyed $firebaseArray object');
          }
        }
      };

      /**
       * This method allows FirebaseArray to be inherited by child classes. Methods passed into this
       * function will be added onto the array's prototype. They can override existing methods as
       * well.
       *
       * In addition to passing additional methods, it is also possible to pass in a class function.
       * The prototype on that class function will be preserved, and it will inherit from
       * FirebaseArray. It's also possible to do both, passing a class to inherit and additional
       * methods to add onto the prototype.
       *
       *  <pre><code>
       * var ExtendedArray = $firebaseArray.$extend({
       *    // add a method onto the prototype that sums all items in the array
       *    getSum: function() {
       *       var ct = 0;
       *       angular.forEach(this.$list, function(rec) { ct += rec.x; });
        *      return ct;
       *    }
       * });
       *
       * // use our new factory in place of $firebaseArray
       * var list = new ExtendedArray(ref);
       * </code></pre>
       *
       * @param {Function} [ChildClass] a child class which should inherit FirebaseArray
       * @param {Object} [methods] a list of functions to add onto the prototype
       * @returns {Function} a child class suitable for use with $firebase (this will be ChildClass if provided)
       * @static
       */
      FirebaseArray.$extend = function(ChildClass, methods) {
        if( arguments.length === 1 && angular.isObject(ChildClass) ) {
          methods = ChildClass;
          ChildClass = function(ref) {
            if( !(this instanceof ChildClass) ) {
              return new ChildClass(ref);
            }
            FirebaseArray.apply(this, arguments);
            return this.$list;
          };
        }
        return $firebaseUtils.inherit(ChildClass, FirebaseArray, methods);
      };

      function ArraySyncManager(firebaseArray) {
        function destroy(err) {
          if( !sync.isDestroyed ) {
            sync.isDestroyed = true;
            var ref = firebaseArray.$ref();
            ref.off('child_added', created);
            ref.off('child_moved', moved);
            ref.off('child_changed', updated);
            ref.off('child_removed', removed);
            firebaseArray = null;
            initComplete(err||'destroyed');
          }
        }

        function init($list) {
          var ref = firebaseArray.$ref();

          // listen for changes at the Firebase instance
          ref.on('child_added', created, error);
          ref.on('child_moved', moved, error);
          ref.on('child_changed', updated, error);
          ref.on('child_removed', removed, error);

          // determine when initial load is completed
          ref.once('value', function(snap) {
            if (angular.isArray(snap.val())) {
              $log.warn('Storing data using array indices in Firebase can result in unexpected behavior. See https://www.firebase.com/docs/web/guide/understanding-data.html#section-arrays-in-firebase for more information.');
            }

            initComplete(null, $list);
          }, initComplete);
        }

        // call initComplete(), do not call this directly
        function _initComplete(err, result) {
          if( !isResolved ) {
            isResolved = true;
            if( err ) { def.reject(err); }
            else { def.resolve(result); }
          }
        }

        var def     = $firebaseUtils.defer();
        var created = function(snap, prevChild) {
          waitForResolution(firebaseArray.$$added(snap, prevChild), function(rec) {
            firebaseArray.$$process('child_added', rec, prevChild);
          });
        };
        var updated = function(snap) {
          var rec = firebaseArray.$getRecord($firebaseUtils.getKey(snap));
          if( rec ) {
            waitForResolution(firebaseArray.$$updated(snap), function() {
              firebaseArray.$$process('child_changed', rec);
            });
          }
        };
        var moved   = function(snap, prevChild) {
          var rec = firebaseArray.$getRecord($firebaseUtils.getKey(snap));
          if( rec ) {
            waitForResolution(firebaseArray.$$moved(snap, prevChild), function() {
              firebaseArray.$$process('child_moved', rec, prevChild);
            });
          }
        };
        var removed = function(snap) {
          var rec = firebaseArray.$getRecord($firebaseUtils.getKey(snap));
          if( rec ) {
            waitForResolution(firebaseArray.$$removed(snap), function() {
               firebaseArray.$$process('child_removed', rec);
            });
          }
        };

        function waitForResolution(maybePromise, callback) {
          var promise = $q.when(maybePromise);
          promise.then(function(result){
            if (result) {
              callback(result);
            }
          });
          if (!isResolved) {
            resolutionPromises.push(promise);
          }
        }

        var resolutionPromises = [];
        var isResolved = false;
        var error   = $firebaseUtils.batch(function(err) {
          _initComplete(err);
          if( firebaseArray ) {
            firebaseArray.$$error(err);
          }
        });
        var initComplete = $firebaseUtils.batch(_initComplete);

        var sync = {
          destroy: destroy,
          isDestroyed: false,
          init: init,
          ready: function() { return def.promise.then(function(result){
            return $q.all(resolutionPromises).then(function(){
              return result;
            });
          }); }
        };

        return sync;
      }

      return FirebaseArray;
    }
  ]);

  /** @deprecated */
  angular.module('firebase').factory('$FirebaseArray', ['$log', '$firebaseArray',
    function($log, $firebaseArray) {
      return function() {
        $log.warn('$FirebaseArray has been renamed. Use $firebaseArray instead.');
        return $firebaseArray.apply(null, arguments);
      };
    }
  ]);
})();

(function() {
  'use strict';
  var FirebaseAuth;

  // Define a service which provides user authentication and management.
  angular.module('firebase').factory('$firebaseAuth', [
    '$q', '$firebaseUtils', function($q, $firebaseUtils) {
      /**
       * This factory returns an object allowing you to manage the client's authentication state.
       *
       * @param {Firebase} ref A Firebase reference to authenticate.
       * @return {object} An object containing methods for authenticating clients, retrieving
       * authentication state, and managing users.
       */
      return function(ref) {
        var auth = new FirebaseAuth($q, $firebaseUtils, ref);
        return auth.construct();
      };
    }
  ]);

  FirebaseAuth = function($q, $firebaseUtils, ref) {
    this._q = $q;
    this._utils = $firebaseUtils;
    if (typeof ref === 'string') {
      throw new Error('Please provide a Firebase reference instead of a URL when creating a `$firebaseAuth` object.');
    }
    this._ref = ref;
    this._initialAuthResolver = this._initAuthResolver();
  };

  FirebaseAuth.prototype = {
    construct: function() {
      this._object = {
        // Authentication methods
        $authWithCustomToken: this.authWithCustomToken.bind(this),
        $authAnonymously: this.authAnonymously.bind(this),
        $authWithPassword: this.authWithPassword.bind(this),
        $authWithOAuthPopup: this.authWithOAuthPopup.bind(this),
        $authWithOAuthRedirect: this.authWithOAuthRedirect.bind(this),
        $authWithOAuthToken: this.authWithOAuthToken.bind(this),
        $unauth: this.unauth.bind(this),

        // Authentication state methods
        $onAuth: this.onAuth.bind(this),
        $getAuth: this.getAuth.bind(this),
        $requireAuth: this.requireAuth.bind(this),
        $waitForAuth: this.waitForAuth.bind(this),

        // User management methods
        $createUser: this.createUser.bind(this),
        $changePassword: this.changePassword.bind(this),
        $changeEmail: this.changeEmail.bind(this),
        $removeUser: this.removeUser.bind(this),
        $resetPassword: this.resetPassword.bind(this)
      };

      return this._object;
    },


    /********************/
    /*  Authentication  */
    /********************/

    /**
     * Authenticates the Firebase reference with a custom authentication token.
     *
     * @param {string} authToken An authentication token or a Firebase Secret. A Firebase Secret
     * should only be used for authenticating a server process and provides full read / write
     * access to the entire Firebase.
     * @param {Object} [options] An object containing optional client arguments, such as configuring
     * session persistence.
     * @return {Promise<Object>} A promise fulfilled with an object containing authentication data.
     */
    authWithCustomToken: function(authToken, options) {
      var deferred = this._q.defer();

      try {
        this._ref.authWithCustomToken(authToken, this._utils.makeNodeResolver(deferred), options);
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Authenticates the Firebase reference anonymously.
     *
     * @param {Object} [options] An object containing optional client arguments, such as configuring
     * session persistence.
     * @return {Promise<Object>} A promise fulfilled with an object containing authentication data.
     */
    authAnonymously: function(options) {
      var deferred = this._q.defer();

      try {
        this._ref.authAnonymously(this._utils.makeNodeResolver(deferred), options);
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Authenticates the Firebase reference with an email/password user.
     *
     * @param {Object} credentials An object containing email and password attributes corresponding
     * to the user account.
     * @param {Object} [options] An object containing optional client arguments, such as configuring
     * session persistence.
     * @return {Promise<Object>} A promise fulfilled with an object containing authentication data.
     */
    authWithPassword: function(credentials, options) {
      var deferred = this._q.defer();

      try {
        this._ref.authWithPassword(credentials, this._utils.makeNodeResolver(deferred), options);
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Authenticates the Firebase reference with the OAuth popup flow.
     *
     * @param {string} provider The unique string identifying the OAuth provider to authenticate
     * with, e.g. google.
     * @param {Object} [options] An object containing optional client arguments, such as configuring
     * session persistence.
     * @return {Promise<Object>} A promise fulfilled with an object containing authentication data.
     */
    authWithOAuthPopup: function(provider, options) {
      var deferred = this._q.defer();

      try {
        this._ref.authWithOAuthPopup(provider, this._utils.makeNodeResolver(deferred), options);
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Authenticates the Firebase reference with the OAuth redirect flow.
     *
     * @param {string} provider The unique string identifying the OAuth provider to authenticate
     * with, e.g. google.
     * @param {Object} [options] An object containing optional client arguments, such as configuring
     * session persistence.
     * @return {Promise<Object>} A promise fulfilled with an object containing authentication data.
     */
    authWithOAuthRedirect: function(provider, options) {
      var deferred = this._q.defer();

      try {
        this._ref.authWithOAuthRedirect(provider, this._utils.makeNodeResolver(deferred), options);
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Authenticates the Firebase reference with an OAuth token.
     *
     * @param {string} provider The unique string identifying the OAuth provider to authenticate
     * with, e.g. google.
     * @param {string|Object} credentials Either a string, such as an OAuth 2.0 access token, or an
     * Object of key / value pairs, such as a set of OAuth 1.0a credentials.
     * @param {Object} [options] An object containing optional client arguments, such as configuring
     * session persistence.
     * @return {Promise<Object>} A promise fulfilled with an object containing authentication data.
     */
    authWithOAuthToken: function(provider, credentials, options) {
      var deferred = this._q.defer();

      try {
        this._ref.authWithOAuthToken(provider, credentials, this._utils.makeNodeResolver(deferred), options);
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Unauthenticates the Firebase reference.
     */
    unauth: function() {
      if (this.getAuth() !== null) {
        this._ref.unauth();
      }
    },


    /**************************/
    /*  Authentication State  */
    /**************************/
    /**
     * Asynchronously fires the provided callback with the current authentication data every time
     * the authentication data changes. It also fires as soon as the authentication data is
     * retrieved from the server.
     *
     * @param {function} callback A callback that fires when the client's authenticate state
     * changes. If authenticated, the callback will be passed an object containing authentication
     * data according to the provider used to authenticate. Otherwise, it will be passed null.
     * @param {string} [context] If provided, this object will be used as this when calling your
     * callback.
     * @return {function} A function which can be used to deregister the provided callback.
     */
    onAuth: function(callback, context) {
      var self = this;

      var fn = this._utils.debounce(callback, context, 0);
      this._ref.onAuth(fn);

      // Return a method to detach the `onAuth()` callback.
      return function() {
        self._ref.offAuth(fn);
      };
    },

    /**
     * Synchronously retrieves the current authentication data.
     *
     * @return {Object} The client's authentication data.
     */
    getAuth: function() {
      return this._ref.getAuth();
    },

    /**
     * Helper onAuth() callback method for the two router-related methods.
     *
     * @param {boolean} rejectIfAuthDataIsNull Determines if the returned promise should be
     * resolved or rejected upon an unauthenticated client.
     * @return {Promise<Object>} A promise fulfilled with the client's authentication state or
     * rejected if the client is unauthenticated and rejectIfAuthDataIsNull is true.
     */
    _routerMethodOnAuthPromise: function(rejectIfAuthDataIsNull) {
      var ref = this._ref, utils = this._utils;
      // wait for the initial auth state to resolve; on page load we have to request auth state
      // asynchronously so we don't want to resolve router methods or flash the wrong state
      return this._initialAuthResolver.then(function() {
        // auth state may change in the future so rather than depend on the initially resolved state
        // we also check the auth data (synchronously) if a new promise is requested, ensuring we resolve
        // to the current auth state and not a stale/initial state
        var authData = ref.getAuth(), res = null;
        if (rejectIfAuthDataIsNull && authData === null) {
          res = utils.reject("AUTH_REQUIRED");
        }
        else {
          res = utils.resolve(authData);
        }
        return res;
      });
    },

    /**
     * Helper that returns a promise which resolves when the initial auth state has been
     * fetched from the Firebase server. This never rejects and resolves to undefined.
     *
     * @return {Promise<Object>} A promise fulfilled when the server returns initial auth state.
     */
    _initAuthResolver: function() {
      var ref = this._ref;
      return this._utils.promise(function(resolve) {
        function callback() {
          // Turn off this onAuth() callback since we just needed to get the authentication data once.
          ref.offAuth(callback);
          resolve();
        }
        ref.onAuth(callback);
      });
    },

    /**
     * Utility method which can be used in a route's resolve() method to require that a route has
     * a logged in client.
     *
     * @returns {Promise<Object>} A promise fulfilled with the client's current authentication
     * state or rejected if the client is not authenticated.
     */
    requireAuth: function() {
      return this._routerMethodOnAuthPromise(true);
    },

    /**
     * Utility method which can be used in a route's resolve() method to grab the current
     * authentication data.
     *
     * @returns {Promise<Object|null>} A promise fulfilled with the client's current authentication
     * state, which will be null if the client is not authenticated.
     */
    waitForAuth: function() {
      return this._routerMethodOnAuthPromise(false);
    },


    /*********************/
    /*  User Management  */
    /*********************/
    /**
     * Creates a new email/password user. Note that this function only creates the user, if you
     * wish to log in as the newly created user, call $authWithPassword() after the promise for
     * this method has been resolved.
     *
     * @param {Object} credentials An object containing the email and password of the user to create.
     * @return {Promise<Object>} A promise fulfilled with the user object, which contains the
     * uid of the created user.
     */
    createUser: function(credentials) {
      var deferred = this._q.defer();

      // Throw an error if they are trying to pass in separate string arguments
      if (typeof credentials === "string") {
        throw new Error("$createUser() expects an object containing 'email' and 'password', but got a string.");
      }

      try {
        this._ref.createUser(credentials, this._utils.makeNodeResolver(deferred));
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Changes the password for an email/password user.
     *
     * @param {Object} credentials An object containing the email, old password, and new password of
     * the user whose password is to change.
     * @return {Promise<>} An empty promise fulfilled once the password change is complete.
     */
    changePassword: function(credentials) {
      var deferred = this._q.defer();

      // Throw an error if they are trying to pass in separate string arguments
      if (typeof credentials === "string") {
        throw new Error("$changePassword() expects an object containing 'email', 'oldPassword', and 'newPassword', but got a string.");
      }

      try {
        this._ref.changePassword(credentials, this._utils.makeNodeResolver(deferred));
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Changes the email for an email/password user.
     *
     * @param {Object} credentials An object containing the old email, new email, and password of
     * the user whose email is to change.
     * @return {Promise<>} An empty promise fulfilled once the email change is complete.
     */
    changeEmail: function(credentials) {
      var deferred = this._q.defer();

      if (typeof this._ref.changeEmail !== 'function') {
        throw new Error("$firebaseAuth.$changeEmail() requires Firebase version 2.1.0 or greater.");
      } else if (typeof credentials === 'string') {
        throw new Error("$changeEmail() expects an object containing 'oldEmail', 'newEmail', and 'password', but got a string.");
      }

      try {
        this._ref.changeEmail(credentials, this._utils.makeNodeResolver(deferred));
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },

    /**
     * Removes an email/password user.
     *
     * @param {Object} credentials An object containing the email and password of the user to remove.
     * @return {Promise<>} An empty promise fulfilled once the user is removed.
     */
    removeUser: function(credentials) {
      var deferred = this._q.defer();

      // Throw an error if they are trying to pass in separate string arguments
      if (typeof credentials === "string") {
        throw new Error("$removeUser() expects an object containing 'email' and 'password', but got a string.");
      }

      try {
        this._ref.removeUser(credentials, this._utils.makeNodeResolver(deferred));
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    },


    /**
     * Sends a password reset email to an email/password user.
     *
     * @param {Object} credentials An object containing the email of the user to send a reset
     * password email to.
     * @return {Promise<>} An empty promise fulfilled once the reset password email is sent.
     */
    resetPassword: function(credentials) {
      var deferred = this._q.defer();

      // Throw an error if they are trying to pass in a string argument
      if (typeof credentials === "string") {
        throw new Error("$resetPassword() expects an object containing 'email', but got a string.");
      }

      try {
        this._ref.resetPassword(credentials, this._utils.makeNodeResolver(deferred));
      } catch (error) {
        deferred.reject(error);
      }

      return deferred.promise;
    }
  };
})();

(function() {
  'use strict';
  /**
   * Creates and maintains a synchronized object, with 2-way bindings between Angular and Firebase.
   *
   * Implementations of this class are contracted to provide the following internal methods,
   * which are used by the synchronization process and 3-way bindings:
   *    $$updated - called whenever a change occurs (a value event from Firebase)
   *    $$error - called when listeners are canceled due to a security error
   *    $$notify - called to update $watch listeners and trigger updates to 3-way bindings
   *    $ref - called to obtain the underlying Firebase reference
   *
   * Instead of directly modifying this class, one should generally use the $extend
   * method to add or change how methods behave:
   *
   * <pre><code>
   * var ExtendedObject = $firebaseObject.$extend({
   *    // add a new method to the prototype
   *    foo: function() { return 'bar'; },
   * });
   *
   * var obj = new ExtendedObject(ref);
   * </code></pre>
   */
  angular.module('firebase').factory('$firebaseObject', [
    '$parse', '$firebaseUtils', '$log',
    function($parse, $firebaseUtils, $log) {
      /**
       * Creates a synchronized object with 2-way bindings between Angular and Firebase.
       *
       * @param {Firebase} ref
       * @returns {FirebaseObject}
       * @constructor
       */
      function FirebaseObject(ref) {
        if( !(this instanceof FirebaseObject) ) {
          return new FirebaseObject(ref);
        }
        // These are private config props and functions used internally
        // they are collected here to reduce clutter in console.log and forEach
        this.$$conf = {
          // synchronizes data to Firebase
          sync: new ObjectSyncManager(this, ref),
          // stores the Firebase ref
          ref: ref,
          // synchronizes $scope variables with this object
          binding: new ThreeWayBinding(this),
          // stores observers registered with $watch
          listeners: []
        };

        // this bit of magic makes $$conf non-enumerable and non-configurable
        // and non-writable (its properties are still writable but the ref cannot be replaced)
        // we redundantly assign it above so the IDE can relax
        Object.defineProperty(this, '$$conf', {
          value: this.$$conf
        });

        this.$id = $firebaseUtils.getKey(ref.ref());
        this.$priority = null;

        $firebaseUtils.applyDefaults(this, this.$$defaults);

        // start synchronizing data with Firebase
        this.$$conf.sync.init();
      }

      FirebaseObject.prototype = {
        /**
         * Saves all data on the FirebaseObject back to Firebase.
         * @returns a promise which will resolve after the save is completed.
         */
        $save: function () {
          var self = this;
          var ref = self.$ref();
          var data = $firebaseUtils.toJSON(self);
          return $firebaseUtils.doSet(ref, data).then(function() {
            self.$$notify();
            return self.$ref();
          });
        },

        /**
         * Removes all keys from the FirebaseObject and also removes
         * the remote data from the server.
         *
         * @returns a promise which will resolve after the op completes
         */
        $remove: function() {
          var self = this;
          $firebaseUtils.trimKeys(self, {});
          self.$value = null;
          return $firebaseUtils.doRemove(self.$ref()).then(function() {
            self.$$notify();
            return self.$ref();
          });
        },

        /**
         * The loaded method is invoked after the initial batch of data arrives from the server.
         * When this resolves, all data which existed prior to calling $asObject() is now cached
         * locally in the object.
         *
         * As a shortcut is also possible to pass resolve/reject methods directly into this
         * method just as they would be passed to .then()
         *
         * @param {Function} resolve
         * @param {Function} reject
         * @returns a promise which resolves after initial data is downloaded from Firebase
         */
        $loaded: function(resolve, reject) {
          var promise = this.$$conf.sync.ready();
          if (arguments.length) {
            // allow this method to be called just like .then
            // by passing any arguments on to .then
            promise = promise.then.call(promise, resolve, reject);
          }
          return promise;
        },

        /**
         * @returns {Firebase} the original Firebase instance used to create this object.
         */
        $ref: function () {
          return this.$$conf.ref;
        },

        /**
         * Creates a 3-way data sync between this object, the Firebase server, and a
         * scope variable. This means that any changes made to the scope variable are
         * pushed to Firebase, and vice versa.
         *
         * If scope emits a $destroy event, the binding is automatically severed. Otherwise,
         * it is possible to unbind the scope variable by using the `unbind` function
         * passed into the resolve method.
         *
         * Can only be bound to one scope variable at a time. If a second is attempted,
         * the promise will be rejected with an error.
         *
         * @param {object} scope
         * @param {string} varName
         * @returns a promise which resolves to an unbind method after data is set in scope
         */
        $bindTo: function (scope, varName) {
          var self = this;
          return self.$loaded().then(function () {
            return self.$$conf.binding.bindTo(scope, varName);
          });
        },

        /**
         * Listeners passed into this method are notified whenever a new change is received
         * from the server. Each invocation is sent an object containing
         * <code>{ type: 'value', key: 'my_firebase_id' }</code>
         *
         * This method returns an unbind function that can be used to detach the listener.
         *
         * @param {Function} cb
         * @param {Object} [context]
         * @returns {Function} invoke to stop observing events
         */
        $watch: function (cb, context) {
          var list = this.$$conf.listeners;
          list.push([cb, context]);
          // an off function for cancelling the listener
          return function () {
            var i = list.findIndex(function (parts) {
              return parts[0] === cb && parts[1] === context;
            });
            if (i > -1) {
              list.splice(i, 1);
            }
          };
        },

        /**
         * Informs $firebase to stop sending events and clears memory being used
         * by this object (delete's its local content).
         */
        $destroy: function(err) {
          var self = this;
          if (!self.$isDestroyed) {
            self.$isDestroyed = true;
            self.$$conf.sync.destroy(err);
            self.$$conf.binding.destroy();
            $firebaseUtils.each(self, function (v, k) {
              delete self[k];
            });
          }
        },

        /**
         * Called by $firebase whenever an item is changed at the server.
         * This method must exist on any objectFactory passed into $firebase.
         *
         * It should return true if any changes were made, otherwise `$$notify` will
         * not be invoked.
         *
         * @param {object} snap a Firebase snapshot
         * @return {boolean} true if any changes were made.
         */
        $$updated: function (snap) {
          // applies new data to this object
          var changed = $firebaseUtils.updateRec(this, snap);
          // applies any defaults set using $$defaults
          $firebaseUtils.applyDefaults(this, this.$$defaults);
          // returning true here causes $$notify to be triggered
          return changed;
        },

        /**
         * Called whenever a security error or other problem causes the listeners to become
         * invalid. This is generally an unrecoverable error.
         * @param {Object} err which will have a `code` property and possibly a `message`
         */
        $$error: function (err) {
          // prints an error to the console (via Angular's logger)
          $log.error(err);
          // frees memory and cancels any remaining listeners
          this.$destroy(err);
        },

        /**
         * Called internally by $bindTo when data is changed in $scope.
         * Should apply updates to this record but should not call
         * notify().
         */
        $$scopeUpdated: function(newData) {
          // we use a one-directional loop to avoid feedback with 3-way bindings
          // since set() is applied locally anyway, this is still performant
          var def = $firebaseUtils.defer();
          this.$ref().set($firebaseUtils.toJSON(newData), $firebaseUtils.makeNodeResolver(def));
          return def.promise;
        },

        /**
         * Updates any bound scope variables and
         * notifies listeners registered with $watch
         */
        $$notify: function() {
          var self = this, list = this.$$conf.listeners.slice();
          // be sure to do this after setting up data and init state
          angular.forEach(list, function (parts) {
            parts[0].call(parts[1], {event: 'value', key: self.$id});
          });
        },

        /**
         * Overrides how Angular.forEach iterates records on this object so that only
         * fields stored in Firebase are part of the iteration. To include meta fields like
         * $id and $priority in the iteration, utilize for(key in obj) instead.
         */
        forEach: function(iterator, context) {
          return $firebaseUtils.each(this, iterator, context);
        }
      };

      /**
       * This method allows FirebaseObject to be copied into a new factory. Methods passed into this
       * function will be added onto the object's prototype. They can override existing methods as
       * well.
       *
       * In addition to passing additional methods, it is also possible to pass in a class function.
       * The prototype on that class function will be preserved, and it will inherit from
       * FirebaseObject. It's also possible to do both, passing a class to inherit and additional
       * methods to add onto the prototype.
       *
       * Once a factory is obtained by this method, it can be passed into $firebase as the
       * `objectFactory` parameter:
       *
       * <pre><code>
       * var MyFactory = $firebaseObject.$extend({
       *    // add a method onto the prototype that prints a greeting
       *    getGreeting: function() {
       *       return 'Hello ' + this.first_name + ' ' + this.last_name + '!';
       *    }
       * });
       *
       * // use our new factory in place of $firebaseObject
       * var obj = $firebase(ref, {objectFactory: MyFactory}).$asObject();
       * </code></pre>
       *
       * @param {Function} [ChildClass] a child class which should inherit FirebaseObject
       * @param {Object} [methods] a list of functions to add onto the prototype
       * @returns {Function} a new factory suitable for use with $firebase
       */
      FirebaseObject.$extend = function(ChildClass, methods) {
        if( arguments.length === 1 && angular.isObject(ChildClass) ) {
          methods = ChildClass;
          ChildClass = function(ref) {
            if( !(this instanceof ChildClass) ) {
              return new ChildClass(ref);
            }
            FirebaseObject.apply(this, arguments);
          };
        }
        return $firebaseUtils.inherit(ChildClass, FirebaseObject, methods);
      };

      /**
       * Creates a three-way data binding on a scope variable.
       *
       * @param {FirebaseObject} rec
       * @returns {*}
       * @constructor
       */
      function ThreeWayBinding(rec) {
        this.subs = [];
        this.scope = null;
        this.key = null;
        this.rec = rec;
      }

      ThreeWayBinding.prototype = {
        assertNotBound: function(varName) {
          if( this.scope ) {
            var msg = 'Cannot bind to ' + varName + ' because this instance is already bound to ' +
              this.key + '; one binding per instance ' +
              '(call unbind method or create another FirebaseObject instance)';
            $log.error(msg);
            return $firebaseUtils.reject(msg);
          }
        },

        bindTo: function(scope, varName) {
          function _bind(self) {
            var sending = false;
            var parsed = $parse(varName);
            var rec = self.rec;
            self.scope = scope;
            self.varName = varName;

            function equals(scopeValue) {
              return angular.equals(scopeValue, rec) &&
                scopeValue.$priority === rec.$priority &&
                scopeValue.$value === rec.$value;
            }

            function setScope(rec) {
              parsed.assign(scope, $firebaseUtils.scopeData(rec));
            }

            var send = $firebaseUtils.debounce(function(val) {
              var scopeData = $firebaseUtils.scopeData(val);
              rec.$$scopeUpdated(scopeData)
                ['finally'](function() {
                  sending = false;
                  if(!scopeData.hasOwnProperty('$value')){
                    delete rec.$value;
                    delete parsed(scope).$value;
                  }
                  setScope(rec);
                }
              );
            }, 50, 500);

            var scopeUpdated = function(newVal) {
              newVal = newVal[0];
              if( !equals(newVal) ) {
                sending = true;
                send(newVal);
              }
            };

            var recUpdated = function() {
              if( !sending && !equals(parsed(scope)) ) {
                setScope(rec);
              }
            };

            // $watch will not check any vars prefixed with $, so we
            // manually check $priority and $value using this method
            function watchExp(){
              var obj = parsed(scope);
              return [obj, obj.$priority, obj.$value];
            }

            setScope(rec);
            self.subs.push(scope.$on('$destroy', self.unbind.bind(self)));

            // monitor scope for any changes
            self.subs.push(scope.$watch(watchExp, scopeUpdated, true));

            // monitor the object for changes
            self.subs.push(rec.$watch(recUpdated));

            return self.unbind.bind(self);
          }

          return this.assertNotBound(varName) || _bind(this);
        },

        unbind: function() {
          if( this.scope ) {
            angular.forEach(this.subs, function(unbind) {
              unbind();
            });
            this.subs = [];
            this.scope = null;
            this.key = null;
          }
        },

        destroy: function() {
          this.unbind();
          this.rec = null;
        }
      };

      function ObjectSyncManager(firebaseObject, ref) {
        function destroy(err) {
          if( !sync.isDestroyed ) {
            sync.isDestroyed = true;
            ref.off('value', applyUpdate);
            firebaseObject = null;
            initComplete(err||'destroyed');
          }
        }

        function init() {
          ref.on('value', applyUpdate, error);
          ref.once('value', function(snap) {
            if (angular.isArray(snap.val())) {
              $log.warn('Storing data using array indices in Firebase can result in unexpected behavior. See https://www.firebase.com/docs/web/guide/understanding-data.html#section-arrays-in-firebase for more information. Also note that you probably wanted $firebaseArray and not $firebaseObject.');
            }

            initComplete(null);
          }, initComplete);
        }

        // call initComplete(); do not call this directly
        function _initComplete(err) {
          if( !isResolved ) {
            isResolved = true;
            if( err ) { def.reject(err); }
            else { def.resolve(firebaseObject); }
          }
        }

        var isResolved = false;
        var def = $firebaseUtils.defer();
        var applyUpdate = $firebaseUtils.batch(function(snap) {
          var changed = firebaseObject.$$updated(snap);
          if( changed ) {
            // notifies $watch listeners and
            // updates $scope if bound to a variable
            firebaseObject.$$notify();
          }
        });
        var error = $firebaseUtils.batch(function(err) {
          _initComplete(err);
          if( firebaseObject ) {
            firebaseObject.$$error(err);
          }
        });
        var initComplete = $firebaseUtils.batch(_initComplete);

        var sync = {
          isDestroyed: false,
          destroy: destroy,
          init: init,
          ready: function() { return def.promise; }
        };
        return sync;
      }

      return FirebaseObject;
    }
  ]);

  /** @deprecated */
  angular.module('firebase').factory('$FirebaseObject', ['$log', '$firebaseObject',
    function($log, $firebaseObject) {
      return function() {
        $log.warn('$FirebaseObject has been renamed. Use $firebaseObject instead.');
        return $firebaseObject.apply(null, arguments);
      };
    }
  ]);
})();

(function() {
  'use strict';

  angular.module("firebase")

    /** @deprecated */
    .factory("$firebase", function() {
      return function() {
        throw new Error('$firebase has been removed. You may instantiate $firebaseArray and $firebaseObject ' +
        'directly now. For simple write operations, just use the Firebase ref directly. ' +
        'See the AngularFire 1.0.0 changelog for details: https://www.firebase.com/docs/web/libraries/angular/changelog.html');
      };
    });

})();

'use strict';

// Shim Array.indexOf for IE compatibility.
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement, fromIndex) {
    if (this === undefined || this === null) {
      throw new TypeError("'this' is null or not defined");
    }
    // Hack to convert object.length to a UInt32
    // jshint -W016
    var length = this.length >>> 0;
    fromIndex = +fromIndex || 0;
    // jshint +W016

    if (Math.abs(fromIndex) === Infinity) {
      fromIndex = 0;
    }

    if (fromIndex < 0) {
      fromIndex += length;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
    }

    for (;fromIndex < length; fromIndex++) {
      if (this[fromIndex] === searchElement) {
        return fromIndex;
      }
    }

    return -1;
  };
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () {},
      fBound = function () {
        return fToBind.apply(this instanceof fNOP && oThis
            ? this
            : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
if (!Array.prototype.findIndex) {
  Object.defineProperty(Array.prototype, 'findIndex', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(predicate) {
      if (this == null) {
        throw new TypeError('Array.prototype.find called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;

      for (var i = 0; i < length; i++) {
        if (i in list) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return i;
          }
        }
      }
      return -1;
    }
  });
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
if (typeof Object.create != 'function') {
  (function () {
    var F = function () {};
    Object.create = function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (o === null) {
        throw new Error('Cannot set a null [[Prototype]]');
      }
      if (typeof o != 'object') {
        throw new TypeError('Argument must be an object');
      }
      F.prototype = o;
      return new F();
    };
  })();
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
      hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
      dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
      ],
      dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}

// http://ejohn.org/blog/objectgetprototypeof/
if ( typeof Object.getPrototypeOf !== "function" ) {
  if ( typeof "test".__proto__ === "object" ) {
    Object.getPrototypeOf = function(object){
      return object.__proto__;
    };
  } else {
    Object.getPrototypeOf = function(object){
      // May break if the constructor has been tampered with
      return object.constructor.prototype;
    };
  }
}

(function() {
  'use strict';

  angular.module('firebase')
    .factory('$firebaseConfig', ["$firebaseArray", "$firebaseObject", "$injector",
      function($firebaseArray, $firebaseObject, $injector) {
        return function(configOpts) {
          // make a copy we can modify
          var opts = angular.extend({}, configOpts);
          // look up factories if passed as string names
          if( typeof opts.objectFactory === 'string' ) {
            opts.objectFactory = $injector.get(opts.objectFactory);
          }
          if( typeof opts.arrayFactory === 'string' ) {
            opts.arrayFactory = $injector.get(opts.arrayFactory);
          }
          // extend defaults and return
          return angular.extend({
            arrayFactory: $firebaseArray,
            objectFactory: $firebaseObject
          }, opts);
        };
      }
    ])

    .factory('$firebaseUtils', ["$q", "$timeout", "$rootScope",
      function($q, $timeout, $rootScope) {

        // ES6 style promises polyfill for angular 1.2.x
        // Copied from angular 1.3.x implementation: https://github.com/angular/angular.js/blob/v1.3.5/src/ng/q.js#L539
        function Q(resolver) {
          if (!angular.isFunction(resolver)) {
            throw new Error('missing resolver function');
          }

          var deferred = $q.defer();

          function resolveFn(value) {
            deferred.resolve(value);
          }

          function rejectFn(reason) {
            deferred.reject(reason);
          }

          resolver(resolveFn, rejectFn);

          return deferred.promise;
        }

        var utils = {
          /**
           * Returns a function which, each time it is invoked, will gather up the values until
           * the next "tick" in the Angular compiler process. Then they are all run at the same
           * time to avoid multiple cycles of the digest loop. Internally, this is done using $evalAsync()
           *
           * @param {Function} action
           * @param {Object} [context]
           * @returns {Function}
           */
          batch: function(action, context) {
            return function() {
              var args = Array.prototype.slice.call(arguments, 0);
              utils.compile(function() {
                action.apply(context, args);
              });
            };
          },

          /**
           * A rudimentary debounce method
           * @param {function} fn the function to debounce
           * @param {object} [ctx] the `this` context to set in fn
           * @param {int} wait number of milliseconds to pause before sending out after each invocation
           * @param {int} [maxWait] max milliseconds to wait before sending out, defaults to wait * 10 or 100
           */
          debounce: function(fn, ctx, wait, maxWait) {
            var start, cancelTimer, args, runScheduledForNextTick;
            if( typeof(ctx) === 'number' ) {
              maxWait = wait;
              wait = ctx;
              ctx = null;
            }

            if( typeof wait !== 'number' ) {
              throw new Error('Must provide a valid integer for wait. Try 0 for a default');
            }
            if( typeof(fn) !== 'function' ) {
              throw new Error('Must provide a valid function to debounce');
            }
            if( !maxWait ) { maxWait = wait*10 || 100; }

            // clears the current wait timer and creates a new one
            // however, if maxWait is exceeded, calls runNow() on the next tick.
            function resetTimer() {
              if( cancelTimer ) {
                cancelTimer();
                cancelTimer = null;
              }
              if( start && Date.now() - start > maxWait ) {
                if(!runScheduledForNextTick){
                  runScheduledForNextTick = true;
                  utils.compile(runNow);
                }
              }
              else {
                if( !start ) { start = Date.now(); }
                cancelTimer = utils.wait(runNow, wait);
              }
            }

            // Clears the queue and invokes the debounced function with the most recent arguments
            function runNow() {
              cancelTimer = null;
              start = null;
              runScheduledForNextTick = false;
              fn.apply(ctx, args);
            }

            function debounced() {
              args = Array.prototype.slice.call(arguments, 0);
              resetTimer();
            }
            debounced.running = function() {
              return start > 0;
            };

            return debounced;
          },

          assertValidRef: function(ref, msg) {
            if( !angular.isObject(ref) ||
              typeof(ref.ref) !== 'function' ||
              typeof(ref.ref().transaction) !== 'function' ) {
              throw new Error(msg || 'Invalid Firebase reference');
            }
          },

          // http://stackoverflow.com/questions/7509831/alternative-for-the-deprecated-proto
          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
          inherit: function(ChildClass, ParentClass, methods) {
            var childMethods = ChildClass.prototype;
            ChildClass.prototype = Object.create(ParentClass.prototype);
            ChildClass.prototype.constructor = ChildClass; // restoring proper constructor for child class
            angular.forEach(Object.keys(childMethods), function(k) {
              ChildClass.prototype[k] = childMethods[k];
            });
            if( angular.isObject(methods) ) {
              angular.extend(ChildClass.prototype, methods);
            }
            return ChildClass;
          },

          getPrototypeMethods: function(inst, iterator, context) {
            var methods = {};
            var objProto = Object.getPrototypeOf({});
            var proto = angular.isFunction(inst) && angular.isObject(inst.prototype)?
              inst.prototype : Object.getPrototypeOf(inst);
            while(proto && proto !== objProto) {
              for (var key in proto) {
                // we only invoke each key once; if a super is overridden it's skipped here
                if (proto.hasOwnProperty(key) && !methods.hasOwnProperty(key)) {
                  methods[key] = true;
                  iterator.call(context, proto[key], key, proto);
                }
              }
              proto = Object.getPrototypeOf(proto);
            }
          },

          getPublicMethods: function(inst, iterator, context) {
            utils.getPrototypeMethods(inst, function(m, k) {
              if( typeof(m) === 'function' && k.charAt(0) !== '_' ) {
                iterator.call(context, m, k);
              }
            });
          },

          defer: $q.defer,

          reject: $q.reject,

          resolve: $q.when,

          //TODO: Remove false branch and use only angular implementation when we drop angular 1.2.x support.
          promise: angular.isFunction($q) ? $q : Q,

          makeNodeResolver:function(deferred){
            return function(err,result){
              if(err === null){
                if(arguments.length > 2){
                  result = Array.prototype.slice.call(arguments,1);
                }
                deferred.resolve(result);
              }
              else {
                deferred.reject(err);
              }
            };
          },

          wait: function(fn, wait) {
            var to = $timeout(fn, wait||0);
            return function() {
              if( to ) {
                $timeout.cancel(to);
                to = null;
              }
            };
          },

          compile: function(fn) {
            return $rootScope.$evalAsync(fn||function() {});
          },

          deepCopy: function(obj) {
            if( !angular.isObject(obj) ) { return obj; }
            var newCopy = angular.isArray(obj) ? obj.slice() : angular.extend({}, obj);
            for (var key in newCopy) {
              if (newCopy.hasOwnProperty(key)) {
                if (angular.isObject(newCopy[key])) {
                  newCopy[key] = utils.deepCopy(newCopy[key]);
                }
              }
            }
            return newCopy;
          },

          trimKeys: function(dest, source) {
            utils.each(dest, function(v,k) {
              if( !source.hasOwnProperty(k) ) {
                delete dest[k];
              }
            });
          },

          scopeData: function(dataOrRec) {
            var data = {
              $id: dataOrRec.$id,
              $priority: dataOrRec.$priority
            };
            var hasPublicProp = false;
            utils.each(dataOrRec, function(v,k) {
              hasPublicProp = true;
              data[k] = utils.deepCopy(v);
            });
            if(!hasPublicProp && dataOrRec.hasOwnProperty('$value')){
              data.$value = dataOrRec.$value;
            }
            return data;
          },

          updateRec: function(rec, snap) {
            var data = snap.val();
            var oldData = angular.extend({}, rec);

            // deal with primitives
            if( !angular.isObject(data) ) {
              rec.$value = data;
              data = {};
            }
            else {
              delete rec.$value;
            }

            // apply changes: remove old keys, insert new data, set priority
            utils.trimKeys(rec, data);
            angular.extend(rec, data);
            rec.$priority = snap.getPriority();

            return !angular.equals(oldData, rec) ||
              oldData.$value !== rec.$value ||
              oldData.$priority !== rec.$priority;
          },

          applyDefaults: function(rec, defaults) {
            if( angular.isObject(defaults) ) {
              angular.forEach(defaults, function(v,k) {
                if( !rec.hasOwnProperty(k) ) {
                  rec[k] = v;
                }
              });
            }
            return rec;
          },

          dataKeys: function(obj) {
            var out = [];
            utils.each(obj, function(v,k) {
              out.push(k);
            });
            return out;
          },

          each: function(obj, iterator, context) {
            if(angular.isObject(obj)) {
              for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                  var c = k.charAt(0);
                  if( c !== '_' && c !== '$' && c !== '.' ) {
                    iterator.call(context, obj[k], k, obj);
                  }
                }
              }
            }
            else if(angular.isArray(obj)) {
              for(var i = 0, len = obj.length; i < len; i++) {
                iterator.call(context, obj[i], i, obj);
              }
            }
            return obj;
          },

          /**
           * A utility for retrieving a Firebase reference or DataSnapshot's
           * key name. This is backwards-compatible with `name()` from Firebase
           * 1.x.x and `key()` from Firebase 2.0.0+. Once support for Firebase
           * 1.x.x is dropped in AngularFire, this helper can be removed.
           */
          getKey: function(refOrSnapshot) {
            return (typeof refOrSnapshot.key === 'function') ? refOrSnapshot.key() : refOrSnapshot.name();
          },

          /**
           * A utility for converting records to JSON objects
           * which we can save into Firebase. It asserts valid
           * keys and strips off any items prefixed with $.
           *
           * If the rec passed into this method has a toJSON()
           * method, that will be used in place of the custom
           * functionality here.
           *
           * @param rec
           * @returns {*}
           */
          toJSON: function(rec) {
            var dat;
            if( !angular.isObject(rec) ) {
              rec = {$value: rec};
            }
            if (angular.isFunction(rec.toJSON)) {
              dat = rec.toJSON();
            }
            else {
              dat = {};
              utils.each(rec, function (v, k) {
                dat[k] = stripDollarPrefixedKeys(v);
              });
            }
            if( angular.isDefined(rec.$value) && Object.keys(dat).length === 0 && rec.$value !== null ) {
              dat['.value'] = rec.$value;
            }
            if( angular.isDefined(rec.$priority) && Object.keys(dat).length > 0 && rec.$priority !== null ) {
              dat['.priority'] = rec.$priority;
            }
            angular.forEach(dat, function(v,k) {
              if (k.match(/[.$\[\]#\/]/) && k !== '.value' && k !== '.priority' ) {
                throw new Error('Invalid key ' + k + ' (cannot contain .$[]#)');
              }
              else if( angular.isUndefined(v) ) {
                throw new Error('Key '+k+' was undefined. Cannot pass undefined in JSON. Use null instead.');
              }
            });
            return dat;
          },

          doSet: function(ref, data) {
            var def = utils.defer();
            if( angular.isFunction(ref.set) || !angular.isObject(data) ) {
              // this is not a query, just do a flat set
              ref.set(data, utils.makeNodeResolver(def));
            }
            else {
              var dataCopy = angular.extend({}, data);
              // this is a query, so we will replace all the elements
              // of this query with the value provided, but not blow away
              // the entire Firebase path
              ref.once('value', function(snap) {
                snap.forEach(function(ss) {
                  if( !dataCopy.hasOwnProperty(utils.getKey(ss)) ) {
                    dataCopy[utils.getKey(ss)] = null;
                  }
                });
                ref.ref().update(dataCopy, utils.makeNodeResolver(def));
              }, function(err) {
                def.reject(err);
              });
            }
            return def.promise;
          },

          doRemove: function(ref) {
            var def = utils.defer();
            if( angular.isFunction(ref.remove) ) {
              // ref is not a query, just do a flat remove
              ref.remove(utils.makeNodeResolver(def));
            }
            else {
              // ref is a query so let's only remove the
              // items in the query and not the entire path
              ref.once('value', function(snap) {
                var promises = [];
                snap.forEach(function(ss) {
                  var d = utils.defer();
                  promises.push(d.promise);
                  ss.ref().remove(utils.makeNodeResolver(def));
                });
                utils.allPromises(promises)
                  .then(function() {
                    def.resolve(ref);
                  },
                  function(err){
                    def.reject(err);
                  }
                );
              }, function(err) {
                def.reject(err);
              });
            }
            return def.promise;
          },

          /**
           * AngularFire version number.
           */
          VERSION: '1.1.4',

          allPromises: $q.all.bind($q)
        };

        return utils;
      }
    ]);

    function stripDollarPrefixedKeys(data) {
      if( !angular.isObject(data) ) { return data; }
      var out = angular.isArray(data)? [] : {};
      angular.forEach(data, function(v,k) {
        if(typeof k !== 'string' || k.charAt(0) !== '$') {
          out[k] = stripDollarPrefixedKeys(v);
        }
      });
      return out;
    }
})();

},{}],4:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":43}],5:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],6:[function(require,module,exports){

},{}],7:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":5,"ieee754":11,"isarray":8}],8:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],9:[function(require,module,exports){
(function (Buffer){
'use strict';
var fs = require('fs');
var path = require('path');

var commentRx = /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+;)?base64,(.*)$/mg;
var mapFileCommentRx =
  //Example (Extra space between slashes added to solve Safari bug. Exclude space in production):
  //     / /# sourceMappingURL=foo.js.map           
  /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg

function decodeBase64(base64) {
  return new Buffer(base64, 'base64').toString();
}

function stripComment(sm) {
  return sm.split(',').pop();
}

function readFromFileMap(sm, dir) {
  // NOTE: this will only work on the server since it attempts to read the map file

  var r = mapFileCommentRx.exec(sm);
  mapFileCommentRx.lastIndex = 0;

  // for some odd reason //# .. captures in 1 and /* .. */ in 2
  var filename = r[1] || r[2];
  var filepath = path.join(dir, filename);

  try {
    return fs.readFileSync(filepath, 'utf8');
  } catch (e) {
    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
  }
}

function Converter (sm, opts) {
  opts = opts || {};

  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
  if (opts.hasComment) sm = stripComment(sm);
  if (opts.isEncoded) sm = decodeBase64(sm);
  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);

  this.sourcemap = sm;
}

function convertFromLargeSource(content){
  var lines = content.split('\n');
  var line;
  // find first line which contains a source map starting at end of content
  for (var i = lines.length - 1; i > 0; i--) {
    line = lines[i]
    if (~line.indexOf('sourceMappingURL=data:')) return exports.fromComment(line);
  }
}

Converter.prototype.toJSON = function (space) {
  return JSON.stringify(this.sourcemap, null, space);
};

Converter.prototype.toBase64 = function () {
  var json = this.toJSON();
  return new Buffer(json).toString('base64');
};

Converter.prototype.toComment = function (options) {
  var base64 = this.toBase64();
  var data = 'sourceMappingURL=data:application/json;base64,' + base64;
  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
};

// returns copy instead of original
Converter.prototype.toObject = function () {
  return JSON.parse(this.toJSON());
};

Converter.prototype.addProperty = function (key, value) {
  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');
  return this.setProperty(key, value);
};

Converter.prototype.setProperty = function (key, value) {
  this.sourcemap[key] = value;
  return this;
};

Converter.prototype.getProperty = function (key) {
  return this.sourcemap[key];
};

exports.fromObject = function (obj) {
  return new Converter(obj);
};

exports.fromJSON = function (json) {
  return new Converter(json, { isJSON: true });
};

exports.fromBase64 = function (base64) {
  return new Converter(base64, { isEncoded: true });
};

exports.fromComment = function (comment) {
  comment = comment
    .replace(/^\/\*/g, '//')
    .replace(/\*\/$/g, '');

  return new Converter(comment, { isEncoded: true, hasComment: true });
};

exports.fromMapFileComment = function (comment, dir) {
  return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
};

// Finds last sourcemap comment in file or returns null if none was found
exports.fromSource = function (content, largeSource) {
  if (largeSource) {
    var res = convertFromLargeSource(content);
    return res ? res : null;
  }

  var m = content.match(commentRx);
  commentRx.lastIndex = 0;
  return m ? exports.fromComment(m.pop()) : null;
};

// Finds last sourcemap comment in file or returns null if none was found
exports.fromMapFileSource = function (content, dir) {
  var m = content.match(mapFileCommentRx);
  mapFileCommentRx.lastIndex = 0;
  return m ? exports.fromMapFileComment(m.pop(), dir) : null;
};

exports.removeComments = function (src) {
  commentRx.lastIndex = 0;
  return src.replace(commentRx, '');
};

exports.removeMapFileComments = function (src) {
  mapFileCommentRx.lastIndex = 0;
  return src.replace(mapFileCommentRx, '');
};

Object.defineProperty(exports, 'commentRegex', {
  get: function getCommentRegex () {
    commentRx.lastIndex = 0;
    return commentRx;
  }
});

Object.defineProperty(exports, 'mapFileCommentRegex', {
  get: function getMapFileCommentRegex () {
    mapFileCommentRx.lastIndex = 0;
    return mapFileCommentRx;
  }
});

}).call(this,require("buffer").Buffer)

},{"buffer":7,"fs":6,"path":23}],10:[function(require,module,exports){
/*! @license Firebase v2.4.1
    License: https://www.firebase.com/terms/terms-of-service.html */
(function() {var h,n=this;function p(a){return void 0!==a}function aa(){}function ba(a){a.yb=function(){return a.zf?a.zf:a.zf=new a}}
function ca(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function da(a){return"array"==ca(a)}function ea(a){var b=ca(a);return"array"==b||"object"==b&&"number"==typeof a.length}function q(a){return"string"==typeof a}function fa(a){return"number"==typeof a}function r(a){return"function"==ca(a)}function ga(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}function ha(a,b,c){return a.call.apply(a.bind,arguments)}
function ia(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function u(a,b,c){u=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?ha:ia;return u.apply(null,arguments)}var ja=Date.now||function(){return+new Date};
function ka(a,b){function c(){}c.prototype=b.prototype;a.oh=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.kh=function(a,c,f){for(var g=Array(arguments.length-2),k=2;k<arguments.length;k++)g[k-2]=arguments[k];return b.prototype[c].apply(a,g)}};function la(a){if(Error.captureStackTrace)Error.captureStackTrace(this,la);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}ka(la,Error);la.prototype.name="CustomError";function v(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function ma(a,b){var c={},d;for(d in a)c[d]=b.call(void 0,a[d],d,a);return c}function na(a,b){for(var c in a)if(!b.call(void 0,a[c],c,a))return!1;return!0}function oa(a){var b=0,c;for(c in a)b++;return b}function pa(a){for(var b in a)return b}function qa(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function ra(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function sa(a,b){for(var c in a)if(a[c]==b)return!0;return!1}
function ta(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d}function ua(a,b){var c=ta(a,b,void 0);return c&&a[c]}function va(a){for(var b in a)return!1;return!0}function wa(a){var b={},c;for(c in a)b[c]=a[c];return b}var xa="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function ya(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<xa.length;f++)c=xa[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function za(a){a=String(a);if(/^\s*$/.test(a)?0:/^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g,"@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,"")))try{return eval("("+a+")")}catch(b){}throw Error("Invalid JSON string: "+a);}function Aa(){this.Vd=void 0}
function Ba(a,b,c){switch(typeof b){case "string":Ca(b,c);break;case "number":c.push(isFinite(b)&&!isNaN(b)?b:"null");break;case "boolean":c.push(b);break;case "undefined":c.push("null");break;case "object":if(null==b){c.push("null");break}if(da(b)){var d=b.length;c.push("[");for(var e="",f=0;f<d;f++)c.push(e),e=b[f],Ba(a,a.Vd?a.Vd.call(b,String(f),e):e,c),e=",";c.push("]");break}c.push("{");d="";for(f in b)Object.prototype.hasOwnProperty.call(b,f)&&(e=b[f],"function"!=typeof e&&(c.push(d),Ca(f,c),
c.push(":"),Ba(a,a.Vd?a.Vd.call(b,f,e):e,c),d=","));c.push("}");break;case "function":break;default:throw Error("Unknown type: "+typeof b);}}var Da={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},Ea=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function Ca(a,b){b.push('"',a.replace(Ea,function(a){if(a in Da)return Da[a];var b=a.charCodeAt(0),e="\\u";16>b?e+="000":256>b?e+="00":4096>b&&(e+="0");return Da[a]=e+b.toString(16)}),'"')};function Fa(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^ja()).toString(36)};var w;a:{var Ga=n.navigator;if(Ga){var Ha=Ga.userAgent;if(Ha){w=Ha;break a}}w=""};function Ia(){this.Ya=-1};function Ja(){this.Ya=-1;this.Ya=64;this.P=[];this.pe=[];this.eg=[];this.Od=[];this.Od[0]=128;for(var a=1;a<this.Ya;++a)this.Od[a]=0;this.ge=this.ec=0;this.reset()}ka(Ja,Ia);Ja.prototype.reset=function(){this.P[0]=1732584193;this.P[1]=4023233417;this.P[2]=2562383102;this.P[3]=271733878;this.P[4]=3285377520;this.ge=this.ec=0};
function Ka(a,b,c){c||(c=0);var d=a.eg;if(q(b))for(var e=0;16>e;e++)d[e]=b.charCodeAt(c)<<24|b.charCodeAt(c+1)<<16|b.charCodeAt(c+2)<<8|b.charCodeAt(c+3),c+=4;else for(e=0;16>e;e++)d[e]=b[c]<<24|b[c+1]<<16|b[c+2]<<8|b[c+3],c+=4;for(e=16;80>e;e++){var f=d[e-3]^d[e-8]^d[e-14]^d[e-16];d[e]=(f<<1|f>>>31)&4294967295}b=a.P[0];c=a.P[1];for(var g=a.P[2],k=a.P[3],m=a.P[4],l,e=0;80>e;e++)40>e?20>e?(f=k^c&(g^k),l=1518500249):(f=c^g^k,l=1859775393):60>e?(f=c&g|k&(c|g),l=2400959708):(f=c^g^k,l=3395469782),f=(b<<
5|b>>>27)+f+m+l+d[e]&4294967295,m=k,k=g,g=(c<<30|c>>>2)&4294967295,c=b,b=f;a.P[0]=a.P[0]+b&4294967295;a.P[1]=a.P[1]+c&4294967295;a.P[2]=a.P[2]+g&4294967295;a.P[3]=a.P[3]+k&4294967295;a.P[4]=a.P[4]+m&4294967295}
Ja.prototype.update=function(a,b){if(null!=a){p(b)||(b=a.length);for(var c=b-this.Ya,d=0,e=this.pe,f=this.ec;d<b;){if(0==f)for(;d<=c;)Ka(this,a,d),d+=this.Ya;if(q(a))for(;d<b;){if(e[f]=a.charCodeAt(d),++f,++d,f==this.Ya){Ka(this,e);f=0;break}}else for(;d<b;)if(e[f]=a[d],++f,++d,f==this.Ya){Ka(this,e);f=0;break}}this.ec=f;this.ge+=b}};var x=Array.prototype,La=x.indexOf?function(a,b,c){return x.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(q(a))return q(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},Ma=x.forEach?function(a,b,c){x.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},Na=x.filter?function(a,b,c){return x.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=q(a)?
a.split(""):a,k=0;k<d;k++)if(k in g){var m=g[k];b.call(c,m,k,a)&&(e[f++]=m)}return e},Oa=x.map?function(a,b,c){return x.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=q(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Pa=x.reduce?function(a,b,c,d){for(var e=[],f=1,g=arguments.length;f<g;f++)e.push(arguments[f]);d&&(e[0]=u(b,d));return x.reduce.apply(a,e)}:function(a,b,c,d){var e=c;Ma(a,function(c,g){e=b.call(d,e,c,g,a)});return e},Qa=x.every?function(a,b,
c){return x.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0};function Ra(a,b){var c=Sa(a,b,void 0);return 0>c?null:q(a)?a.charAt(c):a[c]}function Sa(a,b,c){for(var d=a.length,e=q(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return-1}function Ta(a,b){var c=La(a,b);0<=c&&x.splice.call(a,c,1)}function Ua(a,b,c){return 2>=arguments.length?x.slice.call(a,b):x.slice.call(a,b,c)}
function Va(a,b){a.sort(b||Wa)}function Wa(a,b){return a>b?1:a<b?-1:0};function Xa(a){n.setTimeout(function(){throw a;},0)}var Ya;
function Za(){var a=n.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&-1==w.indexOf("Presto")&&(a=function(){var a=document.createElement("iframe");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow,a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host,a=u(function(a){if(("*"==d||a.origin==
d)&&a.data==c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&-1==w.indexOf("Trident")&&-1==w.indexOf("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(p(c.next)){c=c.next;var a=c.hb;c.hb=null;a()}};return function(a){d.next={hb:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("script")?function(a){var b=
document.createElement("script");b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){n.setTimeout(a,0)}};function $a(a,b){ab||bb();cb||(ab(),cb=!0);db.push(new eb(a,b))}var ab;function bb(){if(n.Promise&&n.Promise.resolve){var a=n.Promise.resolve();ab=function(){a.then(fb)}}else ab=function(){var a=fb;!r(n.setImmediate)||n.Window&&n.Window.prototype&&n.Window.prototype.setImmediate==n.setImmediate?(Ya||(Ya=Za()),Ya(a)):n.setImmediate(a)}}var cb=!1,db=[];[].push(function(){cb=!1;db=[]});
function fb(){for(;db.length;){var a=db;db=[];for(var b=0;b<a.length;b++){var c=a[b];try{c.yg.call(c.scope)}catch(d){Xa(d)}}}cb=!1}function eb(a,b){this.yg=a;this.scope=b};var gb=-1!=w.indexOf("Opera")||-1!=w.indexOf("OPR"),hb=-1!=w.indexOf("Trident")||-1!=w.indexOf("MSIE"),ib=-1!=w.indexOf("Gecko")&&-1==w.toLowerCase().indexOf("webkit")&&!(-1!=w.indexOf("Trident")||-1!=w.indexOf("MSIE")),jb=-1!=w.toLowerCase().indexOf("webkit");
(function(){var a="",b;if(gb&&n.opera)return a=n.opera.version,r(a)?a():a;ib?b=/rv\:([^\);]+)(\)|;)/:hb?b=/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/:jb&&(b=/WebKit\/(\S+)/);b&&(a=(a=b.exec(w))?a[1]:"");return hb&&(b=(b=n.document)?b.documentMode:void 0,b>parseFloat(a))?String(b):a})();var kb=null,lb=null,mb=null;function nb(a,b){if(!ea(a))throw Error("encodeByteArray takes an array as a parameter");ob();for(var c=b?lb:kb,d=[],e=0;e<a.length;e+=3){var f=a[e],g=e+1<a.length,k=g?a[e+1]:0,m=e+2<a.length,l=m?a[e+2]:0,t=f>>2,f=(f&3)<<4|k>>4,k=(k&15)<<2|l>>6,l=l&63;m||(l=64,g||(k=64));d.push(c[t],c[f],c[k],c[l])}return d.join("")}
function ob(){if(!kb){kb={};lb={};mb={};for(var a=0;65>a;a++)kb[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),lb[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a),mb[lb[a]]=a,62<=a&&(mb["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a)]=a)}};function pb(a,b){this.N=qb;this.Rf=void 0;this.Ba=this.Ha=null;this.yd=this.ye=!1;if(a==rb)sb(this,tb,b);else try{var c=this;a.call(b,function(a){sb(c,tb,a)},function(a){if(!(a instanceof ub))try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(b){}sb(c,vb,a)})}catch(d){sb(this,vb,d)}}var qb=0,tb=2,vb=3;function rb(){}pb.prototype.then=function(a,b,c){return wb(this,r(a)?a:null,r(b)?b:null,c)};pb.prototype.then=pb.prototype.then;pb.prototype.$goog_Thenable=!0;h=pb.prototype;
h.fh=function(a,b){return wb(this,null,a,b)};h.cancel=function(a){this.N==qb&&$a(function(){var b=new ub(a);xb(this,b)},this)};function xb(a,b){if(a.N==qb)if(a.Ha){var c=a.Ha;if(c.Ba){for(var d=0,e=-1,f=0,g;g=c.Ba[f];f++)if(g=g.o)if(d++,g==a&&(e=f),0<=e&&1<d)break;0<=e&&(c.N==qb&&1==d?xb(c,b):(d=c.Ba.splice(e,1)[0],yb(c,d,vb,b)))}a.Ha=null}else sb(a,vb,b)}function zb(a,b){a.Ba&&a.Ba.length||a.N!=tb&&a.N!=vb||Ab(a);a.Ba||(a.Ba=[]);a.Ba.push(b)}
function wb(a,b,c,d){var e={o:null,Hf:null,Jf:null};e.o=new pb(function(a,g){e.Hf=b?function(c){try{var e=b.call(d,c);a(e)}catch(l){g(l)}}:a;e.Jf=c?function(b){try{var e=c.call(d,b);!p(e)&&b instanceof ub?g(b):a(e)}catch(l){g(l)}}:g});e.o.Ha=a;zb(a,e);return e.o}h.Yf=function(a){this.N=qb;sb(this,tb,a)};h.Zf=function(a){this.N=qb;sb(this,vb,a)};
function sb(a,b,c){if(a.N==qb){if(a==c)b=vb,c=new TypeError("Promise cannot resolve to itself");else{var d;if(c)try{d=!!c.$goog_Thenable}catch(e){d=!1}else d=!1;if(d){a.N=1;c.then(a.Yf,a.Zf,a);return}if(ga(c))try{var f=c.then;if(r(f)){Bb(a,c,f);return}}catch(g){b=vb,c=g}}a.Rf=c;a.N=b;a.Ha=null;Ab(a);b!=vb||c instanceof ub||Cb(a,c)}}function Bb(a,b,c){function d(b){f||(f=!0,a.Zf(b))}function e(b){f||(f=!0,a.Yf(b))}a.N=1;var f=!1;try{c.call(b,e,d)}catch(g){d(g)}}
function Ab(a){a.ye||(a.ye=!0,$a(a.wg,a))}h.wg=function(){for(;this.Ba&&this.Ba.length;){var a=this.Ba;this.Ba=null;for(var b=0;b<a.length;b++)yb(this,a[b],this.N,this.Rf)}this.ye=!1};function yb(a,b,c,d){if(c==tb)b.Hf(d);else{if(b.o)for(;a&&a.yd;a=a.Ha)a.yd=!1;b.Jf(d)}}function Cb(a,b){a.yd=!0;$a(function(){a.yd&&Db.call(null,b)})}var Db=Xa;function ub(a){la.call(this,a)}ka(ub,la);ub.prototype.name="cancel";var Eb=Eb||"2.4.1";function y(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function z(a,b){if(Object.prototype.hasOwnProperty.call(a,b))return a[b]}function Fb(a,b){for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&b(c,a[c])}function Gb(a){var b={};Fb(a,function(a,d){b[a]=d});return b}function Hb(a){return"object"===typeof a&&null!==a};function Ib(a){var b=[];Fb(a,function(a,d){da(d)?Ma(d,function(d){b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))}):b.push(encodeURIComponent(a)+"="+encodeURIComponent(d))});return b.length?"&"+b.join("&"):""}function Jb(a){var b={};a=a.replace(/^\?/,"").split("&");Ma(a,function(a){a&&(a=a.split("="),b[a[0]]=a[1])});return b};function Kb(a,b){if(!a)throw Lb(b);}function Lb(a){return Error("Firebase ("+Eb+") INTERNAL ASSERT FAILED: "+a)};var Mb=n.Promise||pb;pb.prototype["catch"]=pb.prototype.fh;function B(){var a=this;this.reject=this.resolve=null;this.D=new Mb(function(b,c){a.resolve=b;a.reject=c})}function C(a,b){return function(c,d){c?a.reject(c):a.resolve(d);r(b)&&(Nb(a.D),1===b.length?b(c):b(c,d))}}function Nb(a){a.then(void 0,aa)};function Ob(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);55296<=e&&56319>=e&&(e-=55296,d++,Kb(d<a.length,"Surrogate pair missing trail surrogate."),e=65536+(e<<10)+(a.charCodeAt(d)-56320));128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(65536>e?b[c++]=e>>12|224:(b[c++]=e>>18|240,b[c++]=e>>12&63|128),b[c++]=e>>6&63|128),b[c++]=e&63|128)}return b}function Pb(a){for(var b=0,c=0;c<a.length;c++){var d=a.charCodeAt(c);128>d?b++:2048>d?b+=2:55296<=d&&56319>=d?(b+=4,c++):b+=3}return b};function D(a,b,c,d){var e;d<b?e="at least "+b:d>c&&(e=0===c?"none":"no more than "+c);if(e)throw Error(a+" failed: Was called with "+d+(1===d?" argument.":" arguments.")+" Expects "+e+".");}function E(a,b,c){var d="";switch(b){case 1:d=c?"first":"First";break;case 2:d=c?"second":"Second";break;case 3:d=c?"third":"Third";break;case 4:d=c?"fourth":"Fourth";break;default:throw Error("errorPrefix called with argumentNumber > 4.  Need to update it?");}return a=a+" failed: "+(d+" argument ")}
function F(a,b,c,d){if((!d||p(c))&&!r(c))throw Error(E(a,b,d)+"must be a valid function.");}function Qb(a,b,c){if(p(c)&&(!ga(c)||null===c))throw Error(E(a,b,!0)+"must be a valid context object.");};function Rb(a){return"undefined"!==typeof JSON&&p(JSON.parse)?JSON.parse(a):za(a)}function G(a){if("undefined"!==typeof JSON&&p(JSON.stringify))a=JSON.stringify(a);else{var b=[];Ba(new Aa,a,b);a=b.join("")}return a};function Sb(){this.Zd=H}Sb.prototype.j=function(a){return this.Zd.S(a)};Sb.prototype.toString=function(){return this.Zd.toString()};function Tb(){}Tb.prototype.uf=function(){return null};Tb.prototype.Ce=function(){return null};var Ub=new Tb;function Vb(a,b,c){this.bg=a;this.Oa=b;this.Nd=c}Vb.prototype.uf=function(a){var b=this.Oa.Q;if(Wb(b,a))return b.j().T(a);b=null!=this.Nd?new Xb(this.Nd,!0,!1):this.Oa.w();return this.bg.Bc(a,b)};Vb.prototype.Ce=function(a,b,c){var d=null!=this.Nd?this.Nd:Yb(this.Oa);a=this.bg.qe(d,b,1,c,a);return 0===a.length?null:a[0]};function Zb(){this.xb=[]}function $b(a,b){for(var c=null,d=0;d<b.length;d++){var e=b[d],f=e.cc();null===c||f.ea(c.cc())||(a.xb.push(c),c=null);null===c&&(c=new ac(f));c.add(e)}c&&a.xb.push(c)}function bc(a,b,c){$b(a,c);cc(a,function(a){return a.ea(b)})}function dc(a,b,c){$b(a,c);cc(a,function(a){return a.contains(b)||b.contains(a)})}
function cc(a,b){for(var c=!0,d=0;d<a.xb.length;d++){var e=a.xb[d];if(e)if(e=e.cc(),b(e)){for(var e=a.xb[d],f=0;f<e.xd.length;f++){var g=e.xd[f];if(null!==g){e.xd[f]=null;var k=g.Zb();ec&&fc("event: "+g.toString());gc(k)}}a.xb[d]=null}else c=!1}c&&(a.xb=[])}function ac(a){this.ta=a;this.xd=[]}ac.prototype.add=function(a){this.xd.push(a)};ac.prototype.cc=function(){return this.ta};function J(a,b,c,d){this.type=a;this.Na=b;this.Za=c;this.Oe=d;this.Td=void 0}function hc(a){return new J(ic,a)}var ic="value";function jc(a,b,c,d){this.xe=b;this.be=c;this.Td=d;this.wd=a}jc.prototype.cc=function(){var a=this.be.Mb();return"value"===this.wd?a.path:a.parent().path};jc.prototype.De=function(){return this.wd};jc.prototype.Zb=function(){return this.xe.Zb(this)};jc.prototype.toString=function(){return this.cc().toString()+":"+this.wd+":"+G(this.be.qf())};function kc(a,b,c){this.xe=a;this.error=b;this.path=c}kc.prototype.cc=function(){return this.path};kc.prototype.De=function(){return"cancel"};
kc.prototype.Zb=function(){return this.xe.Zb(this)};kc.prototype.toString=function(){return this.path.toString()+":cancel"};function Xb(a,b,c){this.A=a;this.ga=b;this.Yb=c}function lc(a){return a.ga}function mc(a){return a.Yb}function nc(a,b){return b.e()?a.ga&&!a.Yb:Wb(a,K(b))}function Wb(a,b){return a.ga&&!a.Yb||a.A.Fa(b)}Xb.prototype.j=function(){return this.A};function oc(a){this.pg=a;this.Gd=null}oc.prototype.get=function(){var a=this.pg.get(),b=wa(a);if(this.Gd)for(var c in this.Gd)b[c]-=this.Gd[c];this.Gd=a;return b};function pc(a,b){this.Vf={};this.hd=new oc(a);this.da=b;var c=1E4+2E4*Math.random();setTimeout(u(this.Of,this),Math.floor(c))}pc.prototype.Of=function(){var a=this.hd.get(),b={},c=!1,d;for(d in a)0<a[d]&&y(this.Vf,d)&&(b[d]=a[d],c=!0);c&&this.da.Ye(b);setTimeout(u(this.Of,this),Math.floor(6E5*Math.random()))};function qc(){this.Hc={}}function rc(a,b,c){p(c)||(c=1);y(a.Hc,b)||(a.Hc[b]=0);a.Hc[b]+=c}qc.prototype.get=function(){return wa(this.Hc)};var sc={},tc={};function uc(a){a=a.toString();sc[a]||(sc[a]=new qc);return sc[a]}function vc(a,b){var c=a.toString();tc[c]||(tc[c]=b());return tc[c]};function L(a,b){this.name=a;this.U=b}function wc(a,b){return new L(a,b)};function xc(a,b){return yc(a.name,b.name)}function zc(a,b){return yc(a,b)};function Ac(a,b,c){this.type=Bc;this.source=a;this.path=b;this.Ja=c}Ac.prototype.$c=function(a){return this.path.e()?new Ac(this.source,M,this.Ja.T(a)):new Ac(this.source,N(this.path),this.Ja)};Ac.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" overwrite: "+this.Ja.toString()+")"};function Cc(a,b){this.type=Dc;this.source=a;this.path=b}Cc.prototype.$c=function(){return this.path.e()?new Cc(this.source,M):new Cc(this.source,N(this.path))};Cc.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" listen_complete)"};function Ec(a,b){this.Pa=a;this.xa=b?b:Fc}h=Ec.prototype;h.Sa=function(a,b){return new Ec(this.Pa,this.xa.Sa(a,b,this.Pa).$(null,null,!1,null,null))};h.remove=function(a){return new Ec(this.Pa,this.xa.remove(a,this.Pa).$(null,null,!1,null,null))};h.get=function(a){for(var b,c=this.xa;!c.e();){b=this.Pa(a,c.key);if(0===b)return c.value;0>b?c=c.left:0<b&&(c=c.right)}return null};
function Gc(a,b){for(var c,d=a.xa,e=null;!d.e();){c=a.Pa(b,d.key);if(0===c){if(d.left.e())return e?e.key:null;for(d=d.left;!d.right.e();)d=d.right;return d.key}0>c?d=d.left:0<c&&(e=d,d=d.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}h.e=function(){return this.xa.e()};h.count=function(){return this.xa.count()};h.Vc=function(){return this.xa.Vc()};h.jc=function(){return this.xa.jc()};h.ka=function(a){return this.xa.ka(a)};
h.ac=function(a){return new Hc(this.xa,null,this.Pa,!1,a)};h.bc=function(a,b){return new Hc(this.xa,a,this.Pa,!1,b)};h.dc=function(a,b){return new Hc(this.xa,a,this.Pa,!0,b)};h.xf=function(a){return new Hc(this.xa,null,this.Pa,!0,a)};function Hc(a,b,c,d,e){this.Xd=e||null;this.Je=d;this.Ta=[];for(e=1;!a.e();)if(e=b?c(a.key,b):1,d&&(e*=-1),0>e)a=this.Je?a.left:a.right;else if(0===e){this.Ta.push(a);break}else this.Ta.push(a),a=this.Je?a.right:a.left}
function Ic(a){if(0===a.Ta.length)return null;var b=a.Ta.pop(),c;c=a.Xd?a.Xd(b.key,b.value):{key:b.key,value:b.value};if(a.Je)for(b=b.left;!b.e();)a.Ta.push(b),b=b.right;else for(b=b.right;!b.e();)a.Ta.push(b),b=b.left;return c}function Jc(a){if(0===a.Ta.length)return null;var b;b=a.Ta;b=b[b.length-1];return a.Xd?a.Xd(b.key,b.value):{key:b.key,value:b.value}}function Kc(a,b,c,d,e){this.key=a;this.value=b;this.color=null!=c?c:!0;this.left=null!=d?d:Fc;this.right=null!=e?e:Fc}h=Kc.prototype;
h.$=function(a,b,c,d,e){return new Kc(null!=a?a:this.key,null!=b?b:this.value,null!=c?c:this.color,null!=d?d:this.left,null!=e?e:this.right)};h.count=function(){return this.left.count()+1+this.right.count()};h.e=function(){return!1};h.ka=function(a){return this.left.ka(a)||a(this.key,this.value)||this.right.ka(a)};function Lc(a){return a.left.e()?a:Lc(a.left)}h.Vc=function(){return Lc(this).key};h.jc=function(){return this.right.e()?this.key:this.right.jc()};
h.Sa=function(a,b,c){var d,e;e=this;d=c(a,e.key);e=0>d?e.$(null,null,null,e.left.Sa(a,b,c),null):0===d?e.$(null,b,null,null,null):e.$(null,null,null,null,e.right.Sa(a,b,c));return Mc(e)};function Nc(a){if(a.left.e())return Fc;a.left.ha()||a.left.left.ha()||(a=Oc(a));a=a.$(null,null,null,Nc(a.left),null);return Mc(a)}
h.remove=function(a,b){var c,d;c=this;if(0>b(a,c.key))c.left.e()||c.left.ha()||c.left.left.ha()||(c=Oc(c)),c=c.$(null,null,null,c.left.remove(a,b),null);else{c.left.ha()&&(c=Pc(c));c.right.e()||c.right.ha()||c.right.left.ha()||(c=Qc(c),c.left.left.ha()&&(c=Pc(c),c=Qc(c)));if(0===b(a,c.key)){if(c.right.e())return Fc;d=Lc(c.right);c=c.$(d.key,d.value,null,null,Nc(c.right))}c=c.$(null,null,null,null,c.right.remove(a,b))}return Mc(c)};h.ha=function(){return this.color};
function Mc(a){a.right.ha()&&!a.left.ha()&&(a=Rc(a));a.left.ha()&&a.left.left.ha()&&(a=Pc(a));a.left.ha()&&a.right.ha()&&(a=Qc(a));return a}function Oc(a){a=Qc(a);a.right.left.ha()&&(a=a.$(null,null,null,null,Pc(a.right)),a=Rc(a),a=Qc(a));return a}function Rc(a){return a.right.$(null,null,a.color,a.$(null,null,!0,null,a.right.left),null)}function Pc(a){return a.left.$(null,null,a.color,null,a.$(null,null,!0,a.left.right,null))}
function Qc(a){return a.$(null,null,!a.color,a.left.$(null,null,!a.left.color,null,null),a.right.$(null,null,!a.right.color,null,null))}function Sc(){}h=Sc.prototype;h.$=function(){return this};h.Sa=function(a,b){return new Kc(a,b,null)};h.remove=function(){return this};h.count=function(){return 0};h.e=function(){return!0};h.ka=function(){return!1};h.Vc=function(){return null};h.jc=function(){return null};h.ha=function(){return!1};var Fc=new Sc;function Tc(a,b){return a&&"object"===typeof a?(O(".sv"in a,"Unexpected leaf node or priority contents"),b[a[".sv"]]):a}function Uc(a,b){var c=new Vc;Wc(a,new P(""),function(a,e){c.rc(a,Xc(e,b))});return c}function Xc(a,b){var c=a.C().J(),c=Tc(c,b),d;if(a.L()){var e=Tc(a.Ea(),b);return e!==a.Ea()||c!==a.C().J()?new Yc(e,Q(c)):a}d=a;c!==a.C().J()&&(d=d.ia(new Yc(c)));a.R(R,function(a,c){var e=Xc(c,b);e!==c&&(d=d.W(a,e))});return d};function Zc(){this.Ac={}}Zc.prototype.set=function(a,b){null==b?delete this.Ac[a]:this.Ac[a]=b};Zc.prototype.get=function(a){return y(this.Ac,a)?this.Ac[a]:null};Zc.prototype.remove=function(a){delete this.Ac[a]};Zc.prototype.Af=!0;function $c(a){this.Ic=a;this.Sd="firebase:"}h=$c.prototype;h.set=function(a,b){null==b?this.Ic.removeItem(this.Sd+a):this.Ic.setItem(this.Sd+a,G(b))};h.get=function(a){a=this.Ic.getItem(this.Sd+a);return null==a?null:Rb(a)};h.remove=function(a){this.Ic.removeItem(this.Sd+a)};h.Af=!1;h.toString=function(){return this.Ic.toString()};function ad(a){try{if("undefined"!==typeof window&&"undefined"!==typeof window[a]){var b=window[a];b.setItem("firebase:sentinel","cache");b.removeItem("firebase:sentinel");return new $c(b)}}catch(c){}return new Zc}var bd=ad("localStorage"),cd=ad("sessionStorage");function dd(a,b,c,d,e){this.host=a.toLowerCase();this.domain=this.host.substr(this.host.indexOf(".")+1);this.ob=b;this.lc=c;this.ih=d;this.Rd=e||"";this.ab=bd.get("host:"+a)||this.host}function ed(a,b){b!==a.ab&&(a.ab=b,"s-"===a.ab.substr(0,2)&&bd.set("host:"+a.host,a.ab))}
function fd(a,b,c){O("string"===typeof b,"typeof type must == string");O("object"===typeof c,"typeof params must == object");if(b===gd)b=(a.ob?"wss://":"ws://")+a.ab+"/.ws?";else if(b===hd)b=(a.ob?"https://":"http://")+a.ab+"/.lp?";else throw Error("Unknown connection type: "+b);a.host!==a.ab&&(c.ns=a.lc);var d=[];v(c,function(a,b){d.push(b+"="+a)});return b+d.join("&")}dd.prototype.toString=function(){var a=(this.ob?"https://":"http://")+this.host;this.Rd&&(a+="<"+this.Rd+">");return a};var id=function(){var a=1;return function(){return a++}}(),O=Kb,jd=Lb;
function kd(a){try{var b;if("undefined"!==typeof atob)b=atob(a);else{ob();for(var c=mb,d=[],e=0;e<a.length;){var f=c[a.charAt(e++)],g=e<a.length?c[a.charAt(e)]:0;++e;var k=e<a.length?c[a.charAt(e)]:64;++e;var m=e<a.length?c[a.charAt(e)]:64;++e;if(null==f||null==g||null==k||null==m)throw Error();d.push(f<<2|g>>4);64!=k&&(d.push(g<<4&240|k>>2),64!=m&&d.push(k<<6&192|m))}if(8192>d.length)b=String.fromCharCode.apply(null,d);else{a="";for(c=0;c<d.length;c+=8192)a+=String.fromCharCode.apply(null,Ua(d,c,
c+8192));b=a}}return b}catch(l){fc("base64Decode failed: ",l)}return null}function ld(a){var b=Ob(a);a=new Ja;a.update(b);var b=[],c=8*a.ge;56>a.ec?a.update(a.Od,56-a.ec):a.update(a.Od,a.Ya-(a.ec-56));for(var d=a.Ya-1;56<=d;d--)a.pe[d]=c&255,c/=256;Ka(a,a.pe);for(d=c=0;5>d;d++)for(var e=24;0<=e;e-=8)b[c]=a.P[d]>>e&255,++c;return nb(b)}
function md(a){for(var b="",c=0;c<arguments.length;c++)b=ea(arguments[c])?b+md.apply(null,arguments[c]):"object"===typeof arguments[c]?b+G(arguments[c]):b+arguments[c],b+=" ";return b}var ec=null,nd=!0;
function od(a,b){Kb(!b||!0===a||!1===a,"Can't turn on custom loggers persistently.");!0===a?("undefined"!==typeof console&&("function"===typeof console.log?ec=u(console.log,console):"object"===typeof console.log&&(ec=function(a){console.log(a)})),b&&cd.set("logging_enabled",!0)):r(a)?ec=a:(ec=null,cd.remove("logging_enabled"))}function fc(a){!0===nd&&(nd=!1,null===ec&&!0===cd.get("logging_enabled")&&od(!0));if(ec){var b=md.apply(null,arguments);ec(b)}}
function pd(a){return function(){fc(a,arguments)}}function qd(a){if("undefined"!==typeof console){var b="FIREBASE INTERNAL ERROR: "+md.apply(null,arguments);"undefined"!==typeof console.error?console.error(b):console.log(b)}}function rd(a){var b=md.apply(null,arguments);throw Error("FIREBASE FATAL ERROR: "+b);}function S(a){if("undefined"!==typeof console){var b="FIREBASE WARNING: "+md.apply(null,arguments);"undefined"!==typeof console.warn?console.warn(b):console.log(b)}}
function sd(a){var b="",c="",d="",e="",f=!0,g="https",k=443;if(q(a)){var m=a.indexOf("//");0<=m&&(g=a.substring(0,m-1),a=a.substring(m+2));m=a.indexOf("/");-1===m&&(m=a.length);b=a.substring(0,m);e="";a=a.substring(m).split("/");for(m=0;m<a.length;m++)if(0<a[m].length){var l=a[m];try{l=decodeURIComponent(l.replace(/\+/g," "))}catch(t){}e+="/"+l}a=b.split(".");3===a.length?(c=a[1],d=a[0].toLowerCase()):2===a.length&&(c=a[0]);m=b.indexOf(":");0<=m&&(f="https"===g||"wss"===g,k=b.substring(m+1),isFinite(k)&&
(k=String(k)),k=q(k)?/^\s*-?0x/i.test(k)?parseInt(k,16):parseInt(k,10):NaN)}return{host:b,port:k,domain:c,eh:d,ob:f,scheme:g,bd:e}}function td(a){return fa(a)&&(a!=a||a==Number.POSITIVE_INFINITY||a==Number.NEGATIVE_INFINITY)}
function ud(a){if("complete"===document.readyState)a();else{var b=!1,c=function(){document.body?b||(b=!0,a()):setTimeout(c,Math.floor(10))};document.addEventListener?(document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",c,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){"complete"===document.readyState&&c()}),window.attachEvent("onload",c))}}
function yc(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===a)return 1;var c=vd(a),d=vd(b);return null!==c?null!==d?0==c-d?a.length-b.length:c-d:-1:null!==d?1:a<b?-1:1}function wd(a,b){if(b&&a in b)return b[a];throw Error("Missing required key ("+a+") in object: "+G(b));}
function xd(a){if("object"!==typeof a||null===a)return G(a);var b=[],c;for(c in a)b.push(c);b.sort();c="{";for(var d=0;d<b.length;d++)0!==d&&(c+=","),c+=G(b[d]),c+=":",c+=xd(a[b[d]]);return c+"}"}function yd(a,b){if(a.length<=b)return[a];for(var c=[],d=0;d<a.length;d+=b)d+b>a?c.push(a.substring(d,a.length)):c.push(a.substring(d,d+b));return c}function zd(a,b){if(da(a))for(var c=0;c<a.length;++c)b(c,a[c]);else v(a,b)}
function Ad(a){O(!td(a),"Invalid JSON number");var b,c,d,e;0===a?(d=c=0,b=-Infinity===1/a?1:0):(b=0>a,a=Math.abs(a),a>=Math.pow(2,-1022)?(d=Math.min(Math.floor(Math.log(a)/Math.LN2),1023),c=d+1023,d=Math.round(a*Math.pow(2,52-d)-Math.pow(2,52))):(c=0,d=Math.round(a/Math.pow(2,-1074))));e=[];for(a=52;a;--a)e.push(d%2?1:0),d=Math.floor(d/2);for(a=11;a;--a)e.push(c%2?1:0),c=Math.floor(c/2);e.push(b?1:0);e.reverse();b=e.join("");c="";for(a=0;64>a;a+=8)d=parseInt(b.substr(a,8),2).toString(16),1===d.length&&
(d="0"+d),c+=d;return c.toLowerCase()}var Bd=/^-?\d{1,10}$/;function vd(a){return Bd.test(a)&&(a=Number(a),-2147483648<=a&&2147483647>=a)?a:null}function gc(a){try{a()}catch(b){setTimeout(function(){S("Exception was thrown by user callback.",b.stack||"");throw b;},Math.floor(0))}}function T(a,b){if(r(a)){var c=Array.prototype.slice.call(arguments,1).slice();gc(function(){a.apply(null,c)})}};function Cd(a){var b={},c={},d={},e="";try{var f=a.split("."),b=Rb(kd(f[0])||""),c=Rb(kd(f[1])||""),e=f[2],d=c.d||{};delete c.d}catch(g){}return{lh:b,Ec:c,data:d,ah:e}}function Dd(a){a=Cd(a).Ec;return"object"===typeof a&&a.hasOwnProperty("iat")?z(a,"iat"):null}function Ed(a){a=Cd(a);var b=a.Ec;return!!a.ah&&!!b&&"object"===typeof b&&b.hasOwnProperty("iat")};function Fd(a){this.Y=a;this.g=a.n.g}function Gd(a,b,c,d){var e=[],f=[];Ma(b,function(b){"child_changed"===b.type&&a.g.Dd(b.Oe,b.Na)&&f.push(new J("child_moved",b.Na,b.Za))});Hd(a,e,"child_removed",b,d,c);Hd(a,e,"child_added",b,d,c);Hd(a,e,"child_moved",f,d,c);Hd(a,e,"child_changed",b,d,c);Hd(a,e,ic,b,d,c);return e}function Hd(a,b,c,d,e,f){d=Na(d,function(a){return a.type===c});Va(d,u(a.qg,a));Ma(d,function(c){var d=Id(a,c,f);Ma(e,function(e){e.Qf(c.type)&&b.push(e.createEvent(d,a.Y))})})}
function Id(a,b,c){"value"!==b.type&&"child_removed"!==b.type&&(b.Td=c.wf(b.Za,b.Na,a.g));return b}Fd.prototype.qg=function(a,b){if(null==a.Za||null==b.Za)throw jd("Should only compare child_ events.");return this.g.compare(new L(a.Za,a.Na),new L(b.Za,b.Na))};function Jd(){this.ib={}}
function Kd(a,b){var c=b.type,d=b.Za;O("child_added"==c||"child_changed"==c||"child_removed"==c,"Only child changes supported for tracking");O(".priority"!==d,"Only non-priority child changes can be tracked.");var e=z(a.ib,d);if(e){var f=e.type;if("child_added"==c&&"child_removed"==f)a.ib[d]=new J("child_changed",b.Na,d,e.Na);else if("child_removed"==c&&"child_added"==f)delete a.ib[d];else if("child_removed"==c&&"child_changed"==f)a.ib[d]=new J("child_removed",e.Oe,d);else if("child_changed"==c&&
"child_added"==f)a.ib[d]=new J("child_added",b.Na,d);else if("child_changed"==c&&"child_changed"==f)a.ib[d]=new J("child_changed",b.Na,d,e.Oe);else throw jd("Illegal combination of changes: "+b+" occurred after "+e);}else a.ib[d]=b};function Ld(a){this.g=a}h=Ld.prototype;h.H=function(a,b,c,d,e,f){O(a.Mc(this.g),"A node must be indexed if only a child is updated");e=a.T(b);if(e.S(d).ea(c.S(d))&&e.e()==c.e())return a;null!=f&&(c.e()?a.Fa(b)?Kd(f,new J("child_removed",e,b)):O(a.L(),"A child remove without an old child only makes sense on a leaf node"):e.e()?Kd(f,new J("child_added",c,b)):Kd(f,new J("child_changed",c,b,e)));return a.L()&&c.e()?a:a.W(b,c).pb(this.g)};
h.ya=function(a,b,c){null!=c&&(a.L()||a.R(R,function(a,e){b.Fa(a)||Kd(c,new J("child_removed",e,a))}),b.L()||b.R(R,function(b,e){if(a.Fa(b)){var f=a.T(b);f.ea(e)||Kd(c,new J("child_changed",e,b,f))}else Kd(c,new J("child_added",e,b))}));return b.pb(this.g)};h.ia=function(a,b){return a.e()?H:a.ia(b)};h.Ra=function(){return!1};h.$b=function(){return this};function Md(a){this.Fe=new Ld(a.g);this.g=a.g;var b;a.oa?(b=Nd(a),b=a.g.Sc(Od(a),b)):b=a.g.Wc();this.gd=b;a.ra?(b=Pd(a),a=a.g.Sc(Rd(a),b)):a=a.g.Tc();this.Jc=a}h=Md.prototype;h.matches=function(a){return 0>=this.g.compare(this.gd,a)&&0>=this.g.compare(a,this.Jc)};h.H=function(a,b,c,d,e,f){this.matches(new L(b,c))||(c=H);return this.Fe.H(a,b,c,d,e,f)};
h.ya=function(a,b,c){b.L()&&(b=H);var d=b.pb(this.g),d=d.ia(H),e=this;b.R(R,function(a,b){e.matches(new L(a,b))||(d=d.W(a,H))});return this.Fe.ya(a,d,c)};h.ia=function(a){return a};h.Ra=function(){return!0};h.$b=function(){return this.Fe};function Sd(a){this.ua=new Md(a);this.g=a.g;O(a.la,"Only valid if limit has been set");this.ma=a.ma;this.Nb=!Td(a)}h=Sd.prototype;h.H=function(a,b,c,d,e,f){this.ua.matches(new L(b,c))||(c=H);return a.T(b).ea(c)?a:a.Hb()<this.ma?this.ua.$b().H(a,b,c,d,e,f):Ud(this,a,b,c,e,f)};
h.ya=function(a,b,c){var d;if(b.L()||b.e())d=H.pb(this.g);else if(2*this.ma<b.Hb()&&b.Mc(this.g)){d=H.pb(this.g);b=this.Nb?b.dc(this.ua.Jc,this.g):b.bc(this.ua.gd,this.g);for(var e=0;0<b.Ta.length&&e<this.ma;){var f=Ic(b),g;if(g=this.Nb?0>=this.g.compare(this.ua.gd,f):0>=this.g.compare(f,this.ua.Jc))d=d.W(f.name,f.U),e++;else break}}else{d=b.pb(this.g);d=d.ia(H);var k,m,l;if(this.Nb){b=d.xf(this.g);k=this.ua.Jc;m=this.ua.gd;var t=Vd(this.g);l=function(a,b){return t(b,a)}}else b=d.ac(this.g),k=this.ua.gd,
m=this.ua.Jc,l=Vd(this.g);for(var e=0,A=!1;0<b.Ta.length;)f=Ic(b),!A&&0>=l(k,f)&&(A=!0),(g=A&&e<this.ma&&0>=l(f,m))?e++:d=d.W(f.name,H)}return this.ua.$b().ya(a,d,c)};h.ia=function(a){return a};h.Ra=function(){return!0};h.$b=function(){return this.ua.$b()};
function Ud(a,b,c,d,e,f){var g;if(a.Nb){var k=Vd(a.g);g=function(a,b){return k(b,a)}}else g=Vd(a.g);O(b.Hb()==a.ma,"");var m=new L(c,d),l=a.Nb?Wd(b,a.g):Xd(b,a.g),t=a.ua.matches(m);if(b.Fa(c)){for(var A=b.T(c),l=e.Ce(a.g,l,a.Nb);null!=l&&(l.name==c||b.Fa(l.name));)l=e.Ce(a.g,l,a.Nb);e=null==l?1:g(l,m);if(t&&!d.e()&&0<=e)return null!=f&&Kd(f,new J("child_changed",d,c,A)),b.W(c,d);null!=f&&Kd(f,new J("child_removed",A,c));b=b.W(c,H);return null!=l&&a.ua.matches(l)?(null!=f&&Kd(f,new J("child_added",
l.U,l.name)),b.W(l.name,l.U)):b}return d.e()?b:t&&0<=g(l,m)?(null!=f&&(Kd(f,new J("child_removed",l.U,l.name)),Kd(f,new J("child_added",d,c))),b.W(c,d).W(l.name,H)):b};function Yd(a,b){this.me=a;this.og=b}function Zd(a){this.X=a}
Zd.prototype.gb=function(a,b,c,d){var e=new Jd,f;if(b.type===Bc)b.source.Ae?c=$d(this,a,b.path,b.Ja,c,d,e):(O(b.source.tf,"Unknown source."),f=b.source.ef||mc(a.w())&&!b.path.e(),c=ae(this,a,b.path,b.Ja,c,d,f,e));else if(b.type===be)b.source.Ae?c=ce(this,a,b.path,b.children,c,d,e):(O(b.source.tf,"Unknown source."),f=b.source.ef||mc(a.w()),c=de(this,a,b.path,b.children,c,d,f,e));else if(b.type===ee)if(b.Yd)if(b=b.path,null!=c.xc(b))c=a;else{f=new Vb(c,a,d);d=a.Q.j();if(b.e()||".priority"===K(b))lc(a.w())?
b=c.Aa(Yb(a)):(b=a.w().j(),O(b instanceof fe,"serverChildren would be complete if leaf node"),b=c.Cc(b)),b=this.X.ya(d,b,e);else{var g=K(b),k=c.Bc(g,a.w());null==k&&Wb(a.w(),g)&&(k=d.T(g));b=null!=k?this.X.H(d,g,k,N(b),f,e):a.Q.j().Fa(g)?this.X.H(d,g,H,N(b),f,e):d;b.e()&&lc(a.w())&&(d=c.Aa(Yb(a)),d.L()&&(b=this.X.ya(b,d,e)))}d=lc(a.w())||null!=c.xc(M);c=ge(a,b,d,this.X.Ra())}else c=he(this,a,b.path,b.Ub,c,d,e);else if(b.type===Dc)d=b.path,b=a.w(),f=b.j(),g=b.ga||d.e(),c=ie(this,new je(a.Q,new Xb(f,
g,b.Yb)),d,c,Ub,e);else throw jd("Unknown operation type: "+b.type);e=qa(e.ib);d=c;b=d.Q;b.ga&&(f=b.j().L()||b.j().e(),g=ke(a),(0<e.length||!a.Q.ga||f&&!b.j().ea(g)||!b.j().C().ea(g.C()))&&e.push(hc(ke(d))));return new Yd(c,e)};
function ie(a,b,c,d,e,f){var g=b.Q;if(null!=d.xc(c))return b;var k;if(c.e())O(lc(b.w()),"If change path is empty, we must have complete server data"),mc(b.w())?(e=Yb(b),d=d.Cc(e instanceof fe?e:H)):d=d.Aa(Yb(b)),f=a.X.ya(b.Q.j(),d,f);else{var m=K(c);if(".priority"==m)O(1==le(c),"Can't have a priority with additional path components"),f=g.j(),k=b.w().j(),d=d.nd(c,f,k),f=null!=d?a.X.ia(f,d):g.j();else{var l=N(c);Wb(g,m)?(k=b.w().j(),d=d.nd(c,g.j(),k),d=null!=d?g.j().T(m).H(l,d):g.j().T(m)):d=d.Bc(m,
b.w());f=null!=d?a.X.H(g.j(),m,d,l,e,f):g.j()}}return ge(b,f,g.ga||c.e(),a.X.Ra())}function ae(a,b,c,d,e,f,g,k){var m=b.w();g=g?a.X:a.X.$b();if(c.e())d=g.ya(m.j(),d,null);else if(g.Ra()&&!m.Yb)d=m.j().H(c,d),d=g.ya(m.j(),d,null);else{var l=K(c);if(!nc(m,c)&&1<le(c))return b;var t=N(c);d=m.j().T(l).H(t,d);d=".priority"==l?g.ia(m.j(),d):g.H(m.j(),l,d,t,Ub,null)}m=m.ga||c.e();b=new je(b.Q,new Xb(d,m,g.Ra()));return ie(a,b,c,e,new Vb(e,b,f),k)}
function $d(a,b,c,d,e,f,g){var k=b.Q;e=new Vb(e,b,f);if(c.e())g=a.X.ya(b.Q.j(),d,g),a=ge(b,g,!0,a.X.Ra());else if(f=K(c),".priority"===f)g=a.X.ia(b.Q.j(),d),a=ge(b,g,k.ga,k.Yb);else{c=N(c);var m=k.j().T(f);if(!c.e()){var l=e.uf(f);d=null!=l?".priority"===me(c)&&l.S(c.parent()).e()?l:l.H(c,d):H}m.ea(d)?a=b:(g=a.X.H(k.j(),f,d,c,e,g),a=ge(b,g,k.ga,a.X.Ra()))}return a}
function ce(a,b,c,d,e,f,g){var k=b;ne(d,function(d,l){var t=c.o(d);Wb(b.Q,K(t))&&(k=$d(a,k,t,l,e,f,g))});ne(d,function(d,l){var t=c.o(d);Wb(b.Q,K(t))||(k=$d(a,k,t,l,e,f,g))});return k}function oe(a,b){ne(b,function(b,d){a=a.H(b,d)});return a}
function de(a,b,c,d,e,f,g,k){if(b.w().j().e()&&!lc(b.w()))return b;var m=b;c=c.e()?d:pe(qe,c,d);var l=b.w().j();c.children.ka(function(c,d){if(l.Fa(c)){var I=b.w().j().T(c),I=oe(I,d);m=ae(a,m,new P(c),I,e,f,g,k)}});c.children.ka(function(c,d){var I=!Wb(b.w(),c)&&null==d.value;l.Fa(c)||I||(I=b.w().j().T(c),I=oe(I,d),m=ae(a,m,new P(c),I,e,f,g,k))});return m}
function he(a,b,c,d,e,f,g){if(null!=e.xc(c))return b;var k=mc(b.w()),m=b.w();if(null!=d.value){if(c.e()&&m.ga||nc(m,c))return ae(a,b,c,m.j().S(c),e,f,k,g);if(c.e()){var l=qe;m.j().R(re,function(a,b){l=l.set(new P(a),b)});return de(a,b,c,l,e,f,k,g)}return b}l=qe;ne(d,function(a){var b=c.o(a);nc(m,b)&&(l=l.set(a,m.j().S(b)))});return de(a,b,c,l,e,f,k,g)};function se(){}var te={};function Vd(a){return u(a.compare,a)}se.prototype.Dd=function(a,b){return 0!==this.compare(new L("[MIN_NAME]",a),new L("[MIN_NAME]",b))};se.prototype.Wc=function(){return ue};function ve(a){O(!a.e()&&".priority"!==K(a),"Can't create PathIndex with empty path or .priority key");this.gc=a}ka(ve,se);h=ve.prototype;h.Lc=function(a){return!a.S(this.gc).e()};h.compare=function(a,b){var c=a.U.S(this.gc),d=b.U.S(this.gc),c=c.Gc(d);return 0===c?yc(a.name,b.name):c};
h.Sc=function(a,b){var c=Q(a),c=H.H(this.gc,c);return new L(b,c)};h.Tc=function(){var a=H.H(this.gc,we);return new L("[MAX_NAME]",a)};h.toString=function(){return this.gc.slice().join("/")};function xe(){}ka(xe,se);h=xe.prototype;h.compare=function(a,b){var c=a.U.C(),d=b.U.C(),c=c.Gc(d);return 0===c?yc(a.name,b.name):c};h.Lc=function(a){return!a.C().e()};h.Dd=function(a,b){return!a.C().ea(b.C())};h.Wc=function(){return ue};h.Tc=function(){return new L("[MAX_NAME]",new Yc("[PRIORITY-POST]",we))};
h.Sc=function(a,b){var c=Q(a);return new L(b,new Yc("[PRIORITY-POST]",c))};h.toString=function(){return".priority"};var R=new xe;function ye(){}ka(ye,se);h=ye.prototype;h.compare=function(a,b){return yc(a.name,b.name)};h.Lc=function(){throw jd("KeyIndex.isDefinedOn not expected to be called.");};h.Dd=function(){return!1};h.Wc=function(){return ue};h.Tc=function(){return new L("[MAX_NAME]",H)};h.Sc=function(a){O(q(a),"KeyIndex indexValue must always be a string.");return new L(a,H)};h.toString=function(){return".key"};
var re=new ye;function ze(){}ka(ze,se);h=ze.prototype;h.compare=function(a,b){var c=a.U.Gc(b.U);return 0===c?yc(a.name,b.name):c};h.Lc=function(){return!0};h.Dd=function(a,b){return!a.ea(b)};h.Wc=function(){return ue};h.Tc=function(){return Ae};h.Sc=function(a,b){var c=Q(a);return new L(b,c)};h.toString=function(){return".value"};var Be=new ze;function Ce(){this.Xb=this.ra=this.Pb=this.oa=this.la=!1;this.ma=0;this.Rb="";this.ic=null;this.Bb="";this.fc=null;this.zb="";this.g=R}var De=new Ce;function Td(a){return""===a.Rb?a.oa:"l"===a.Rb}function Od(a){O(a.oa,"Only valid if start has been set");return a.ic}function Nd(a){O(a.oa,"Only valid if start has been set");return a.Pb?a.Bb:"[MIN_NAME]"}function Rd(a){O(a.ra,"Only valid if end has been set");return a.fc}
function Pd(a){O(a.ra,"Only valid if end has been set");return a.Xb?a.zb:"[MAX_NAME]"}function Ee(a){var b=new Ce;b.la=a.la;b.ma=a.ma;b.oa=a.oa;b.ic=a.ic;b.Pb=a.Pb;b.Bb=a.Bb;b.ra=a.ra;b.fc=a.fc;b.Xb=a.Xb;b.zb=a.zb;b.g=a.g;return b}h=Ce.prototype;h.Le=function(a){var b=Ee(this);b.la=!0;b.ma=a;b.Rb="";return b};h.Me=function(a){var b=Ee(this);b.la=!0;b.ma=a;b.Rb="l";return b};h.Ne=function(a){var b=Ee(this);b.la=!0;b.ma=a;b.Rb="r";return b};
h.ce=function(a,b){var c=Ee(this);c.oa=!0;p(a)||(a=null);c.ic=a;null!=b?(c.Pb=!0,c.Bb=b):(c.Pb=!1,c.Bb="");return c};h.vd=function(a,b){var c=Ee(this);c.ra=!0;p(a)||(a=null);c.fc=a;p(b)?(c.Xb=!0,c.zb=b):(c.nh=!1,c.zb="");return c};function Fe(a,b){var c=Ee(a);c.g=b;return c}function Ge(a){var b={};a.oa&&(b.sp=a.ic,a.Pb&&(b.sn=a.Bb));a.ra&&(b.ep=a.fc,a.Xb&&(b.en=a.zb));if(a.la){b.l=a.ma;var c=a.Rb;""===c&&(c=Td(a)?"l":"r");b.vf=c}a.g!==R&&(b.i=a.g.toString());return b}
function He(a){return!(a.oa||a.ra||a.la)}function Ie(a){return He(a)&&a.g==R}function Je(a){var b={};if(Ie(a))return b;var c;a.g===R?c="$priority":a.g===Be?c="$value":a.g===re?c="$key":(O(a.g instanceof ve,"Unrecognized index type!"),c=a.g.toString());b.orderBy=G(c);a.oa&&(b.startAt=G(a.ic),a.Pb&&(b.startAt+=","+G(a.Bb)));a.ra&&(b.endAt=G(a.fc),a.Xb&&(b.endAt+=","+G(a.zb)));a.la&&(Td(a)?b.limitToFirst=a.ma:b.limitToLast=a.ma);return b}h.toString=function(){return G(Ge(this))};function Ke(a,b){this.Ed=a;this.hc=b}Ke.prototype.get=function(a){var b=z(this.Ed,a);if(!b)throw Error("No index defined for "+a);return b===te?null:b};function Le(a,b,c){var d=ma(a.Ed,function(d,f){var g=z(a.hc,f);O(g,"Missing index implementation for "+f);if(d===te){if(g.Lc(b.U)){for(var k=[],m=c.ac(wc),l=Ic(m);l;)l.name!=b.name&&k.push(l),l=Ic(m);k.push(b);return Me(k,Vd(g))}return te}g=c.get(b.name);k=d;g&&(k=k.remove(new L(b.name,g)));return k.Sa(b,b.U)});return new Ke(d,a.hc)}
function Ne(a,b,c){var d=ma(a.Ed,function(a){if(a===te)return a;var d=c.get(b.name);return d?a.remove(new L(b.name,d)):a});return new Ke(d,a.hc)}var Oe=new Ke({".priority":te},{".priority":R});function Yc(a,b){this.B=a;O(p(this.B)&&null!==this.B,"LeafNode shouldn't be created with null/undefined value.");this.ca=b||H;Pe(this.ca);this.Gb=null}var Qe=["object","boolean","number","string"];h=Yc.prototype;h.L=function(){return!0};h.C=function(){return this.ca};h.ia=function(a){return new Yc(this.B,a)};h.T=function(a){return".priority"===a?this.ca:H};h.S=function(a){return a.e()?this:".priority"===K(a)?this.ca:H};h.Fa=function(){return!1};h.wf=function(){return null};
h.W=function(a,b){return".priority"===a?this.ia(b):b.e()&&".priority"!==a?this:H.W(a,b).ia(this.ca)};h.H=function(a,b){var c=K(a);if(null===c)return b;if(b.e()&&".priority"!==c)return this;O(".priority"!==c||1===le(a),".priority must be the last token in a path");return this.W(c,H.H(N(a),b))};h.e=function(){return!1};h.Hb=function(){return 0};h.R=function(){return!1};h.J=function(a){return a&&!this.C().e()?{".value":this.Ea(),".priority":this.C().J()}:this.Ea()};
h.hash=function(){if(null===this.Gb){var a="";this.ca.e()||(a+="priority:"+Re(this.ca.J())+":");var b=typeof this.B,a=a+(b+":"),a="number"===b?a+Ad(this.B):a+this.B;this.Gb=ld(a)}return this.Gb};h.Ea=function(){return this.B};h.Gc=function(a){if(a===H)return 1;if(a instanceof fe)return-1;O(a.L(),"Unknown node type");var b=typeof a.B,c=typeof this.B,d=La(Qe,b),e=La(Qe,c);O(0<=d,"Unknown leaf type: "+b);O(0<=e,"Unknown leaf type: "+c);return d===e?"object"===c?0:this.B<a.B?-1:this.B===a.B?0:1:e-d};
h.pb=function(){return this};h.Mc=function(){return!0};h.ea=function(a){return a===this?!0:a.L()?this.B===a.B&&this.ca.ea(a.ca):!1};h.toString=function(){return G(this.J(!0))};function fe(a,b,c){this.m=a;(this.ca=b)&&Pe(this.ca);a.e()&&O(!this.ca||this.ca.e(),"An empty node cannot have a priority");this.Ab=c;this.Gb=null}h=fe.prototype;h.L=function(){return!1};h.C=function(){return this.ca||H};h.ia=function(a){return this.m.e()?this:new fe(this.m,a,this.Ab)};h.T=function(a){if(".priority"===a)return this.C();a=this.m.get(a);return null===a?H:a};h.S=function(a){var b=K(a);return null===b?this:this.T(b).S(N(a))};h.Fa=function(a){return null!==this.m.get(a)};
h.W=function(a,b){O(b,"We should always be passing snapshot nodes");if(".priority"===a)return this.ia(b);var c=new L(a,b),d,e;b.e()?(d=this.m.remove(a),c=Ne(this.Ab,c,this.m)):(d=this.m.Sa(a,b),c=Le(this.Ab,c,this.m));e=d.e()?H:this.ca;return new fe(d,e,c)};h.H=function(a,b){var c=K(a);if(null===c)return b;O(".priority"!==K(a)||1===le(a),".priority must be the last token in a path");var d=this.T(c).H(N(a),b);return this.W(c,d)};h.e=function(){return this.m.e()};h.Hb=function(){return this.m.count()};
var Se=/^(0|[1-9]\d*)$/;h=fe.prototype;h.J=function(a){if(this.e())return null;var b={},c=0,d=0,e=!0;this.R(R,function(f,g){b[f]=g.J(a);c++;e&&Se.test(f)?d=Math.max(d,Number(f)):e=!1});if(!a&&e&&d<2*c){var f=[],g;for(g in b)f[g]=b[g];return f}a&&!this.C().e()&&(b[".priority"]=this.C().J());return b};h.hash=function(){if(null===this.Gb){var a="";this.C().e()||(a+="priority:"+Re(this.C().J())+":");this.R(R,function(b,c){var d=c.hash();""!==d&&(a+=":"+b+":"+d)});this.Gb=""===a?"":ld(a)}return this.Gb};
h.wf=function(a,b,c){return(c=Te(this,c))?(a=Gc(c,new L(a,b)))?a.name:null:Gc(this.m,a)};function Wd(a,b){var c;c=(c=Te(a,b))?(c=c.Vc())&&c.name:a.m.Vc();return c?new L(c,a.m.get(c)):null}function Xd(a,b){var c;c=(c=Te(a,b))?(c=c.jc())&&c.name:a.m.jc();return c?new L(c,a.m.get(c)):null}h.R=function(a,b){var c=Te(this,a);return c?c.ka(function(a){return b(a.name,a.U)}):this.m.ka(b)};h.ac=function(a){return this.bc(a.Wc(),a)};
h.bc=function(a,b){var c=Te(this,b);if(c)return c.bc(a,function(a){return a});for(var c=this.m.bc(a.name,wc),d=Jc(c);null!=d&&0>b.compare(d,a);)Ic(c),d=Jc(c);return c};h.xf=function(a){return this.dc(a.Tc(),a)};h.dc=function(a,b){var c=Te(this,b);if(c)return c.dc(a,function(a){return a});for(var c=this.m.dc(a.name,wc),d=Jc(c);null!=d&&0<b.compare(d,a);)Ic(c),d=Jc(c);return c};h.Gc=function(a){return this.e()?a.e()?0:-1:a.L()||a.e()?1:a===we?-1:0};
h.pb=function(a){if(a===re||sa(this.Ab.hc,a.toString()))return this;var b=this.Ab,c=this.m;O(a!==re,"KeyIndex always exists and isn't meant to be added to the IndexMap.");for(var d=[],e=!1,c=c.ac(wc),f=Ic(c);f;)e=e||a.Lc(f.U),d.push(f),f=Ic(c);d=e?Me(d,Vd(a)):te;e=a.toString();c=wa(b.hc);c[e]=a;a=wa(b.Ed);a[e]=d;return new fe(this.m,this.ca,new Ke(a,c))};h.Mc=function(a){return a===re||sa(this.Ab.hc,a.toString())};
h.ea=function(a){if(a===this)return!0;if(a.L())return!1;if(this.C().ea(a.C())&&this.m.count()===a.m.count()){var b=this.ac(R);a=a.ac(R);for(var c=Ic(b),d=Ic(a);c&&d;){if(c.name!==d.name||!c.U.ea(d.U))return!1;c=Ic(b);d=Ic(a)}return null===c&&null===d}return!1};function Te(a,b){return b===re?null:a.Ab.get(b.toString())}h.toString=function(){return G(this.J(!0))};function Q(a,b){if(null===a)return H;var c=null;"object"===typeof a&&".priority"in a?c=a[".priority"]:"undefined"!==typeof b&&(c=b);O(null===c||"string"===typeof c||"number"===typeof c||"object"===typeof c&&".sv"in c,"Invalid priority type found: "+typeof c);"object"===typeof a&&".value"in a&&null!==a[".value"]&&(a=a[".value"]);if("object"!==typeof a||".sv"in a)return new Yc(a,Q(c));if(a instanceof Array){var d=H,e=a;v(e,function(a,b){if(y(e,b)&&"."!==b.substring(0,1)){var c=Q(a);if(c.L()||!c.e())d=
d.W(b,c)}});return d.ia(Q(c))}var f=[],g=!1,k=a;Fb(k,function(a){if("string"!==typeof a||"."!==a.substring(0,1)){var b=Q(k[a]);b.e()||(g=g||!b.C().e(),f.push(new L(a,b)))}});if(0==f.length)return H;var m=Me(f,xc,function(a){return a.name},zc);if(g){var l=Me(f,Vd(R));return new fe(m,Q(c),new Ke({".priority":l},{".priority":R}))}return new fe(m,Q(c),Oe)}var Ue=Math.log(2);
function Ve(a){this.count=parseInt(Math.log(a+1)/Ue,10);this.nf=this.count-1;this.ng=a+1&parseInt(Array(this.count+1).join("1"),2)}function We(a){var b=!(a.ng&1<<a.nf);a.nf--;return b}
function Me(a,b,c,d){function e(b,d){var f=d-b;if(0==f)return null;if(1==f){var l=a[b],t=c?c(l):l;return new Kc(t,l.U,!1,null,null)}var l=parseInt(f/2,10)+b,f=e(b,l),A=e(l+1,d),l=a[l],t=c?c(l):l;return new Kc(t,l.U,!1,f,A)}a.sort(b);var f=function(b){function d(b,g){var k=t-b,A=t;t-=b;var A=e(k+1,A),k=a[k],I=c?c(k):k,A=new Kc(I,k.U,g,null,A);f?f.left=A:l=A;f=A}for(var f=null,l=null,t=a.length,A=0;A<b.count;++A){var I=We(b),Qd=Math.pow(2,b.count-(A+1));I?d(Qd,!1):(d(Qd,!1),d(Qd,!0))}return l}(new Ve(a.length));
return null!==f?new Ec(d||b,f):new Ec(d||b)}function Re(a){return"number"===typeof a?"number:"+Ad(a):"string:"+a}function Pe(a){if(a.L()){var b=a.J();O("string"===typeof b||"number"===typeof b||"object"===typeof b&&y(b,".sv"),"Priority must be a string or number.")}else O(a===we||a.e(),"priority of unexpected type.");O(a===we||a.C().e(),"Priority nodes can't have a priority of their own.")}var H=new fe(new Ec(zc),null,Oe);function Xe(){fe.call(this,new Ec(zc),H,Oe)}ka(Xe,fe);h=Xe.prototype;
h.Gc=function(a){return a===this?0:1};h.ea=function(a){return a===this};h.C=function(){return this};h.T=function(){return H};h.e=function(){return!1};var we=new Xe,ue=new L("[MIN_NAME]",H),Ae=new L("[MAX_NAME]",we);function je(a,b){this.Q=a;this.ae=b}function ge(a,b,c,d){return new je(new Xb(b,c,d),a.ae)}function ke(a){return a.Q.ga?a.Q.j():null}je.prototype.w=function(){return this.ae};function Yb(a){return a.ae.ga?a.ae.j():null};function Ye(a,b){this.Y=a;var c=a.n,d=new Ld(c.g),c=He(c)?new Ld(c.g):c.la?new Sd(c):new Md(c);this.Nf=new Zd(c);var e=b.w(),f=b.Q,g=d.ya(H,e.j(),null),k=c.ya(H,f.j(),null);this.Oa=new je(new Xb(k,f.ga,c.Ra()),new Xb(g,e.ga,d.Ra()));this.$a=[];this.ug=new Fd(a)}function Ze(a){return a.Y}h=Ye.prototype;h.w=function(){return this.Oa.w().j()};h.kb=function(a){var b=Yb(this.Oa);return b&&(He(this.Y.n)||!a.e()&&!b.T(K(a)).e())?b.S(a):null};h.e=function(){return 0===this.$a.length};h.Tb=function(a){this.$a.push(a)};
h.nb=function(a,b){var c=[];if(b){O(null==a,"A cancel should cancel all event registrations.");var d=this.Y.path;Ma(this.$a,function(a){(a=a.lf(b,d))&&c.push(a)})}if(a){for(var e=[],f=0;f<this.$a.length;++f){var g=this.$a[f];if(!g.matches(a))e.push(g);else if(a.yf()){e=e.concat(this.$a.slice(f+1));break}}this.$a=e}else this.$a=[];return c};
h.gb=function(a,b,c){a.type===be&&null!==a.source.Lb&&(O(Yb(this.Oa),"We should always have a full cache before handling merges"),O(ke(this.Oa),"Missing event cache, even though we have a server cache"));var d=this.Oa;a=this.Nf.gb(d,a,b,c);b=this.Nf;c=a.me;O(c.Q.j().Mc(b.X.g),"Event snap not indexed");O(c.w().j().Mc(b.X.g),"Server snap not indexed");O(lc(a.me.w())||!lc(d.w()),"Once a server snap is complete, it should never go back");this.Oa=a.me;return $e(this,a.og,a.me.Q.j(),null)};
function af(a,b){var c=a.Oa.Q,d=[];c.j().L()||c.j().R(R,function(a,b){d.push(new J("child_added",b,a))});c.ga&&d.push(hc(c.j()));return $e(a,d,c.j(),b)}function $e(a,b,c,d){return Gd(a.ug,b,c,d?[d]:a.$a)};function bf(a,b,c){this.type=be;this.source=a;this.path=b;this.children=c}bf.prototype.$c=function(a){if(this.path.e())return a=this.children.subtree(new P(a)),a.e()?null:a.value?new Ac(this.source,M,a.value):new bf(this.source,M,a);O(K(this.path)===a,"Can't get a merge for a child not on the path of the operation");return new bf(this.source,N(this.path),this.children)};bf.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"};function cf(a,b){this.f=pd("p:rest:");this.G=a;this.Kb=b;this.Ca=null;this.ba={}}function df(a,b){if(p(b))return"tag$"+b;O(Ie(a.n),"should have a tag if it's not a default query.");return a.path.toString()}h=cf.prototype;
h.Cf=function(a,b,c,d){var e=a.path.toString();this.f("Listen called for "+e+" "+a.wa());var f=df(a,c),g={};this.ba[f]=g;a=Je(a.n);var k=this;ef(this,e+".json",a,function(a,b){var t=b;404===a&&(a=t=null);null===a&&k.Kb(e,t,!1,c);z(k.ba,f)===g&&d(a?401==a?"permission_denied":"rest_error:"+a:"ok",null)})};h.$f=function(a,b){var c=df(a,b);delete this.ba[c]};h.O=function(a,b){this.Ca=a;var c=Cd(a),d=c.data,c=c.Ec&&c.Ec.exp;b&&b("ok",{auth:d,expires:c})};h.je=function(a){this.Ca=null;a("ok",null)};
h.Qe=function(){};h.Gf=function(){};h.Md=function(){};h.put=function(){};h.Df=function(){};h.Ye=function(){};
function ef(a,b,c,d){c=c||{};c.format="export";a.Ca&&(c.auth=a.Ca);var e=(a.G.ob?"https://":"http://")+a.G.host+b+"?"+Ib(c);a.f("Sending REST request for "+e);var f=new XMLHttpRequest;f.onreadystatechange=function(){if(d&&4===f.readyState){a.f("REST Response for "+e+" received. status:",f.status,"response:",f.responseText);var b=null;if(200<=f.status&&300>f.status){try{b=Rb(f.responseText)}catch(c){S("Failed to parse JSON response for "+e+": "+f.responseText)}d(null,b)}else 401!==f.status&&404!==
f.status&&S("Got unsuccessful REST response for "+e+" Status: "+f.status),d(f.status);d=null}};f.open("GET",e,!0);f.send()};function ff(a){O(da(a)&&0<a.length,"Requires a non-empty array");this.fg=a;this.Rc={}}ff.prototype.ie=function(a,b){var c;c=this.Rc[a]||[];var d=c.length;if(0<d){for(var e=Array(d),f=0;f<d;f++)e[f]=c[f];c=e}else c=[];for(d=0;d<c.length;d++)c[d].Dc.apply(c[d].Qa,Array.prototype.slice.call(arguments,1))};ff.prototype.Ib=function(a,b,c){gf(this,a);this.Rc[a]=this.Rc[a]||[];this.Rc[a].push({Dc:b,Qa:c});(a=this.Ee(a))&&b.apply(c,a)};
ff.prototype.mc=function(a,b,c){gf(this,a);a=this.Rc[a]||[];for(var d=0;d<a.length;d++)if(a[d].Dc===b&&(!c||c===a[d].Qa)){a.splice(d,1);break}};function gf(a,b){O(Ra(a.fg,function(a){return a===b}),"Unknown event: "+b)};var hf=function(){var a=0,b=[];return function(c){var d=c===a;a=c;for(var e=Array(8),f=7;0<=f;f--)e[f]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c%64),c=Math.floor(c/64);O(0===c,"Cannot push at time == 0");c=e.join("");if(d){for(f=11;0<=f&&63===b[f];f--)b[f]=0;b[f]++}else for(f=0;12>f;f++)b[f]=Math.floor(64*Math.random());for(f=0;12>f;f++)c+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);O(20===c.length,"nextPushId: Length should be 20.");
return c}}();function jf(){ff.call(this,["online"]);this.oc=!0;if("undefined"!==typeof window&&"undefined"!==typeof window.addEventListener){var a=this;window.addEventListener("online",function(){a.oc||(a.oc=!0,a.ie("online",!0))},!1);window.addEventListener("offline",function(){a.oc&&(a.oc=!1,a.ie("online",!1))},!1)}}ka(jf,ff);jf.prototype.Ee=function(a){O("online"===a,"Unknown event type: "+a);return[this.oc]};ba(jf);function kf(){ff.call(this,["visible"]);var a,b;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(b="visibilitychange",a="hidden"):"undefined"!==typeof document.mozHidden?(b="mozvisibilitychange",a="mozHidden"):"undefined"!==typeof document.msHidden?(b="msvisibilitychange",a="msHidden"):"undefined"!==typeof document.webkitHidden&&(b="webkitvisibilitychange",a="webkitHidden"));this.Sb=!0;if(b){var c=this;document.addEventListener(b,
function(){var b=!document[a];b!==c.Sb&&(c.Sb=b,c.ie("visible",b))},!1)}}ka(kf,ff);kf.prototype.Ee=function(a){O("visible"===a,"Unknown event type: "+a);return[this.Sb]};ba(kf);function P(a,b){if(1==arguments.length){this.u=a.split("/");for(var c=0,d=0;d<this.u.length;d++)0<this.u[d].length&&(this.u[c]=this.u[d],c++);this.u.length=c;this.aa=0}else this.u=a,this.aa=b}function lf(a,b){var c=K(a);if(null===c)return b;if(c===K(b))return lf(N(a),N(b));throw Error("INTERNAL ERROR: innerPath ("+b+") is not within outerPath ("+a+")");}
function mf(a,b){for(var c=a.slice(),d=b.slice(),e=0;e<c.length&&e<d.length;e++){var f=yc(c[e],d[e]);if(0!==f)return f}return c.length===d.length?0:c.length<d.length?-1:1}function K(a){return a.aa>=a.u.length?null:a.u[a.aa]}function le(a){return a.u.length-a.aa}function N(a){var b=a.aa;b<a.u.length&&b++;return new P(a.u,b)}function me(a){return a.aa<a.u.length?a.u[a.u.length-1]:null}h=P.prototype;
h.toString=function(){for(var a="",b=this.aa;b<this.u.length;b++)""!==this.u[b]&&(a+="/"+this.u[b]);return a||"/"};h.slice=function(a){return this.u.slice(this.aa+(a||0))};h.parent=function(){if(this.aa>=this.u.length)return null;for(var a=[],b=this.aa;b<this.u.length-1;b++)a.push(this.u[b]);return new P(a,0)};
h.o=function(a){for(var b=[],c=this.aa;c<this.u.length;c++)b.push(this.u[c]);if(a instanceof P)for(c=a.aa;c<a.u.length;c++)b.push(a.u[c]);else for(a=a.split("/"),c=0;c<a.length;c++)0<a[c].length&&b.push(a[c]);return new P(b,0)};h.e=function(){return this.aa>=this.u.length};h.ea=function(a){if(le(this)!==le(a))return!1;for(var b=this.aa,c=a.aa;b<=this.u.length;b++,c++)if(this.u[b]!==a.u[c])return!1;return!0};
h.contains=function(a){var b=this.aa,c=a.aa;if(le(this)>le(a))return!1;for(;b<this.u.length;){if(this.u[b]!==a.u[c])return!1;++b;++c}return!0};var M=new P("");function nf(a,b){this.Ua=a.slice();this.Ka=Math.max(1,this.Ua.length);this.pf=b;for(var c=0;c<this.Ua.length;c++)this.Ka+=Pb(this.Ua[c]);of(this)}nf.prototype.push=function(a){0<this.Ua.length&&(this.Ka+=1);this.Ua.push(a);this.Ka+=Pb(a);of(this)};nf.prototype.pop=function(){var a=this.Ua.pop();this.Ka-=Pb(a);0<this.Ua.length&&--this.Ka};
function of(a){if(768<a.Ka)throw Error(a.pf+"has a key path longer than 768 bytes ("+a.Ka+").");if(32<a.Ua.length)throw Error(a.pf+"path specified exceeds the maximum depth that can be written (32) or object contains a cycle "+pf(a));}function pf(a){return 0==a.Ua.length?"":"in property '"+a.Ua.join(".")+"'"};function qf(a,b){this.value=a;this.children=b||rf}var rf=new Ec(function(a,b){return a===b?0:a<b?-1:1});function sf(a){var b=qe;v(a,function(a,d){b=b.set(new P(d),a)});return b}h=qf.prototype;h.e=function(){return null===this.value&&this.children.e()};function tf(a,b,c){if(null!=a.value&&c(a.value))return{path:M,value:a.value};if(b.e())return null;var d=K(b);a=a.children.get(d);return null!==a?(b=tf(a,N(b),c),null!=b?{path:(new P(d)).o(b.path),value:b.value}:null):null}
function uf(a,b){return tf(a,b,function(){return!0})}h.subtree=function(a){if(a.e())return this;var b=this.children.get(K(a));return null!==b?b.subtree(N(a)):qe};h.set=function(a,b){if(a.e())return new qf(b,this.children);var c=K(a),d=(this.children.get(c)||qe).set(N(a),b),c=this.children.Sa(c,d);return new qf(this.value,c)};
h.remove=function(a){if(a.e())return this.children.e()?qe:new qf(null,this.children);var b=K(a),c=this.children.get(b);return c?(a=c.remove(N(a)),b=a.e()?this.children.remove(b):this.children.Sa(b,a),null===this.value&&b.e()?qe:new qf(this.value,b)):this};h.get=function(a){if(a.e())return this.value;var b=this.children.get(K(a));return b?b.get(N(a)):null};
function pe(a,b,c){if(b.e())return c;var d=K(b);b=pe(a.children.get(d)||qe,N(b),c);d=b.e()?a.children.remove(d):a.children.Sa(d,b);return new qf(a.value,d)}function vf(a,b){return wf(a,M,b)}function wf(a,b,c){var d={};a.children.ka(function(a,f){d[a]=wf(f,b.o(a),c)});return c(b,a.value,d)}function xf(a,b,c){return yf(a,b,M,c)}function yf(a,b,c,d){var e=a.value?d(c,a.value):!1;if(e)return e;if(b.e())return null;e=K(b);return(a=a.children.get(e))?yf(a,N(b),c.o(e),d):null}
function zf(a,b,c){Af(a,b,M,c)}function Af(a,b,c,d){if(b.e())return a;a.value&&d(c,a.value);var e=K(b);return(a=a.children.get(e))?Af(a,N(b),c.o(e),d):qe}function ne(a,b){Bf(a,M,b)}function Bf(a,b,c){a.children.ka(function(a,e){Bf(e,b.o(a),c)});a.value&&c(b,a.value)}function Cf(a,b){a.children.ka(function(a,d){d.value&&b(a,d.value)})}var qe=new qf(null);qf.prototype.toString=function(){var a={};ne(this,function(b,c){a[b.toString()]=c.toString()});return G(a)};function Df(a,b,c){this.type=ee;this.source=Ef;this.path=a;this.Ub=b;this.Yd=c}Df.prototype.$c=function(a){if(this.path.e()){if(null!=this.Ub.value)return O(this.Ub.children.e(),"affectedTree should not have overlapping affected paths."),this;a=this.Ub.subtree(new P(a));return new Df(M,a,this.Yd)}O(K(this.path)===a,"operationForChild called for unrelated child.");return new Df(N(this.path),this.Ub,this.Yd)};
Df.prototype.toString=function(){return"Operation("+this.path+": "+this.source.toString()+" ack write revert="+this.Yd+" affectedTree="+this.Ub+")"};var Bc=0,be=1,ee=2,Dc=3;function Ff(a,b,c,d){this.Ae=a;this.tf=b;this.Lb=c;this.ef=d;O(!d||b,"Tagged queries must be from server.")}var Ef=new Ff(!0,!1,null,!1),Gf=new Ff(!1,!0,null,!1);Ff.prototype.toString=function(){return this.Ae?"user":this.ef?"server(queryID="+this.Lb+")":"server"};function Hf(a){this.Z=a}var If=new Hf(new qf(null));function Jf(a,b,c){if(b.e())return new Hf(new qf(c));var d=uf(a.Z,b);if(null!=d){var e=d.path,d=d.value;b=lf(e,b);d=d.H(b,c);return new Hf(a.Z.set(e,d))}a=pe(a.Z,b,new qf(c));return new Hf(a)}function Kf(a,b,c){var d=a;Fb(c,function(a,c){d=Jf(d,b.o(a),c)});return d}Hf.prototype.Ud=function(a){if(a.e())return If;a=pe(this.Z,a,qe);return new Hf(a)};function Lf(a,b){var c=uf(a.Z,b);return null!=c?a.Z.get(c.path).S(lf(c.path,b)):null}
function Mf(a){var b=[],c=a.Z.value;null!=c?c.L()||c.R(R,function(a,c){b.push(new L(a,c))}):a.Z.children.ka(function(a,c){null!=c.value&&b.push(new L(a,c.value))});return b}function Nf(a,b){if(b.e())return a;var c=Lf(a,b);return null!=c?new Hf(new qf(c)):new Hf(a.Z.subtree(b))}Hf.prototype.e=function(){return this.Z.e()};Hf.prototype.apply=function(a){return Of(M,this.Z,a)};
function Of(a,b,c){if(null!=b.value)return c.H(a,b.value);var d=null;b.children.ka(function(b,f){".priority"===b?(O(null!==f.value,"Priority writes must always be leaf nodes"),d=f.value):c=Of(a.o(b),f,c)});c.S(a).e()||null===d||(c=c.H(a.o(".priority"),d));return c};function Pf(){this.V=If;this.pa=[];this.Pc=-1}function Qf(a,b){for(var c=0;c<a.pa.length;c++){var d=a.pa[c];if(d.md===b)return d}return null}h=Pf.prototype;
h.Ud=function(a){var b=Sa(this.pa,function(b){return b.md===a});O(0<=b,"removeWrite called with nonexistent writeId.");var c=this.pa[b];this.pa.splice(b,1);for(var d=c.visible,e=!1,f=this.pa.length-1;d&&0<=f;){var g=this.pa[f];g.visible&&(f>=b&&Rf(g,c.path)?d=!1:c.path.contains(g.path)&&(e=!0));f--}if(d){if(e)this.V=Sf(this.pa,Tf,M),this.Pc=0<this.pa.length?this.pa[this.pa.length-1].md:-1;else if(c.Ja)this.V=this.V.Ud(c.path);else{var k=this;v(c.children,function(a,b){k.V=k.V.Ud(c.path.o(b))})}return!0}return!1};
h.Aa=function(a,b,c,d){if(c||d){var e=Nf(this.V,a);return!d&&e.e()?b:d||null!=b||null!=Lf(e,M)?(e=Sf(this.pa,function(b){return(b.visible||d)&&(!c||!(0<=La(c,b.md)))&&(b.path.contains(a)||a.contains(b.path))},a),b=b||H,e.apply(b)):null}e=Lf(this.V,a);if(null!=e)return e;e=Nf(this.V,a);return e.e()?b:null!=b||null!=Lf(e,M)?(b=b||H,e.apply(b)):null};
h.Cc=function(a,b){var c=H,d=Lf(this.V,a);if(d)d.L()||d.R(R,function(a,b){c=c.W(a,b)});else if(b){var e=Nf(this.V,a);b.R(R,function(a,b){var d=Nf(e,new P(a)).apply(b);c=c.W(a,d)});Ma(Mf(e),function(a){c=c.W(a.name,a.U)})}else e=Nf(this.V,a),Ma(Mf(e),function(a){c=c.W(a.name,a.U)});return c};h.nd=function(a,b,c,d){O(c||d,"Either existingEventSnap or existingServerSnap must exist");a=a.o(b);if(null!=Lf(this.V,a))return null;a=Nf(this.V,a);return a.e()?d.S(b):a.apply(d.S(b))};
h.Bc=function(a,b,c){a=a.o(b);var d=Lf(this.V,a);return null!=d?d:Wb(c,b)?Nf(this.V,a).apply(c.j().T(b)):null};h.xc=function(a){return Lf(this.V,a)};h.qe=function(a,b,c,d,e,f){var g;a=Nf(this.V,a);g=Lf(a,M);if(null==g)if(null!=b)g=a.apply(b);else return[];g=g.pb(f);if(g.e()||g.L())return[];b=[];a=Vd(f);e=e?g.dc(c,f):g.bc(c,f);for(f=Ic(e);f&&b.length<d;)0!==a(f,c)&&b.push(f),f=Ic(e);return b};
function Rf(a,b){return a.Ja?a.path.contains(b):!!ta(a.children,function(c,d){return a.path.o(d).contains(b)})}function Tf(a){return a.visible}
function Sf(a,b,c){for(var d=If,e=0;e<a.length;++e){var f=a[e];if(b(f)){var g=f.path;if(f.Ja)c.contains(g)?(g=lf(c,g),d=Jf(d,g,f.Ja)):g.contains(c)&&(g=lf(g,c),d=Jf(d,M,f.Ja.S(g)));else if(f.children)if(c.contains(g))g=lf(c,g),d=Kf(d,g,f.children);else{if(g.contains(c))if(g=lf(g,c),g.e())d=Kf(d,M,f.children);else if(f=z(f.children,K(g)))f=f.S(N(g)),d=Jf(d,M,f)}else throw jd("WriteRecord should have .snap or .children");}}return d}function Uf(a,b){this.Qb=a;this.Z=b}h=Uf.prototype;
h.Aa=function(a,b,c){return this.Z.Aa(this.Qb,a,b,c)};h.Cc=function(a){return this.Z.Cc(this.Qb,a)};h.nd=function(a,b,c){return this.Z.nd(this.Qb,a,b,c)};h.xc=function(a){return this.Z.xc(this.Qb.o(a))};h.qe=function(a,b,c,d,e){return this.Z.qe(this.Qb,a,b,c,d,e)};h.Bc=function(a,b){return this.Z.Bc(this.Qb,a,b)};h.o=function(a){return new Uf(this.Qb.o(a),this.Z)};function Vf(){this.children={};this.pd=0;this.value=null}function Wf(a,b,c){this.Jd=a?a:"";this.Ha=b?b:null;this.A=c?c:new Vf}function Xf(a,b){for(var c=b instanceof P?b:new P(b),d=a,e;null!==(e=K(c));)d=new Wf(e,d,z(d.A.children,e)||new Vf),c=N(c);return d}h=Wf.prototype;h.Ea=function(){return this.A.value};function Yf(a,b){O("undefined"!==typeof b,"Cannot set value to undefined");a.A.value=b;Zf(a)}h.clear=function(){this.A.value=null;this.A.children={};this.A.pd=0;Zf(this)};
h.zd=function(){return 0<this.A.pd};h.e=function(){return null===this.Ea()&&!this.zd()};h.R=function(a){var b=this;v(this.A.children,function(c,d){a(new Wf(d,b,c))})};function $f(a,b,c,d){c&&!d&&b(a);a.R(function(a){$f(a,b,!0,d)});c&&d&&b(a)}function ag(a,b){for(var c=a.parent();null!==c&&!b(c);)c=c.parent()}h.path=function(){return new P(null===this.Ha?this.Jd:this.Ha.path()+"/"+this.Jd)};h.name=function(){return this.Jd};h.parent=function(){return this.Ha};
function Zf(a){if(null!==a.Ha){var b=a.Ha,c=a.Jd,d=a.e(),e=y(b.A.children,c);d&&e?(delete b.A.children[c],b.A.pd--,Zf(b)):d||e||(b.A.children[c]=a.A,b.A.pd++,Zf(b))}};var bg=/[\[\].#$\/\u0000-\u001F\u007F]/,cg=/[\[\].#$\u0000-\u001F\u007F]/,dg=/^[a-zA-Z][a-zA-Z._\-+]+$/;function eg(a){return q(a)&&0!==a.length&&!bg.test(a)}function fg(a){return null===a||q(a)||fa(a)&&!td(a)||ga(a)&&y(a,".sv")}function gg(a,b,c,d){d&&!p(b)||hg(E(a,1,d),b,c)}
function hg(a,b,c){c instanceof P&&(c=new nf(c,a));if(!p(b))throw Error(a+"contains undefined "+pf(c));if(r(b))throw Error(a+"contains a function "+pf(c)+" with contents: "+b.toString());if(td(b))throw Error(a+"contains "+b.toString()+" "+pf(c));if(q(b)&&b.length>10485760/3&&10485760<Pb(b))throw Error(a+"contains a string greater than 10485760 utf8 bytes "+pf(c)+" ('"+b.substring(0,50)+"...')");if(ga(b)){var d=!1,e=!1;Fb(b,function(b,g){if(".value"===b)d=!0;else if(".priority"!==b&&".sv"!==b&&(e=
!0,!eg(b)))throw Error(a+" contains an invalid key ("+b+") "+pf(c)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');c.push(b);hg(a,g,c);c.pop()});if(d&&e)throw Error(a+' contains ".value" child '+pf(c)+" in addition to actual children.");}}
function ig(a,b){var c,d;for(c=0;c<b.length;c++){d=b[c];for(var e=d.slice(),f=0;f<e.length;f++)if((".priority"!==e[f]||f!==e.length-1)&&!eg(e[f]))throw Error(a+"contains an invalid key ("+e[f]+") in path "+d.toString()+'. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');}b.sort(mf);e=null;for(c=0;c<b.length;c++){d=b[c];if(null!==e&&e.contains(d))throw Error(a+"contains a path "+e.toString()+" that is ancestor of another path "+d.toString());e=d}}
function jg(a,b,c){var d=E(a,1,!1);if(!ga(b)||da(b))throw Error(d+" must be an object containing the children to replace.");var e=[];Fb(b,function(a,b){var k=new P(a);hg(d,b,c.o(k));if(".priority"===me(k)&&!fg(b))throw Error(d+"contains an invalid value for '"+k.toString()+"', which must be a valid Firebase priority (a string, finite number, server value, or null).");e.push(k)});ig(d,e)}
function kg(a,b,c){if(td(c))throw Error(E(a,b,!1)+"is "+c.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!fg(c))throw Error(E(a,b,!1)+"must be a valid Firebase priority (a string, finite number, server value, or null).");}
function lg(a,b,c){if(!c||p(b))switch(b){case "value":case "child_added":case "child_removed":case "child_changed":case "child_moved":break;default:throw Error(E(a,1,c)+'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".');}}function mg(a,b){if(p(b)&&!eg(b))throw Error(E(a,2,!0)+'was an invalid key: "'+b+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');}
function ng(a,b){if(!q(b)||0===b.length||cg.test(b))throw Error(E(a,1,!1)+'was an invalid path: "'+b+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');}function og(a,b){if(".info"===K(b))throw Error(a+" failed: Can't modify data under /.info/");}function pg(a,b){if(!q(b))throw Error(E(a,1,!1)+"must be a valid credential (a string).");}function qg(a,b,c){if(!q(c))throw Error(E(a,b,!1)+"must be a valid string.");}
function rg(a,b){qg(a,1,b);if(!dg.test(b))throw Error(E(a,1,!1)+"'"+b+"' is not a valid authentication provider.");}function sg(a,b,c,d){if(!d||p(c))if(!ga(c)||null===c)throw Error(E(a,b,d)+"must be a valid object.");}function tg(a,b,c){if(!ga(b)||!y(b,c))throw Error(E(a,1,!1)+'must contain the key "'+c+'"');if(!q(z(b,c)))throw Error(E(a,1,!1)+'must contain the key "'+c+'" with type "string"');};function ug(){this.set={}}h=ug.prototype;h.add=function(a,b){this.set[a]=null!==b?b:!0};h.contains=function(a){return y(this.set,a)};h.get=function(a){return this.contains(a)?this.set[a]:void 0};h.remove=function(a){delete this.set[a]};h.clear=function(){this.set={}};h.e=function(){return va(this.set)};h.count=function(){return oa(this.set)};function vg(a,b){v(a.set,function(a,d){b(d,a)})}h.keys=function(){var a=[];v(this.set,function(b,c){a.push(c)});return a};function Vc(){this.m=this.B=null}Vc.prototype.find=function(a){if(null!=this.B)return this.B.S(a);if(a.e()||null==this.m)return null;var b=K(a);a=N(a);return this.m.contains(b)?this.m.get(b).find(a):null};Vc.prototype.rc=function(a,b){if(a.e())this.B=b,this.m=null;else if(null!==this.B)this.B=this.B.H(a,b);else{null==this.m&&(this.m=new ug);var c=K(a);this.m.contains(c)||this.m.add(c,new Vc);c=this.m.get(c);a=N(a);c.rc(a,b)}};
function wg(a,b){if(b.e())return a.B=null,a.m=null,!0;if(null!==a.B){if(a.B.L())return!1;var c=a.B;a.B=null;c.R(R,function(b,c){a.rc(new P(b),c)});return wg(a,b)}return null!==a.m?(c=K(b),b=N(b),a.m.contains(c)&&wg(a.m.get(c),b)&&a.m.remove(c),a.m.e()?(a.m=null,!0):!1):!0}function Wc(a,b,c){null!==a.B?c(b,a.B):a.R(function(a,e){var f=new P(b.toString()+"/"+a);Wc(e,f,c)})}Vc.prototype.R=function(a){null!==this.m&&vg(this.m,function(b,c){a(b,c)})};var xg="auth.firebase.com";function yg(a,b,c){this.qd=a||{};this.he=b||{};this.fb=c||{};this.qd.remember||(this.qd.remember="default")}var zg=["remember","redirectTo"];function Ag(a){var b={},c={};Fb(a||{},function(a,e){0<=La(zg,a)?b[a]=e:c[a]=e});return new yg(b,{},c)};function Bg(a,b){this.Ue=["session",a.Rd,a.lc].join(":");this.ee=b}Bg.prototype.set=function(a,b){if(!b)if(this.ee.length)b=this.ee[0];else throw Error("fb.login.SessionManager : No storage options available!");b.set(this.Ue,a)};Bg.prototype.get=function(){var a=Oa(this.ee,u(this.Bg,this)),a=Na(a,function(a){return null!==a});Va(a,function(a,c){return Dd(c.token)-Dd(a.token)});return 0<a.length?a.shift():null};Bg.prototype.Bg=function(a){try{var b=a.get(this.Ue);if(b&&b.token)return b}catch(c){}return null};
Bg.prototype.clear=function(){var a=this;Ma(this.ee,function(b){b.remove(a.Ue)})};function Cg(){return"undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:""}function Dg(){return"undefined"!==typeof window&&!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Cg())}function Eg(){return"undefined"!==typeof location&&/^file:\//.test(location.href)}
function Fg(a){var b=Cg();if(""===b)return!1;if("Microsoft Internet Explorer"===navigator.appName){if((b=b.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/))&&1<b.length)return parseFloat(b[1])>=a}else if(-1<b.indexOf("Trident")&&(b=b.match(/rv:([0-9]{2,2}[\.0-9]{0,})/))&&1<b.length)return parseFloat(b[1])>=a;return!1};function Gg(){var a=window.opener.frames,b;for(b=a.length-1;0<=b;b--)try{if(a[b].location.protocol===window.location.protocol&&a[b].location.host===window.location.host&&"__winchan_relay_frame"===a[b].name)return a[b]}catch(c){}return null}function Hg(a,b,c){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,!1)}function Ig(a,b,c){a.detachEvent?a.detachEvent("on"+b,c):a.removeEventListener&&a.removeEventListener(b,c,!1)}
function Jg(a){/^https?:\/\//.test(a)||(a=window.location.href);var b=/^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);return b?b[1]:a}function Kg(a){var b="";try{a=a.replace(/.*\?/,"");var c=Jb(a);c&&y(c,"__firebase_request_key")&&(b=z(c,"__firebase_request_key"))}catch(d){}return b}function Lg(){try{var a=document.location.hash.replace(/&__firebase_request_key=([a-zA-z0-9]*)/,""),a=a.replace(/\?$/,""),a=a.replace(/^#+$/,"");document.location.hash=a}catch(b){}}
function Mg(){var a=sd(xg);return a.scheme+"://"+a.host+"/v2"}function Ng(a){return Mg()+"/"+a+"/auth/channel"};function Og(a){var b=this;this.hb=a;this.fe="*";Fg(8)?this.Uc=this.Cd=Gg():(this.Uc=window.opener,this.Cd=window);if(!b.Uc)throw"Unable to find relay frame";Hg(this.Cd,"message",u(this.nc,this));Hg(this.Cd,"message",u(this.Ff,this));try{Pg(this,{a:"ready"})}catch(c){Hg(this.Uc,"load",function(){Pg(b,{a:"ready"})})}Hg(window,"unload",u(this.Mg,this))}function Pg(a,b){b=G(b);Fg(8)?a.Uc.doPost(b,a.fe):a.Uc.postMessage(b,a.fe)}
Og.prototype.nc=function(a){var b=this,c;try{c=Rb(a.data)}catch(d){}c&&"request"===c.a&&(Ig(window,"message",this.nc),this.fe=a.origin,this.hb&&setTimeout(function(){b.hb(b.fe,c.d,function(a,c){b.mg=!c;b.hb=void 0;Pg(b,{a:"response",d:a,forceKeepWindowOpen:c})})},0))};Og.prototype.Mg=function(){try{Ig(this.Cd,"message",this.Ff)}catch(a){}this.hb&&(Pg(this,{a:"error",d:"unknown closed window"}),this.hb=void 0);try{window.close()}catch(b){}};Og.prototype.Ff=function(a){if(this.mg&&"die"===a.data)try{window.close()}catch(b){}};function Qg(a){this.tc=Fa()+Fa()+Fa();this.Kf=a}Qg.prototype.open=function(a,b){cd.set("redirect_request_id",this.tc);cd.set("redirect_request_id",this.tc);b.requestId=this.tc;b.redirectTo=b.redirectTo||window.location.href;a+=(/\?/.test(a)?"":"?")+Ib(b);window.location=a};Qg.isAvailable=function(){return!Eg()&&!Dg()};Qg.prototype.Fc=function(){return"redirect"};var Rg={NETWORK_ERROR:"Unable to contact the Firebase server.",SERVER_ERROR:"An unknown server error occurred.",TRANSPORT_UNAVAILABLE:"There are no login transports available for the requested method.",REQUEST_INTERRUPTED:"The browser redirected the page before the login request could complete.",USER_CANCELLED:"The user cancelled authentication."};function Sg(a){var b=Error(z(Rg,a),a);b.code=a;return b};function Tg(a){var b;(b=!a.window_features)||(b=Cg(),b=-1!==b.indexOf("Fennec/")||-1!==b.indexOf("Firefox/")&&-1!==b.indexOf("Android"));b&&(a.window_features=void 0);a.window_name||(a.window_name="_blank");this.options=a}
Tg.prototype.open=function(a,b,c){function d(a){g&&(document.body.removeChild(g),g=void 0);t&&(t=clearInterval(t));Ig(window,"message",e);Ig(window,"unload",d);if(l&&!a)try{l.close()}catch(b){k.postMessage("die",m)}l=k=void 0}function e(a){if(a.origin===m)try{var b=Rb(a.data);"ready"===b.a?k.postMessage(A,m):"error"===b.a?(d(!1),c&&(c(b.d),c=null)):"response"===b.a&&(d(b.forceKeepWindowOpen),c&&(c(null,b.d),c=null))}catch(e){}}var f=Fg(8),g,k;if(!this.options.relay_url)return c(Error("invalid arguments: origin of url and relay_url must match"));
var m=Jg(a);if(m!==Jg(this.options.relay_url))c&&setTimeout(function(){c(Error("invalid arguments: origin of url and relay_url must match"))},0);else{f&&(g=document.createElement("iframe"),g.setAttribute("src",this.options.relay_url),g.style.display="none",g.setAttribute("name","__winchan_relay_frame"),document.body.appendChild(g),k=g.contentWindow);a+=(/\?/.test(a)?"":"?")+Ib(b);var l=window.open(a,this.options.window_name,this.options.window_features);k||(k=l);var t=setInterval(function(){l&&l.closed&&
(d(!1),c&&(c(Sg("USER_CANCELLED")),c=null))},500),A=G({a:"request",d:b});Hg(window,"unload",d);Hg(window,"message",e)}};
Tg.isAvailable=function(){var a;if(a="postMessage"in window&&!Eg())(a=Dg()||"undefined"!==typeof navigator&&(!!Cg().match(/Windows Phone/)||!!window.Windows&&/^ms-appx:/.test(location.href)))||(a=Cg(),a="undefined"!==typeof navigator&&"undefined"!==typeof window&&!!(a.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i)||a.match(/CriOS/)||a.match(/Twitter for iPhone/)||a.match(/FBAN\/FBIOS/)||window.navigator.standalone)),a=!a;return a&&!Cg().match(/PhantomJS/)};Tg.prototype.Fc=function(){return"popup"};function Ug(a){a.method||(a.method="GET");a.headers||(a.headers={});a.headers.content_type||(a.headers.content_type="application/json");a.headers.content_type=a.headers.content_type.toLowerCase();this.options=a}
Ug.prototype.open=function(a,b,c){function d(){c&&(c(Sg("REQUEST_INTERRUPTED")),c=null)}var e=new XMLHttpRequest,f=this.options.method.toUpperCase(),g;Hg(window,"beforeunload",d);e.onreadystatechange=function(){if(c&&4===e.readyState){var a;if(200<=e.status&&300>e.status){try{a=Rb(e.responseText)}catch(b){}c(null,a)}else 500<=e.status&&600>e.status?c(Sg("SERVER_ERROR")):c(Sg("NETWORK_ERROR"));c=null;Ig(window,"beforeunload",d)}};if("GET"===f)a+=(/\?/.test(a)?"":"?")+Ib(b),g=null;else{var k=this.options.headers.content_type;
"application/json"===k&&(g=G(b));"application/x-www-form-urlencoded"===k&&(g=Ib(b))}e.open(f,a,!0);a={"X-Requested-With":"XMLHttpRequest",Accept:"application/json;text/plain"};ya(a,this.options.headers);for(var m in a)e.setRequestHeader(m,a[m]);e.send(g)};Ug.isAvailable=function(){var a;if(a=!!window.XMLHttpRequest)a=Cg(),a=!(a.match(/MSIE/)||a.match(/Trident/))||Fg(10);return a};Ug.prototype.Fc=function(){return"json"};function Vg(a){this.tc=Fa()+Fa()+Fa();this.Kf=a}
Vg.prototype.open=function(a,b,c){function d(){c&&(c(Sg("USER_CANCELLED")),c=null)}var e=this,f=sd(xg),g;b.requestId=this.tc;b.redirectTo=f.scheme+"://"+f.host+"/blank/page.html";a+=/\?/.test(a)?"":"?";a+=Ib(b);(g=window.open(a,"_blank","location=no"))&&r(g.addEventListener)?(g.addEventListener("loadstart",function(a){var b;if(b=a&&a.url)a:{try{var l=document.createElement("a");l.href=a.url;b=l.host===f.host&&"/blank/page.html"===l.pathname;break a}catch(t){}b=!1}b&&(a=Kg(a.url),g.removeEventListener("exit",
d),g.close(),a=new yg(null,null,{requestId:e.tc,requestKey:a}),e.Kf.requestWithCredential("/auth/session",a,c),c=null)}),g.addEventListener("exit",d)):c(Sg("TRANSPORT_UNAVAILABLE"))};Vg.isAvailable=function(){return Dg()};Vg.prototype.Fc=function(){return"redirect"};function Wg(a){a.callback_parameter||(a.callback_parameter="callback");this.options=a;window.__firebase_auth_jsonp=window.__firebase_auth_jsonp||{}}
Wg.prototype.open=function(a,b,c){function d(){c&&(c(Sg("REQUEST_INTERRUPTED")),c=null)}function e(){setTimeout(function(){window.__firebase_auth_jsonp[f]=void 0;va(window.__firebase_auth_jsonp)&&(window.__firebase_auth_jsonp=void 0);try{var a=document.getElementById(f);a&&a.parentNode.removeChild(a)}catch(b){}},1);Ig(window,"beforeunload",d)}var f="fn"+(new Date).getTime()+Math.floor(99999*Math.random());b[this.options.callback_parameter]="__firebase_auth_jsonp."+f;a+=(/\?/.test(a)?"":"?")+Ib(b);
Hg(window,"beforeunload",d);window.__firebase_auth_jsonp[f]=function(a){c&&(c(null,a),c=null);e()};Xg(f,a,c)};
function Xg(a,b,c){setTimeout(function(){try{var d=document.createElement("script");d.type="text/javascript";d.id=a;d.async=!0;d.src=b;d.onerror=function(){var b=document.getElementById(a);null!==b&&b.parentNode.removeChild(b);c&&c(Sg("NETWORK_ERROR"))};var e=document.getElementsByTagName("head");(e&&0!=e.length?e[0]:document.documentElement).appendChild(d)}catch(f){c&&c(Sg("NETWORK_ERROR"))}},0)}Wg.isAvailable=function(){return"undefined"!==typeof document&&null!=document.createElement};
Wg.prototype.Fc=function(){return"json"};function Yg(a,b,c,d){ff.call(this,["auth_status"]);this.G=a;this.hf=b;this.hh=c;this.Pe=d;this.wc=new Bg(a,[bd,cd]);this.qb=null;this.We=!1;Zg(this)}ka(Yg,ff);h=Yg.prototype;h.Be=function(){return this.qb||null};function Zg(a){cd.get("redirect_request_id")&&$g(a);var b=a.wc.get();b&&b.token?(ah(a,b),a.hf(b.token,function(c,d){bh(a,c,d,!1,b.token,b)},function(b,d){ch(a,"resumeSession()",b,d)})):ah(a,null)}
function dh(a,b,c,d,e,f){"firebaseio-demo.com"===a.G.domain&&S("Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com.");a.hf(b,function(f,k){bh(a,f,k,!0,b,c,d||{},e)},function(b,c){ch(a,"auth()",b,c,f)})}function eh(a,b){a.wc.clear();ah(a,null);a.hh(function(a,d){if("ok"===a)T(b,null);else{var e=(a||"error").toUpperCase(),f=e;d&&(f+=": "+d);f=Error(f);f.code=e;T(b,f)}})}
function bh(a,b,c,d,e,f,g,k){"ok"===b?(d&&(b=c.auth,f.auth=b,f.expires=c.expires,f.token=Ed(e)?e:"",c=null,b&&y(b,"uid")?c=z(b,"uid"):y(f,"uid")&&(c=z(f,"uid")),f.uid=c,c="custom",b&&y(b,"provider")?c=z(b,"provider"):y(f,"provider")&&(c=z(f,"provider")),f.provider=c,a.wc.clear(),Ed(e)&&(g=g||{},c=bd,"sessionOnly"===g.remember&&(c=cd),"none"!==g.remember&&a.wc.set(f,c)),ah(a,f)),T(k,null,f)):(a.wc.clear(),ah(a,null),f=a=(b||"error").toUpperCase(),c&&(f+=": "+c),f=Error(f),f.code=a,T(k,f))}
function ch(a,b,c,d,e){S(b+" was canceled: "+d);a.wc.clear();ah(a,null);a=Error(d);a.code=c.toUpperCase();T(e,a)}function fh(a,b,c,d,e){gh(a);c=new yg(d||{},{},c||{});hh(a,[Ug,Wg],"/auth/"+b,c,e)}
function ih(a,b,c,d){gh(a);var e=[Tg,Vg];c=Ag(c);"anonymous"===b||"password"===b?setTimeout(function(){T(d,Sg("TRANSPORT_UNAVAILABLE"))},0):(c.he.window_features="menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top="+("object"===typeof screen?.5*(screen.height-625):0)+",left="+("object"===typeof screen?.5*(screen.width-625):0),c.he.relay_url=Ng(a.G.lc),c.he.requestWithCredential=u(a.uc,a),hh(a,e,"/auth/"+b,c,d))}
function $g(a){var b=cd.get("redirect_request_id");if(b){var c=cd.get("redirect_client_options");cd.remove("redirect_request_id");cd.remove("redirect_client_options");var d=[Ug,Wg],b={requestId:b,requestKey:Kg(document.location.hash)},c=new yg(c,{},b);a.We=!0;Lg();hh(a,d,"/auth/session",c,function(){this.We=!1}.bind(a))}}h.ve=function(a,b){gh(this);var c=Ag(a);c.fb._method="POST";this.uc("/users",c,function(a,c){a?T(b,a):T(b,a,c)})};
h.Xe=function(a,b){var c=this;gh(this);var d="/users/"+encodeURIComponent(a.email),e=Ag(a);e.fb._method="DELETE";this.uc(d,e,function(a,d){!a&&d&&d.uid&&c.qb&&c.qb.uid&&c.qb.uid===d.uid&&eh(c);T(b,a)})};h.se=function(a,b){gh(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=Ag(a);d.fb._method="PUT";d.fb.password=a.newPassword;this.uc(c,d,function(a){T(b,a)})};
h.re=function(a,b){gh(this);var c="/users/"+encodeURIComponent(a.oldEmail)+"/email",d=Ag(a);d.fb._method="PUT";d.fb.email=a.newEmail;d.fb.password=a.password;this.uc(c,d,function(a){T(b,a)})};h.Ze=function(a,b){gh(this);var c="/users/"+encodeURIComponent(a.email)+"/password",d=Ag(a);d.fb._method="POST";this.uc(c,d,function(a){T(b,a)})};h.uc=function(a,b,c){jh(this,[Ug,Wg],a,b,c)};
function hh(a,b,c,d,e){jh(a,b,c,d,function(b,c){!b&&c&&c.token&&c.uid?dh(a,c.token,c,d.qd,function(a,b){a?T(e,a):T(e,null,b)}):T(e,b||Sg("UNKNOWN_ERROR"))})}
function jh(a,b,c,d,e){b=Na(b,function(a){return"function"===typeof a.isAvailable&&a.isAvailable()});0===b.length?setTimeout(function(){T(e,Sg("TRANSPORT_UNAVAILABLE"))},0):(b=new (b.shift())(d.he),d=Gb(d.fb),d.v="js-"+Eb,d.transport=b.Fc(),d.suppress_status_codes=!0,a=Mg()+"/"+a.G.lc+c,b.open(a,d,function(a,b){if(a)T(e,a);else if(b&&b.error){var c=Error(b.error.message);c.code=b.error.code;c.details=b.error.details;T(e,c)}else T(e,null,b)}))}
function ah(a,b){var c=null!==a.qb||null!==b;a.qb=b;c&&a.ie("auth_status",b);a.Pe(null!==b)}h.Ee=function(a){O("auth_status"===a,'initial event must be of type "auth_status"');return this.We?null:[this.qb]};function gh(a){var b=a.G;if("firebaseio.com"!==b.domain&&"firebaseio-demo.com"!==b.domain&&"auth.firebase.com"===xg)throw Error("This custom Firebase server ('"+a.G.domain+"') does not support delegated login.");};var gd="websocket",hd="long_polling";function kh(a){this.nc=a;this.Qd=[];this.Wb=0;this.te=-1;this.Jb=null}function lh(a,b,c){a.te=b;a.Jb=c;a.te<a.Wb&&(a.Jb(),a.Jb=null)}function mh(a,b,c){for(a.Qd[b]=c;a.Qd[a.Wb];){var d=a.Qd[a.Wb];delete a.Qd[a.Wb];for(var e=0;e<d.length;++e)if(d[e]){var f=a;gc(function(){f.nc(d[e])})}if(a.Wb===a.te){a.Jb&&(clearTimeout(a.Jb),a.Jb(),a.Jb=null);break}a.Wb++}};function nh(a,b,c,d){this.ue=a;this.f=pd(a);this.rb=this.sb=0;this.Xa=uc(b);this.Xf=c;this.Kc=!1;this.Fb=d;this.ld=function(a){return fd(b,hd,a)}}var oh,ph;
nh.prototype.open=function(a,b){this.mf=0;this.na=b;this.Ef=new kh(a);this.Db=!1;var c=this;this.ub=setTimeout(function(){c.f("Timed out trying to connect.");c.bb();c.ub=null},Math.floor(3E4));ud(function(){if(!c.Db){c.Wa=new qh(function(a,b,d,k,m){rh(c,arguments);if(c.Wa)if(c.ub&&(clearTimeout(c.ub),c.ub=null),c.Kc=!0,"start"==a)c.id=b,c.Mf=d;else if("close"===a)b?(c.Wa.$d=!1,lh(c.Ef,b,function(){c.bb()})):c.bb();else throw Error("Unrecognized command received: "+a);},function(a,b){rh(c,arguments);
mh(c.Ef,a,b)},function(){c.bb()},c.ld);var a={start:"t"};a.ser=Math.floor(1E8*Math.random());c.Wa.ke&&(a.cb=c.Wa.ke);a.v="5";c.Xf&&(a.s=c.Xf);c.Fb&&(a.ls=c.Fb);"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");a=c.ld(a);c.f("Connecting via long-poll to "+a);sh(c.Wa,a,function(){})}})};
nh.prototype.start=function(){var a=this.Wa,b=this.Mf;a.Fg=this.id;a.Gg=b;for(a.oe=!0;th(a););a=this.id;b=this.Mf;this.kc=document.createElement("iframe");var c={dframe:"t"};c.id=a;c.pw=b;this.kc.src=this.ld(c);this.kc.style.display="none";document.body.appendChild(this.kc)};
nh.isAvailable=function(){return oh||!ph&&"undefined"!==typeof document&&null!=document.createElement&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===typeof Windows.jh)&&!0};h=nh.prototype;h.Hd=function(){};h.fd=function(){this.Db=!0;this.Wa&&(this.Wa.close(),this.Wa=null);this.kc&&(document.body.removeChild(this.kc),this.kc=null);this.ub&&(clearTimeout(this.ub),this.ub=null)};
h.bb=function(){this.Db||(this.f("Longpoll is closing itself"),this.fd(),this.na&&(this.na(this.Kc),this.na=null))};h.close=function(){this.Db||(this.f("Longpoll is being closed."),this.fd())};h.send=function(a){a=G(a);this.sb+=a.length;rc(this.Xa,"bytes_sent",a.length);a=Ob(a);a=nb(a,!0);a=yd(a,1840);for(var b=0;b<a.length;b++){var c=this.Wa;c.cd.push({Xg:this.mf,gh:a.length,of:a[b]});c.oe&&th(c);this.mf++}};function rh(a,b){var c=G(b).length;a.rb+=c;rc(a.Xa,"bytes_received",c)}
function qh(a,b,c,d){this.ld=d;this.lb=c;this.Te=new ug;this.cd=[];this.we=Math.floor(1E8*Math.random());this.$d=!0;this.ke=id();window["pLPCommand"+this.ke]=a;window["pRTLPCB"+this.ke]=b;a=document.createElement("iframe");a.style.display="none";if(document.body){document.body.appendChild(a);try{a.contentWindow.document||fc("No IE domain setting required")}catch(e){a.src="javascript:void((function(){document.open();document.domain='"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
a.contentDocument?a.jb=a.contentDocument:a.contentWindow?a.jb=a.contentWindow.document:a.document&&(a.jb=a.document);this.Ga=a;a="";this.Ga.src&&"javascript:"===this.Ga.src.substr(0,11)&&(a='<script>document.domain="'+document.domain+'";\x3c/script>');a="<html><body>"+a+"</body></html>";try{this.Ga.jb.open(),this.Ga.jb.write(a),this.Ga.jb.close()}catch(f){fc("frame writing exception"),f.stack&&fc(f.stack),fc(f)}}
qh.prototype.close=function(){this.oe=!1;if(this.Ga){this.Ga.jb.body.innerHTML="";var a=this;setTimeout(function(){null!==a.Ga&&(document.body.removeChild(a.Ga),a.Ga=null)},Math.floor(0))}var b=this.lb;b&&(this.lb=null,b())};
function th(a){if(a.oe&&a.$d&&a.Te.count()<(0<a.cd.length?2:1)){a.we++;var b={};b.id=a.Fg;b.pw=a.Gg;b.ser=a.we;for(var b=a.ld(b),c="",d=0;0<a.cd.length;)if(1870>=a.cd[0].of.length+30+c.length){var e=a.cd.shift(),c=c+"&seg"+d+"="+e.Xg+"&ts"+d+"="+e.gh+"&d"+d+"="+e.of;d++}else break;uh(a,b+c,a.we);return!0}return!1}function uh(a,b,c){function d(){a.Te.remove(c);th(a)}a.Te.add(c,1);var e=setTimeout(d,Math.floor(25E3));sh(a,b,function(){clearTimeout(e);d()})}
function sh(a,b,c){setTimeout(function(){try{if(a.$d){var d=a.Ga.jb.createElement("script");d.type="text/javascript";d.async=!0;d.src=b;d.onload=d.onreadystatechange=function(){var a=d.readyState;a&&"loaded"!==a&&"complete"!==a||(d.onload=d.onreadystatechange=null,d.parentNode&&d.parentNode.removeChild(d),c())};d.onerror=function(){fc("Long-poll script failed to load: "+b);a.$d=!1;a.close()};a.Ga.jb.body.appendChild(d)}}catch(e){}},Math.floor(1))};var vh=null;"undefined"!==typeof MozWebSocket?vh=MozWebSocket:"undefined"!==typeof WebSocket&&(vh=WebSocket);function wh(a,b,c,d){this.ue=a;this.f=pd(this.ue);this.frames=this.Nc=null;this.rb=this.sb=this.ff=0;this.Xa=uc(b);a={v:"5"};"undefined"!==typeof location&&location.href&&-1!==location.href.indexOf("firebaseio.com")&&(a.r="f");c&&(a.s=c);d&&(a.ls=d);this.jf=fd(b,gd,a)}var xh;
wh.prototype.open=function(a,b){this.lb=b;this.Kg=a;this.f("Websocket connecting to "+this.jf);this.Kc=!1;bd.set("previous_websocket_failure",!0);try{this.La=new vh(this.jf)}catch(c){this.f("Error instantiating WebSocket.");var d=c.message||c.data;d&&this.f(d);this.bb();return}var e=this;this.La.onopen=function(){e.f("Websocket connected.");e.Kc=!0};this.La.onclose=function(){e.f("Websocket connection was disconnected.");e.La=null;e.bb()};this.La.onmessage=function(a){if(null!==e.La)if(a=a.data,e.rb+=
a.length,rc(e.Xa,"bytes_received",a.length),yh(e),null!==e.frames)zh(e,a);else{a:{O(null===e.frames,"We already have a frame buffer");if(6>=a.length){var b=Number(a);if(!isNaN(b)){e.ff=b;e.frames=[];a=null;break a}}e.ff=1;e.frames=[]}null!==a&&zh(e,a)}};this.La.onerror=function(a){e.f("WebSocket error.  Closing connection.");(a=a.message||a.data)&&e.f(a);e.bb()}};wh.prototype.start=function(){};
wh.isAvailable=function(){var a=!1;if("undefined"!==typeof navigator&&navigator.userAgent){var b=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);b&&1<b.length&&4.4>parseFloat(b[1])&&(a=!0)}return!a&&null!==vh&&!xh};wh.responsesRequiredToBeHealthy=2;wh.healthyTimeout=3E4;h=wh.prototype;h.Hd=function(){bd.remove("previous_websocket_failure")};function zh(a,b){a.frames.push(b);if(a.frames.length==a.ff){var c=a.frames.join("");a.frames=null;c=Rb(c);a.Kg(c)}}
h.send=function(a){yh(this);a=G(a);this.sb+=a.length;rc(this.Xa,"bytes_sent",a.length);a=yd(a,16384);1<a.length&&Ah(this,String(a.length));for(var b=0;b<a.length;b++)Ah(this,a[b])};h.fd=function(){this.Db=!0;this.Nc&&(clearInterval(this.Nc),this.Nc=null);this.La&&(this.La.close(),this.La=null)};h.bb=function(){this.Db||(this.f("WebSocket is closing itself"),this.fd(),this.lb&&(this.lb(this.Kc),this.lb=null))};h.close=function(){this.Db||(this.f("WebSocket is being closed"),this.fd())};
function yh(a){clearInterval(a.Nc);a.Nc=setInterval(function(){a.La&&Ah(a,"0");yh(a)},Math.floor(45E3))}function Ah(a,b){try{a.La.send(b)}catch(c){a.f("Exception thrown from WebSocket.send():",c.message||c.data,"Closing connection."),setTimeout(u(a.bb,a),0)}};function Bh(a){Ch(this,a)}var Dh=[nh,wh];function Ch(a,b){var c=wh&&wh.isAvailable(),d=c&&!(bd.Af||!0===bd.get("previous_websocket_failure"));b.ih&&(c||S("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),d=!0);if(d)a.jd=[wh];else{var e=a.jd=[];zd(Dh,function(a,b){b&&b.isAvailable()&&e.push(b)})}}function Eh(a){if(0<a.jd.length)return a.jd[0];throw Error("No transports available");};function Fh(a,b,c,d,e,f,g){this.id=a;this.f=pd("c:"+this.id+":");this.nc=c;this.Zc=d;this.na=e;this.Re=f;this.G=b;this.Pd=[];this.kf=0;this.Wf=new Bh(b);this.N=0;this.Fb=g;this.f("Connection created");Gh(this)}
function Gh(a){var b=Eh(a.Wf);a.K=new b("c:"+a.id+":"+a.kf++,a.G,void 0,a.Fb);a.Ve=b.responsesRequiredToBeHealthy||0;var c=Hh(a,a.K),d=Ih(a,a.K);a.kd=a.K;a.ed=a.K;a.F=null;a.Eb=!1;setTimeout(function(){a.K&&a.K.open(c,d)},Math.floor(0));b=b.healthyTimeout||0;0<b&&(a.Bd=setTimeout(function(){a.Bd=null;a.Eb||(a.K&&102400<a.K.rb?(a.f("Connection exceeded healthy timeout but has received "+a.K.rb+" bytes.  Marking connection healthy."),a.Eb=!0,a.K.Hd()):a.K&&10240<a.K.sb?a.f("Connection exceeded healthy timeout but has sent "+
a.K.sb+" bytes.  Leaving connection alive."):(a.f("Closing unhealthy connection after timeout."),a.close()))},Math.floor(b)))}function Ih(a,b){return function(c){b===a.K?(a.K=null,c||0!==a.N?1===a.N&&a.f("Realtime connection lost."):(a.f("Realtime connection failed."),"s-"===a.G.ab.substr(0,2)&&(bd.remove("host:"+a.G.host),a.G.ab=a.G.host)),a.close()):b===a.F?(a.f("Secondary connection lost."),c=a.F,a.F=null,a.kd!==c&&a.ed!==c||a.close()):a.f("closing an old connection")}}
function Hh(a,b){return function(c){if(2!=a.N)if(b===a.ed){var d=wd("t",c);c=wd("d",c);if("c"==d){if(d=wd("t",c),"d"in c)if(c=c.d,"h"===d){var d=c.ts,e=c.v,f=c.h;a.Uf=c.s;ed(a.G,f);0==a.N&&(a.K.start(),Jh(a,a.K,d),"5"!==e&&S("Protocol version mismatch detected"),c=a.Wf,(c=1<c.jd.length?c.jd[1]:null)&&Kh(a,c))}else if("n"===d){a.f("recvd end transmission on primary");a.ed=a.F;for(c=0;c<a.Pd.length;++c)a.Ld(a.Pd[c]);a.Pd=[];Lh(a)}else"s"===d?(a.f("Connection shutdown command received. Shutting down..."),
a.Re&&(a.Re(c),a.Re=null),a.na=null,a.close()):"r"===d?(a.f("Reset packet received.  New host: "+c),ed(a.G,c),1===a.N?a.close():(Mh(a),Gh(a))):"e"===d?qd("Server Error: "+c):"o"===d?(a.f("got pong on primary."),Nh(a),Oh(a)):qd("Unknown control packet command: "+d)}else"d"==d&&a.Ld(c)}else if(b===a.F)if(d=wd("t",c),c=wd("d",c),"c"==d)"t"in c&&(c=c.t,"a"===c?Ph(a):"r"===c?(a.f("Got a reset on secondary, closing it"),a.F.close(),a.kd!==a.F&&a.ed!==a.F||a.close()):"o"===c&&(a.f("got pong on secondary."),
a.Tf--,Ph(a)));else if("d"==d)a.Pd.push(c);else throw Error("Unknown protocol layer: "+d);else a.f("message on old connection")}}Fh.prototype.Ia=function(a){Qh(this,{t:"d",d:a})};function Lh(a){a.kd===a.F&&a.ed===a.F&&(a.f("cleaning up and promoting a connection: "+a.F.ue),a.K=a.F,a.F=null)}
function Ph(a){0>=a.Tf?(a.f("Secondary connection is healthy."),a.Eb=!0,a.F.Hd(),a.F.start(),a.f("sending client ack on secondary"),a.F.send({t:"c",d:{t:"a",d:{}}}),a.f("Ending transmission on primary"),a.K.send({t:"c",d:{t:"n",d:{}}}),a.kd=a.F,Lh(a)):(a.f("sending ping on secondary."),a.F.send({t:"c",d:{t:"p",d:{}}}))}Fh.prototype.Ld=function(a){Nh(this);this.nc(a)};function Nh(a){a.Eb||(a.Ve--,0>=a.Ve&&(a.f("Primary connection is healthy."),a.Eb=!0,a.K.Hd()))}
function Kh(a,b){a.F=new b("c:"+a.id+":"+a.kf++,a.G,a.Uf);a.Tf=b.responsesRequiredToBeHealthy||0;a.F.open(Hh(a,a.F),Ih(a,a.F));setTimeout(function(){a.F&&(a.f("Timed out trying to upgrade."),a.F.close())},Math.floor(6E4))}function Jh(a,b,c){a.f("Realtime connection established.");a.K=b;a.N=1;a.Zc&&(a.Zc(c,a.Uf),a.Zc=null);0===a.Ve?(a.f("Primary connection is healthy."),a.Eb=!0):setTimeout(function(){Oh(a)},Math.floor(5E3))}
function Oh(a){a.Eb||1!==a.N||(a.f("sending ping on primary."),Qh(a,{t:"c",d:{t:"p",d:{}}}))}function Qh(a,b){if(1!==a.N)throw"Connection is not connected";a.kd.send(b)}Fh.prototype.close=function(){2!==this.N&&(this.f("Closing realtime connection."),this.N=2,Mh(this),this.na&&(this.na(),this.na=null))};function Mh(a){a.f("Shutting down all connections");a.K&&(a.K.close(),a.K=null);a.F&&(a.F.close(),a.F=null);a.Bd&&(clearTimeout(a.Bd),a.Bd=null)};function Rh(a,b,c,d){this.id=Sh++;this.f=pd("p:"+this.id+":");this.Bf=this.Ie=!1;this.ba={};this.sa=[];this.ad=0;this.Yc=[];this.qa=!1;this.eb=1E3;this.Id=3E5;this.Kb=b;this.Xc=c;this.Se=d;this.G=a;this.wb=this.Ca=this.Ma=this.Fb=this.$e=null;this.Sb=!1;this.Wd={};this.Wg=0;this.rf=!0;this.Oc=this.Ke=null;Th(this,0);kf.yb().Ib("visible",this.Ng,this);-1===a.host.indexOf("fblocal")&&jf.yb().Ib("online",this.Lg,this)}var Sh=0,Uh=0;h=Rh.prototype;
h.Ia=function(a,b,c){var d=++this.Wg;a={r:d,a:a,b:b};this.f(G(a));O(this.qa,"sendRequest call when we're not connected not allowed.");this.Ma.Ia(a);c&&(this.Wd[d]=c)};h.Cf=function(a,b,c,d){var e=a.wa(),f=a.path.toString();this.f("Listen called for "+f+" "+e);this.ba[f]=this.ba[f]||{};O(Ie(a.n)||!He(a.n),"listen() called for non-default but complete query");O(!this.ba[f][e],"listen() called twice for same path/queryId.");a={I:d,Ad:b,Tg:a,tag:c};this.ba[f][e]=a;this.qa&&Vh(this,a)};
function Vh(a,b){var c=b.Tg,d=c.path.toString(),e=c.wa();a.f("Listen on "+d+" for "+e);var f={p:d};b.tag&&(f.q=Ge(c.n),f.t=b.tag);f.h=b.Ad();a.Ia("q",f,function(f){var k=f.d,m=f.s;if(k&&"object"===typeof k&&y(k,"w")){var l=z(k,"w");da(l)&&0<=La(l,"no_index")&&S("Using an unspecified index. Consider adding "+('".indexOn": "'+c.n.g.toString()+'"')+" at "+c.path.toString()+" to your security rules for better performance")}(a.ba[d]&&a.ba[d][e])===b&&(a.f("listen response",f),"ok"!==m&&Wh(a,d,e),b.I&&
b.I(m,k))})}h.O=function(a,b,c){this.Ca={rg:a,sf:!1,Dc:b,od:c};this.f("Authenticating using credential: "+a);Xh(this);(b=40==a.length)||(a=Cd(a).Ec,b="object"===typeof a&&!0===z(a,"admin"));b&&(this.f("Admin auth credential detected.  Reducing max reconnect time."),this.Id=3E4)};h.je=function(a){this.Ca=null;this.qa&&this.Ia("unauth",{},function(b){a(b.s,b.d)})};
function Xh(a){var b=a.Ca;a.qa&&b&&a.Ia("auth",{cred:b.rg},function(c){var d=c.s;c=c.d||"error";"ok"!==d&&a.Ca===b&&(a.Ca=null);b.sf?"ok"!==d&&b.od&&b.od(d,c):(b.sf=!0,b.Dc&&b.Dc(d,c))})}h.$f=function(a,b){var c=a.path.toString(),d=a.wa();this.f("Unlisten called for "+c+" "+d);O(Ie(a.n)||!He(a.n),"unlisten() called for non-default but complete query");if(Wh(this,c,d)&&this.qa){var e=Ge(a.n);this.f("Unlisten on "+c+" for "+d);c={p:c};b&&(c.q=e,c.t=b);this.Ia("n",c)}};
h.Qe=function(a,b,c){this.qa?Yh(this,"o",a,b,c):this.Yc.push({bd:a,action:"o",data:b,I:c})};h.Gf=function(a,b,c){this.qa?Yh(this,"om",a,b,c):this.Yc.push({bd:a,action:"om",data:b,I:c})};h.Md=function(a,b){this.qa?Yh(this,"oc",a,null,b):this.Yc.push({bd:a,action:"oc",data:null,I:b})};function Yh(a,b,c,d,e){c={p:c,d:d};a.f("onDisconnect "+b,c);a.Ia(b,c,function(a){e&&setTimeout(function(){e(a.s,a.d)},Math.floor(0))})}h.put=function(a,b,c,d){Zh(this,"p",a,b,c,d)};
h.Df=function(a,b,c,d){Zh(this,"m",a,b,c,d)};function Zh(a,b,c,d,e,f){d={p:c,d:d};p(f)&&(d.h=f);a.sa.push({action:b,Pf:d,I:e});a.ad++;b=a.sa.length-1;a.qa?$h(a,b):a.f("Buffering put: "+c)}function $h(a,b){var c=a.sa[b].action,d=a.sa[b].Pf,e=a.sa[b].I;a.sa[b].Ug=a.qa;a.Ia(c,d,function(d){a.f(c+" response",d);delete a.sa[b];a.ad--;0===a.ad&&(a.sa=[]);e&&e(d.s,d.d)})}
h.Ye=function(a){this.qa&&(a={c:a},this.f("reportStats",a),this.Ia("s",a,function(a){"ok"!==a.s&&this.f("reportStats","Error sending stats: "+a.d)}))};
h.Ld=function(a){if("r"in a){this.f("from server: "+G(a));var b=a.r,c=this.Wd[b];c&&(delete this.Wd[b],c(a.b))}else{if("error"in a)throw"A server-side error has occurred: "+a.error;"a"in a&&(b=a.a,c=a.b,this.f("handleServerMessage",b,c),"d"===b?this.Kb(c.p,c.d,!1,c.t):"m"===b?this.Kb(c.p,c.d,!0,c.t):"c"===b?ai(this,c.p,c.q):"ac"===b?(a=c.s,b=c.d,c=this.Ca,this.Ca=null,c&&c.od&&c.od(a,b)):"sd"===b?this.$e?this.$e(c):"msg"in c&&"undefined"!==typeof console&&console.log("FIREBASE: "+c.msg.replace("\n",
"\nFIREBASE: ")):qd("Unrecognized action received from server: "+G(b)+"\nAre you using the latest client?"))}};h.Zc=function(a,b){this.f("connection ready");this.qa=!0;this.Oc=(new Date).getTime();this.Se({serverTimeOffset:a-(new Date).getTime()});this.Fb=b;if(this.rf){var c={};c["sdk.js."+Eb.replace(/\./g,"-")]=1;Dg()?c["framework.cordova"]=1:"object"===typeof navigator&&"ReactNative"===navigator.product&&(c["framework.reactnative"]=1);this.Ye(c)}bi(this);this.rf=!1;this.Xc(!0)};
function Th(a,b){O(!a.Ma,"Scheduling a connect when we're already connected/ing?");a.wb&&clearTimeout(a.wb);a.wb=setTimeout(function(){a.wb=null;ci(a)},Math.floor(b))}h.Ng=function(a){a&&!this.Sb&&this.eb===this.Id&&(this.f("Window became visible.  Reducing delay."),this.eb=1E3,this.Ma||Th(this,0));this.Sb=a};h.Lg=function(a){a?(this.f("Browser went online."),this.eb=1E3,this.Ma||Th(this,0)):(this.f("Browser went offline.  Killing connection."),this.Ma&&this.Ma.close())};
h.If=function(){this.f("data client disconnected");this.qa=!1;this.Ma=null;for(var a=0;a<this.sa.length;a++){var b=this.sa[a];b&&"h"in b.Pf&&b.Ug&&(b.I&&b.I("disconnect"),delete this.sa[a],this.ad--)}0===this.ad&&(this.sa=[]);this.Wd={};di(this)&&(this.Sb?this.Oc&&(3E4<(new Date).getTime()-this.Oc&&(this.eb=1E3),this.Oc=null):(this.f("Window isn't visible.  Delaying reconnect."),this.eb=this.Id,this.Ke=(new Date).getTime()),a=Math.max(0,this.eb-((new Date).getTime()-this.Ke)),a*=Math.random(),this.f("Trying to reconnect in "+
a+"ms"),Th(this,a),this.eb=Math.min(this.Id,1.3*this.eb));this.Xc(!1)};function ci(a){if(di(a)){a.f("Making a connection attempt");a.Ke=(new Date).getTime();a.Oc=null;var b=u(a.Ld,a),c=u(a.Zc,a),d=u(a.If,a),e=a.id+":"+Uh++;a.Ma=new Fh(e,a.G,b,c,d,function(b){S(b+" ("+a.G.toString()+")");a.Bf=!0},a.Fb)}}h.Cb=function(){this.Ie=!0;this.Ma?this.Ma.close():(this.wb&&(clearTimeout(this.wb),this.wb=null),this.qa&&this.If())};h.vc=function(){this.Ie=!1;this.eb=1E3;this.Ma||Th(this,0)};
function ai(a,b,c){c=c?Oa(c,function(a){return xd(a)}).join("$"):"default";(a=Wh(a,b,c))&&a.I&&a.I("permission_denied")}function Wh(a,b,c){b=(new P(b)).toString();var d;p(a.ba[b])?(d=a.ba[b][c],delete a.ba[b][c],0===oa(a.ba[b])&&delete a.ba[b]):d=void 0;return d}function bi(a){Xh(a);v(a.ba,function(b){v(b,function(b){Vh(a,b)})});for(var b=0;b<a.sa.length;b++)a.sa[b]&&$h(a,b);for(;a.Yc.length;)b=a.Yc.shift(),Yh(a,b.action,b.bd,b.data,b.I)}function di(a){var b;b=jf.yb().oc;return!a.Bf&&!a.Ie&&b};var U={zg:function(){oh=xh=!0}};U.forceLongPolling=U.zg;U.Ag=function(){ph=!0};U.forceWebSockets=U.Ag;U.$g=function(a,b){a.k.Va.$e=b};U.setSecurityDebugCallback=U.$g;U.bf=function(a,b){a.k.bf(b)};U.stats=U.bf;U.cf=function(a,b){a.k.cf(b)};U.statsIncrementCounter=U.cf;U.ud=function(a){return a.k.ud};U.dataUpdateCount=U.ud;U.Dg=function(a,b){a.k.He=b};U.interceptServerData=U.Dg;U.Jg=function(a){new Og(a)};U.onPopupOpen=U.Jg;U.Yg=function(a){xg=a};U.setAuthenticationServer=U.Yg;function ei(a,b){this.committed=a;this.snapshot=b};function V(a,b){this.dd=a;this.ta=b}V.prototype.cancel=function(a){D("Firebase.onDisconnect().cancel",0,1,arguments.length);F("Firebase.onDisconnect().cancel",1,a,!0);var b=new B;this.dd.Md(this.ta,C(b,a));return b.D};V.prototype.cancel=V.prototype.cancel;V.prototype.remove=function(a){D("Firebase.onDisconnect().remove",0,1,arguments.length);og("Firebase.onDisconnect().remove",this.ta);F("Firebase.onDisconnect().remove",1,a,!0);var b=new B;fi(this.dd,this.ta,null,C(b,a));return b.D};
V.prototype.remove=V.prototype.remove;V.prototype.set=function(a,b){D("Firebase.onDisconnect().set",1,2,arguments.length);og("Firebase.onDisconnect().set",this.ta);gg("Firebase.onDisconnect().set",a,this.ta,!1);F("Firebase.onDisconnect().set",2,b,!0);var c=new B;fi(this.dd,this.ta,a,C(c,b));return c.D};V.prototype.set=V.prototype.set;
V.prototype.Ob=function(a,b,c){D("Firebase.onDisconnect().setWithPriority",2,3,arguments.length);og("Firebase.onDisconnect().setWithPriority",this.ta);gg("Firebase.onDisconnect().setWithPriority",a,this.ta,!1);kg("Firebase.onDisconnect().setWithPriority",2,b);F("Firebase.onDisconnect().setWithPriority",3,c,!0);var d=new B;gi(this.dd,this.ta,a,b,C(d,c));return d.D};V.prototype.setWithPriority=V.prototype.Ob;
V.prototype.update=function(a,b){D("Firebase.onDisconnect().update",1,2,arguments.length);og("Firebase.onDisconnect().update",this.ta);if(da(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;S("Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}jg("Firebase.onDisconnect().update",a,this.ta);F("Firebase.onDisconnect().update",2,b,!0);
c=new B;hi(this.dd,this.ta,a,C(c,b));return c.D};V.prototype.update=V.prototype.update;function W(a,b,c){this.A=a;this.Y=b;this.g=c}W.prototype.J=function(){D("Firebase.DataSnapshot.val",0,0,arguments.length);return this.A.J()};W.prototype.val=W.prototype.J;W.prototype.qf=function(){D("Firebase.DataSnapshot.exportVal",0,0,arguments.length);return this.A.J(!0)};W.prototype.exportVal=W.prototype.qf;W.prototype.xg=function(){D("Firebase.DataSnapshot.exists",0,0,arguments.length);return!this.A.e()};W.prototype.exists=W.prototype.xg;
W.prototype.o=function(a){D("Firebase.DataSnapshot.child",0,1,arguments.length);fa(a)&&(a=String(a));ng("Firebase.DataSnapshot.child",a);var b=new P(a),c=this.Y.o(b);return new W(this.A.S(b),c,R)};W.prototype.child=W.prototype.o;W.prototype.Fa=function(a){D("Firebase.DataSnapshot.hasChild",1,1,arguments.length);ng("Firebase.DataSnapshot.hasChild",a);var b=new P(a);return!this.A.S(b).e()};W.prototype.hasChild=W.prototype.Fa;
W.prototype.C=function(){D("Firebase.DataSnapshot.getPriority",0,0,arguments.length);return this.A.C().J()};W.prototype.getPriority=W.prototype.C;W.prototype.forEach=function(a){D("Firebase.DataSnapshot.forEach",1,1,arguments.length);F("Firebase.DataSnapshot.forEach",1,a,!1);if(this.A.L())return!1;var b=this;return!!this.A.R(this.g,function(c,d){return a(new W(d,b.Y.o(c),R))})};W.prototype.forEach=W.prototype.forEach;
W.prototype.zd=function(){D("Firebase.DataSnapshot.hasChildren",0,0,arguments.length);return this.A.L()?!1:!this.A.e()};W.prototype.hasChildren=W.prototype.zd;W.prototype.name=function(){S("Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead.");D("Firebase.DataSnapshot.name",0,0,arguments.length);return this.key()};W.prototype.name=W.prototype.name;W.prototype.key=function(){D("Firebase.DataSnapshot.key",0,0,arguments.length);return this.Y.key()};
W.prototype.key=W.prototype.key;W.prototype.Hb=function(){D("Firebase.DataSnapshot.numChildren",0,0,arguments.length);return this.A.Hb()};W.prototype.numChildren=W.prototype.Hb;W.prototype.Mb=function(){D("Firebase.DataSnapshot.ref",0,0,arguments.length);return this.Y};W.prototype.ref=W.prototype.Mb;function ii(a,b,c){this.Vb=a;this.tb=b;this.vb=c||null}h=ii.prototype;h.Qf=function(a){return"value"===a};h.createEvent=function(a,b){var c=b.n.g;return new jc("value",this,new W(a.Na,b.Mb(),c))};h.Zb=function(a){var b=this.vb;if("cancel"===a.De()){O(this.tb,"Raising a cancel event on a listener with no cancel callback");var c=this.tb;return function(){c.call(b,a.error)}}var d=this.Vb;return function(){d.call(b,a.be)}};h.lf=function(a,b){return this.tb?new kc(this,a,b):null};
h.matches=function(a){return a instanceof ii?a.Vb&&this.Vb?a.Vb===this.Vb&&a.vb===this.vb:!0:!1};h.yf=function(){return null!==this.Vb};function ji(a,b,c){this.ja=a;this.tb=b;this.vb=c}h=ji.prototype;h.Qf=function(a){a="children_added"===a?"child_added":a;return("children_removed"===a?"child_removed":a)in this.ja};h.lf=function(a,b){return this.tb?new kc(this,a,b):null};
h.createEvent=function(a,b){O(null!=a.Za,"Child events should have a childName.");var c=b.Mb().o(a.Za);return new jc(a.type,this,new W(a.Na,c,b.n.g),a.Td)};h.Zb=function(a){var b=this.vb;if("cancel"===a.De()){O(this.tb,"Raising a cancel event on a listener with no cancel callback");var c=this.tb;return function(){c.call(b,a.error)}}var d=this.ja[a.wd];return function(){d.call(b,a.be,a.Td)}};
h.matches=function(a){if(a instanceof ji){if(!this.ja||!a.ja)return!0;if(this.vb===a.vb){var b=oa(a.ja);if(b===oa(this.ja)){if(1===b){var b=pa(a.ja),c=pa(this.ja);return c===b&&(!a.ja[b]||!this.ja[c]||a.ja[b]===this.ja[c])}return na(this.ja,function(b,c){return a.ja[c]===b})}}}return!1};h.yf=function(){return null!==this.ja};function ki(){this.za={}}h=ki.prototype;h.e=function(){return va(this.za)};h.gb=function(a,b,c){var d=a.source.Lb;if(null!==d)return d=z(this.za,d),O(null!=d,"SyncTree gave us an op for an invalid query."),d.gb(a,b,c);var e=[];v(this.za,function(d){e=e.concat(d.gb(a,b,c))});return e};h.Tb=function(a,b,c,d,e){var f=a.wa(),g=z(this.za,f);if(!g){var g=c.Aa(e?d:null),k=!1;g?k=!0:(g=d instanceof fe?c.Cc(d):H,k=!1);g=new Ye(a,new je(new Xb(g,k,!1),new Xb(d,e,!1)));this.za[f]=g}g.Tb(b);return af(g,b)};
h.nb=function(a,b,c){var d=a.wa(),e=[],f=[],g=null!=li(this);if("default"===d){var k=this;v(this.za,function(a,d){f=f.concat(a.nb(b,c));a.e()&&(delete k.za[d],He(a.Y.n)||e.push(a.Y))})}else{var m=z(this.za,d);m&&(f=f.concat(m.nb(b,c)),m.e()&&(delete this.za[d],He(m.Y.n)||e.push(m.Y)))}g&&null==li(this)&&e.push(new X(a.k,a.path));return{Vg:e,vg:f}};function mi(a){return Na(qa(a.za),function(a){return!He(a.Y.n)})}h.kb=function(a){var b=null;v(this.za,function(c){b=b||c.kb(a)});return b};
function ni(a,b){if(He(b.n))return li(a);var c=b.wa();return z(a.za,c)}function li(a){return ua(a.za,function(a){return He(a.Y.n)})||null};function oi(a){this.va=qe;this.mb=new Pf;this.df={};this.qc={};this.Qc=a}function pi(a,b,c,d,e){var f=a.mb,g=e;O(d>f.Pc,"Stacking an older write on top of newer ones");p(g)||(g=!0);f.pa.push({path:b,Ja:c,md:d,visible:g});g&&(f.V=Jf(f.V,b,c));f.Pc=d;return e?qi(a,new Ac(Ef,b,c)):[]}function ri(a,b,c,d){var e=a.mb;O(d>e.Pc,"Stacking an older merge on top of newer ones");e.pa.push({path:b,children:c,md:d,visible:!0});e.V=Kf(e.V,b,c);e.Pc=d;c=sf(c);return qi(a,new bf(Ef,b,c))}
function si(a,b,c){c=c||!1;var d=Qf(a.mb,b);if(a.mb.Ud(b)){var e=qe;null!=d.Ja?e=e.set(M,!0):Fb(d.children,function(a,b){e=e.set(new P(a),b)});return qi(a,new Df(d.path,e,c))}return[]}function ti(a,b,c){c=sf(c);return qi(a,new bf(Gf,b,c))}function ui(a,b,c,d){d=vi(a,d);if(null!=d){var e=wi(d);d=e.path;e=e.Lb;b=lf(d,b);c=new Ac(new Ff(!1,!0,e,!0),b,c);return xi(a,d,c)}return[]}
function yi(a,b,c,d){if(d=vi(a,d)){var e=wi(d);d=e.path;e=e.Lb;b=lf(d,b);c=sf(c);c=new bf(new Ff(!1,!0,e,!0),b,c);return xi(a,d,c)}return[]}
oi.prototype.Tb=function(a,b){var c=a.path,d=null,e=!1;zf(this.va,c,function(a,b){var f=lf(a,c);d=d||b.kb(f);e=e||null!=li(b)});var f=this.va.get(c);f?(e=e||null!=li(f),d=d||f.kb(M)):(f=new ki,this.va=this.va.set(c,f));var g;null!=d?g=!0:(g=!1,d=H,Cf(this.va.subtree(c),function(a,b){var c=b.kb(M);c&&(d=d.W(a,c))}));var k=null!=ni(f,a);if(!k&&!He(a.n)){var m=zi(a);O(!(m in this.qc),"View does not exist, but we have a tag");var l=Ai++;this.qc[m]=l;this.df["_"+l]=m}g=f.Tb(a,b,new Uf(c,this.mb),d,g);
k||e||(f=ni(f,a),g=g.concat(Bi(this,a,f)));return g};
oi.prototype.nb=function(a,b,c){var d=a.path,e=this.va.get(d),f=[];if(e&&("default"===a.wa()||null!=ni(e,a))){f=e.nb(a,b,c);e.e()&&(this.va=this.va.remove(d));e=f.Vg;f=f.vg;b=-1!==Sa(e,function(a){return He(a.n)});var g=xf(this.va,d,function(a,b){return null!=li(b)});if(b&&!g&&(d=this.va.subtree(d),!d.e()))for(var d=Ci(d),k=0;k<d.length;++k){var m=d[k],l=m.Y,m=Di(this,m);this.Qc.af(Ei(l),Fi(this,l),m.Ad,m.I)}if(!g&&0<e.length&&!c)if(b)this.Qc.de(Ei(a),null);else{var t=this;Ma(e,function(a){a.wa();
var b=t.qc[zi(a)];t.Qc.de(Ei(a),b)})}Gi(this,e)}return f};oi.prototype.Aa=function(a,b){var c=this.mb,d=xf(this.va,a,function(b,c){var d=lf(b,a);if(d=c.kb(d))return d});return c.Aa(a,d,b,!0)};function Ci(a){return vf(a,function(a,c,d){if(c&&null!=li(c))return[li(c)];var e=[];c&&(e=mi(c));v(d,function(a){e=e.concat(a)});return e})}function Gi(a,b){for(var c=0;c<b.length;++c){var d=b[c];if(!He(d.n)){var d=zi(d),e=a.qc[d];delete a.qc[d];delete a.df["_"+e]}}}
function Ei(a){return He(a.n)&&!Ie(a.n)?a.Mb():a}function Bi(a,b,c){var d=b.path,e=Fi(a,b);c=Di(a,c);b=a.Qc.af(Ei(b),e,c.Ad,c.I);d=a.va.subtree(d);if(e)O(null==li(d.value),"If we're adding a query, it shouldn't be shadowed");else for(e=vf(d,function(a,b,c){if(!a.e()&&b&&null!=li(b))return[Ze(li(b))];var d=[];b&&(d=d.concat(Oa(mi(b),function(a){return a.Y})));v(c,function(a){d=d.concat(a)});return d}),d=0;d<e.length;++d)c=e[d],a.Qc.de(Ei(c),Fi(a,c));return b}
function Di(a,b){var c=b.Y,d=Fi(a,c);return{Ad:function(){return(b.w()||H).hash()},I:function(b){if("ok"===b){if(d){var f=c.path;if(b=vi(a,d)){var g=wi(b);b=g.path;g=g.Lb;f=lf(b,f);f=new Cc(new Ff(!1,!0,g,!0),f);b=xi(a,b,f)}else b=[]}else b=qi(a,new Cc(Gf,c.path));return b}f="Unknown Error";"too_big"===b?f="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"==b?f="Client doesn't have permission to access the desired data.":"unavailable"==b&&
(f="The service is unavailable");f=Error(b+" at "+c.path.toString()+": "+f);f.code=b.toUpperCase();return a.nb(c,null,f)}}}function zi(a){return a.path.toString()+"$"+a.wa()}function wi(a){var b=a.indexOf("$");O(-1!==b&&b<a.length-1,"Bad queryKey.");return{Lb:a.substr(b+1),path:new P(a.substr(0,b))}}function vi(a,b){var c=a.df,d="_"+b;return d in c?c[d]:void 0}function Fi(a,b){var c=zi(b);return z(a.qc,c)}var Ai=1;
function xi(a,b,c){var d=a.va.get(b);O(d,"Missing sync point for query tag that we're tracking");return d.gb(c,new Uf(b,a.mb),null)}function qi(a,b){return Hi(a,b,a.va,null,new Uf(M,a.mb))}function Hi(a,b,c,d,e){if(b.path.e())return Ii(a,b,c,d,e);var f=c.get(M);null==d&&null!=f&&(d=f.kb(M));var g=[],k=K(b.path),m=b.$c(k);if((c=c.children.get(k))&&m)var l=d?d.T(k):null,k=e.o(k),g=g.concat(Hi(a,m,c,l,k));f&&(g=g.concat(f.gb(b,e,d)));return g}
function Ii(a,b,c,d,e){var f=c.get(M);null==d&&null!=f&&(d=f.kb(M));var g=[];c.children.ka(function(c,f){var l=d?d.T(c):null,t=e.o(c),A=b.$c(c);A&&(g=g.concat(Ii(a,A,f,l,t)))});f&&(g=g.concat(f.gb(b,e,d)));return g};function Ji(a,b){this.G=a;this.Xa=uc(a);this.hd=null;this.fa=new Zb;this.Kd=1;this.Va=null;b||0<=("object"===typeof window&&window.navigator&&window.navigator.userAgent||"").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)?(this.da=new cf(this.G,u(this.Kb,this)),setTimeout(u(this.Xc,this,!0),0)):this.da=this.Va=new Rh(this.G,u(this.Kb,this),u(this.Xc,this),u(this.Se,this));this.dh=vc(a,u(function(){return new pc(this.Xa,this.da)},this));this.yc=new Wf;
this.Ge=new Sb;var c=this;this.Fd=new oi({af:function(a,b,f,g){b=[];f=c.Ge.j(a.path);f.e()||(b=qi(c.Fd,new Ac(Gf,a.path,f)),setTimeout(function(){g("ok")},0));return b},de:aa});Ki(this,"connected",!1);this.na=new Vc;this.O=new Yg(a,u(this.da.O,this.da),u(this.da.je,this.da),u(this.Pe,this));this.ud=0;this.He=null;this.M=new oi({af:function(a,b,f,g){c.da.Cf(a,f,b,function(b,e){var f=g(b,e);dc(c.fa,a.path,f)});return[]},de:function(a,b){c.da.$f(a,b)}})}h=Ji.prototype;
h.toString=function(){return(this.G.ob?"https://":"http://")+this.G.host};h.name=function(){return this.G.lc};function Li(a){a=a.Ge.j(new P(".info/serverTimeOffset")).J()||0;return(new Date).getTime()+a}function Mi(a){a=a={timestamp:Li(a)};a.timestamp=a.timestamp||(new Date).getTime();return a}
h.Kb=function(a,b,c,d){this.ud++;var e=new P(a);b=this.He?this.He(a,b):b;a=[];d?c?(b=ma(b,function(a){return Q(a)}),a=yi(this.M,e,b,d)):(b=Q(b),a=ui(this.M,e,b,d)):c?(d=ma(b,function(a){return Q(a)}),a=ti(this.M,e,d)):(d=Q(b),a=qi(this.M,new Ac(Gf,e,d)));d=e;0<a.length&&(d=Ni(this,e));dc(this.fa,d,a)};h.Xc=function(a){Ki(this,"connected",a);!1===a&&Oi(this)};h.Se=function(a){var b=this;zd(a,function(a,d){Ki(b,d,a)})};h.Pe=function(a){Ki(this,"authenticated",a)};
function Ki(a,b,c){b=new P("/.info/"+b);c=Q(c);var d=a.Ge;d.Zd=d.Zd.H(b,c);c=qi(a.Fd,new Ac(Gf,b,c));dc(a.fa,b,c)}h.Ob=function(a,b,c,d){this.f("set",{path:a.toString(),value:b,mh:c});var e=Mi(this);b=Q(b,c);var e=Xc(b,e),f=this.Kd++,e=pi(this.M,a,e,f,!0);$b(this.fa,e);var g=this;this.da.put(a.toString(),b.J(!0),function(b,c){var e="ok"===b;e||S("set at "+a+" failed: "+b);e=si(g.M,f,!e);dc(g.fa,a,e);Pi(d,b,c)});e=Qi(this,a);Ni(this,e);dc(this.fa,e,[])};
h.update=function(a,b,c){this.f("update",{path:a.toString(),value:b});var d=!0,e=Mi(this),f={};v(b,function(a,b){d=!1;var c=Q(a);f[b]=Xc(c,e)});if(d)fc("update() called with empty data.  Don't do anything."),Pi(c,"ok");else{var g=this.Kd++,k=ri(this.M,a,f,g);$b(this.fa,k);var m=this;this.da.Df(a.toString(),b,function(b,d){var e="ok"===b;e||S("update at "+a+" failed: "+b);var e=si(m.M,g,!e),f=a;0<e.length&&(f=Ni(m,a));dc(m.fa,f,e);Pi(c,b,d)});b=Qi(this,a);Ni(this,b);dc(this.fa,a,[])}};
function Oi(a){a.f("onDisconnectEvents");var b=Mi(a),c=[];Wc(Uc(a.na,b),M,function(b,e){c=c.concat(qi(a.M,new Ac(Gf,b,e)));var f=Qi(a,b);Ni(a,f)});a.na=new Vc;dc(a.fa,M,c)}h.Md=function(a,b){var c=this;this.da.Md(a.toString(),function(d,e){"ok"===d&&wg(c.na,a);Pi(b,d,e)})};function fi(a,b,c,d){var e=Q(c);a.da.Qe(b.toString(),e.J(!0),function(c,g){"ok"===c&&a.na.rc(b,e);Pi(d,c,g)})}function gi(a,b,c,d,e){var f=Q(c,d);a.da.Qe(b.toString(),f.J(!0),function(c,d){"ok"===c&&a.na.rc(b,f);Pi(e,c,d)})}
function hi(a,b,c,d){var e=!0,f;for(f in c)e=!1;e?(fc("onDisconnect().update() called with empty data.  Don't do anything."),Pi(d,"ok")):a.da.Gf(b.toString(),c,function(e,f){if("ok"===e)for(var m in c){var l=Q(c[m]);a.na.rc(b.o(m),l)}Pi(d,e,f)})}function Ri(a,b,c){c=".info"===K(b.path)?a.Fd.Tb(b,c):a.M.Tb(b,c);bc(a.fa,b.path,c)}h.Cb=function(){this.Va&&this.Va.Cb()};h.vc=function(){this.Va&&this.Va.vc()};
h.bf=function(a){if("undefined"!==typeof console){a?(this.hd||(this.hd=new oc(this.Xa)),a=this.hd.get()):a=this.Xa.get();var b=Pa(ra(a),function(a,b){return Math.max(b.length,a)},0),c;for(c in a){for(var d=a[c],e=c.length;e<b+2;e++)c+=" ";console.log(c+d)}}};h.cf=function(a){rc(this.Xa,a);this.dh.Vf[a]=!0};h.f=function(a){var b="";this.Va&&(b=this.Va.id+":");fc(b,arguments)};
function Pi(a,b,c){a&&gc(function(){if("ok"==b)a(null);else{var d=(b||"error").toUpperCase(),e=d;c&&(e+=": "+c);e=Error(e);e.code=d;a(e)}})};function Si(a,b,c,d,e){function f(){}a.f("transaction on "+b);var g=new X(a,b);g.Ib("value",f);c={path:b,update:c,I:d,status:null,Lf:id(),gf:e,Sf:0,le:function(){g.mc("value",f)},ne:null,Da:null,rd:null,sd:null,td:null};d=a.M.Aa(b,void 0)||H;c.rd=d;d=c.update(d.J());if(p(d)){hg("transaction failed: Data returned ",d,c.path);c.status=1;e=Xf(a.yc,b);var k=e.Ea()||[];k.push(c);Yf(e,k);"object"===typeof d&&null!==d&&y(d,".priority")?(k=z(d,".priority"),O(fg(k),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):
k=(a.M.Aa(b)||H).C().J();e=Mi(a);d=Q(d,k);e=Xc(d,e);c.sd=d;c.td=e;c.Da=a.Kd++;c=pi(a.M,b,e,c.Da,c.gf);dc(a.fa,b,c);Ti(a)}else c.le(),c.sd=null,c.td=null,c.I&&(a=new W(c.rd,new X(a,c.path),R),c.I(null,!1,a))}function Ti(a,b){var c=b||a.yc;b||Ui(a,c);if(null!==c.Ea()){var d=Vi(a,c);O(0<d.length,"Sending zero length transaction queue");Qa(d,function(a){return 1===a.status})&&Wi(a,c.path(),d)}else c.zd()&&c.R(function(b){Ti(a,b)})}
function Wi(a,b,c){for(var d=Oa(c,function(a){return a.Da}),e=a.M.Aa(b,d)||H,d=e,e=e.hash(),f=0;f<c.length;f++){var g=c[f];O(1===g.status,"tryToSendTransactionQueue_: items in queue should all be run.");g.status=2;g.Sf++;var k=lf(b,g.path),d=d.H(k,g.sd)}d=d.J(!0);a.da.put(b.toString(),d,function(d){a.f("transaction put response",{path:b.toString(),status:d});var e=[];if("ok"===d){d=[];for(f=0;f<c.length;f++){c[f].status=3;e=e.concat(si(a.M,c[f].Da));if(c[f].I){var g=c[f].td,k=new X(a,c[f].path);d.push(u(c[f].I,
null,null,!0,new W(g,k,R)))}c[f].le()}Ui(a,Xf(a.yc,b));Ti(a);dc(a.fa,b,e);for(f=0;f<d.length;f++)gc(d[f])}else{if("datastale"===d)for(f=0;f<c.length;f++)c[f].status=4===c[f].status?5:1;else for(S("transaction at "+b.toString()+" failed: "+d),f=0;f<c.length;f++)c[f].status=5,c[f].ne=d;Ni(a,b)}},e)}function Ni(a,b){var c=Xi(a,b),d=c.path(),c=Vi(a,c);Yi(a,c,d);return d}
function Yi(a,b,c){if(0!==b.length){for(var d=[],e=[],f=Oa(b,function(a){return a.Da}),g=0;g<b.length;g++){var k=b[g],m=lf(c,k.path),l=!1,t;O(null!==m,"rerunTransactionsUnderNode_: relativePath should not be null.");if(5===k.status)l=!0,t=k.ne,e=e.concat(si(a.M,k.Da,!0));else if(1===k.status)if(25<=k.Sf)l=!0,t="maxretry",e=e.concat(si(a.M,k.Da,!0));else{var A=a.M.Aa(k.path,f)||H;k.rd=A;var I=b[g].update(A.J());p(I)?(hg("transaction failed: Data returned ",I,k.path),m=Q(I),"object"===typeof I&&null!=
I&&y(I,".priority")||(m=m.ia(A.C())),A=k.Da,I=Mi(a),I=Xc(m,I),k.sd=m,k.td=I,k.Da=a.Kd++,Ta(f,A),e=e.concat(pi(a.M,k.path,I,k.Da,k.gf)),e=e.concat(si(a.M,A,!0))):(l=!0,t="nodata",e=e.concat(si(a.M,k.Da,!0)))}dc(a.fa,c,e);e=[];l&&(b[g].status=3,setTimeout(b[g].le,Math.floor(0)),b[g].I&&("nodata"===t?(k=new X(a,b[g].path),d.push(u(b[g].I,null,null,!1,new W(b[g].rd,k,R)))):d.push(u(b[g].I,null,Error(t),!1,null))))}Ui(a,a.yc);for(g=0;g<d.length;g++)gc(d[g]);Ti(a)}}
function Xi(a,b){for(var c,d=a.yc;null!==(c=K(b))&&null===d.Ea();)d=Xf(d,c),b=N(b);return d}function Vi(a,b){var c=[];Zi(a,b,c);c.sort(function(a,b){return a.Lf-b.Lf});return c}function Zi(a,b,c){var d=b.Ea();if(null!==d)for(var e=0;e<d.length;e++)c.push(d[e]);b.R(function(b){Zi(a,b,c)})}function Ui(a,b){var c=b.Ea();if(c){for(var d=0,e=0;e<c.length;e++)3!==c[e].status&&(c[d]=c[e],d++);c.length=d;Yf(b,0<c.length?c:null)}b.R(function(b){Ui(a,b)})}
function Qi(a,b){var c=Xi(a,b).path(),d=Xf(a.yc,b);ag(d,function(b){$i(a,b)});$i(a,d);$f(d,function(b){$i(a,b)});return c}
function $i(a,b){var c=b.Ea();if(null!==c){for(var d=[],e=[],f=-1,g=0;g<c.length;g++)4!==c[g].status&&(2===c[g].status?(O(f===g-1,"All SENT items should be at beginning of queue."),f=g,c[g].status=4,c[g].ne="set"):(O(1===c[g].status,"Unexpected transaction status in abort"),c[g].le(),e=e.concat(si(a.M,c[g].Da,!0)),c[g].I&&d.push(u(c[g].I,null,Error("set"),!1,null))));-1===f?Yf(b,null):c.length=f+1;dc(a.fa,b.path(),e);for(g=0;g<d.length;g++)gc(d[g])}};function aj(){this.sc={};this.ag=!1}aj.prototype.Cb=function(){for(var a in this.sc)this.sc[a].Cb()};aj.prototype.vc=function(){for(var a in this.sc)this.sc[a].vc()};aj.prototype.ze=function(){this.ag=!0};ba(aj);aj.prototype.interrupt=aj.prototype.Cb;aj.prototype.resume=aj.prototype.vc;function Y(a,b,c,d){this.k=a;this.path=b;this.n=c;this.pc=d}
function bj(a){var b=null,c=null;a.oa&&(b=Od(a));a.ra&&(c=Rd(a));if(a.g===re){if(a.oa){if("[MIN_NAME]"!=Nd(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==typeof b)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}if(a.ra){if("[MAX_NAME]"!=Pd(a))throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==
typeof c)throw Error("Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string.");}}else if(a.g===R){if(null!=b&&!fg(b)||null!=c&&!fg(c))throw Error("Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string).");}else if(O(a.g instanceof ve||a.g===Be,"unknown index type."),null!=b&&"object"===typeof b||null!=c&&"object"===typeof c)throw Error("Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object.");
}function cj(a){if(a.oa&&a.ra&&a.la&&(!a.la||""===a.Rb))throw Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");}function dj(a,b){if(!0===a.pc)throw Error(b+": You can't combine multiple orderBy calls.");}h=Y.prototype;h.Mb=function(){D("Query.ref",0,0,arguments.length);return new X(this.k,this.path)};
h.Ib=function(a,b,c,d){D("Query.on",2,4,arguments.length);lg("Query.on",a,!1);F("Query.on",2,b,!1);var e=ej("Query.on",c,d);if("value"===a)Ri(this.k,this,new ii(b,e.cancel||null,e.Qa||null));else{var f={};f[a]=b;Ri(this.k,this,new ji(f,e.cancel,e.Qa))}return b};
h.mc=function(a,b,c){D("Query.off",0,3,arguments.length);lg("Query.off",a,!0);F("Query.off",2,b,!0);Qb("Query.off",3,c);var d=null,e=null;"value"===a?d=new ii(b||null,null,c||null):a&&(b&&(e={},e[a]=b),d=new ji(e,null,c||null));e=this.k;d=".info"===K(this.path)?e.Fd.nb(this,d):e.M.nb(this,d);bc(e.fa,this.path,d)};
h.Og=function(a,b){function c(k){f&&(f=!1,e.mc(a,c),b&&b.call(d.Qa,k),g.resolve(k))}D("Query.once",1,4,arguments.length);lg("Query.once",a,!1);F("Query.once",2,b,!0);var d=ej("Query.once",arguments[2],arguments[3]),e=this,f=!0,g=new B;Nb(g.D);this.Ib(a,c,function(b){e.mc(a,c);d.cancel&&d.cancel.call(d.Qa,b);g.reject(b)});return g.D};
h.Le=function(a){S("Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead.");D("Query.limit",1,1,arguments.length);if(!fa(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limit: First argument must be a positive integer.");if(this.n.la)throw Error("Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast.");var b=this.n.Le(a);cj(b);return new Y(this.k,this.path,b,this.pc)};
h.Me=function(a){D("Query.limitToFirst",1,1,arguments.length);if(!fa(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToFirst: First argument must be a positive integer.");if(this.n.la)throw Error("Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Y(this.k,this.path,this.n.Me(a),this.pc)};
h.Ne=function(a){D("Query.limitToLast",1,1,arguments.length);if(!fa(a)||Math.floor(a)!==a||0>=a)throw Error("Query.limitToLast: First argument must be a positive integer.");if(this.n.la)throw Error("Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast).");return new Y(this.k,this.path,this.n.Ne(a),this.pc)};
h.Pg=function(a){D("Query.orderByChild",1,1,arguments.length);if("$key"===a)throw Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');if("$priority"===a)throw Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');if("$value"===a)throw Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');ng("Query.orderByChild",a);dj(this,"Query.orderByChild");var b=new P(a);if(b.e())throw Error("Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.");
b=new ve(b);b=Fe(this.n,b);bj(b);return new Y(this.k,this.path,b,!0)};h.Qg=function(){D("Query.orderByKey",0,0,arguments.length);dj(this,"Query.orderByKey");var a=Fe(this.n,re);bj(a);return new Y(this.k,this.path,a,!0)};h.Rg=function(){D("Query.orderByPriority",0,0,arguments.length);dj(this,"Query.orderByPriority");var a=Fe(this.n,R);bj(a);return new Y(this.k,this.path,a,!0)};
h.Sg=function(){D("Query.orderByValue",0,0,arguments.length);dj(this,"Query.orderByValue");var a=Fe(this.n,Be);bj(a);return new Y(this.k,this.path,a,!0)};h.ce=function(a,b){D("Query.startAt",0,2,arguments.length);gg("Query.startAt",a,this.path,!0);mg("Query.startAt",b);var c=this.n.ce(a,b);cj(c);bj(c);if(this.n.oa)throw Error("Query.startAt: Starting point was already set (by another call to startAt or equalTo).");p(a)||(b=a=null);return new Y(this.k,this.path,c,this.pc)};
h.vd=function(a,b){D("Query.endAt",0,2,arguments.length);gg("Query.endAt",a,this.path,!0);mg("Query.endAt",b);var c=this.n.vd(a,b);cj(c);bj(c);if(this.n.ra)throw Error("Query.endAt: Ending point was already set (by another call to endAt or equalTo).");return new Y(this.k,this.path,c,this.pc)};
h.tg=function(a,b){D("Query.equalTo",1,2,arguments.length);gg("Query.equalTo",a,this.path,!1);mg("Query.equalTo",b);if(this.n.oa)throw Error("Query.equalTo: Starting point was already set (by another call to endAt or equalTo).");if(this.n.ra)throw Error("Query.equalTo: Ending point was already set (by another call to endAt or equalTo).");return this.ce(a,b).vd(a,b)};
h.toString=function(){D("Query.toString",0,0,arguments.length);for(var a=this.path,b="",c=a.aa;c<a.u.length;c++)""!==a.u[c]&&(b+="/"+encodeURIComponent(String(a.u[c])));return this.k.toString()+(b||"/")};h.wa=function(){var a=xd(Ge(this.n));return"{}"===a?"default":a};
function ej(a,b,c){var d={cancel:null,Qa:null};if(b&&c)d.cancel=b,F(a,3,d.cancel,!0),d.Qa=c,Qb(a,4,d.Qa);else if(b)if("object"===typeof b&&null!==b)d.Qa=b;else if("function"===typeof b)d.cancel=b;else throw Error(E(a,3,!0)+" must either be a cancel callback or a context object.");return d}Y.prototype.ref=Y.prototype.Mb;Y.prototype.on=Y.prototype.Ib;Y.prototype.off=Y.prototype.mc;Y.prototype.once=Y.prototype.Og;Y.prototype.limit=Y.prototype.Le;Y.prototype.limitToFirst=Y.prototype.Me;
Y.prototype.limitToLast=Y.prototype.Ne;Y.prototype.orderByChild=Y.prototype.Pg;Y.prototype.orderByKey=Y.prototype.Qg;Y.prototype.orderByPriority=Y.prototype.Rg;Y.prototype.orderByValue=Y.prototype.Sg;Y.prototype.startAt=Y.prototype.ce;Y.prototype.endAt=Y.prototype.vd;Y.prototype.equalTo=Y.prototype.tg;Y.prototype.toString=Y.prototype.toString;var Z={};Z.zc=Rh;Z.DataConnection=Z.zc;Rh.prototype.bh=function(a,b){this.Ia("q",{p:a},b)};Z.zc.prototype.simpleListen=Z.zc.prototype.bh;Rh.prototype.sg=function(a,b){this.Ia("echo",{d:a},b)};Z.zc.prototype.echo=Z.zc.prototype.sg;Rh.prototype.interrupt=Rh.prototype.Cb;Z.dg=Fh;Z.RealTimeConnection=Z.dg;Fh.prototype.sendRequest=Fh.prototype.Ia;Fh.prototype.close=Fh.prototype.close;
Z.Cg=function(a){var b=Rh.prototype.put;Rh.prototype.put=function(c,d,e,f){p(f)&&(f=a());b.call(this,c,d,e,f)};return function(){Rh.prototype.put=b}};Z.hijackHash=Z.Cg;Z.cg=dd;Z.ConnectionTarget=Z.cg;Z.wa=function(a){return a.wa()};Z.queryIdentifier=Z.wa;Z.Eg=function(a){return a.k.Va.ba};Z.listens=Z.Eg;Z.ze=function(a){a.ze()};Z.forceRestClient=Z.ze;function X(a,b){var c,d,e;if(a instanceof Ji)c=a,d=b;else{D("new Firebase",1,2,arguments.length);d=sd(arguments[0]);c=d.eh;"firebase"===d.domain&&rd(d.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");c&&"undefined"!=c||rd("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");d.ob||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&S("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
c=new dd(d.host,d.ob,c,"ws"===d.scheme||"wss"===d.scheme);d=new P(d.bd);e=d.toString();var f;!(f=!q(c.host)||0===c.host.length||!eg(c.lc))&&(f=0!==e.length)&&(e&&(e=e.replace(/^\/*\.info(\/|$)/,"/")),f=!(q(e)&&0!==e.length&&!cg.test(e)));if(f)throw Error(E("new Firebase",1,!1)+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');if(b)if(b instanceof aj)e=b;else if(q(b))e=aj.yb(),c.Rd=b;else throw Error("Expected a valid Firebase.Context for second argument to new Firebase()");
else e=aj.yb();f=c.toString();var g=z(e.sc,f);g||(g=new Ji(c,e.ag),e.sc[f]=g);c=g}Y.call(this,c,d,De,!1);this.then=void 0;this["catch"]=void 0}ka(X,Y);var fj=X,gj=["Firebase"],hj=n;gj[0]in hj||!hj.execScript||hj.execScript("var "+gj[0]);for(var ij;gj.length&&(ij=gj.shift());)!gj.length&&p(fj)?hj[ij]=fj:hj=hj[ij]?hj[ij]:hj[ij]={};X.goOffline=function(){D("Firebase.goOffline",0,0,arguments.length);aj.yb().Cb()};X.goOnline=function(){D("Firebase.goOnline",0,0,arguments.length);aj.yb().vc()};
X.enableLogging=od;X.ServerValue={TIMESTAMP:{".sv":"timestamp"}};X.SDK_VERSION=Eb;X.INTERNAL=U;X.Context=aj;X.TEST_ACCESS=Z;X.prototype.name=function(){S("Firebase.name() being deprecated. Please use Firebase.key() instead.");D("Firebase.name",0,0,arguments.length);return this.key()};X.prototype.name=X.prototype.name;X.prototype.key=function(){D("Firebase.key",0,0,arguments.length);return this.path.e()?null:me(this.path)};X.prototype.key=X.prototype.key;
X.prototype.o=function(a){D("Firebase.child",1,1,arguments.length);if(fa(a))a=String(a);else if(!(a instanceof P))if(null===K(this.path)){var b=a;b&&(b=b.replace(/^\/*\.info(\/|$)/,"/"));ng("Firebase.child",b)}else ng("Firebase.child",a);return new X(this.k,this.path.o(a))};X.prototype.child=X.prototype.o;X.prototype.parent=function(){D("Firebase.parent",0,0,arguments.length);var a=this.path.parent();return null===a?null:new X(this.k,a)};X.prototype.parent=X.prototype.parent;
X.prototype.root=function(){D("Firebase.ref",0,0,arguments.length);for(var a=this;null!==a.parent();)a=a.parent();return a};X.prototype.root=X.prototype.root;X.prototype.set=function(a,b){D("Firebase.set",1,2,arguments.length);og("Firebase.set",this.path);gg("Firebase.set",a,this.path,!1);F("Firebase.set",2,b,!0);var c=new B;this.k.Ob(this.path,a,null,C(c,b));return c.D};X.prototype.set=X.prototype.set;
X.prototype.update=function(a,b){D("Firebase.update",1,2,arguments.length);og("Firebase.update",this.path);if(da(a)){for(var c={},d=0;d<a.length;++d)c[""+d]=a[d];a=c;S("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")}jg("Firebase.update",a,this.path);F("Firebase.update",2,b,!0);c=new B;this.k.update(this.path,a,C(c,b));return c.D};
X.prototype.update=X.prototype.update;X.prototype.Ob=function(a,b,c){D("Firebase.setWithPriority",2,3,arguments.length);og("Firebase.setWithPriority",this.path);gg("Firebase.setWithPriority",a,this.path,!1);kg("Firebase.setWithPriority",2,b);F("Firebase.setWithPriority",3,c,!0);if(".length"===this.key()||".keys"===this.key())throw"Firebase.setWithPriority failed: "+this.key()+" is a read-only object.";var d=new B;this.k.Ob(this.path,a,b,C(d,c));return d.D};X.prototype.setWithPriority=X.prototype.Ob;
X.prototype.remove=function(a){D("Firebase.remove",0,1,arguments.length);og("Firebase.remove",this.path);F("Firebase.remove",1,a,!0);return this.set(null,a)};X.prototype.remove=X.prototype.remove;
X.prototype.transaction=function(a,b,c){D("Firebase.transaction",1,3,arguments.length);og("Firebase.transaction",this.path);F("Firebase.transaction",1,a,!1);F("Firebase.transaction",2,b,!0);if(p(c)&&"boolean"!=typeof c)throw Error(E("Firebase.transaction",3,!0)+"must be a boolean.");if(".length"===this.key()||".keys"===this.key())throw"Firebase.transaction failed: "+this.key()+" is a read-only object.";"undefined"===typeof c&&(c=!0);var d=new B;r(b)&&Nb(d.D);Si(this.k,this.path,a,function(a,c,g){a?
d.reject(a):d.resolve(new ei(c,g));r(b)&&b(a,c,g)},c);return d.D};X.prototype.transaction=X.prototype.transaction;X.prototype.Zg=function(a,b){D("Firebase.setPriority",1,2,arguments.length);og("Firebase.setPriority",this.path);kg("Firebase.setPriority",1,a);F("Firebase.setPriority",2,b,!0);var c=new B;this.k.Ob(this.path.o(".priority"),a,null,C(c,b));return c.D};X.prototype.setPriority=X.prototype.Zg;
X.prototype.push=function(a,b){D("Firebase.push",0,2,arguments.length);og("Firebase.push",this.path);gg("Firebase.push",a,this.path,!0);F("Firebase.push",2,b,!0);var c=Li(this.k),d=hf(c),c=this.o(d);if(null!=a){var e=this,f=c.set(a,b).then(function(){return e.o(d)});c.then=u(f.then,f);c["catch"]=u(f.then,f,void 0);r(b)&&Nb(f)}return c};X.prototype.push=X.prototype.push;X.prototype.lb=function(){og("Firebase.onDisconnect",this.path);return new V(this.k,this.path)};X.prototype.onDisconnect=X.prototype.lb;
X.prototype.O=function(a,b,c){S("FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead.");D("Firebase.auth",1,3,arguments.length);pg("Firebase.auth",a);F("Firebase.auth",2,b,!0);F("Firebase.auth",3,b,!0);var d=new B;dh(this.k.O,a,{},{remember:"none"},C(d,b),c);return d.D};X.prototype.auth=X.prototype.O;X.prototype.je=function(a){D("Firebase.unauth",0,1,arguments.length);F("Firebase.unauth",1,a,!0);var b=new B;eh(this.k.O,C(b,a));return b.D};X.prototype.unauth=X.prototype.je;
X.prototype.Be=function(){D("Firebase.getAuth",0,0,arguments.length);return this.k.O.Be()};X.prototype.getAuth=X.prototype.Be;X.prototype.Ig=function(a,b){D("Firebase.onAuth",1,2,arguments.length);F("Firebase.onAuth",1,a,!1);Qb("Firebase.onAuth",2,b);this.k.O.Ib("auth_status",a,b)};X.prototype.onAuth=X.prototype.Ig;X.prototype.Hg=function(a,b){D("Firebase.offAuth",1,2,arguments.length);F("Firebase.offAuth",1,a,!1);Qb("Firebase.offAuth",2,b);this.k.O.mc("auth_status",a,b)};X.prototype.offAuth=X.prototype.Hg;
X.prototype.hg=function(a,b,c){D("Firebase.authWithCustomToken",1,3,arguments.length);2===arguments.length&&Hb(b)&&(c=b,b=void 0);pg("Firebase.authWithCustomToken",a);F("Firebase.authWithCustomToken",2,b,!0);sg("Firebase.authWithCustomToken",3,c,!0);var d=new B;dh(this.k.O,a,{},c||{},C(d,b));return d.D};X.prototype.authWithCustomToken=X.prototype.hg;
X.prototype.ig=function(a,b,c){D("Firebase.authWithOAuthPopup",1,3,arguments.length);2===arguments.length&&Hb(b)&&(c=b,b=void 0);rg("Firebase.authWithOAuthPopup",a);F("Firebase.authWithOAuthPopup",2,b,!0);sg("Firebase.authWithOAuthPopup",3,c,!0);var d=new B;ih(this.k.O,a,c,C(d,b));return d.D};X.prototype.authWithOAuthPopup=X.prototype.ig;
X.prototype.jg=function(a,b,c){D("Firebase.authWithOAuthRedirect",1,3,arguments.length);2===arguments.length&&Hb(b)&&(c=b,b=void 0);rg("Firebase.authWithOAuthRedirect",a);F("Firebase.authWithOAuthRedirect",2,b,!1);sg("Firebase.authWithOAuthRedirect",3,c,!0);var d=new B,e=this.k.O,f=c,g=C(d,b);gh(e);var k=[Qg],f=Ag(f);"anonymous"===a||"firebase"===a?T(g,Sg("TRANSPORT_UNAVAILABLE")):(cd.set("redirect_client_options",f.qd),hh(e,k,"/auth/"+a,f,g));return d.D};X.prototype.authWithOAuthRedirect=X.prototype.jg;
X.prototype.kg=function(a,b,c,d){D("Firebase.authWithOAuthToken",2,4,arguments.length);3===arguments.length&&Hb(c)&&(d=c,c=void 0);rg("Firebase.authWithOAuthToken",a);F("Firebase.authWithOAuthToken",3,c,!0);sg("Firebase.authWithOAuthToken",4,d,!0);var e=new B;q(b)?(qg("Firebase.authWithOAuthToken",2,b),fh(this.k.O,a+"/token",{access_token:b},d,C(e,c))):(sg("Firebase.authWithOAuthToken",2,b,!1),fh(this.k.O,a+"/token",b,d,C(e,c)));return e.D};X.prototype.authWithOAuthToken=X.prototype.kg;
X.prototype.gg=function(a,b){D("Firebase.authAnonymously",0,2,arguments.length);1===arguments.length&&Hb(a)&&(b=a,a=void 0);F("Firebase.authAnonymously",1,a,!0);sg("Firebase.authAnonymously",2,b,!0);var c=new B;fh(this.k.O,"anonymous",{},b,C(c,a));return c.D};X.prototype.authAnonymously=X.prototype.gg;
X.prototype.lg=function(a,b,c){D("Firebase.authWithPassword",1,3,arguments.length);2===arguments.length&&Hb(b)&&(c=b,b=void 0);sg("Firebase.authWithPassword",1,a,!1);tg("Firebase.authWithPassword",a,"email");tg("Firebase.authWithPassword",a,"password");F("Firebase.authWithPassword",2,b,!0);sg("Firebase.authWithPassword",3,c,!0);var d=new B;fh(this.k.O,"password",a,c,C(d,b));return d.D};X.prototype.authWithPassword=X.prototype.lg;
X.prototype.ve=function(a,b){D("Firebase.createUser",1,2,arguments.length);sg("Firebase.createUser",1,a,!1);tg("Firebase.createUser",a,"email");tg("Firebase.createUser",a,"password");F("Firebase.createUser",2,b,!0);var c=new B;this.k.O.ve(a,C(c,b));return c.D};X.prototype.createUser=X.prototype.ve;
X.prototype.Xe=function(a,b){D("Firebase.removeUser",1,2,arguments.length);sg("Firebase.removeUser",1,a,!1);tg("Firebase.removeUser",a,"email");tg("Firebase.removeUser",a,"password");F("Firebase.removeUser",2,b,!0);var c=new B;this.k.O.Xe(a,C(c,b));return c.D};X.prototype.removeUser=X.prototype.Xe;
X.prototype.se=function(a,b){D("Firebase.changePassword",1,2,arguments.length);sg("Firebase.changePassword",1,a,!1);tg("Firebase.changePassword",a,"email");tg("Firebase.changePassword",a,"oldPassword");tg("Firebase.changePassword",a,"newPassword");F("Firebase.changePassword",2,b,!0);var c=new B;this.k.O.se(a,C(c,b));return c.D};X.prototype.changePassword=X.prototype.se;
X.prototype.re=function(a,b){D("Firebase.changeEmail",1,2,arguments.length);sg("Firebase.changeEmail",1,a,!1);tg("Firebase.changeEmail",a,"oldEmail");tg("Firebase.changeEmail",a,"newEmail");tg("Firebase.changeEmail",a,"password");F("Firebase.changeEmail",2,b,!0);var c=new B;this.k.O.re(a,C(c,b));return c.D};X.prototype.changeEmail=X.prototype.re;
X.prototype.Ze=function(a,b){D("Firebase.resetPassword",1,2,arguments.length);sg("Firebase.resetPassword",1,a,!1);tg("Firebase.resetPassword",a,"email");F("Firebase.resetPassword",2,b,!0);var c=new B;this.k.O.Ze(a,C(c,b));return c.D};X.prototype.resetPassword=X.prototype.Ze;})();

module.exports = Firebase;

},{}],11:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],12:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],13:[function(require,module,exports){
"use strict";

var os = require("os");
var convertSourceMap = require("convert-source-map");
var SourceMapConsumer = require("source-map").SourceMapConsumer;
var SourceMapGenerator = require("source-map").SourceMapGenerator;
var stableSort = require("stable");

function SourceMapper(src, nodePositions, fragments, inFile, sourceRoot) {
    this.generator = new SourceMapGenerator({ sourceRoot: sourceRoot });
    this.src = src;
    // stableSort does not mutate input array so no need to copy it
    this.nodePositions = stableSort(nodePositions, compareLoc);
    this.fragments = stableSort(fragments, function(a, b) { return a.start - b.start });
    this.inFile = inFile;

    this.generator.setSourceContent(this.inFile, src);
}

SourceMapper.prototype.calculateMappings = function() {
    var self = this;

    // These offsets represent the difference in coordinates between a node in the source
    // and the corresponding position in the output.
    var lineOffset = 0;
    var columnOffset = 0;

    // Since the column position resets to zero after each newline, we have to keep track
    // of the current line that columnOffset refers to in order to know whether to reset it
    var currentLine = 0;

    var frag = 0;
    var pos = 0;

    while (pos < self.nodePositions.length) {
        while (frag < self.fragments.length &&
            compareLoc(self.fragments[frag].loc.start, self.nodePositions[pos]) < 1) {

            var fragmentLines = self.fragments[frag].str.split("\n");
            var addedNewlines = fragmentLines.length - 1;

            var replacedLines = self.fragments[frag].loc.end.line - self.fragments[frag].loc.start.line;
            var replacedColumns = self.fragments[frag].loc.end.column - self.fragments[frag].loc.start.column;

            // If there were any lines added by the fragment string, the line offset should increase;
            // If there were any lines removed by the fragment replacement then the line offset should decrease
            lineOffset = lineOffset + addedNewlines - replacedLines;

            // The column position needs to reset after each newline.  So if the fragment added any
            // newlines then the column offset is the difference between the column of the last line of
            // the fragment, and the column of the end of the replaced section of the source.
            // Otherwise we increment or decrement the column offset just like how the line offset works.
            // Note that "replacedColumns" might be negative in some cases (if the beginning of the source
            // was further right than the end due to a newline); the math still works out.
            columnOffset = fragmentLines.length > 1 ?
                fragmentLines[fragmentLines.length - 1].length - self.fragments[frag].loc.end.column :
                columnOffset + self.fragments[frag].str.length - replacedColumns;

            currentLine = self.fragments[frag].loc.end.line;

            // Skip creating mappings for any source nodes that were replaced by this fragment (and are thus
            // no longer a part of the output)
            while (pos < self.nodePositions.length &&
                compareLoc(self.fragments[frag].loc.end, self.nodePositions[pos]) > 0) {
                ++pos;
            }

            ++frag;
        }

        if (pos < self.nodePositions.length) {
            if (currentLine < self.nodePositions[pos].line)
                columnOffset = 0;
            self.addMapping(self.nodePositions[pos], {
                line: self.nodePositions[pos].line + lineOffset,
                column: self.nodePositions[pos].column + columnOffset
            });
            ++pos;
        }
    }
}

SourceMapper.prototype.addMapping = function(input, output) {
    this.generator.addMapping({
        source: this.inFile,
        original: input,
        generated: output
    });
}

SourceMapper.prototype.applySourceMap = function (consumer) {
    this.generator.applySourceMap(consumer);
}

SourceMapper.prototype.generate = function () {
    return this.generator.toString();
}

function compareLoc(a, b) {
    return (a.line - b.line) || (a.column - b.column);
}

module.exports = function generateSourcemap(result, src, nodePositions, fragments, mapOpts) {
    var existingMap = convertSourceMap.fromSource(src);
    var existingMapObject = existingMap && existingMap.toObject();
    var inFile = (existingMapObject && existingMapObject.file) || mapOpts.inFile || "source.js";
    var sourceRoot = (existingMapObject && existingMapObject.sourceRoot) || mapOpts.sourceRoot;
    src = convertSourceMap.removeMapFileComments(src);

    var mapper = new SourceMapper(src, nodePositions, fragments, inFile, sourceRoot);
    mapper.calculateMappings();

    if (mapOpts.inline) {
        if (existingMapObject)
            mapper.applySourceMap(new SourceMapConsumer(existingMapObject));

        result.src = convertSourceMap.removeMapFileComments(result.src) +
            os.EOL +
            convertSourceMap.fromJSON(mapper.generate()).toComment();
    } else {
        result.map = mapper.generate();
    }
}

},{"convert-source-map":9,"os":22,"source-map":37,"stable":38}],14:[function(require,module,exports){
// lut.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>

"use strict";

var assert = require("assert");
var traverse = require("ordered-ast-traverse");
var is = require("simple-is");

module.exports = Lut;

function Lut(ast, src) {
    assert(this instanceof Lut);

    var sparseBegins = new Array(src.length);
    var begins = [];
    var sparseEnds = new Array(src.length);
    var ends = [];
    var p = 0;
    var t0 = Date.now();
    traverse(ast, {pre: function(node) {
        //        assert (node.range[0] >= p);
        if (node.type === "Program") {
            return;
        }
        p = node.range[0];
        if (!sparseBegins[p]) {
            sparseBegins[p] = node;
        }
        p = node.range[1];
        if (!sparseEnds[p]) {
            sparseEnds[p] = node;
        }
    }});
    for (var i in sparseBegins) {
        begins.push(sparseBegins[i]);
    }
    for (var i$0 in sparseEnds) {
        ends.push(sparseEnds[i$0]);
    }
    var t1 = Date.now();
    //    console.error(t1-t0)

    // begins and ends are compact arrays with nodes,
    // sorted on node.range[0/1] (unique)
    this.begins = begins;
    this.ends = ends;
}

Lut.prototype.findNodeFromPos = findNodeFromPos;
Lut.prototype.findNodeBeforePos = findNodeBeforePos;

// binary search lut to find node beginning at pos
// or as close after pos as possible. null if none
function findNodeFromPos(pos) {
    var lut = this.begins;
    assert(is.finitenumber(pos) && pos >= 0);

    var left = 0;
    var right = lut.length - 1;
    while (left < right) {
        var mid = Math.floor((left + right) / 2);
        assert(mid >= 0 && mid < lut.length);
        if (pos > lut[mid].range[0]) {
            left = mid + 1;
        }
        else {
            right = mid;
        }
    }
    if (left > right) {
        assert(last(lut).range[0] < pos);
        return null;
    }

    var found = left;
    var foundPos = lut[found].range[0];
    assert(foundPos >= pos);
    if (found >= 1) {
        var prevPos = lut[found - 1].range[0];
        assert(prevPos < pos);
    }

    return lut[found];
}

// binary search lut to find node ending (as in range[1]
// at or before pos. null if none
function findNodeBeforePos(pos) {
    var lut = this.ends;
    assert(is.finitenumber(pos) && pos >= 0);

    var left = 0;
    var right = lut.length - 1;
    while (left < right) {
        var mid = Math.ceil((left + right) / 2);
        assert(mid >= 0 && mid < lut.length);
        if (pos < lut[mid].range[1]) {
            right = mid - 1;
        }
        else {
            left = mid;
        }
    }
    if (left > right) {
        assert(lut[0].range[1] > pos);
        return null;
    }

    var found = left;
    var foundPos = lut[found].range[1];
    if(foundPos > pos) {
        return null;
    }
    if (found <= lut.length - 2) {
        var nextPos = lut[found + 1].range[1];
        assert(nextPos > pos);
    }

    return lut[found];
}

function last(arr) {
    return arr[arr.length - 1];
}

},{"assert":4,"ordered-ast-traverse":20,"simple-is":26}],15:[function(require,module,exports){
// ng-annotate-main.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>

"use strict";
var fmt = require("simple-fmt");
var is = require("simple-is");
var alter = require("alter");
var traverse = require("ordered-ast-traverse");
var EOL = require("os").EOL;
var assert = require("assert");
var ngInject = require("./nginject");
var generateSourcemap = require("./generate-sourcemap");
var Lut = require("./lut");
var scopeTools = require("./scopetools");
var stringmap = require("stringmap");
var optionalAngularDashboardFramework = require("./optionals/angular-dashboard-framework");
var require_acorn_t0 = Date.now();
var parser = require("acorn").parse;
var require_acorn_t1 = Date.now();

var chainedRouteProvider = 1;
var chainedUrlRouterProvider = 2;
var chainedStateProvider = 3;
var chainedRegular = 4;

function match(node, ctx, matchPlugins) {
    var isMethodCall = (
        node.type === "CallExpression" &&
            node.callee.type === "MemberExpression" &&
            node.callee.computed === false
        );

    // matchInjectorInvoke must happen before matchRegular
    // to prevent false positive ($injector.invoke() outside module)
    // matchProvide must happen before matchRegular
    // to prevent regular from matching it as a short-form
    var matchMethodCalls = (isMethodCall &&
        (matchInjectorInvoke(node) || matchProvide(node, ctx) || matchRegular(node, ctx) || matchNgRoute(node) || matchMaterialShowModalOpen(node) || matchNgUi(node) || matchHttpProvider(node) || matchControllerProvider(node)));

    return matchMethodCalls ||
        (matchPlugins && matchPlugins(node)) ||
        matchDirectiveReturnObject(node) ||
        matchProviderGet(node);
}

function matchMaterialShowModalOpen(node) {
    // $mdDialog.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});
    // $mdToast.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});
    // $mdBottomSheet.show({.. controller: fn, resolve: {f: function($scope) {}, ..}});
    // $modal.open({.. controller: fn, resolve: {f: function($scope) {}, ..}});

    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    var method = callee.property; // identifier
    var args = node.arguments;

    if (obj.type === "Identifier" &&
        ((is.someof(obj.name, ["$modal", "$uibModal"]) && method.name === "open") || (is.someof(obj.name, ["$mdDialog", "$mdToast", "$mdBottomSheet"]) && method.name === "show")) &&
        args.length === 1 && args[0].type === "ObjectExpression") {
        var props = args[0].properties;
        var res = [matchProp("controller", props)];
        res.push.apply(res, matchResolve(props));
        return res.filter(Boolean);
    }
    return false;
}

function matchDirectiveReturnObject(node) {
    // only matches inside directives
    // return { .. controller: function($scope, $timeout), ...}

    return limit("directive", node.type === "ReturnStatement" &&
        node.argument && node.argument.type === "ObjectExpression" &&
        matchProp("controller", node.argument.properties));
}

function limit(name, node) {
    if (node && !node.$limitToMethodName) {
        node.$limitToMethodName = name;
    }
    return node;
}

function matchProviderGet(node) {
    // only matches inside providers
    // (this|self|that).$get = function($scope, $timeout)
    // { ... $get: function($scope, $timeout), ...}
    var memberExpr;
    var self;
    return limit("provider", (node.type === "AssignmentExpression" && (memberExpr = node.left).type === "MemberExpression" &&
        memberExpr.property.name === "$get" &&
        ((self = memberExpr.object).type === "ThisExpression" || (self.type === "Identifier" && is.someof(self.name, ["self", "that"]))) &&
        node.right) ||
        (node.type === "ObjectExpression" && matchProp("$get", node.properties)));
}

function matchNgRoute(node) {
    // $routeProvider.when("path", {
    //   ...
    //   controller: function($scope) {},
    //   resolve: {f: function($scope) {}, ..}
    // })

    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    if (!(obj.$chained === chainedRouteProvider || (obj.type === "Identifier" && obj.name === "$routeProvider"))) {
        return false;
    }
    node.$chained = chainedRouteProvider;

    var method = callee.property; // identifier
    if (method.name !== "when") {
        return false;
    }

    var args = node.arguments;
    if (args.length !== 2) {
        return false;
    }
    var configArg = last(args)
    if (configArg.type !== "ObjectExpression") {
        return false;
    }

    var props = configArg.properties;
    var res = [
        matchProp("controller", props)
    ];
    // {resolve: ..}
    res.push.apply(res, matchResolve(props));

    var filteredRes = res.filter(Boolean);
    return (filteredRes.length === 0 ? false : filteredRes);
}

function matchNgUi(node) {
    // $stateProvider.state("myState", {
    //     ...
    //     controller: function($scope)
    //     controllerProvider: function($scope)
    //     templateProvider: function($scope)
    //     onEnter: function($scope)
    //     onExit: function($scope)
    // });
    // $stateProvider.state("myState", {... resolve: {f: function($scope) {}, ..} ..})
    // $stateProvider.state("myState", {... params: {params: {simple: function($scope) {}, inValue: { value: function($scope) {} }} ..})
    // $stateProvider.state("myState", {... views: {... somename: {... controller: fn, controllerProvider: fn, templateProvider: fn, resolve: {f: fn}}}})
    //
    // stateHelperProvider.setNestedState({ sameasregularstate, children: [sameasregularstate, ..]})
    // stateHelperProvider.setNestedState({ sameasregularstate, children: [sameasregularstate, ..]}, true)
    //
    // $urlRouterProvider.when(.., function($scope) {})
    //
    // $modal.open see matchMaterialShowModalOpen

    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    var method = callee.property; // identifier
    var args = node.arguments;

    // shortcut for $urlRouterProvider.when(.., function($scope) {})
    if (obj.$chained === chainedUrlRouterProvider || (obj.type === "Identifier" && obj.name === "$urlRouterProvider")) {
        node.$chained = chainedUrlRouterProvider;

        if (method.name === "when" && args.length >= 1) {
            return last(args);
        }
        return false;
    }

    // everything below is for $stateProvider and stateHelperProvider alone
    if (!(obj.$chained === chainedStateProvider || (obj.type === "Identifier" && is.someof(obj.name, ["$stateProvider", "stateHelperProvider"])))) {
        return false;
    }
    node.$chained = chainedStateProvider;

    if (is.noneof(method.name, ["state", "setNestedState"])) {
        return false;
    }

    // $stateProvider.state({ ... }) and $stateProvider.state("name", { ... })
    // stateHelperProvider.setNestedState({ .. }) and stateHelperProvider.setNestedState({ .. }, true)
    if (!(args.length >= 1 && args.length <= 2)) {
        return false;
    }

    var configArg = (method.name === "state" ? last(args) : args[0]);

    var res = [];

    recursiveMatch(configArg);

    var filteredRes = res.filter(Boolean);
    return (filteredRes.length === 0 ? false : filteredRes);


    function recursiveMatch(objectExpressionNode) {
        if (!objectExpressionNode || objectExpressionNode.type !== "ObjectExpression") {
            return false;
        }

        var properties = objectExpressionNode.properties;

        matchStateProps(properties, res);

        var childrenArrayExpression = matchProp("children", properties);
        var children = childrenArrayExpression && childrenArrayExpression.elements;

        if (!children) {
            return;
        }
        children.forEach(recursiveMatch);
    }

    function matchStateProps(props, res) {
        var simple = [
            matchProp("controller", props),
            matchProp("controllerProvider", props),
            matchProp("templateProvider", props),
            matchProp("onEnter", props),
            matchProp("onExit", props),
        ];
        res.push.apply(res, simple);

        // {resolve: ..}
        res.push.apply(res, matchResolve(props));

        // {params: {simple: function($scope) {}, inValue: { value: function($scope) {} }}
        var a = matchProp("params", props);
        if (a && a.type === "ObjectExpression") {
            a.properties.forEach(function(prop) {
                if (prop.value.type === "ObjectExpression") {
                    res.push(matchProp("value", prop.value.properties));
                } else {
                    res.push(prop.value);
                }
            });
        }

        // {view: ...}
        var viewObject = matchProp("views", props);
        if (viewObject && viewObject.type === "ObjectExpression") {
            viewObject.properties.forEach(function(prop) {
                if (prop.value.type === "ObjectExpression") {
                    res.push(matchProp("controller", prop.value.properties));
                    res.push(matchProp("controllerProvider", prop.value.properties));
                    res.push(matchProp("templateProvider", prop.value.properties));
                    res.push.apply(res, matchResolve(prop.value.properties));
                }
            });
        }
    }
}

function matchInjectorInvoke(node) {
    // $injector.invoke(function($compile) { ... });

    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    var method = callee.property; // identifier

    return method.name === "invoke" &&
        obj.type === "Identifier" && obj.name === "$injector" &&
        node.arguments.length >= 1 && node.arguments;
}

function matchHttpProvider(node) {
    // $httpProvider.interceptors.push(function($scope) {});
    // $httpProvider.responseInterceptors.push(function($scope) {});

    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    var method = callee.property; // identifier

    return (method.name === "push" &&
        obj.type === "MemberExpression" && !obj.computed &&
        obj.object.name === "$httpProvider" && is.someof(obj.property.name,  ["interceptors", "responseInterceptors"]) &&
        node.arguments.length >= 1 && node.arguments);
}

function matchControllerProvider(node) {
    // $controllerProvider.register("foo", function($scope) {});

    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    var method = callee.property; // identifier
    var args = node.arguments;

    var target = obj.type === "Identifier" && obj.name === "$controllerProvider" &&
        method.name === "register" && args.length === 2 && args[1];

    if (target) {
        target.$methodName = method.name;
    }
    return target;
}

function matchProvide(node, ctx) {
    // $provide.decorator("foo", function($scope) {});
    // $provide.service("foo", function($scope) {});
    // $provide.factory("foo", function($scope) {});
    // $provide.provider("foo", function($scope) {});

    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    var method = callee.property; // identifier
    var args = node.arguments;

    var target = obj.type === "Identifier" && obj.name === "$provide" &&
        is.someof(method.name, ["decorator", "service", "factory", "provider"]) &&
        args.length === 2 && args[1];

    if (target) {
        target.$methodName = method.name;

        if (ctx.rename) {
            // for eventual rename purposes
            return args;
        }
    }
    return target;
}

function matchRegular(node, ctx) {
    // we already know that node is a (non-computed) method call
    var callee = node.callee;
    var obj = callee.object; // identifier or expression
    var method = callee.property; // identifier

    // short-cut implicit config special case:
    // angular.module("MyMod", function(a) {})
    if (obj.name === "angular" && method.name === "module") {
        var args$0 = node.arguments;
        if (args$0.length >= 2) {
            node.$chained = chainedRegular;
            return last(args$0);
        }
    }

    // hardcoded exception: foo.decorator is generally considered a short-form
    // declaration but $stateProvider.decorator is not. see https://github.com/olov/ng-annotate/issues/82
    if (obj.name === "$stateProvider" && method.name === "decorator") {
        return false;
    }

    var matchAngularModule = (obj.$chained === chainedRegular || isReDef(obj, ctx) || isLongDef(obj)) &&
        is.someof(method.name, ["provider", "value", "constant", "bootstrap", "config", "factory", "directive", "filter", "run", "controller", "service", "animation", "invoke", "store", "decorator", "component"]);
    if (!matchAngularModule) {
        return false;
    }
    node.$chained = chainedRegular;

    if (is.someof(method.name, ["value", "constant", "bootstrap"])) {
        return false; // affects matchAngularModule because of chaining
    }

    var args = node.arguments;
    var target = (is.someof(method.name, ["config", "run"]) ?
        args.length === 1 && args[0] :
        args.length === 2 && args[0].type === "Literal" && is.string(args[0].value) && args[1]);

    if (method.name === "component") {
        var controllerProp = (target && target.type === "ObjectExpression" && matchProp("controller", target.properties));
        if (!controllerProp) {
            return false;
        }
        target = controllerProp;
    }

    if (target) {
        target.$methodName = method.name;
    }

    if (ctx.rename && args.length === 2 && target) {
        // for eventual rename purposes
        var somethingNameLiteral = args[0];
        return [somethingNameLiteral, target];
    }
    return target;
}

// matches with default regexp
//   *.controller("MyCtrl", function($scope, $timeout) {});
//   *.*.controller("MyCtrl", function($scope, $timeout) {});
// matches with --regexp "^require(.*)$"
//   require("app-module").controller("MyCtrl", function($scope) {});
function isReDef(node, ctx) {
    return ctx.re.test(ctx.srcForRange(node.range));
}

// Long form: angular.module(*).controller("MyCtrl", function($scope, $timeout) {});
function isLongDef(node) {
    return node.callee &&
        node.callee.object && node.callee.object.name === "angular" &&
        node.callee.property && node.callee.property.name === "module";
}

function last(arr) {
    return arr[arr.length - 1];
}

function matchProp(name, props) {
    for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if ((prop.key.type === "Identifier" && prop.key.name === name) ||
            (prop.key.type === "Literal" && prop.key.value === name)) {
            return prop.value; // FunctionExpression or ArrayExpression
        }
    }
    return null;
}

function matchResolve(props) {
    var resolveObject = matchProp("resolve", props);
    if (resolveObject && resolveObject.type === "ObjectExpression") {
        return resolveObject.properties.map(function(prop) {
            return prop.value;
        });
    }
    return [];
};

function renamedString(ctx, originalString) {
    if (ctx.rename) {
        return ctx.rename.get(originalString) || originalString;
    }
    return originalString;
}

function stringify(ctx, arr, quot) {
    return "[" + arr.map(function(arg) {
        return quot + renamedString(ctx, arg.name) + quot;
    }).join(", ") + "]";
}

function parseExpressionOfType(str, type) {
    var node = parser(str).body[0].expression;
    assert(node.type === type);
    return node;
}

// stand-in for not having a jsshaper-style ref's
function replaceNodeWith(node, newNode) {
    var done = false;
    var parent = node.$parent;
    var keys = Object.keys(parent);
    keys.forEach(function(key) {
        if (parent[key] === node) {
            parent[key] = newNode;
            done = true;
        }
    });

    if (done) {
        return;
    }

    // second pass, now check arrays
    keys.forEach(function(key) {
        if (Array.isArray(parent[key])) {
            var arr = parent[key];
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] === node) {
                    arr[i] = newNode;
                    done = true;
                }
            }
        }
    });

    assert(done);
}

function insertArray(ctx, functionExpression, fragments, quot) {
    var args = stringify(ctx, functionExpression.params, quot);

    fragments.push({
        start: functionExpression.range[0],
        end: functionExpression.range[0],
        str: args.slice(0, -1) + ", ",
        loc: {
            start: functionExpression.loc.start,
            end: functionExpression.loc.start
        }
    });
    fragments.push({
        start: functionExpression.range[1],
        end: functionExpression.range[1],
        str: "]",
        loc: {
            start: functionExpression.loc.end,
            end: functionExpression.loc.end
        }
    });
}

function replaceArray(ctx, array, fragments, quot) {
    var functionExpression = last(array.elements);

    if (functionExpression.params.length === 0) {
        return removeArray(array, fragments);
    }

    var args = stringify(ctx, functionExpression.params, quot);
    fragments.push({
        start: array.range[0],
        end: functionExpression.range[0],
        str: args.slice(0, -1) + ", ",
        loc: {
            start: array.loc.start,
            end: functionExpression.loc.start
        }
    });
}

function removeArray(array, fragments) {
    var functionExpression = last(array.elements);

    fragments.push({
        start: array.range[0],
        end: functionExpression.range[0],
        str: "",
        loc: {
            start: array.loc.start,
            end: functionExpression.loc.start
        }
    });
    fragments.push({
        start: functionExpression.range[1],
        end: array.range[1],
        str: "",
        loc: {
            start: functionExpression.loc.end,
            end: array.loc.end
        }
    });
}

function renameProviderDeclarationSite(ctx, literalNode, fragments) {
    fragments.push({
        start: literalNode.range[0] + 1,
        end: literalNode.range[1] - 1,
        str: renamedString(ctx, literalNode.value),
        loc: {
            start: {
                line: literalNode.loc.start.line,
                column: literalNode.loc.start.column + 1
            }, end: {
                line: literalNode.loc.end.line,
                column: literalNode.loc.end.column - 1
            }
        }
    });
}

function judgeSuspects(ctx) {
    var mode = ctx.mode;
    var fragments = ctx.fragments;
    var quot = ctx.quot;
    var blocked = ctx.blocked;

    var suspects = makeUnique(ctx.suspects, 1);

    for (var n = 0; n < 42; n++) {
        // could be while(true), above is just a safety-net
        // in practice it will loop just a couple of times
        propagateModuleContextAndMethodName(suspects);
        if (!setChainedAndMethodNameThroughIifesAndReferences(suspects)) {
            break;
        }
    }

    // create final suspects by jumping, following, uniq'ing, blocking
    var finalSuspects = makeUnique(suspects.map(function(target) {
        var jumped = jumpOverIife(target);
        var jumpedAndFollowed = followReference(jumped) || jumped;

        if (target.$limitToMethodName && target.$limitToMethodName !== "*never*" && findOuterMethodName(target) !== target.$limitToMethodName) {
            return null;
        }

        if (blocked.indexOf(jumpedAndFollowed) >= 0) {
            return null;
        }

        return jumpedAndFollowed;
    }).filter(Boolean), 2);

    finalSuspects.forEach(function(target) {
        if (target.$chained !== chainedRegular) {
            return;
        }

        if (mode === "rebuild" && isAnnotatedArray(target)) {
            replaceArray(ctx, target, fragments, quot);
        } else if (mode === "remove" && isAnnotatedArray(target)) {
            removeArray(target, fragments);
        } else if (is.someof(mode, ["add", "rebuild"]) && isFunctionExpressionWithArgs(target)) {
            insertArray(ctx, target, fragments, quot);
        } else if (isGenericProviderName(target)) {
            renameProviderDeclarationSite(ctx, target, fragments);
        } else {
            // if it's not array or function-expression, then it's a candidate for foo.$inject = [..]
            judgeInjectArraySuspect(target, ctx);
        }
    });


    function propagateModuleContextAndMethodName(suspects) {
        suspects.forEach(function(target) {
            if (target.$chained !== chainedRegular && isInsideModuleContext(target)) {
                target.$chained = chainedRegular;
            }

            if (!target.$methodName) {
                var methodName = findOuterMethodName(target);
                if (methodName) {
                    target.$methodName = methodName;
                }
            }
        });
    }

    function findOuterMethodName(node) {
        for (; node && !node.$methodName; node = node.$parent) {
        }
        return node ? node.$methodName : null;
    }

    function setChainedAndMethodNameThroughIifesAndReferences(suspects) {
        var modified = false;
        suspects.forEach(function(target) {
            var jumped = jumpOverIife(target);
            if (jumped !== target) { // we did skip an IIFE
                if (target.$chained === chainedRegular && jumped.$chained !== chainedRegular) {
                    modified = true;
                    jumped.$chained = chainedRegular;
                }
                if (target.$methodName && !jumped.$methodName) {
                    modified = true;
                    jumped.$methodName = target.$methodName;
                }
            }

            var jumpedAndFollowed = followReference(jumped) || jumped;
            if (jumpedAndFollowed !== jumped) { // we did follow a reference
                if (jumped.$chained === chainedRegular && jumpedAndFollowed.$chained !== chainedRegular) {
                    modified = true;
                    jumpedAndFollowed.$chained = chainedRegular;
                }
                if (jumped.$methodName && !jumpedAndFollowed.$methodName) {
                    modified = true;
                    jumpedAndFollowed.$methodName = jumped.$methodName;
                }
            }
        });
        return modified;
    }

    function isInsideModuleContext(node) {
        var $parent = node.$parent;
        for (; $parent && $parent.$chained !== chainedRegular; $parent = $parent.$parent) {
        }
        return Boolean($parent);
    }

    function makeUnique(suspects, val) {
        return suspects.filter(function(target) {
            if (target.$seen === val) {
                return false;
            }
            target.$seen = val;
            return true;
        });
    }
}

function followReference(node) {
    if (!scopeTools.isReference(node)) {
        return null;
    }

    var scope = node.$scope.lookup(node.name);
    if (!scope) {
        return null;
    }

    var parent = scope.getNode(node.name).$parent;
    var kind = scope.getKind(node.name);
    if (!parent) {
        return null;
    }
    var ptype = parent.type;

    if (is.someof(kind, ["const", "let", "var"])) {
        assert(ptype === "VariableDeclarator");
        // {type: "VariableDeclarator", id: {type: "Identifier", name: "foo"}, init: ..}
        return parent;
    } else if (kind === "fun") {
        assert(ptype === "FunctionDeclaration" || ptype === "FunctionExpression")
        // FunctionDeclaration is the common case, i.e.
        // function foo(a, b) {}

        // FunctionExpression is only applicable for cases similar to
        // var f = function asdf(a,b) { mymod.controller("asdf", asdf) };
        return parent;
    }

    // other kinds should not be handled ("param", "caught")

    return null;
}

// O(srclength) so should only be used for debugging purposes, else replace with lut
function posToLine(pos, src) {
    if (pos >= src.length) {
        pos = src.length - 1;
    }

    if (pos <= -1) {
        return -1;
    }

    var line = 1;
    for (var i = 0; i < pos; i++) {
        if (src[i] === "\n") {
            ++line;
        }
    }

    return line;
}

function firstNonPrologueStatement(body) {
    for (var i = 0; i < body.length; i++) {
        if (body[i].type !== "ExpressionStatement") {
            return body[i];
        }

        var expr = body[i].expression;
        var isStringLiteral = (expr.type === "Literal" && typeof expr.value === "string");
        if (!isStringLiteral) {
            return body[i];
        }
    }
    return null;
}

function judgeInjectArraySuspect(node, ctx) {
    if (node.type === "VariableDeclaration") {
        // suspect can only be a VariableDeclaration (statement) in case of
        // explicitly marked via /*@ngInject*/, not via references because
        // references follow to VariableDeclarator (child)

        // /*@ngInject*/ var foo = function($scope) {} and

        if (node.declarations.length !== 1) {
            // more than one declarator => exit
            return;
        }

        // one declarator => jump over declaration into declarator
        // rest of code will treat it as any (referenced) declarator
        node = node.declarations[0];
    }

    // onode is a top-level node (inside function block), later verified
    // node is inner match, descent in multiple steps
    var onode = null;
    var declaratorName = null;
    if (node.type === "VariableDeclarator") {
        onode = node.$parent;
        declaratorName = node.id.name;
        node = node.init; // var foo = ___;
    } else {
        onode = node;
    }

    // suspect must be inside of a block or at the top-level (i.e. inside of node.$parent.body[])
    if (!node || !onode.$parent || is.noneof(onode.$parent.type, ["Program", "BlockStatement"])) {
        return;
    }

    var insertPos = {
        pos: onode.range[1],
        loc: onode.loc.end
    };
    var isSemicolonTerminated = (ctx.src[insertPos.pos - 1] === ";");

    node = jumpOverIife(node);

    if (ctx.isFunctionExpressionWithArgs(node)) {
        // var x = 1, y = function(a,b) {}, z;

        assert(declaratorName);
        addRemoveInjectArray(
            node.params,
            isSemicolonTerminated ? insertPos : {
                pos: node.range[1],
                loc: node.loc.end
            },
            declaratorName);

    } else if (ctx.isFunctionDeclarationWithArgs(node)) {
        // /*@ngInject*/ function foo($scope) {}

        addRemoveInjectArray(
            node.params,
            insertPos,
            node.id.name);

    } else if (node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" &&
        ctx.isFunctionExpressionWithArgs(node.expression.right)) {
        // /*@ngInject*/ foo.bar[0] = function($scope) {}

        var name = ctx.srcForRange(node.expression.left.range);
        addRemoveInjectArray(
            node.expression.right.params,
            isSemicolonTerminated ? insertPos : {
                pos: node.expression.right.range[1],
                loc: node.expression.right.loc.end
            },
            name);

    } else if (node = followReference(node)) {
        // node was a reference and followed node now is either a
        // FunctionDeclaration or a VariableDeclarator
        // => recurse

        judgeInjectArraySuspect(node, ctx);
    }


    function getIndent(pos) {
        var src = ctx.src;
        var lineStart = src.lastIndexOf("\n", pos - 1) + 1;
        var i = lineStart;
        for (; src[i] === " " || src[i] === "\t"; i++) {
        }
        return src.slice(lineStart, i);
    }

    function addRemoveInjectArray(params, posAfterFunctionDeclaration, name) {
        // if an existing something.$inject = [..] exists then is will always be recycled when rebuilding

        var indent = getIndent(posAfterFunctionDeclaration.pos);

        var foundSuspectInBody = false;
        var existingExpressionStatementWithArray = null;
        var nodeAfterExtends = null;
        onode.$parent.body.forEach(function(bnode, idx) {
            if (bnode === onode) {
                foundSuspectInBody = true;
            }

            if (hasInjectArray(bnode)) {
                if (existingExpressionStatementWithArray) {
                    throw fmt("conflicting inject arrays at line {0} and {1}",
                        posToLine(existingExpressionStatementWithArray.range[0], ctx.src),
                        posToLine(bnode.range[0], ctx.src));
                }
                existingExpressionStatementWithArray = bnode;
            }

            var e;
            if (!nodeAfterExtends && !foundSuspectInBody && bnode.type === "ExpressionStatement" && (e = bnode.expression).type === "CallExpression" && e.callee.type === "Identifier" && e.callee.name === "__extends") {
                var nextStatement = onode.$parent.body[idx + 1];
                if (nextStatement) {
                    nodeAfterExtends = nextStatement;
                }
            }
        });
        assert(foundSuspectInBody);
        if (onode.type === "FunctionDeclaration") {
            if (!nodeAfterExtends) {
                nodeAfterExtends = firstNonPrologueStatement(onode.$parent.body);
            }
            if (nodeAfterExtends && !existingExpressionStatementWithArray) {
                posAfterFunctionDeclaration = skipPrevNewline(nodeAfterExtends.range[0], nodeAfterExtends.loc.start);
            }
        }

        function hasInjectArray(node) {
            var lvalue;
            var assignment;
            return (node && node.type === "ExpressionStatement" && (assignment = node.expression).type === "AssignmentExpression" &&
                assignment.operator === "=" &&
                (lvalue = assignment.left).type === "MemberExpression" &&
                ((lvalue.computed === false && ctx.srcForRange(lvalue.object.range) === name && lvalue.property.name === "$inject") ||
                    (lvalue.computed === true && ctx.srcForRange(lvalue.object.range) === name && lvalue.property.type === "Literal" && lvalue.property.value === "$inject")));
        }

        function skipPrevNewline(pos, loc) {
            var prevLF = ctx.src.lastIndexOf("\n", pos);
            if (prevLF === -1) {
                return { pos: pos, loc: loc };
            }
            if (prevLF >= 1 && ctx.src[prevLF - 1] === "\r") {
                --prevLF;
            }

            if (/\S/g.test(ctx.src.slice(prevLF, pos - 1))) { // any non-whitespace chars between prev newline and pos?
                return { pos: pos, loc: loc };
            }

            return {
                pos: prevLF,
                loc: {
                    line: loc.line - 1,
                    column: prevLF - ctx.src.lastIndexOf("\n", prevLF) - 1,
                }
            };
        }

        if (ctx.mode === "rebuild" && existingExpressionStatementWithArray) {
            var strNoWhitespace = fmt("{2}.$inject = {3};", null, null, name, ctx.stringify(ctx, params, ctx.quot));
            ctx.fragments.push({
                start: existingExpressionStatementWithArray.range[0],
                end: existingExpressionStatementWithArray.range[1],
                str: strNoWhitespace,
                loc: {
                    start: existingExpressionStatementWithArray.loc.start,
                    end: existingExpressionStatementWithArray.loc.end
                }
            });
        } else if (ctx.mode === "remove" && existingExpressionStatementWithArray) {
            var start = skipPrevNewline(existingExpressionStatementWithArray.range[0], existingExpressionStatementWithArray.loc.start);
            ctx.fragments.push({
                start: start.pos,
                end: existingExpressionStatementWithArray.range[1],
                str: "",
                loc: {
                    start: start.loc,
                    end: existingExpressionStatementWithArray.loc.end
                }
            });
        } else if (is.someof(ctx.mode, ["add", "rebuild"]) && !existingExpressionStatementWithArray) {
            var str = fmt("{0}{1}{2}.$inject = {3};", EOL, indent, name, ctx.stringify(ctx, params, ctx.quot));
            ctx.fragments.push({
                start: posAfterFunctionDeclaration.pos,
                end: posAfterFunctionDeclaration.pos,
                str: str,
                loc: {
                    start: posAfterFunctionDeclaration.loc,
                    end: posAfterFunctionDeclaration.loc
                }
            });
        }
    }
}

function jumpOverIife(node) {
    var outerfn;
    if (!(node.type === "CallExpression" && (outerfn = node.callee).type === "FunctionExpression")) {
        return node;
    }

    var outerbody = outerfn.body.body;
    for (var i = 0; i < outerbody.length; i++) {
        var statement = outerbody[i];
        if (statement.type === "ReturnStatement") {
            return statement.argument;
        }
    }

    return node;
}

function addModuleContextDependentSuspect(target, ctx) {
    ctx.suspects.push(target);
}

function addModuleContextIndependentSuspect(target, ctx) {
    target.$chained = chainedRegular;
    ctx.suspects.push(target);
}

function isAnnotatedArray(node) {
    if (node.type !== "ArrayExpression") {
        return false;
    }
    var elements = node.elements;

    // last should be a function expression
    if (elements.length === 0 || last(elements).type !== "FunctionExpression") {
        return false;
    }

    // all but last should be string literals
    for (var i = 0; i < elements.length - 1; i++) {
        var n = elements[i];
        if (n.type !== "Literal" || !is.string(n.value)) {
            return false;
        }
    }

    return true;
}
function isFunctionExpressionWithArgs(node) {
    return node.type === "FunctionExpression" && node.params.length >= 1;
}
function isFunctionDeclarationWithArgs(node) {
    return node.type === "FunctionDeclaration" && node.params.length >= 1;
}
function isGenericProviderName(node) {
    return node.type === "Literal" && is.string(node.value);
}

function uniqifyFragments(fragments) {
    // must do in-place modification of ctx.fragments because shared reference

    var map = Object.create(null);
    for (var i = 0; i < fragments.length; i++) {
        var frag = fragments[i];
        var str = JSON.stringify({start: frag.start, end: frag.end, str: frag.str});
        if (map[str]) {
            fragments.splice(i, 1); // remove
            i--;
        } else {
            map[str] = true;
        }
    }
}

var allOptionals = {
    "angular-dashboard-framework": optionalAngularDashboardFramework,
};

module.exports = function ngAnnotate(src, options) {
    if (options.list) {
        return {
            list: Object.keys(allOptionals).sort(),
        };
    }

    var mode = (options.add && options.remove ? "rebuild" :
        options.remove ? "remove" :
            options.add ? "add" : null);

    if (!mode) {
        return {src: src};
    }

    var quot = options.single_quotes ? "'" : '"';
    var re = (options.regexp ? new RegExp(options.regexp) : /^[a-zA-Z0-9_\$\.\s]+$/);
    var rename = new stringmap();
    if (options.rename) {
        options.rename.forEach(function(value) {
            rename.set(value.from, value.to);
        });
    }
    var ast;
    var stats = {};

    // detect newline and override os.EOL
    var lf = src.lastIndexOf("\n");
    if (lf >= 1) {
        EOL = (src[lf - 1] === "\r" ? "\r\n" : "\n");
    }

    // [{type: "Block"|"Line", value: str, range: [from,to]}, ..]
    var comments = [];

    try {
        stats.parser_require_t0 = require_acorn_t0;
        stats.parser_require_t1 = require_acorn_t1;
        stats.parser_parse_t0 = Date.now();
        // acorn
        ast = parser(src, {
            ecmaVersion: 6,
            allowReserved: true,
            locations: true,
            ranges: true,
            onComment: comments,
        });
        stats.parser_parse_t1 = Date.now();
    } catch(e) {
        return {
            errors: ["error: couldn't process source due to parse error", e.message],
        };
    }

    // append a dummy-node to ast so that lut.findNodeFromPos(lastPos) returns something
    ast.body.push({
        type: "DebuggerStatement",
        range: [ast.range[1], ast.range[1]],
        loc: {
            start: ast.loc.end,
            end: ast.loc.end
        }
    });

    // all source modifications are built up as operations in the
    // fragments array, later sent to alter in one shot
    var fragments = [];

    // suspects is built up with suspect nodes by match.
    // A suspect node will get annotations added / removed if it
    // fulfills the arrayexpression or functionexpression look,
    // and if it is in the correct context (inside an angular
    // module definition)
    var suspects = [];

    // blocked is an array of blocked suspects. Any target node
    // (final, i.e. IIFE-jumped, reference-followed and such) included
    // in blocked will be ignored by judgeSuspects
    var blocked = [];

    // Position information for all nodes in the AST,
    // used for sourcemap generation
    var nodePositions = [];

    var lut = new Lut(ast, src);

    scopeTools.setupScopeAndReferences(ast);

    var ctx = {
        mode: mode,
        quot: quot,
        src: src,
        srcForRange: function(range) {
            return src.slice(range[0], range[1]);
        },
        re: re,
        rename: rename,
        comments: comments,
        fragments: fragments,
        suspects: suspects,
        blocked: blocked,
        lut: lut,
        isFunctionExpressionWithArgs: isFunctionExpressionWithArgs,
        isFunctionDeclarationWithArgs: isFunctionDeclarationWithArgs,
        isAnnotatedArray: isAnnotatedArray,
        addModuleContextDependentSuspect: addModuleContextDependentSuspect,
        addModuleContextIndependentSuspect: addModuleContextIndependentSuspect,
        stringify: stringify,
        nodePositions: nodePositions,
        matchResolve: matchResolve,
        matchProp: matchProp,
        last: last,
    };

    // setup optionals
    var optionals = options.enable || [];
    for (var i = 0; i < optionals.length; i++) {
        var optional = String(optionals[i]);
        if (!allOptionals.hasOwnProperty(optional)) {
            return {
                errors: ["error: found no optional named " + optional],
            };
        }
    }
    var optionalsPlugins = optionals.map(function(optional) {
        return allOptionals[optional];
    });

    var plugins = [].concat(optionalsPlugins, options.plugin || []);

    function matchPlugins(node, isMethodCall) {
        for (var i = 0; i < plugins.length; i++) {
            var res = plugins[i].match(node, isMethodCall);
            if (res) {
                return res;
            }
        }
        return false;
    }
    var matchPluginsOrNull = (plugins.length === 0 ? null : matchPlugins);

    ngInject.inspectComments(ctx);
    plugins.forEach(function(plugin) {
        plugin.init(ctx);
    });

    traverse(ast, {pre: function(node) {
        ngInject.inspectNode(node, ctx);

    }, post: function(node) {
        ctx.nodePositions.push(node.loc.start);
        var targets = match(node, ctx, matchPluginsOrNull);
        if (!targets) {
            return;
        }
        if (!is.array(targets)) {
            targets = [targets];
        }

        for (var i = 0; i < targets.length; i++) {
            addModuleContextDependentSuspect(targets[i], ctx);
        }
    }});

    try {
        judgeSuspects(ctx);
    } catch(e) {
        return {
            errors: ["error: " + e],
        };
    }

    uniqifyFragments(ctx.fragments);

    var out = alter(src, fragments);
    var result = {
        src: out,
        _stats: stats,
    };

    if (options.map) {
        if (typeof(options.map) !== 'object')
            options.map = {};
        stats.sourcemap_t0 = Date.now();
        generateSourcemap(result, src, nodePositions, fragments, options.map);
        stats.sourcemap_t1 = Date.now();
    }

    return result;
}

},{"./generate-sourcemap":13,"./lut":14,"./nginject":16,"./optionals/angular-dashboard-framework":17,"./scopetools":19,"acorn":1,"alter":2,"assert":4,"ordered-ast-traverse":20,"os":22,"simple-fmt":25,"simple-is":26,"stringmap":39}],16:[function(require,module,exports){
// nginject.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>

"use strict";

var is = require("simple-is");

module.exports = {
    inspectComments: inspectComments,
    inspectNode: inspectNode,
};

function inspectNode(node, ctx) {
    if (node.type === "CallExpression") {
        inspectCallExpression(node, ctx);
    } else if (node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
        inspectFunction(node, ctx);
    }
}

function inspectCallExpression(node, ctx) {
    var name = node.callee.name;
    if (node.callee.type === "Identifier" && (name === "ngInject" || name === "ngNoInject") && node.arguments.length === 1) {
        var block = (name === "ngNoInject");
        addSuspect(node.arguments[0], ctx, block);
    }
}

var ngAnnotatePrologueDirectives = ["ngInject", "ngNoInject"];

function inspectFunction(node, ctx) {
    var str = matchPrologueDirectives(ngAnnotatePrologueDirectives, node);
    if (!str) {
        return;
    }
    var block = (str === "ngNoInject");

    // now add the correct suspect

    // for function declarations, it is always the function declaration node itself
    if (node.type === "FunctionDeclaration") {
        addSuspect(node, ctx, block);
        return;
    }

    // node is a function expression below

    // case 1: a function expression which is the rhs of a variable declarator, such as
    // var f1 = function(a) {
    //     "ngInject"
    // };
    // in this case we can mark the declarator, same as saying var /*@ngInject*/ f1 = function(a) ..
    // or /*@ngInject*/ var f1 = function(a) ..
    // f1.$inject = ["a"]; will be added (or rebuilt/removed)
    if (node.$parent.type === "VariableDeclarator") {
        addSuspect(node.$parent, ctx, block);
        return;
    }

    // case 2: an anonymous function expression, such as
    // g(function(a) {
    //     "ngInject"
    // });
    //
    // the suspect is now its parent annotated array (if any), otherwise itself
    // there is a risk of false suspects here, in case the parent annotated array has nothing to do
    // with annotations. the risk should be very low and hopefully easy to workaround
    //
    // added/rebuilt/removed => g(["a", function(a) {
    //     "ngInject"
    // }]);
    var maybeArrayExpression = node.$parent;
    if (ctx.isAnnotatedArray(maybeArrayExpression)) {
        addSuspect(maybeArrayExpression, ctx, block);
    } else {
        addSuspect(node, ctx, block);
    }
}

function matchPrologueDirectives(prologueDirectives, node) {
    var body = node.body.body;

    var found = null;
    for (var i = 0; i < body.length; i++) {
        if (body[i].type !== "ExpressionStatement") {
            break;
        }

        var expr = body[i].expression;
        var isStringLiteral = (expr.type === "Literal" && typeof expr.value === "string");
        if (!isStringLiteral) {
            break;
        }

        if (prologueDirectives.indexOf(expr.value) >= 0) {
            found = expr.value;
            break;
        }
    }

    return found;
}

function inspectComments(ctx) {
    var comments = ctx.comments;
    for (var i = 0; i < comments.length; i++) {
        var comment = comments[i];
        var yesPos = comment.value.indexOf("@ngInject");
        var noPos = (yesPos === -1 ? comment.value.indexOf("@ngNoInject") : -1);
        if (yesPos === -1 && noPos === -1) {
            continue;
        }

        var target = ctx.lut.findNodeFromPos(comment.range[1]);
        if (!target) {
            continue;
        }

        addSuspect(target, ctx, noPos >= 0);
    }
}

function isStringArray(node) {
    if (node.type !== "ArrayExpression") {
        return false;
    }
    return node.elements.length >= 1 && node.elements.every(function(n) {
        return n.type === "Literal" && is.string(n.value);
    });
}

function findNextStatement(node) {
    var body = node.$parent.body;
    for (var i = 0; i < body.length; i++) {
        if (body[i] === node) {
            return body[i + 1] || null;
        }
    }
    return null;
}

function addSuspect(target, ctx, block) {
    if (target.type === "ExpressionStatement" && target.expression.type === "AssignmentExpression" && isStringArray(target.expression.right)) {
        // /*@ngInject*/
        // FooBar.$inject = ["$a", "$b"];
        // function FooBar($a, $b) {}
        var adjustedTarget = findNextStatement(target);
        if (adjustedTarget) {
            return addSuspect(adjustedTarget, ctx, block);
        }
    }

    if (target.type === "ObjectExpression") {
        // /*@ngInject*/ {f1: function(a), .., {f2: function(b)}}
        addObjectExpression(target, ctx);
    } else if (target.type === "AssignmentExpression" && target.right.type === "ObjectExpression") {
        // /*@ngInject*/ f(x.y = {f1: function(a), .., {f2: function(b)}})
        addObjectExpression(target.right, ctx);
    } else if (target.type === "ExpressionStatement" && target.expression.type === "AssignmentExpression" && target.expression.right.type === "ObjectExpression") {
        // /*@ngInject*/ x.y = {f1: function(a), .., {f2: function(b)}}
        addObjectExpression(target.expression.right, ctx);
    } else if (target.type === "VariableDeclaration" && target.declarations.length === 1 && target.declarations[0].init && target.declarations[0].init.type === "ObjectExpression") {
        // /*@ngInject*/ var x = {f1: function(a), .., {f2: function(b)}}
        addObjectExpression(target.declarations[0].init, ctx);
    } else if (target.type === "Property") {
        // {/*@ngInject*/ justthisone: function(a), ..}
        target.value.$limitToMethodName = "*never*";
        addOrBlock(target.value, ctx);
    } else {
        // /*@ngInject*/ function(a) {}
        target.$limitToMethodName = "*never*";
        addOrBlock(target, ctx);
    }


    function addObjectExpression(node, ctx) {
        nestedObjectValues(node).forEach(function(n) {
            n.$limitToMethodName = "*never*";
            addOrBlock(n, ctx);
        });
    }

    function addOrBlock(node, ctx) {
        if (block) {
            ctx.blocked.push(node);
        } else {
            ctx.addModuleContextIndependentSuspect(node, ctx)
        }
    }
}

function nestedObjectValues(node, res) {
    res = res || [];

    node.properties.forEach(function(prop) {
        var v = prop.value;
        if (is.someof(v.type, ["FunctionExpression", "ArrayExpression"])) {
            res.push(v);
        } else if (v.type === "ObjectExpression") {
            nestedObjectValues(v, res);
        }
    });

    return res;
}

},{"simple-is":26}],17:[function(require,module,exports){
"use strict";

var ctx = null;
module.exports = {
    init: function(_ctx) {
        ctx = _ctx;
    },

    match: function(node) {
        // dashboardProvider.widget("name", {
        //   ...
        //   controller: function($scope) {},
        //   resolve: {f: function($scope) {}, ..}
        // })

        var callee = node.callee;
        if (!callee) {
            return false;
        }

        var obj = callee.object;
        if (!obj) {
            return false;
        }

        // identifier or expression
        if (!(obj.$chained === 1 || (obj.type === "Identifier" && obj.name === "dashboardProvider"))) {
            return false;
        }

        node.$chained = 1;

        var method = callee.property; // identifier
        if (method.name !== "widget") {
            return false;
        }

        var args = node.arguments;
        if (args.length !== 2) {
            return false;
        }

        var configArg = ctx.last(args);
        if (configArg.type !== "ObjectExpression") {
            return false;
        }

        var props = configArg.properties;
        var res = [
            ctx.matchProp("controller", props)
        ];
        // {resolve: ..}
        res.push.apply(res, ctx.matchResolve(props));

        // edit: {controller: function(), resolve: {}, apply: function()}
        var edit = ctx.matchProp('edit', props);
        if (edit && edit.type === "ObjectExpression") {
            var editProps = edit.properties;
            res.push(ctx.matchProp('controller', editProps));
            res.push(ctx.matchProp('apply', editProps));
            res.push.apply(res, ctx.matchResolve(editProps));
        }

        var filteredRes = res.filter(Boolean);
        return (filteredRes.length === 0 ? false : filteredRes);
    }
};

},{}],18:[function(require,module,exports){
// scope.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>

"use strict";

var assert = require("assert");
var stringmap = require("stringmap");
var stringset = require("stringset");
var is = require("simple-is");
var fmt = require("simple-fmt");

function Scope(args) {
    assert(is.someof(args.kind, ["hoist", "block", "catch-block"]));
    assert(is.object(args.node));
    assert(args.parent === null || is.object(args.parent));

    // kind === "hoist": function scopes, program scope, injected globals
    // kind === "block": ES6 block scopes
    // kind === "catch-block": catch block scopes
    this.kind = args.kind;

    // the AST node the block corresponds to
    this.node = args.node;

    // parent scope
    this.parent = args.parent;

    // children scopes for easier traversal (populated internally)
    this.children = [];

    // scope declarations. decls[variable_name] = {
    //     kind: "fun" for functions,
    //           "param" for function parameters,
    //           "caught" for catch parameter
    //           "var",
    //           "const",
    //           "let"
    //     node: the AST node the declaration corresponds to
    //     from: source code index from which it is visible at earliest
    //           (only stored for "const", "let" [and "var"] nodes)
    // }
    this.decls = stringmap();

    // names of all variables declared outside this hoist scope but
    // referenced in this scope (immediately or in child).
    // only stored on hoist scopes for efficiency
    // (because we currently generate lots of empty block scopes)
    this.propagates = (this.kind === "hoist" ? stringset() : null);

    // scopes register themselves with their parents for easier traversal
    if (this.parent) {
        this.parent.children.push(this);
    }
}

Scope.prototype.print = function(indent) {
    indent = indent || 0;
    var scope = this;
    var names = this.decls.keys().map(function(name) {
        return fmt("{0} [{1}]", name, scope.decls.get(name).kind);
    }).join(", ");
    var propagates = this.propagates ? this.propagates.items().join(", ") : "";
    console.log(fmt("{0}{1}: {2}. propagates: {3}", fmt.repeat(" ", indent), this.node.type, names, propagates));
    this.children.forEach(function(c) {
        c.print(indent + 2);
    });
};

Scope.prototype.add = function(name, kind, node, referableFromPos) {
    assert(is.someof(kind, ["fun", "param", "var", "caught", "const", "let"]));

    function isConstLet(kind) {
        return is.someof(kind, ["const", "let"]);
    }

    var scope = this;

    // search nearest hoist-scope for fun, param and var's
    // const, let and caught variables go directly in the scope (which may be hoist, block or catch-block)
    if (is.someof(kind, ["fun", "param", "var"])) {
        while (scope.kind !== "hoist") {
//            if (scope.decls.has(name) && isConstLet(scope.decls.get(name).kind)) { // could be caught
//                return error(getline(node), "{0} is already declared", name);
//            }
            scope = scope.parent;
        }
    }
    // name exists in scope and either new or existing kind is const|let => error
//    if (scope.decls.has(name) && (isConstLet(scope.decls.get(name).kind) || isConstLet(kind))) {
//        return error(getline(node), "{0} is already declared", name);
//    }

    var declaration = {
        kind: kind,
        node: node,
    };
    if (referableFromPos) {
        assert(is.someof(kind, ["var", "const", "let"]));
        declaration.from = referableFromPos;
    }
    scope.decls.set(name, declaration);
};

Scope.prototype.getKind = function(name) {
    assert(is.string(name));
    var decl = this.decls.get(name);
    return decl ? decl.kind : null;
};

Scope.prototype.getNode = function(name) {
    assert(is.string(name));
    var decl = this.decls.get(name);
    return decl ? decl.node : null;
};

Scope.prototype.getFromPos = function(name) {
    assert(is.string(name));
    var decl = this.decls.get(name);
    return decl ? decl.from : null;
};

Scope.prototype.hasOwn = function(name) {
    return this.decls.has(name);
};

Scope.prototype.remove = function(name) {
    return this.decls.remove(name);
};

Scope.prototype.doesPropagate = function(name) {
    return this.propagates.has(name);
};

Scope.prototype.markPropagates = function(name) {
    this.propagates.add(name);
};

Scope.prototype.closestHoistScope = function() {
    var scope = this;
    while (scope.kind !== "hoist") {
        scope = scope.parent;
    }
    return scope;
};

Scope.prototype.lookup = function(name) {
    for (var scope = this; scope; scope = scope.parent) {
        if (scope.decls.has(name)) {
            return scope;
        } else if (scope.kind === "hoist") {
            scope.propagates.add(name);
        }
    }
    return null;
};

module.exports = Scope;

},{"assert":4,"simple-fmt":25,"simple-is":26,"stringmap":39,"stringset":40}],19:[function(require,module,exports){
// scopetools.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013-2016 Olov Lassus <olov.lassus@gmail.com>

"use strict";

var assert = require("assert");
var traverse = require("ordered-ast-traverse");
var Scope = require("./scope");
var is = require("simple-is");

module.exports = {
    setupScopeAndReferences: setupScopeAndReferences,
    isReference: isReference,
};

function setupScopeAndReferences(root) {
    traverse(root, {pre: createScopes});
    createTopScope(root.$scope);
}

function createScopes(node, parent) {
    node.$parent = parent;
    node.$scope = parent ? parent.$scope : null; // may be overridden

    if (isNonFunctionBlock(node, parent)) {
        // A block node is a scope unless parent is a function
        node.$scope = new Scope({
            kind: "block",
            node: node,
            parent: parent.$scope,
        });

    } else if (node.type === "VariableDeclaration") {
        // Variable declarations names goes in current scope
        node.declarations.forEach(function(declarator) {
            var name = declarator.id.name;
            node.$scope.add(name, node.kind, declarator.id, declarator.range[1]);
        });

    } else if (isFunction(node)) {
        // Function is a scope, with params in it
        // There's no block-scope under it

        node.$scope = new Scope({
            kind: "hoist",
            node: node,
            parent: parent.$scope,
        });

        // function has a name
        if (node.id) {
            if (node.type === "FunctionDeclaration") {
                // Function name goes in parent scope for declared functions
                parent.$scope.add(node.id.name, "fun", node.id, null);
            } else if (node.type === "FunctionExpression") {
                // Function name goes in function's scope for named function expressions
                node.$scope.add(node.id.name, "fun", node.id, null);
            } else {
                assert(false);
            }
        }

        node.params.forEach(function(param) {
            node.$scope.add(param.name, "param", param, null);
        });

    } else if (isForWithConstLet(node) || isForInOfWithConstLet(node)) {
        // For(In/Of) loop with const|let declaration is a scope, with declaration in it
        // There may be a block-scope under it
        node.$scope = new Scope({
            kind: "block",
            node: node,
            parent: parent.$scope,
        });

    } else if (node.type === "CatchClause") {
        var identifier = node.param;

        node.$scope = new Scope({
            kind: "catch-block",
            node: node,
            parent: parent.$scope,
        });
        node.$scope.add(identifier.name, "caught", identifier, null);

        // All hoist-scope keeps track of which variables that are propagated through,
        // i.e. an reference inside the scope points to a declaration outside the scope.
        // This is used to mark "taint" the name since adding a new variable in the scope,
        // with a propagated name, would change the meaning of the existing references.
        //
        // catch(e) is special because even though e is a variable in its own scope,
        // we want to make sure that catch(e){let e} is never transformed to
        // catch(e){var e} (but rather var e$0). For that reason we taint the use of e
        // in the closest hoist-scope, i.e. where var e$0 belongs.
        node.$scope.closestHoistScope().markPropagates(identifier.name);

    } else if (node.type === "Program") {
        // Top-level program is a scope
        // There's no block-scope under it
        node.$scope = new Scope({
            kind: "hoist",
            node: node,
            parent: null,
        });
    }
}

function createTopScope(programScope) {
    function inject(obj) {
        for (var name in obj) {
            var writeable = obj[name];
            var kind = (writeable ? "var" : "const");
            if (topScope.hasOwn(name)) {
                topScope.remove(name);
            }
            topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);
        }
    }

    var topScope = new Scope({
        kind: "hoist",
        node: {},
        parent: null,
    });

    var complementary = {
        undefined: false,
        Infinity: false,
        console: false,
    };

    inject(complementary);
//    inject(jshint_vars.reservedVars);
//    inject(jshint_vars.ecmaIdentifiers);

    // link it in
    programScope.parent = topScope;
    topScope.children.push(programScope);

    return topScope;
}

function isConstLet(kind) {
    return kind === "const" || kind === "let";
}

function isNonFunctionBlock(node, parent) {
    return node.type === "BlockStatement" && parent.type !== "FunctionDeclaration" && parent.type !== "FunctionExpression";
}

function isForWithConstLet(node) {
    return node.type === "ForStatement" && node.init && node.init.type === "VariableDeclaration" && isConstLet(node.init.kind);
}

function isForInOfWithConstLet(node) {
    return isForInOf(node) && node.left.type === "VariableDeclaration" && isConstLet(node.left.kind);
}

function isForInOf(node) {
    return node.type === "ForInStatement" || node.type === "ForOfStatement";
}

function isFunction(node) {
    return node.type === "FunctionDeclaration" || node.type === "FunctionExpression";
}

function isReference(node) {
    var parent = node.$parent;
    return node.$refToScope ||
        node.type === "Identifier" &&
            !(parent.type === "VariableDeclarator" && parent.id === node) && // var|let|const $
            !(parent.type === "MemberExpression" && parent.computed === false && parent.property === node) && // obj.$
            !(parent.type === "Property" && parent.key === node) && // {$: ...}
            !(parent.type === "LabeledStatement" && parent.label === node) && // $: ...
            !(parent.type === "CatchClause" && parent.param === node) && // catch($)
            !(isFunction(parent) && parent.id === node) && // function $(..
            !(isFunction(parent) && is.someof(node, parent.params)) && // function f($)..
            true;
}

},{"./scope":18,"assert":4,"ordered-ast-traverse":20,"simple-is":26}],20:[function(require,module,exports){
// ordered-ast-traverse.js
// MIT licensed, see LICENSE file
// Copyright (c) 2014-2015 Olov Lassus <olov.lassus@gmail.com>

"use strict";

var props = require("ordered-esprima-props");
var noProps = [];

function traverse(root, options) {
    "use strict";

    options = options || {};
    var pre = options.pre;
    var post = options.post;
    var skipProperty = options.skipProperty;

    function visit(node, parent, prop, idx) {
        if (!node || typeof node.type !== "string") {
            return;
        }

        var res = undefined;
        if (pre) {
            res = pre(node, parent, prop, idx);
        }

        if (res !== false) {
            var nodeProps = (props[node.type] || noProps);

            for (var idx = 0; idx < nodeProps.length; idx++) {
                var prop = nodeProps[idx];

                if (skipProperty && skipProperty(prop, node)) {
                    continue;
                }

                var child = node[prop];

                if (Array.isArray(child)) {
                    for (var i = 0; i < child.length; i++) {
                        var c = child[i];
                        visit(c, node, prop, i);
                    }
                } else {
                    visit(child, node, prop);
                }
            }
        }

        if (post) {
            post(node, parent, prop, idx);
        }
    }

    visit(root, null);
};

if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
    module.exports = traverse;
}

},{"ordered-esprima-props":21}],21:[function(require,module,exports){
// ordered-esprima-props.js
// MIT licensed, see LICENSE file
// Copyright (c) 2014 Olov Lassus <olov.lassus@gmail.com>

// A map from type (string) to an array of property names (strings)
// in lexical order, i.e. an AST-traversal in this order will visit
// nodes in increasing source code position.
//
// Tested with Esprima but should work for any Mozilla Parser API
// compatible AST, see
// https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API

module.exports = (function() {
    "use strict";

    function id(n) {
        return n;
    }

    var Expression = id;
    var Expressions = id;
    var Statement = id;
    var Statements = id;
    var Identifier = id;
    var Identifiers = id;
    var Lvalue = id;
    var BlockStatement = id;
    var CatchClause = id;
    var CatchClauses_singlearray = id;
    var VariableDeclarationOrIdentifier = id;
    var VariableDeclarationOrExpression = id;
    var VariableDeclarators = id;
    var Properties = id;
    var SwitchCases = id;

    return {
        ArrayExpression: [Expressions("elements")],
        AssignmentExpression: [Lvalue("left"), Expression("right")],
        BinaryExpression: [Expression("left"), Expression("right")],
        BlockStatement: [Statements("body")],
        BreakStatement: [Identifier("label")],
        CallExpression: [Expression("callee"), Expressions("arguments")],
        CatchClause: [Identifier("param"), /*"guard",*/ BlockStatement("body")],
        ConditionalExpression: [Expression("test"), Expression("consequent"), Expression("alternate")],
        ContinueStatement: [Identifier("label")],
        DebuggerStatement: [],
        DoWhileStatement: [Statement("body"), Expression("test")],
        EmptyStatement: [],
        ExpressionStatement: [Expression("expression")],
        ForInStatement: [VariableDeclarationOrIdentifier("left"), Expression("right"), Statement("body")],
        ForStatement: [VariableDeclarationOrExpression("init"), Expression("test"), Expression("update"), Statement("body")],
        FunctionDeclaration: [Identifier("id"), Identifiers("params"), BlockStatement("body")],
        FunctionExpression: [Identifier("id"), Identifiers("params"), BlockStatement("body")],
        Identifier: [],
        IfStatement: [Expression("test"), Statement("consequent"), Statement("alternate")],
        LabeledStatement: [Identifier("label"), Statement("body")],
        Literal: [],
        LogicalExpression: [Expression("left"), Expression("right")],
        MemberExpression: [Expression("object"), Identifier("property")],
        NewExpression: [Expression("callee"), Identifiers("arguments")],
        ObjectExpression: [Properties("properties")],
        Program: [Statements("body")],
        Property: [Identifier("key"), Expression("value")],
        ReturnStatement: [Expression("argument")],
        SequenceExpression: [Expressions("expressions")],
        SwitchCase: [Expression("test"), Statements("consequent")],
        SwitchStatement: [Expression("discriminant"), SwitchCases("cases")],
        ThisExpression: [],
        ThrowStatement: [Expression("argument")],
        TryStatement: [BlockStatement("block"), /*standard, acorn*/ CatchClause("handler"), /*esprima*/ CatchClauses_singlearray("handlers"), /*"guardedHandlers",*/ BlockStatement("finalizer")],
        UnaryExpression: [Expression("argument")],
        UpdateExpression: [Lvalue("argument")],
        VariableDeclaration: [VariableDeclarators("declarations")],
        VariableDeclarator: [Identifier("id"), Expression("init")],
        WhileStatement: [Expression("test"), Statement("body")],
        WithStatement: [Expression("object"), Statement("body")],
    };
})();

},{}],22:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],23:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":24}],24:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],25:[function(require,module,exports){
// simple-fmt.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013 Olov Lassus <olov.lassus@gmail.com>

var fmt = (function() {
    "use strict";

    function fmt(str, var_args) {
        var args = Array.prototype.slice.call(arguments, 1);
        return str.replace(/\{(\d+)\}/g, function(s, match) {
            return (match in args ? args[match] : s);
        });
    }

    function obj(str, obj) {
        return str.replace(/\{([_$a-zA-Z0-9][_$a-zA-Z0-9]*)\}/g, function(s, match) {
            return (match in obj ? obj[match] : s);
        });
    }

    function repeat(str, n) {
        return (new Array(n + 1)).join(str);
    }

    fmt.fmt = fmt;
    fmt.obj = obj;
    fmt.repeat = repeat;
    return fmt;
})();

if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
    module.exports = fmt;
}

},{}],26:[function(require,module,exports){
// simple-is.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013 Olov Lassus <olov.lassus@gmail.com>

var is = (function() {
    "use strict";

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    var _undefined = void 0;

    return {
        nan: function(v) {
            return v !== v;
        },
        boolean: function(v) {
            return typeof v === "boolean";
        },
        number: function(v) {
            return typeof v === "number";
        },
        string: function(v) {
            return typeof v === "string";
        },
        fn: function(v) {
            return typeof v === "function";
        },
        object: function(v) {
            return v !== null && typeof v === "object";
        },
        primitive: function(v) {
            var t = typeof v;
            return v === null || v === _undefined ||
                t === "boolean" || t === "number" || t === "string";
        },
        array: Array.isArray || function(v) {
            return toString.call(v) === "[object Array]";
        },
        finitenumber: function(v) {
            return typeof v === "number" && isFinite(v);
        },
        someof: function(v, values) {
            return values.indexOf(v) >= 0;
        },
        noneof: function(v, values) {
            return values.indexOf(v) === -1;
        },
        own: function(obj, prop) {
            return hasOwnProperty.call(obj, prop);
        },
    };
})();

if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
    module.exports = is;
}

},{}],27:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = util.toSetString(aStr);
  var isDuplicate = has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = util.toSetString(aStr);
  return has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = util.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":36}],28:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":29}],29:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],30:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],31:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":36}],32:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],33:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":27,"./base64-vlq":28,"./binary-search":30,"./quick-sort":32,"./util":36}],34:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":27,"./base64-vlq":28,"./mapping-list":31,"./util":36}],35:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function() {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":34,"./util":36}],36:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

},{}],37:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":33,"./lib/source-map-generator":34,"./lib/source-node":35}],38:[function(require,module,exports){
//! stable.js 0.1.5, https://github.com/Two-Screen/stable
//! © 2014 Angry Bytes and contributors. MIT licensed.

(function() {

// A stable array sort, because `Array#sort()` is not guaranteed stable.
// This is an implementation of merge sort, without recursion.

var stable = function(arr, comp) {
    return exec(arr.slice(), comp);
};

stable.inplace = function(arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
        pass(result, null, arr.length, arr);
    }

    return arr;
};

// Execute the sort using the input array and a second buffer as work space.
// Returns one of those two, containing the final result.
function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
        comp = function(a, b) {
            return String(a).localeCompare(b);
        };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
        return arr;
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
        pass(arr, comp, chk, buffer);

        var tmp = arr;
        arr = buffer;
        buffer = tmp;
    }

    return arr;
}

// Run a single pass with the given chunk size.
var pass = function(arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
        r = l + chk;
        e = r + chk;
        if (r > len) r = len;
        if (e > len) e = len;

        // Iterate both chunks in parallel.
        li = l;
        ri = r;
        while (true) {
            // Compare the chunks.
            if (li < r && ri < e) {
                // This works for a regular `sort()` compatible comparator,
                // but also for a simple comparator like: `a > b`
                if (comp(arr[li], arr[ri]) <= 0) {
                    result[i++] = arr[li++];
                }
                else {
                    result[i++] = arr[ri++];
                }
            }
            // Nothing to compare, just flush what's left.
            else if (li < r) {
                result[i++] = arr[li++];
            }
            else if (ri < e) {
                result[i++] = arr[ri++];
            }
            // Both iterators are at the chunk ends.
            else {
                break;
            }
        }
    }
};

// Export using CommonJS or to the window.
if (typeof(module) !== 'undefined') {
    module.exports = stable;
}
else {
    window.stable = stable;
}

})();

},{}],39:[function(require,module,exports){
// stringmap.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013 Olov Lassus <olov.lassus@gmail.com>

var StringMap = (function() {
    "use strict";

    // to save us a few characters
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var create = (function() {
        function hasOwnEnumerableProps(obj) {
            for (var prop in obj) {
                if (hasOwnProperty.call(obj, prop)) {
                    return true;
                }
            }
            return false;
        }
        // FF <= 3.6:
        // o = {}; o.hasOwnProperty("__proto__" or "__count__" or "__parent__") => true
        // o = {"__proto__": null}; Object.prototype.hasOwnProperty.call(o, "__proto__" or "__count__" or "__parent__") => false
        function hasOwnPollutedProps(obj) {
            return hasOwnProperty.call(obj, "__count__") || hasOwnProperty.call(obj, "__parent__");
        }

        var useObjectCreate = false;
        if (typeof Object.create === "function") {
            if (!hasOwnEnumerableProps(Object.create(null))) {
                useObjectCreate = true;
            }
        }
        if (useObjectCreate === false) {
            if (hasOwnEnumerableProps({})) {
                throw new Error("StringMap environment error 0, please file a bug at https://github.com/olov/stringmap/issues");
            }
        }
        // no throw yet means we can create objects without own enumerable props (safe-guard against VMs and shims)

        var o = (useObjectCreate ? Object.create(null) : {});
        var useProtoClear = false;
        if (hasOwnPollutedProps(o)) {
            o.__proto__ = null;
            if (hasOwnEnumerableProps(o) || hasOwnPollutedProps(o)) {
                throw new Error("StringMap environment error 1, please file a bug at https://github.com/olov/stringmap/issues");
            }
            useProtoClear = true;
        }
        // no throw yet means we can create objects without own polluted props (safe-guard against VMs and shims)

        return function() {
            var o = (useObjectCreate ? Object.create(null) : {});
            if (useProtoClear) {
                o.__proto__ = null;
            }
            return o;
        };
    })();

    // stringmap ctor
    function stringmap(optional_object) {
        // use with or without new
        if (!(this instanceof stringmap)) {
            return new stringmap(optional_object);
        }
        this.obj = create();
        this.hasProto = false; // false (no __proto__ key) or true (has __proto__ key)
        this.proto = undefined; // value for __proto__ key when hasProto is true, undefined otherwise

        if (optional_object) {
            this.setMany(optional_object);
        }
    };

    // primitive methods that deals with data representation
    stringmap.prototype.has = function(key) {
        // The type-check of key in has, get, set and delete is important because otherwise an object
        // {toString: function() { return "__proto__"; }} can avoid the key === "__proto__" test.
        // The alternative to type-checking would be to force string conversion, i.e. key = String(key);
        if (typeof key !== "string") {
            throw new Error("StringMap expected string key");
        }
        return (key === "__proto__" ?
            this.hasProto :
            hasOwnProperty.call(this.obj, key));
    };

    stringmap.prototype.get = function(key) {
        if (typeof key !== "string") {
            throw new Error("StringMap expected string key");
        }
        return (key === "__proto__" ?
            this.proto :
            (hasOwnProperty.call(this.obj, key) ? this.obj[key] : undefined));
    };

    stringmap.prototype.set = function(key, value) {
        if (typeof key !== "string") {
            throw new Error("StringMap expected string key");
        }
        if (key === "__proto__") {
            this.hasProto = true;
            this.proto = value;
        } else {
            this.obj[key] = value;
        }
    };

    stringmap.prototype.remove = function(key) {
        if (typeof key !== "string") {
            throw new Error("StringMap expected string key");
        }
        var didExist = this.has(key);
        if (key === "__proto__") {
            this.hasProto = false;
            this.proto = undefined;
        } else {
            delete this.obj[key];
        }
        return didExist;
    };

    // alias remove to delete but beware:
    // sm.delete("key"); // OK in ES5 and later
    // sm['delete']("key"); // OK in all ES versions
    // sm.remove("key"); // OK in all ES versions
    stringmap.prototype['delete'] = stringmap.prototype.remove;

    stringmap.prototype.isEmpty = function() {
        for (var key in this.obj) {
            if (hasOwnProperty.call(this.obj, key)) {
                return false;
            }
        }
        return !this.hasProto;
    };

    stringmap.prototype.size = function() {
        var len = 0;
        for (var key in this.obj) {
            if (hasOwnProperty.call(this.obj, key)) {
                ++len;
            }
        }
        return (this.hasProto ? len + 1 : len);
    };

    stringmap.prototype.keys = function() {
        var keys = [];
        for (var key in this.obj) {
            if (hasOwnProperty.call(this.obj, key)) {
                keys.push(key);
            }
        }
        if (this.hasProto) {
            keys.push("__proto__");
        }
        return keys;
    };

    stringmap.prototype.values = function() {
        var values = [];
        for (var key in this.obj) {
            if (hasOwnProperty.call(this.obj, key)) {
                values.push(this.obj[key]);
            }
        }
        if (this.hasProto) {
            values.push(this.proto);
        }
        return values;
    };

    stringmap.prototype.items = function() {
        var items = [];
        for (var key in this.obj) {
            if (hasOwnProperty.call(this.obj, key)) {
                items.push([key, this.obj[key]]);
            }
        }
        if (this.hasProto) {
            items.push(["__proto__", this.proto]);
        }
        return items;
    };


    // methods that rely on the above primitives
    stringmap.prototype.setMany = function(object) {
        if (object === null || (typeof object !== "object" && typeof object !== "function")) {
            throw new Error("StringMap expected Object");
        }
        for (var key in object) {
            if (hasOwnProperty.call(object, key)) {
                this.set(key, object[key]);
            }
        }
        return this;
    };

    stringmap.prototype.merge = function(other) {
        var keys = other.keys();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            this.set(key, other.get(key));
        }
        return this;
    };

    stringmap.prototype.map = function(fn) {
        var keys = this.keys();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            keys[i] = fn(this.get(key), key); // re-use keys array for results
        }
        return keys;
    };

    stringmap.prototype.forEach = function(fn) {
        var keys = this.keys();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            fn(this.get(key), key);
        }
    };

    stringmap.prototype.clone = function() {
        var other = stringmap();
        return other.merge(this);
    };

    stringmap.prototype.toString = function() {
        var self = this;
        return "{" + this.keys().map(function(key) {
            return JSON.stringify(key) + ":" + JSON.stringify(self.get(key));
        }).join(",") + "}";
    };

    return stringmap;
})();

if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
    module.exports = StringMap;
}

},{}],40:[function(require,module,exports){
// stringset.js
// MIT licensed, see LICENSE file
// Copyright (c) 2013 Olov Lassus <olov.lassus@gmail.com>

var StringSet = (function() {
    "use strict";

    // to save us a few characters
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var create = (function() {
        function hasOwnEnumerableProps(obj) {
            for (var prop in obj) {
                if (hasOwnProperty.call(obj, prop)) {
                    return true;
                }
            }
            return false;
        }

        // FF <= 3.6:
        // o = {}; o.hasOwnProperty("__proto__" or "__count__" or "__parent__") => true
        // o = {"__proto__": null}; Object.prototype.hasOwnProperty.call(o, "__proto__" or "__count__" or "__parent__") => false
        function hasOwnPollutedProps(obj) {
            return hasOwnProperty.call(obj, "__count__") || hasOwnProperty.call(obj, "__parent__");
        }

        var useObjectCreate = false;
        if (typeof Object.create === "function") {
            if (!hasOwnEnumerableProps(Object.create(null))) {
                useObjectCreate = true;
            }
        }
        if (useObjectCreate === false) {
            if (hasOwnEnumerableProps({})) {
                throw new Error("StringSet environment error 0, please file a bug at https://github.com/olov/stringset/issues");
            }
        }
        // no throw yet means we can create objects without own enumerable props (safe-guard against VMs and shims)

        var o = (useObjectCreate ? Object.create(null) : {});
        var useProtoClear = false;
        if (hasOwnPollutedProps(o)) {
            o.__proto__ = null;
            if (hasOwnEnumerableProps(o) || hasOwnPollutedProps(o)) {
                throw new Error("StringSet environment error 1, please file a bug at https://github.com/olov/stringset/issues");
            }
            useProtoClear = true;
        }
        // no throw yet means we can create objects without own polluted props (safe-guard against VMs and shims)

        return function() {
            var o = (useObjectCreate ? Object.create(null) : {});
            if (useProtoClear) {
                o.__proto__ = null;
            }
            return o;
        };
    })();

    // stringset ctor
    function stringset(optional_array) {
        // use with or without new
        if (!(this instanceof stringset)) {
            return new stringset(optional_array);
        }
        this.obj = create();
        this.hasProto = false; // false (no __proto__ item) or true (has __proto__ item)

        if (optional_array) {
            this.addMany(optional_array);
        }
    };

    // primitive methods that deals with data representation
    stringset.prototype.has = function(item) {
        // The type-check of item in has, get, set and delete is important because otherwise an object
        // {toString: function() { return "__proto__"; }} can avoid the item === "__proto__" test.
        // The alternative to type-checking would be to force string conversion, i.e. item = String(item);
        if (typeof item !== "string") {
            throw new Error("StringSet expected string item");
        }
        return (item === "__proto__" ?
            this.hasProto :
            hasOwnProperty.call(this.obj, item));
    };

    stringset.prototype.add = function(item) {
        if (typeof item !== "string") {
            throw new Error("StringSet expected string item");
        }
        if (item === "__proto__") {
            this.hasProto = true;
        } else {
            this.obj[item] = true;
        }
    };

    stringset.prototype.remove = function(item) {
        if (typeof item !== "string") {
            throw new Error("StringSet expected string item");
        }
        var didExist = this.has(item);
        if (item === "__proto__") {
            this.hasProto = false;
        } else {
            delete this.obj[item];
        }
        return didExist;
    };

    // alias remove to delete but beware:
    // ss.delete("key"); // OK in ES5 and later
    // ss['delete']("key"); // OK in all ES versions
    // ss.remove("key"); // OK in all ES versions
    stringset.prototype['delete'] = stringset.prototype.remove;

    stringset.prototype.isEmpty = function() {
        for (var item in this.obj) {
            if (hasOwnProperty.call(this.obj, item)) {
                return false;
            }
        }
        return !this.hasProto;
    };

    stringset.prototype.size = function() {
        var len = 0;
        for (var item in this.obj) {
            if (hasOwnProperty.call(this.obj, item)) {
                ++len;
            }
        }
        return (this.hasProto ? len + 1 : len);
    };

    stringset.prototype.items = function() {
        var items = [];
        for (var item in this.obj) {
            if (hasOwnProperty.call(this.obj, item)) {
                items.push(item);
            }
        }
        if (this.hasProto) {
            items.push("__proto__");
        }
        return items;
    };


    // methods that rely on the above primitives
    stringset.prototype.addMany = function(items) {
        if (!Array.isArray(items)) {
            throw new Error("StringSet expected array");
        }
        for (var i = 0; i < items.length; i++) {
            this.add(items[i]);
        }
        return this;
    };

    stringset.prototype.merge = function(other) {
        this.addMany(other.items());
        return this;
    };

    stringset.prototype.clone = function() {
        var other = stringset();
        return other.merge(this);
    };

    stringset.prototype.toString = function() {
        return "{" + this.items().map(JSON.stringify).join(",") + "}";
    };

    return stringset;
})();

if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
    module.exports = StringSet;
}

},{}],41:[function(require,module,exports){
(function (global){
/*
 *  Sugar Library v1.4.1
 *
 *  Freely distributable and licensed under the MIT-style license.
 *  Copyright (c) 2013 Andrew Plummer
 *  http://sugarjs.com/
 *
 * ---------------------------- */
(function(){
  'use strict';

  /***
   * @package Core
   * @description Internal utility and common methods.
   ***/


  // A few optimizations for Google Closure Compiler will save us a couple kb in the release script.
  var object = Object, array = Array, regexp = RegExp, date = Date, string = String, number = Number, math = Math, Undefined;

  // The global context
  var globalContext = typeof global !== 'undefined' ? global : this;

  // Internal toString
  var internalToString = object.prototype.toString;

  // Internal hasOwnProperty
  var internalHasOwnProperty = object.prototype.hasOwnProperty;

  // defineProperty exists in IE8 but will error when trying to define a property on
  // native objects. IE8 does not have defineProperies, however, so this check saves a try/catch block.
  var definePropertySupport = object.defineProperty && object.defineProperties;

  // Are regexes type function?
  var regexIsFunction = typeof regexp() === 'function';

  // Do strings have no keys?
  var noKeysInStringObjects = !('0' in new string('a'));

  // Type check methods need a way to be accessed dynamically.
  var typeChecks = {};

  // Classes that can be matched by value
  var matchedByValueReg = /^\[object Date|Array|String|Number|RegExp|Boolean|Arguments\]$/;

  // Class initializers and class helpers
  var ClassNames = 'Boolean,Number,String,Array,Date,RegExp,Function'.split(',');

  var isBoolean  = buildPrimitiveClassCheck('boolean', ClassNames[0]);
  var isNumber   = buildPrimitiveClassCheck('number',  ClassNames[1]);
  var isString   = buildPrimitiveClassCheck('string',  ClassNames[2]);

  var isArray    = buildClassCheck(ClassNames[3]);
  var isDate     = buildClassCheck(ClassNames[4]);
  var isRegExp   = buildClassCheck(ClassNames[5]);


  // Wanted to enhance performance here by using simply "typeof"
  // but Firefox has two major issues that make this impossible,
  // one fixed, the other not. Despite being typeof "function"
  // the objects below still report in as [object Function], so
  // we need to perform a full class check here.
  //
  // 1. Regexes can be typeof "function" in FF < 3
  //    https://bugzilla.mozilla.org/show_bug.cgi?id=61911 (fixed)
  //
  // 2. HTMLEmbedElement and HTMLObjectElement are be typeof "function"
  //    https://bugzilla.mozilla.org/show_bug.cgi?id=268945 (won't fix)
  //
  var isFunction = buildClassCheck(ClassNames[6]);

  function isClass(obj, klass, cached) {
    var k = cached || className(obj);
    return k === '[object '+klass+']';
  }

  function buildClassCheck(klass) {
    var fn = (klass === 'Array' && array.isArray) || function(obj, cached) {
      return isClass(obj, klass, cached);
    };
    typeChecks[klass] = fn;
    return fn;
  }

  function buildPrimitiveClassCheck(type, klass) {
    var fn = function(obj) {
      if(isObjectType(obj)) {
        return isClass(obj, klass);
      }
      return typeof obj === type;
    }
    typeChecks[klass] = fn;
    return fn;
  }

  function className(obj) {
    return internalToString.call(obj);
  }

  function initializeClasses() {
    initializeClass(object);
    iterateOverObject(ClassNames, function(i,name) {
      initializeClass(globalContext[name]);
    });
  }

  function initializeClass(klass) {
    if(klass['SugarMethods']) return;
    defineProperty(klass, 'SugarMethods', {});
    extend(klass, false, true, {
      'extend': function(methods, override, instance) {
        extend(klass, instance !== false, override, methods);
      },
      'sugarRestore': function() {
        return batchMethodExecute(this, klass, arguments, function(target, name, m) {
          defineProperty(target, name, m.method);
        });
      },
      'sugarRevert': function() {
        return batchMethodExecute(this, klass, arguments, function(target, name, m) {
          if(m['existed']) {
            defineProperty(target, name, m['original']);
          } else {
            delete target[name];
          }
        });
      }
    });
  }

  // Class extending methods

  function extend(klass, instance, override, methods) {
    var extendee = instance ? klass.prototype : klass;
    initializeClass(klass);
    iterateOverObject(methods, function(name, extendedFn) {
      var nativeFn = extendee[name],
          existed  = hasOwnProperty(extendee, name);
      if(isFunction(override) && nativeFn) {
        extendedFn = wrapNative(nativeFn, extendedFn, override);
      }
      if(override !== false || !nativeFn) {
        defineProperty(extendee, name, extendedFn);
      }
      // If the method is internal to Sugar, then
      // store a reference so it can be restored later.
      klass['SugarMethods'][name] = {
        'method':   extendedFn,
        'existed':  existed,
        'original': nativeFn,
        'instance': instance
      };
    });
  }

  function extendSimilar(klass, instance, override, set, fn) {
    var methods = {};
    set = isString(set) ? set.split(',') : set;
    set.forEach(function(name, i) {
      fn(methods, name, i);
    });
    extend(klass, instance, override, methods);
  }

  function batchMethodExecute(target, klass, args, fn) {
    var all = args.length === 0, methods = multiArgs(args), changed = false;
    iterateOverObject(klass['SugarMethods'], function(name, m) {
      if(all || methods.indexOf(name) !== -1) {
        changed = true;
        fn(m['instance'] ? target.prototype : target, name, m);
      }
    });
    return changed;
  }

  function wrapNative(nativeFn, extendedFn, condition) {
    return function(a) {
      return condition.apply(this, arguments) ?
             extendedFn.apply(this, arguments) :
             nativeFn.apply(this, arguments);
    }
  }

  function defineProperty(target, name, method) {
    if(definePropertySupport) {
      object.defineProperty(target, name, {
        'value': method,
        'configurable': true,
        'enumerable': false,
        'writable': true
      });
    } else {
      target[name] = method;
    }
  }


  // Argument helpers

  function multiArgs(args, fn, from) {
    var result = [], i = from || 0, len;
    for(len = args.length; i < len; i++) {
      result.push(args[i]);
      if(fn) fn.call(args, args[i], i);
    }
    return result;
  }

  function flattenedArgs(args, fn, from) {
    var arg = args[from || 0];
    if(isArray(arg)) {
      args = arg;
      from = 0;
    }
    return multiArgs(args, fn, from);
  }

  function checkCallback(fn) {
    if(!fn || !fn.call) {
      throw new TypeError('Callback is not callable');
    }
  }


  // General helpers

  function isDefined(o) {
    return o !== Undefined;
  }

  function isUndefined(o) {
    return o === Undefined;
  }


  // Object helpers

  function hasProperty(obj, prop) {
    return !isPrimitiveType(obj) && prop in obj;
  }

  function hasOwnProperty(obj, prop) {
    return !!obj && internalHasOwnProperty.call(obj, prop);
  }

  function isObjectType(obj) {
    // 1. Check for null
    // 2. Check for regexes in environments where they are "functions".
    return !!obj && (typeof obj === 'object' || (regexIsFunction && isRegExp(obj)));
  }

  function isPrimitiveType(obj) {
    var type = typeof obj;
    return obj == null || type === 'string' || type === 'number' || type === 'boolean';
  }

  function isPlainObject(obj, klass) {
    klass = klass || className(obj);
    try {
      // Not own constructor property must be Object
      // This code was borrowed from jQuery.isPlainObject
      if (obj && obj.constructor &&
            !hasOwnProperty(obj, 'constructor') &&
            !hasOwnProperty(obj.constructor.prototype, 'isPrototypeOf')) {
        return false;
      }
    } catch (e) {
      // IE8,9 Will throw exceptions on certain host objects.
      return false;
    }
    // === on the constructor is not safe across iframes
    // 'hasOwnProperty' ensures that the object also inherits
    // from Object, which is false for DOMElements in IE.
    return !!obj && klass === '[object Object]' && 'hasOwnProperty' in obj;
  }

  function iterateOverObject(obj, fn) {
    var key;
    for(key in obj) {
      if(!hasOwnProperty(obj, key)) continue;
      if(fn.call(obj, key, obj[key], obj) === false) break;
    }
  }

  function simpleRepeat(n, fn) {
    for(var i = 0; i < n; i++) {
      fn(i);
    }
  }

  function simpleMerge(target, source) {
    iterateOverObject(source, function(key) {
      target[key] = source[key];
    });
    return target;
  }

   // Make primtives types like strings into objects.
   function coercePrimitiveToObject(obj) {
     if(isPrimitiveType(obj)) {
       obj = object(obj);
     }
     if(noKeysInStringObjects && isString(obj)) {
       forceStringCoercion(obj);
     }
     return obj;
   }

   // Force strings to have their indexes set in
   // environments that don't do this automatically.
   function forceStringCoercion(obj) {
     var i = 0, chr;
     while(chr = obj.charAt(i)) {
       obj[i++] = chr;
     }
   }

  // Hash definition

  function Hash(obj) {
    simpleMerge(this, coercePrimitiveToObject(obj));
  };

  Hash.prototype.constructor = object;

  // Math helpers

  var abs   = math.abs;
  var pow   = math.pow;
  var ceil  = math.ceil;
  var floor = math.floor;
  var round = math.round;
  var min   = math.min;
  var max   = math.max;

  function withPrecision(val, precision, fn) {
    var multiplier = pow(10, abs(precision || 0));
    fn = fn || round;
    if(precision < 0) multiplier = 1 / multiplier;
    return fn(val * multiplier) / multiplier;
  }

  // Full width number helpers

  var HalfWidthZeroCode = 0x30;
  var HalfWidthNineCode = 0x39;
  var FullWidthZeroCode = 0xff10;
  var FullWidthNineCode = 0xff19;

  var HalfWidthPeriod = '.';
  var FullWidthPeriod = '．';
  var HalfWidthComma  = ',';

  // Used here and later in the Date package.
  var FullWidthDigits   = '';

  var NumberNormalizeMap = {};
  var NumberNormalizeReg;

  function codeIsNumeral(code) {
    return (code >= HalfWidthZeroCode && code <= HalfWidthNineCode) ||
           (code >= FullWidthZeroCode && code <= FullWidthNineCode);
  }

  function buildNumberHelpers() {
    var digit, i;
    for(i = 0; i <= 9; i++) {
      digit = chr(i + FullWidthZeroCode);
      FullWidthDigits += digit;
      NumberNormalizeMap[digit] = chr(i + HalfWidthZeroCode);
    }
    NumberNormalizeMap[HalfWidthComma] = '';
    NumberNormalizeMap[FullWidthPeriod] = HalfWidthPeriod;
    // Mapping this to itself to easily be able to easily
    // capture it in stringToNumber to detect decimals later.
    NumberNormalizeMap[HalfWidthPeriod] = HalfWidthPeriod;
    NumberNormalizeReg = regexp('[' + FullWidthDigits + FullWidthPeriod + HalfWidthComma + HalfWidthPeriod + ']', 'g');
  }

  // String helpers

  function chr(num) {
    return string.fromCharCode(num);
  }

  // WhiteSpace/LineTerminator as defined in ES5.1 plus Unicode characters in the Space, Separator category.
  function getTrimmableCharacters() {
    return '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF';
  }

  function repeatString(str, num) {
    var result = '', str = str.toString();
    while (num > 0) {
      if (num & 1) {
        result += str;
      }
      if (num >>= 1) {
        str += str;
      }
    }
    return result;
  }

  // Returns taking into account full-width characters, commas, and decimals.
  function stringToNumber(str, base) {
    var sanitized, isDecimal;
    sanitized = str.replace(NumberNormalizeReg, function(chr) {
      var replacement = NumberNormalizeMap[chr];
      if(replacement === HalfWidthPeriod) {
        isDecimal = true;
      }
      return replacement;
    });
    return isDecimal ? parseFloat(sanitized) : parseInt(sanitized, base || 10);
  }


  // Used by Number and Date

  function padNumber(num, place, sign, base) {
    var str = abs(num).toString(base || 10);
    str = repeatString('0', place - str.replace(/\.\d+/, '').length) + str;
    if(sign || num < 0) {
      str = (num < 0 ? '-' : '+') + str;
    }
    return str;
  }

  function getOrdinalizedSuffix(num) {
    if(num >= 11 && num <= 13) {
      return 'th';
    } else {
      switch(num % 10) {
        case 1:  return 'st';
        case 2:  return 'nd';
        case 3:  return 'rd';
        default: return 'th';
      }
    }
  }


  // RegExp helpers

  function getRegExpFlags(reg, add) {
    var flags = '';
    add = add || '';
    function checkFlag(prop, flag) {
      if(prop || add.indexOf(flag) > -1) {
        flags += flag;
      }
    }
    checkFlag(reg.multiline, 'm');
    checkFlag(reg.ignoreCase, 'i');
    checkFlag(reg.global, 'g');
    checkFlag(reg.sticky, 'y');
    return flags;
  }

  function escapeRegExp(str) {
    if(!isString(str)) str = string(str);
    return str.replace(/([\\/\'*+?|()\[\]{}.^$])/g,'\\$1');
  }


  // Date helpers

  function callDateGet(d, method) {
    return d['get' + (d._utc ? 'UTC' : '') + method]();
  }

  function callDateSet(d, method, value) {
    return d['set' + (d._utc && method != 'ISOWeek' ? 'UTC' : '') + method](value);
  }

  // Used by Array#unique and Object.equal

  function stringify(thing, stack) {
    var type = typeof thing,
        thingIsObject,
        thingIsArray,
        klass, value,
        arr, key, i, len;

    // Return quickly if string to save cycles
    if(type === 'string') return thing;

    klass         = internalToString.call(thing)
    thingIsObject = isPlainObject(thing, klass);
    thingIsArray  = isArray(thing, klass);

    if(thing != null && thingIsObject || thingIsArray) {
      // This method for checking for cyclic structures was egregiously stolen from
      // the ingenious method by @kitcambridge from the Underscore script:
      // https://github.com/documentcloud/underscore/issues/240
      if(!stack) stack = [];
      // Allowing a step into the structure before triggering this
      // script to save cycles on standard JSON structures and also to
      // try as hard as possible to catch basic properties that may have
      // been modified.
      if(stack.length > 1) {
        i = stack.length;
        while (i--) {
          if (stack[i] === thing) {
            return 'CYC';
          }
        }
      }
      stack.push(thing);
      value = thing.valueOf() + string(thing.constructor);
      arr = thingIsArray ? thing : object.keys(thing).sort();
      for(i = 0, len = arr.length; i < len; i++) {
        key = thingIsArray ? i : arr[i];
        value += key + stringify(thing[key], stack);
      }
      stack.pop();
    } else if(1 / thing === -Infinity) {
      value = '-0';
    } else {
      value = string(thing && thing.valueOf ? thing.valueOf() : thing);
    }
    return type + klass + value;
  }

  function isEqual(a, b) {
    if(a === b) {
      // Return quickly up front when matching by reference,
      // but be careful about 0 !== -0.
      return a !== 0 || 1 / a === 1 / b;
    } else if(objectIsMatchedByValue(a) && objectIsMatchedByValue(b)) {
      return stringify(a) === stringify(b);
    }
    return false;
  }

  function objectIsMatchedByValue(obj) {
    // Only known objects are matched by value. This is notably excluding functions, DOM Elements, and instances of
    // user-created classes. The latter can arguably be matched by value, but distinguishing between these and
    // host objects -- which should never be compared by value -- is very tricky so not dealing with it here.
    var klass = className(obj);
    return matchedByValueReg.test(klass) || isPlainObject(obj, klass);
  }


  // Used by Array#at and String#at

  function getEntriesForIndexes(obj, args, isString) {
    var result,
        length    = obj.length,
        argsLen   = args.length,
        overshoot = args[argsLen - 1] !== false,
        multiple  = argsLen > (overshoot ? 1 : 2);
    if(!multiple) {
      return entryAtIndex(obj, length, args[0], overshoot, isString);
    }
    result = [];
    multiArgs(args, function(index) {
      if(isBoolean(index)) return false;
      result.push(entryAtIndex(obj, length, index, overshoot, isString));
    });
    return result;
  }

  function entryAtIndex(obj, length, index, overshoot, isString) {
    if(overshoot) {
      index = index % length;
      if(index < 0) index = length + index;
    }
    return isString ? obj.charAt(index) : obj[index];
  }


  // Object class methods implemented as instance methods

  function buildObjectInstanceMethods(set, target) {
    extendSimilar(target, true, false, set, function(methods, name) {
      methods[name + (name === 'equal' ? 's' : '')] = function() {
        return object[name].apply(null, [this].concat(multiArgs(arguments)));
      }
    });
  }

  initializeClasses();
  buildNumberHelpers();


  /***
   * @package ES5
   * @description Shim methods that provide ES5 compatible functionality. This package can be excluded if you do not require legacy browser support (IE8 and below).
   *
   ***/


  /***
   * Object module
   *
   ***/

  extend(object, false, false, {

    'keys': function(obj) {
      var keys = [];
      if(!isObjectType(obj) && !isRegExp(obj) && !isFunction(obj)) {
        throw new TypeError('Object required');
      }
      iterateOverObject(obj, function(key, value) {
        keys.push(key);
      });
      return keys;
    }

  });


  /***
   * Array module
   *
   ***/

  // ECMA5 methods

  function arrayIndexOf(arr, search, fromIndex, increment) {
    var length = arr.length,
        fromRight = increment == -1,
        start = fromRight ? length - 1 : 0,
        index = toIntegerWithDefault(fromIndex, start);
    if(index < 0) {
      index = length + index;
    }
    if((!fromRight && index < 0) || (fromRight && index >= length)) {
      index = start;
    }
    while((fromRight && index >= 0) || (!fromRight && index < length)) {
      if(arr[index] === search) {
        return index;
      }
      index += increment;
    }
    return -1;
  }

  function arrayReduce(arr, fn, initialValue, fromRight) {
    var length = arr.length, count = 0, defined = isDefined(initialValue), result, index;
    checkCallback(fn);
    if(length == 0 && !defined) {
      throw new TypeError('Reduce called on empty array with no initial value');
    } else if(defined) {
      result = initialValue;
    } else {
      result = arr[fromRight ? length - 1 : count];
      count++;
    }
    while(count < length) {
      index = fromRight ? length - count - 1 : count;
      if(index in arr) {
        result = fn(result, arr[index], index, arr);
      }
      count++;
    }
    return result;
  }

  function toIntegerWithDefault(i, d) {
    if(isNaN(i)) {
      return d;
    } else {
      return parseInt(i >> 0);
    }
  }

  function checkFirstArgumentExists(args) {
    if(args.length === 0) {
      throw new TypeError('First argument must be defined');
    }
  }




  extend(array, false, false, {

    /***
     *
     * @method Array.isArray(<obj>)
     * @returns Boolean
     * @short Returns true if <obj> is an Array.
     * @extra This method is provided for browsers that don't support it internally.
     * @example
     *
     *   Array.isArray(3)        -> false
     *   Array.isArray(true)     -> false
     *   Array.isArray('wasabi') -> false
     *   Array.isArray([1,2,3])  -> true
     *
     ***/
    'isArray': function(obj) {
      return isArray(obj);
    }

  });


  extend(array, true, false, {

    /***
     * @method every(<f>, [scope])
     * @returns Boolean
     * @short Returns true if all elements in the array match <f>.
     * @extra [scope] is the %this% object. %all% is provided an alias. In addition to providing this method for browsers that don't support it natively, this method also implements @array_matching.
     * @example
     *
     +   ['a','a','a'].every(function(n) {
     *     return n == 'a';
     *   });
     *   ['a','a','a'].every('a')   -> true
     *   [{a:2},{a:2}].every({a:2}) -> true
     ***/
    'every': function(fn, scope) {
      var length = this.length, index = 0;
      checkFirstArgumentExists(arguments);
      while(index < length) {
        if(index in this && !fn.call(scope, this[index], index, this)) {
          return false;
        }
        index++;
      }
      return true;
    },

    /***
     * @method some(<f>, [scope])
     * @returns Boolean
     * @short Returns true if any element in the array matches <f>.
     * @extra [scope] is the %this% object. %any% is provided as an alias. In addition to providing this method for browsers that don't support it natively, this method also implements @array_matching.
     * @example
     *
     +   ['a','b','c'].some(function(n) {
     *     return n == 'a';
     *   });
     +   ['a','b','c'].some(function(n) {
     *     return n == 'd';
     *   });
     *   ['a','b','c'].some('a')   -> true
     *   [{a:2},{b:5}].some({a:2}) -> true
     ***/
    'some': function(fn, scope) {
      var length = this.length, index = 0;
      checkFirstArgumentExists(arguments);
      while(index < length) {
        if(index in this && fn.call(scope, this[index], index, this)) {
          return true;
        }
        index++;
      }
      return false;
    },

    /***
     * @method map(<map>, [scope])
     * @returns Array
     * @short Maps the array to another array containing the values that are the result of calling <map> on each element.
     * @extra [scope] is the %this% object. When <map> is a function, it receives three arguments: the current element, the current index, and a reference to the array. In addition to providing this method for browsers that don't support it natively, this enhanced method also directly accepts a string, which is a shortcut for a function that gets that property (or invokes a function) on each element.
     * @example
     *
     *   [1,2,3].map(function(n) {
     *     return n * 3;
     *   });                                  -> [3,6,9]
     *   ['one','two','three'].map(function(n) {
     *     return n.length;
     *   });                                  -> [3,3,5]
     *   ['one','two','three'].map('length')  -> [3,3,5]
     *
     ***/
    'map': function(fn, scope) {
      var scope = arguments[1], length = this.length, index = 0, result = new Array(length);
      checkFirstArgumentExists(arguments);
      while(index < length) {
        if(index in this) {
          result[index] = fn.call(scope, this[index], index, this);
        }
        index++;
      }
      return result;
    },

    /***
     * @method filter(<f>, [scope])
     * @returns Array
     * @short Returns any elements in the array that match <f>.
     * @extra [scope] is the %this% object. In addition to providing this method for browsers that don't support it natively, this method also implements @array_matching.
     * @example
     *
     +   [1,2,3].filter(function(n) {
     *     return n > 1;
     *   });
     *   [1,2,2,4].filter(2) -> 2
     *
     ***/
    'filter': function(fn) {
      var scope = arguments[1];
      var length = this.length, index = 0, result = [];
      checkFirstArgumentExists(arguments);
      while(index < length) {
        if(index in this && fn.call(scope, this[index], index, this)) {
          result.push(this[index]);
        }
        index++;
      }
      return result;
    },

    /***
     * @method indexOf(<search>, [fromIndex])
     * @returns Number
     * @short Searches the array and returns the first index where <search> occurs, or -1 if the element is not found.
     * @extra [fromIndex] is the index from which to begin the search. This method performs a simple strict equality comparison on <search>. It does not support enhanced functionality such as searching the contents against a regex, callback, or deep comparison of objects. For such functionality, use the %findIndex% method instead.
     * @example
     *
     *   [1,2,3].indexOf(3)           -> 1
     *   [1,2,3].indexOf(7)           -> -1
     *
     ***/
    'indexOf': function(search) {
      var fromIndex = arguments[1];
      if(isString(this)) return this.indexOf(search, fromIndex);
      return arrayIndexOf(this, search, fromIndex, 1);
    },

    /***
     * @method lastIndexOf(<search>, [fromIndex])
     * @returns Number
     * @short Searches the array and returns the last index where <search> occurs, or -1 if the element is not found.
     * @extra [fromIndex] is the index from which to begin the search. This method performs a simple strict equality comparison on <search>.
     * @example
     *
     *   [1,2,1].lastIndexOf(1)                 -> 2
     *   [1,2,1].lastIndexOf(7)                 -> -1
     *
     ***/
    'lastIndexOf': function(search) {
      var fromIndex = arguments[1];
      if(isString(this)) return this.lastIndexOf(search, fromIndex);
      return arrayIndexOf(this, search, fromIndex, -1);
    },

    /***
     * @method forEach([fn], [scope])
     * @returns Nothing
     * @short Iterates over the array, calling [fn] on each loop.
     * @extra This method is only provided for those browsers that do not support it natively. [scope] becomes the %this% object.
     * @example
     *
     *   ['a','b','c'].forEach(function(a) {
     *     // Called 3 times: 'a','b','c'
     *   });
     *
     ***/
    'forEach': function(fn) {
      var length = this.length, index = 0, scope = arguments[1];
      checkCallback(fn);
      while(index < length) {
        if(index in this) {
          fn.call(scope, this[index], index, this);
        }
        index++;
      }
    },

    /***
     * @method reduce(<fn>, [init])
     * @returns Mixed
     * @short Reduces the array to a single result.
     * @extra If [init] is passed as a starting value, that value will be passed as the first argument to the callback. The second argument will be the first element in the array. From that point, the result of the callback will then be used as the first argument of the next iteration. This is often refered to as "accumulation", and [init] is often called an "accumulator". If [init] is not passed, then <fn> will be called n - 1 times, where n is the length of the array. In this case, on the first iteration only, the first argument will be the first element of the array, and the second argument will be the second. After that callbacks work as normal, using the result of the previous callback as the first argument of the next. This method is only provided for those browsers that do not support it natively.
     *
     * @example
     *
     +   [1,2,3,4].reduce(function(a, b) {
     *     return a - b;
     *   });
     +   [1,2,3,4].reduce(function(a, b) {
     *     return a - b;
     *   }, 100);
     *
     ***/
    'reduce': function(fn) {
      return arrayReduce(this, fn, arguments[1]);
    },

    /***
     * @method reduceRight([fn], [init])
     * @returns Mixed
     * @short Identical to %Array#reduce%, but operates on the elements in reverse order.
     * @extra This method is only provided for those browsers that do not support it natively.
     *
     *
     *
     *
     * @example
     *
     +   [1,2,3,4].reduceRight(function(a, b) {
     *     return a - b;
     *   });
     *
     ***/
    'reduceRight': function(fn) {
      return arrayReduce(this, fn, arguments[1], true);
    }


  });




  /***
   * String module
   *
   ***/


  function buildTrim() {
    var support = getTrimmableCharacters().match(/^\s+$/);
    try { string.prototype.trim.call([1]); } catch(e) { support = false; }
    extend(string, true, !support, {

      /***
       * @method trim[Side]()
       * @returns String
       * @short Removes leading and/or trailing whitespace from the string.
       * @extra Whitespace is defined as line breaks, tabs, and any character in the "Space, Separator" Unicode category, conforming to the the ES5 spec. The standard %trim% method is only added when not fully supported natively.
       *
       * @set
       *   trim
       *   trimLeft
       *   trimRight
       *
       * @example
       *
       *   '   wasabi   '.trim()      -> 'wasabi'
       *   '   wasabi   '.trimLeft()  -> 'wasabi   '
       *   '   wasabi   '.trimRight() -> '   wasabi'
       *
       ***/
      'trim': function() {
        return this.toString().trimLeft().trimRight();
      },

      'trimLeft': function() {
        return this.replace(regexp('^['+getTrimmableCharacters()+']+'), '');
      },

      'trimRight': function() {
        return this.replace(regexp('['+getTrimmableCharacters()+']+$'), '');
      }
    });
  }



  /***
   * Function module
   *
   ***/


  extend(Function, true, false, {

     /***
     * @method bind(<scope>, [arg1], ...)
     * @returns Function
     * @short Binds <scope> as the %this% object for the function when it is called. Also allows currying an unlimited number of parameters.
     * @extra "currying" means setting parameters ([arg1], [arg2], etc.) ahead of time so that they are passed when the function is called later. If you pass additional parameters when the function is actually called, they will be added will be added to the end of the curried parameters. This method is provided for browsers that don't support it internally.
     * @example
     *
     +   (function() {
     *     return this;
     *   }).bind('woof')(); -> returns 'woof'; function is bound with 'woof' as the this object.
     *   (function(a) {
     *     return a;
     *   }).bind(1, 2)();   -> returns 2; function is bound with 1 as the this object and 2 curried as the first parameter
     *   (function(a, b) {
     *     return a + b;
     *   }).bind(1, 2)(3);  -> returns 5; function is bound with 1 as the this object, 2 curied as the first parameter and 3 passed as the second when calling the function
     *
     ***/
    'bind': function(scope) {
      var fn = this, args = multiArgs(arguments, null, 1), bound;
      if(!isFunction(this)) {
        throw new TypeError('Function.prototype.bind called on a non-function');
      }
      bound = function() {
        return fn.apply(fn.prototype && this instanceof fn ? this : scope, args.concat(multiArgs(arguments)));
      }
      bound.prototype = this.prototype;
      return bound;
    }

  });

  /***
   * Date module
   *
   ***/

   /***
   * @method toISOString()
   * @returns String
   * @short Formats the string to ISO8601 format.
   * @extra This will always format as UTC time. Provided for browsers that do not support this method.
   * @example
   *
   *   Date.create().toISOString() -> ex. 2011-07-05 12:24:55.528Z
   *
   ***
   * @method toJSON()
   * @returns String
   * @short Returns a JSON representation of the date.
   * @extra This is effectively an alias for %toISOString%. Will always return the date in UTC time. Provided for browsers that do not support this method.
   * @example
   *
   *   Date.create().toJSON() -> ex. 2011-07-05 12:24:55.528Z
   *
   ***/

  extend(date, false, false, {

     /***
     * @method Date.now()
     * @returns String
     * @short Returns the number of milliseconds since January 1st, 1970 00:00:00 (UTC time).
     * @extra Provided for browsers that do not support this method.
     * @example
     *
     *   Date.now() -> ex. 1311938296231
     *
     ***/
    'now': function() {
      return new date().getTime();
    }

  });

   function buildISOString() {
    var d = new date(date.UTC(1999, 11, 31)), target = '1999-12-31T00:00:00.000Z';
    var support = d.toISOString && d.toISOString() === target;
    extendSimilar(date, true, !support, 'toISOString,toJSON', function(methods, name) {
      methods[name] = function() {
        return padNumber(this.getUTCFullYear(), 4) + '-' +
               padNumber(this.getUTCMonth() + 1, 2) + '-' +
               padNumber(this.getUTCDate(), 2) + 'T' +
               padNumber(this.getUTCHours(), 2) + ':' +
               padNumber(this.getUTCMinutes(), 2) + ':' +
               padNumber(this.getUTCSeconds(), 2) + '.' +
               padNumber(this.getUTCMilliseconds(), 3) + 'Z';
      }
    });
   }

  // Initialize
  buildTrim();
  buildISOString();


  /***
   * @package Array
   * @dependency core
   * @description Array manipulation and traversal, "fuzzy matching" against elements, alphanumeric sorting and collation, enumerable methods on Object.
   *
   ***/


  function regexMatcher(reg) {
    reg = regexp(reg);
    return function (el) {
      return reg.test(el);
    }
  }

  function dateMatcher(d) {
    var ms = d.getTime();
    return function (el) {
      return !!(el && el.getTime) && el.getTime() === ms;
    }
  }

  function functionMatcher(fn) {
    return function (el, i, arr) {
      // Return true up front if match by reference
      return el === fn || fn.call(this, el, i, arr);
    }
  }

  function invertedArgsFunctionMatcher(fn) {
    return function (value, key, obj) {
      // Return true up front if match by reference
      return value === fn || fn.call(obj, key, value, obj);
    }
  }

  function fuzzyMatcher(obj, isObject) {
    var matchers = {};
    return function (el, i, arr) {
      var key;
      if(!isObjectType(el)) {
        return false;
      }
      for(key in obj) {
        matchers[key] = matchers[key] || getMatcher(obj[key], isObject);
        if(matchers[key].call(arr, el[key], i, arr) === false) {
          return false;
        }
      }
      return true;
    }
  }

  function defaultMatcher(f) {
    return function (el) {
      return el === f || isEqual(el, f);
    }
  }

  function getMatcher(f, isObject) {
    if(isPrimitiveType(f)) {
      // Do nothing and fall through to the
      // default matcher below.
    } else if(isRegExp(f)) {
      // Match against a regexp
      return regexMatcher(f);
    } else if(isDate(f)) {
      // Match against a date. isEqual below should also
      // catch this but matching directly up front for speed.
      return dateMatcher(f);
    } else if(isFunction(f)) {
      // Match against a filtering function
      if(isObject) {
        return invertedArgsFunctionMatcher(f);
      } else {
        return functionMatcher(f);
      }
    } else if(isPlainObject(f)) {
      // Match against a fuzzy hash or array.
      return fuzzyMatcher(f, isObject);
    }
    // Default is standard isEqual
    return defaultMatcher(f);
  }

  function transformArgument(el, map, context, mapArgs) {
    if(!map) {
      return el;
    } else if(map.apply) {
      return map.apply(context, mapArgs || []);
    } else if(isFunction(el[map])) {
      return el[map].call(el);
    } else {
      return el[map];
    }
  }

  // Basic array internal methods

  function arrayEach(arr, fn, startIndex, loop) {
    var index, i, length = +arr.length;
    if(startIndex < 0) startIndex = arr.length + startIndex;
    i = isNaN(startIndex) ? 0 : startIndex;
    if(loop === true) {
      length += i;
    }
    while(i < length) {
      index = i % arr.length;
      if(!(index in arr)) {
        return iterateOverSparseArray(arr, fn, i, loop);
      } else if(fn.call(arr, arr[index], index, arr) === false) {
        break;
      }
      i++;
    }
  }

  function iterateOverSparseArray(arr, fn, fromIndex, loop) {
    var indexes = [], i;
    for(i in arr) {
      if(isArrayIndex(arr, i) && i >= fromIndex) {
        indexes.push(parseInt(i));
      }
    }
    indexes.sort().each(function(index) {
      return fn.call(arr, arr[index], index, arr);
    });
    return arr;
  }

  function isArrayIndex(arr, i) {
    return i in arr && toUInt32(i) == i && i != 0xffffffff;
  }

  function toUInt32(i) {
    return i >>> 0;
  }

  function arrayFind(arr, f, startIndex, loop, returnIndex, context) {
    var result, index, matcher;
    if(arr.length > 0) {
      matcher = getMatcher(f);
      arrayEach(arr, function(el, i) {
        if(matcher.call(context, el, i, arr)) {
          result = el;
          index = i;
          return false;
        }
      }, startIndex, loop);
    }
    return returnIndex ? index : result;
  }

  function arrayUnique(arr, map) {
    var result = [], o = {}, transformed;
    arrayEach(arr, function(el, i) {
      transformed = map ? transformArgument(el, map, arr, [el, i, arr]) : el;
      if(!checkForElementInHashAndSet(o, transformed)) {
        result.push(el);
      }
    })
    return result;
  }

  function arrayIntersect(arr1, arr2, subtract) {
    var result = [], o = {};
    arr2.each(function(el) {
      checkForElementInHashAndSet(o, el);
    });
    arr1.each(function(el) {
      var stringified = stringify(el),
          isReference = !objectIsMatchedByValue(el);
      // Add the result to the array if:
      // 1. We're subtracting intersections or it doesn't already exist in the result and
      // 2. It exists in the compared array and we're adding, or it doesn't exist and we're removing.
      if(elementExistsInHash(o, stringified, el, isReference) !== subtract) {
        discardElementFromHash(o, stringified, el, isReference);
        result.push(el);
      }
    });
    return result;
  }

  function arrayFlatten(arr, level, current) {
    level = level || Infinity;
    current = current || 0;
    var result = [];
    arrayEach(arr, function(el) {
      if(isArray(el) && current < level) {
        result = result.concat(arrayFlatten(el, level, current + 1));
      } else {
        result.push(el);
      }
    });
    return result;
  }

  function isArrayLike(obj) {
    return hasProperty(obj, 'length') && !isString(obj) && !isPlainObject(obj);
  }

  function isArgumentsObject(obj) {
    // .callee exists on Arguments objects in < IE8
    return hasProperty(obj, 'length') && (className(obj) === '[object Arguments]' || !!obj.callee);
  }

  function flatArguments(args) {
    var result = [];
    multiArgs(args, function(arg) {
      result = result.concat(arg);
    });
    return result;
  }

  function elementExistsInHash(hash, key, element, isReference) {
    var exists = key in hash;
    if(isReference) {
      if(!hash[key]) {
        hash[key] = [];
      }
      exists = hash[key].indexOf(element) !== -1;
    }
    return exists;
  }

  function checkForElementInHashAndSet(hash, element) {
    var stringified = stringify(element),
        isReference = !objectIsMatchedByValue(element),
        exists      = elementExistsInHash(hash, stringified, element, isReference);
    if(isReference) {
      hash[stringified].push(element);
    } else {
      hash[stringified] = element;
    }
    return exists;
  }

  function discardElementFromHash(hash, key, element, isReference) {
    var arr, i = 0;
    if(isReference) {
      arr = hash[key];
      while(i < arr.length) {
        if(arr[i] === element) {
          arr.splice(i, 1);
        } else {
          i += 1;
        }
      }
    } else {
      delete hash[key];
    }
  }

  // Support methods

  function getMinOrMax(obj, map, which, all) {
    var el,
        key,
        edge,
        test,
        result = [],
        max = which === 'max',
        min = which === 'min',
        isArray = array.isArray(obj);
    for(key in obj) {
      if(!obj.hasOwnProperty(key)) continue;
      el   = obj[key];
      test = transformArgument(el, map, obj, isArray ? [el, parseInt(key), obj] : []);
      if(isUndefined(test)) {
        throw new TypeError('Cannot compare with undefined');
      }
      if(test === edge) {
        result.push(el);
      } else if(isUndefined(edge) || (max && test > edge) || (min && test < edge)) {
        result = [el];
        edge = test;
      }
    }
    if(!isArray) result = arrayFlatten(result, 1);
    return all ? result : result[0];
  }


  // Alphanumeric collation helpers

  function collateStrings(a, b) {
    var aValue, bValue, aChar, bChar, aEquiv, bEquiv, index = 0, tiebreaker = 0;

    var sortIgnore      = array[AlphanumericSortIgnore];
    var sortIgnoreCase  = array[AlphanumericSortIgnoreCase];
    var sortEquivalents = array[AlphanumericSortEquivalents];
    var sortOrder       = array[AlphanumericSortOrder];
    var naturalSort     = array[AlphanumericSortNatural];

    a = getCollationReadyString(a, sortIgnore, sortIgnoreCase);
    b = getCollationReadyString(b, sortIgnore, sortIgnoreCase);

    do {

      aChar  = getCollationCharacter(a, index, sortEquivalents);
      bChar  = getCollationCharacter(b, index, sortEquivalents);
      aValue = getSortOrderIndex(aChar, sortOrder);
      bValue = getSortOrderIndex(bChar, sortOrder);

      if(aValue === -1 || bValue === -1) {
        aValue = a.charCodeAt(index) || null;
        bValue = b.charCodeAt(index) || null;
        if(naturalSort && codeIsNumeral(aValue) && codeIsNumeral(bValue)) {
          aValue = stringToNumber(a.slice(index));
          bValue = stringToNumber(b.slice(index));
        }
      } else {
        aEquiv = aChar !== a.charAt(index);
        bEquiv = bChar !== b.charAt(index);
        if(aEquiv !== bEquiv && tiebreaker === 0) {
          tiebreaker = aEquiv - bEquiv;
        }
      }
      index += 1;
    } while(aValue != null && bValue != null && aValue === bValue);
    if(aValue === bValue) return tiebreaker;
    return aValue - bValue;
  }

  function getCollationReadyString(str, sortIgnore, sortIgnoreCase) {
    if(!isString(str)) str = string(str);
    if(sortIgnoreCase) {
      str = str.toLowerCase();
    }
    if(sortIgnore) {
      str = str.replace(sortIgnore, '');
    }
    return str;
  }

  function getCollationCharacter(str, index, sortEquivalents) {
    var chr = str.charAt(index);
    return sortEquivalents[chr] || chr;
  }

  function getSortOrderIndex(chr, sortOrder) {
    if(!chr) {
      return null;
    } else {
      return sortOrder.indexOf(chr);
    }
  }

  var AlphanumericSort            = 'AlphanumericSort';
  var AlphanumericSortOrder       = 'AlphanumericSortOrder';
  var AlphanumericSortIgnore      = 'AlphanumericSortIgnore';
  var AlphanumericSortIgnoreCase  = 'AlphanumericSortIgnoreCase';
  var AlphanumericSortEquivalents = 'AlphanumericSortEquivalents';
  var AlphanumericSortNatural     = 'AlphanumericSortNatural';



  function buildEnhancements() {
    var nativeMap = array.prototype.map;
    var callbackCheck = function() {
      var args = arguments;
      return args.length > 0 && !isFunction(args[0]);
    };
    extendSimilar(array, true, callbackCheck, 'every,all,some,filter,any,none,find,findIndex', function(methods, name) {
      var nativeFn = array.prototype[name]
      methods[name] = function(f) {
        var matcher = getMatcher(f);
        return nativeFn.call(this, function(el, index) {
          return matcher(el, index, this);
        });
      }
    });
    extend(array, true, callbackCheck, {
      'map': function(f) {
        return nativeMap.call(this, function(el, index) {
          return transformArgument(el, f, this, [el, index, this]);
        });
      }
    });
  }

  function buildAlphanumericSort() {
    var order = 'AÁÀÂÃĄBCĆČÇDĎÐEÉÈĚÊËĘFGĞHıIÍÌİÎÏJKLŁMNŃŇÑOÓÒÔPQRŘSŚŠŞTŤUÚÙŮÛÜVWXYÝZŹŻŽÞÆŒØÕÅÄÖ';
    var equiv = 'AÁÀÂÃÄ,CÇ,EÉÈÊË,IÍÌİÎÏ,OÓÒÔÕÖ,Sß,UÚÙÛÜ';
    array[AlphanumericSortOrder] = order.split('').map(function(str) {
      return str + str.toLowerCase();
    }).join('');
    var equivalents = {};
    arrayEach(equiv.split(','), function(set) {
      var equivalent = set.charAt(0);
      arrayEach(set.slice(1).split(''), function(chr) {
        equivalents[chr] = equivalent;
        equivalents[chr.toLowerCase()] = equivalent.toLowerCase();
      });
    });
    array[AlphanumericSortNatural] = true;
    array[AlphanumericSortIgnoreCase] = true;
    array[AlphanumericSortEquivalents] = equivalents;
  }

  extend(array, false, true, {

    /***
     *
     * @method Array.create(<obj1>, <obj2>, ...)
     * @returns Array
     * @short Alternate array constructor.
     * @extra This method will create a single array by calling %concat% on all arguments passed. In addition to ensuring that an unknown variable is in a single, flat array (the standard constructor will create nested arrays, this one will not), it is also a useful shorthand to convert a function's arguments object into a standard array.
     * @example
     *
     *   Array.create('one', true, 3)   -> ['one', true, 3]
     *   Array.create(['one', true, 3]) -> ['one', true, 3]
     +   Array.create(function(n) {
     *     return arguments;
     *   }('howdy', 'doody'));
     *
     ***/
    'create': function() {
      var result = [];
      multiArgs(arguments, function(a) {
        if(isArgumentsObject(a) || isArrayLike(a)) {
          a = array.prototype.slice.call(a, 0);
        }
        result = result.concat(a);
      });
      return result;
    }

  });

  extend(array, true, false, {

    /***
     * @method find(<f>, [context] = undefined)
     * @returns Mixed
     * @short Returns the first element that matches <f>.
     * @extra [context] is the %this% object if passed. When <f> is a function, will use native implementation if it exists. <f> will also match a string, number, array, object, or alternately test against a function or regex. This method implements @array_matching.
     * @example
     *
     +   [{a:1,b:2},{a:1,b:3},{a:1,b:4}].find(function(n) {
     *     return n['a'] == 1;
     *   });                                  -> {a:1,b:3}
     *   ['cuba','japan','canada'].find(/^c/) -> 'cuba'
     *
     ***/
    'find': function(f, context) {
      checkCallback(f);
      return arrayFind(this, f, 0, false, false, context);
    },

    /***
     * @method findIndex(<f>, [context] = undefined)
     * @returns Number
     * @short Returns the index of the first element that matches <f> or -1 if not found.
     * @extra [context] is the %this% object if passed. When <f> is a function, will use native implementation if it exists. <f> will also match a string, number, array, object, or alternately test against a function or regex. This method implements @array_matching.
     *
     * @example
     *
     +   [1,2,3,4].findIndex(function(n) {
     *     return n % 2 == 0;
     *   }); -> 1
     +   [1,2,3,4].findIndex(3);               -> 2
     +   ['one','two','three'].findIndex(/t/); -> 1
     *
     ***/
    'findIndex': function(f, context) {
      var index;
      checkCallback(f);
      index = arrayFind(this, f, 0, false, true, context);
      return isUndefined(index) ? -1 : index;
    }

  });

  extend(array, true, true, {

    /***
     * @method findFrom(<f>, [index] = 0, [loop] = false)
     * @returns Array
     * @short Returns any element that matches <f>, beginning from [index].
     * @extra <f> will match a string, number, array, object, or alternately test against a function or regex. Will continue from index = 0 if [loop] is true. This method implements @array_matching.
     * @example
     *
     *   ['cuba','japan','canada'].findFrom(/^c/, 2) -> 'canada'
     *
     ***/
    'findFrom': function(f, index, loop) {
      return arrayFind(this, f, index, loop);
    },

    /***
     * @method findIndexFrom(<f>, [index] = 0, [loop] = false)
     * @returns Array
     * @short Returns the index of any element that matches <f>, beginning from [index].
     * @extra <f> will match a string, number, array, object, or alternately test against a function or regex. Will continue from index = 0 if [loop] is true. This method implements @array_matching.
     * @example
     *
     *   ['cuba','japan','canada'].findIndexFrom(/^c/, 2) -> 2
     *
     ***/
    'findIndexFrom': function(f, index, loop) {
      var index = arrayFind(this, f, index, loop, true);
      return isUndefined(index) ? -1 : index;
    },

    /***
     * @method findAll(<f>, [index] = 0, [loop] = false)
     * @returns Array
     * @short Returns all elements that match <f>.
     * @extra <f> will match a string, number, array, object, or alternately test against a function or regex. Starts at [index], and will continue once from index = 0 if [loop] is true. This method implements @array_matching.
     * @example
     *
     +   [{a:1,b:2},{a:1,b:3},{a:2,b:4}].findAll(function(n) {
     *     return n['a'] == 1;
     *   });                                        -> [{a:1,b:3},{a:1,b:4}]
     *   ['cuba','japan','canada'].findAll(/^c/)    -> 'cuba','canada'
     *   ['cuba','japan','canada'].findAll(/^c/, 2) -> 'canada'
     *
     ***/
    'findAll': function(f, index, loop) {
      var result = [], matcher;
      if(this.length > 0) {
        matcher = getMatcher(f);
        arrayEach(this, function(el, i, arr) {
          if(matcher(el, i, arr)) {
            result.push(el);
          }
        }, index, loop);
      }
      return result;
    },

    /***
     * @method count(<f>)
     * @returns Number
     * @short Counts all elements in the array that match <f>.
     * @extra <f> will match a string, number, array, object, or alternately test against a function or regex. This method implements @array_matching.
     * @example
     *
     *   [1,2,3,1].count(1)       -> 2
     *   ['a','b','c'].count(/b/) -> 1
     +   [{a:1},{b:2}].count(function(n) {
     *     return n['a'] > 1;
     *   });                      -> 0
     *
     ***/
    'count': function(f) {
      if(isUndefined(f)) return this.length;
      return this.findAll(f).length;
    },

    /***
     * @method removeAt(<start>, [end])
     * @returns Array
     * @short Removes element at <start>. If [end] is specified, removes the range between <start> and [end]. This method will change the array! If you don't intend the array to be changed use %clone% first.
     * @example
     *
     *   ['a','b','c'].removeAt(0) -> ['b','c']
     *   [1,2,3,4].removeAt(1, 3)  -> [1]
     *
     ***/
    'removeAt': function(start, end) {
      if(isUndefined(start)) return this;
      if(isUndefined(end))   end = start;
      this.splice(start, end - start + 1);
      return this;
    },

    /***
     * @method include(<el>, [index])
     * @returns Array
     * @short Adds <el> to the array.
     * @extra This is a non-destructive alias for %add%. It will not change the original array.
     * @example
     *
     *   [1,2,3,4].include(5)       -> [1,2,3,4,5]
     *   [1,2,3,4].include(8, 1)    -> [1,8,2,3,4]
     *   [1,2,3,4].include([5,6,7]) -> [1,2,3,4,5,6,7]
     *
     ***/
    'include': function(el, index) {
      return this.clone().add(el, index);
    },

    /***
     * @method exclude([f1], [f2], ...)
     * @returns Array
     * @short Removes any element in the array that matches [f1], [f2], etc.
     * @extra This is a non-destructive alias for %remove%. It will not change the original array. This method implements @array_matching.
     * @example
     *
     *   [1,2,3].exclude(3)         -> [1,2]
     *   ['a','b','c'].exclude(/b/) -> ['a','c']
     +   [{a:1},{b:2}].exclude(function(n) {
     *     return n['a'] == 1;
     *   });                       -> [{b:2}]
     *
     ***/
    'exclude': function() {
      return array.prototype.remove.apply(this.clone(), arguments);
    },

    /***
     * @method clone()
     * @returns Array
     * @short Makes a shallow clone of the array.
     * @example
     *
     *   [1,2,3].clone() -> [1,2,3]
     *
     ***/
    'clone': function() {
      return simpleMerge([], this);
    },

    /***
     * @method unique([map] = null)
     * @returns Array
     * @short Removes all duplicate elements in the array.
     * @extra [map] may be a function mapping the value to be uniqued on or a string acting as a shortcut. This is most commonly used when you have a key that ensures the object's uniqueness, and don't need to check all fields. This method will also correctly operate on arrays of objects.
     * @example
     *
     *   [1,2,2,3].unique()                 -> [1,2,3]
     *   [{foo:'bar'},{foo:'bar'}].unique() -> [{foo:'bar'}]
     +   [{foo:'bar'},{foo:'bar'}].unique(function(obj){
     *     return obj.foo;
     *   }); -> [{foo:'bar'}]
     *   [{foo:'bar'},{foo:'bar'}].unique('foo') -> [{foo:'bar'}]
     *
     ***/
    'unique': function(map) {
      return arrayUnique(this, map);
    },

    /***
     * @method flatten([limit] = Infinity)
     * @returns Array
     * @short Returns a flattened, one-dimensional copy of the array.
     * @extra You can optionally specify a [limit], which will only flatten that depth.
     * @example
     *
     *   [[1], 2, [3]].flatten()      -> [1,2,3]
     *   [['a'],[],'b','c'].flatten() -> ['a','b','c']
     *
     ***/
    'flatten': function(limit) {
      return arrayFlatten(this, limit);
    },

    /***
     * @method union([a1], [a2], ...)
     * @returns Array
     * @short Returns an array containing all elements in all arrays with duplicates removed.
     * @extra This method will also correctly operate on arrays of objects.
     * @example
     *
     *   [1,3,5].union([5,7,9])     -> [1,3,5,7,9]
     *   ['a','b'].union(['b','c']) -> ['a','b','c']
     *
     ***/
    'union': function() {
      return arrayUnique(this.concat(flatArguments(arguments)));
    },

    /***
     * @method intersect([a1], [a2], ...)
     * @returns Array
     * @short Returns an array containing the elements all arrays have in common.
     * @extra This method will also correctly operate on arrays of objects.
     * @example
     *
     *   [1,3,5].intersect([5,7,9])   -> [5]
     *   ['a','b'].intersect('b','c') -> ['b']
     *
     ***/
    'intersect': function() {
      return arrayIntersect(this, flatArguments(arguments), false);
    },

    /***
     * @method subtract([a1], [a2], ...)
     * @returns Array
     * @short Subtracts from the array all elements in [a1], [a2], etc.
     * @extra This method will also correctly operate on arrays of objects.
     * @example
     *
     *   [1,3,5].subtract([5,7,9])   -> [1,3]
     *   [1,3,5].subtract([3],[5])   -> [1]
     *   ['a','b'].subtract('b','c') -> ['a']
     *
     ***/
    'subtract': function(a) {
      return arrayIntersect(this, flatArguments(arguments), true);
    },

    /***
     * @method at(<index>, [loop] = true)
     * @returns Mixed
     * @short Gets the element(s) at a given index.
     * @extra When [loop] is true, overshooting the end of the array (or the beginning) will begin counting from the other end. As an alternate syntax, passing multiple indexes will get the elements at those indexes.
     * @example
     *
     *   [1,2,3].at(0)        -> 1
     *   [1,2,3].at(2)        -> 3
     *   [1,2,3].at(4)        -> 2
     *   [1,2,3].at(4, false) -> null
     *   [1,2,3].at(-1)       -> 3
     *   [1,2,3].at(0,1)      -> [1,2]
     *
     ***/
    'at': function() {
      return getEntriesForIndexes(this, arguments);
    },

    /***
     * @method first([num] = 1)
     * @returns Mixed
     * @short Returns the first element(s) in the array.
     * @extra When <num> is passed, returns the first <num> elements in the array.
     * @example
     *
     *   [1,2,3].first()        -> 1
     *   [1,2,3].first(2)       -> [1,2]
     *
     ***/
    'first': function(num) {
      if(isUndefined(num)) return this[0];
      if(num < 0) num = 0;
      return this.slice(0, num);
    },

    /***
     * @method last([num] = 1)
     * @returns Mixed
     * @short Returns the last element(s) in the array.
     * @extra When <num> is passed, returns the last <num> elements in the array.
     * @example
     *
     *   [1,2,3].last()        -> 3
     *   [1,2,3].last(2)       -> [2,3]
     *
     ***/
    'last': function(num) {
      if(isUndefined(num)) return this[this.length - 1];
      var start = this.length - num < 0 ? 0 : this.length - num;
      return this.slice(start);
    },

    /***
     * @method from(<index>)
     * @returns Array
     * @short Returns a slice of the array from <index>.
     * @example
     *
     *   [1,2,3].from(1)  -> [2,3]
     *   [1,2,3].from(2)  -> [3]
     *
     ***/
    'from': function(num) {
      return this.slice(num);
    },

    /***
     * @method to(<index>)
     * @returns Array
     * @short Returns a slice of the array up to <index>.
     * @example
     *
     *   [1,2,3].to(1)  -> [1]
     *   [1,2,3].to(2)  -> [1,2]
     *
     ***/
    'to': function(num) {
      if(isUndefined(num)) num = this.length;
      return this.slice(0, num);
    },

    /***
     * @method min([map], [all] = false)
     * @returns Mixed
     * @short Returns the element in the array with the lowest value.
     * @extra [map] may be a function mapping the value to be checked or a string acting as a shortcut. If [all] is true, will return all min values in an array.
     * @example
     *
     *   [1,2,3].min()                          -> 1
     *   ['fee','fo','fum'].min('length')       -> 'fo'
     *   ['fee','fo','fum'].min('length', true) -> ['fo']
     +   ['fee','fo','fum'].min(function(n) {
     *     return n.length;
     *   });                              -> ['fo']
     +   [{a:3,a:2}].min(function(n) {
     *     return n['a'];
     *   });                              -> [{a:2}]
     *
     ***/
    'min': function(map, all) {
      return getMinOrMax(this, map, 'min', all);
    },

    /***
     * @method max([map], [all] = false)
     * @returns Mixed
     * @short Returns the element in the array with the greatest value.
     * @extra [map] may be a function mapping the value to be checked or a string acting as a shortcut. If [all] is true, will return all max values in an array.
     * @example
     *
     *   [1,2,3].max()                          -> 3
     *   ['fee','fo','fum'].max('length')       -> 'fee'
     *   ['fee','fo','fum'].max('length', true) -> ['fee']
     +   [{a:3,a:2}].max(function(n) {
     *     return n['a'];
     *   });                              -> {a:3}
     *
     ***/
    'max': function(map, all) {
      return getMinOrMax(this, map, 'max', all);
    },

    /***
     * @method least([map])
     * @returns Array
     * @short Returns the elements in the array with the least commonly occuring value.
     * @extra [map] may be a function mapping the value to be checked or a string acting as a shortcut.
     * @example
     *
     *   [3,2,2].least()                   -> [3]
     *   ['fe','fo','fum'].least('length') -> ['fum']
     +   [{age:35,name:'ken'},{age:12,name:'bob'},{age:12,name:'ted'}].least(function(n) {
     *     return n.age;
     *   });                               -> [{age:35,name:'ken'}]
     *
     ***/
    'least': function(map, all) {
      return getMinOrMax(this.groupBy.apply(this, [map]), 'length', 'min', all);
    },

    /***
     * @method most([map])
     * @returns Array
     * @short Returns the elements in the array with the most commonly occuring value.
     * @extra [map] may be a function mapping the value to be checked or a string acting as a shortcut.
     * @example
     *
     *   [3,2,2].most()                   -> [2]
     *   ['fe','fo','fum'].most('length') -> ['fe','fo']
     +   [{age:35,name:'ken'},{age:12,name:'bob'},{age:12,name:'ted'}].most(function(n) {
     *     return n.age;
     *   });                              -> [{age:12,name:'bob'},{age:12,name:'ted'}]
     *
     ***/
    'most': function(map, all) {
      return getMinOrMax(this.groupBy.apply(this, [map]), 'length', 'max', all);
    },

    /***
     * @method sum([map])
     * @returns Number
     * @short Sums all values in the array.
     * @extra [map] may be a function mapping the value to be summed or a string acting as a shortcut.
     * @example
     *
     *   [1,2,2].sum()                           -> 5
     +   [{age:35},{age:12},{age:12}].sum(function(n) {
     *     return n.age;
     *   });                                     -> 59
     *   [{age:35},{age:12},{age:12}].sum('age') -> 59
     *
     ***/
    'sum': function(map) {
      var arr = map ? this.map(map) : this;
      return arr.length > 0 ? arr.reduce(function(a,b) { return a + b; }) : 0;
    },

    /***
     * @method average([map])
     * @returns Number
     * @short Gets the mean average for all values in the array.
     * @extra [map] may be a function mapping the value to be averaged or a string acting as a shortcut.
     * @example
     *
     *   [1,2,3].average()                           -> 2
     +   [{age:35},{age:11},{age:11}].average(function(n) {
     *     return n.age;
     *   });                                         -> 19
     *   [{age:35},{age:11},{age:11}].average('age') -> 19
     *
     ***/
    'average': function(map) {
      var arr = map ? this.map(map) : this;
      return arr.length > 0 ? arr.sum() / arr.length : 0;
    },

    /***
     * @method inGroups(<num>, [padding])
     * @returns Array
     * @short Groups the array into <num> arrays.
     * @extra [padding] specifies a value with which to pad the last array so that they are all equal length.
     * @example
     *
     *   [1,2,3,4,5,6,7].inGroups(3)         -> [ [1,2,3], [4,5,6], [7] ]
     *   [1,2,3,4,5,6,7].inGroups(3, 'none') -> [ [1,2,3], [4,5,6], [7,'none','none'] ]
     *
     ***/
    'inGroups': function(num, padding) {
      var pad = arguments.length > 1;
      var arr = this;
      var result = [];
      var divisor = ceil(this.length / num);
      simpleRepeat(num, function(i) {
        var index = i * divisor;
        var group = arr.slice(index, index + divisor);
        if(pad && group.length < divisor) {
          simpleRepeat(divisor - group.length, function() {
            group = group.add(padding);
          });
        }
        result.push(group);
      });
      return result;
    },

    /***
     * @method inGroupsOf(<num>, [padding] = null)
     * @returns Array
     * @short Groups the array into arrays of <num> elements each.
     * @extra [padding] specifies a value with which to pad the last array so that they are all equal length.
     * @example
     *
     *   [1,2,3,4,5,6,7].inGroupsOf(4)         -> [ [1,2,3,4], [5,6,7] ]
     *   [1,2,3,4,5,6,7].inGroupsOf(4, 'none') -> [ [1,2,3,4], [5,6,7,'none'] ]
     *
     ***/
    'inGroupsOf': function(num, padding) {
      var result = [], len = this.length, arr = this, group;
      if(len === 0 || num === 0) return arr;
      if(isUndefined(num)) num = 1;
      if(isUndefined(padding)) padding = null;
      simpleRepeat(ceil(len / num), function(i) {
        group = arr.slice(num * i, num * i + num);
        while(group.length < num) {
          group.push(padding);
        }
        result.push(group);
      });
      return result;
    },

    /***
     * @method isEmpty()
     * @returns Boolean
     * @short Returns true if the array is empty.
     * @extra This is true if the array has a length of zero, or contains only %undefined%, %null%, or %NaN%.
     * @example
     *
     *   [].isEmpty()               -> true
     *   [null,undefined].isEmpty() -> true
     *
     ***/
    'isEmpty': function() {
      return this.compact().length == 0;
    },

    /***
     * @method sortBy(<map>, [desc] = false)
     * @returns Array
     * @short Sorts the array by <map>.
     * @extra <map> may be a function, a string acting as a shortcut, or blank (direct comparison of array values). [desc] will sort the array in descending order. When the field being sorted on is a string, the resulting order will be determined by an internal collation algorithm that is optimized for major Western languages, but can be customized. For more information see @array_sorting.
     * @example
     *
     *   ['world','a','new'].sortBy('length')       -> ['a','new','world']
     *   ['world','a','new'].sortBy('length', true) -> ['world','new','a']
     +   [{age:72},{age:13},{age:18}].sortBy(function(n) {
     *     return n.age;
     *   });                                        -> [{age:13},{age:18},{age:72}]
     *
     ***/
    'sortBy': function(map, desc) {
      var arr = this.clone();
      arr.sort(function(a, b) {
        var aProperty, bProperty, comp;
        aProperty = transformArgument(a, map, arr, [a]);
        bProperty = transformArgument(b, map, arr, [b]);
        if(isString(aProperty) && isString(bProperty)) {
          comp = collateStrings(aProperty, bProperty);
        } else if(aProperty < bProperty) {
          comp = -1;
        } else if(aProperty > bProperty) {
          comp = 1;
        } else {
          comp = 0;
        }
        return comp * (desc ? -1 : 1);
      });
      return arr;
    },

    /***
     * @method randomize()
     * @returns Array
     * @short Returns a copy of the array with the elements randomized.
     * @extra Uses Fisher-Yates algorithm.
     * @example
     *
     *   [1,2,3,4].randomize()  -> [?,?,?,?]
     *
     ***/
    'randomize': function() {
      var arr = this.concat(), i = arr.length, j, x;
      while(i) {
        j = (math.random() * i) | 0;
        x = arr[--i];
        arr[i] = arr[j];
        arr[j] = x;
      }
      return arr;
    },

    /***
     * @method zip([arr1], [arr2], ...)
     * @returns Array
     * @short Merges multiple arrays together.
     * @extra This method "zips up" smaller arrays into one large whose elements are "all elements at index 0", "all elements at index 1", etc. Useful when you have associated data that is split over separated arrays. If the arrays passed have more elements than the original array, they will be discarded. If they have fewer elements, the missing elements will filled with %null%.
     * @example
     *
     *   [1,2,3].zip([4,5,6])                                       -> [[1,2], [3,4], [5,6]]
     *   ['Martin','John'].zip(['Luther','F.'], ['King','Kennedy']) -> [['Martin','Luther','King'], ['John','F.','Kennedy']]
     *
     ***/
    'zip': function() {
      var args = multiArgs(arguments);
      return this.map(function(el, i) {
        return [el].concat(args.map(function(k) {
          return (i in k) ? k[i] : null;
        }));
      });
    },

    /***
     * @method sample([num])
     * @returns Mixed
     * @short Returns a random element from the array.
     * @extra If [num] is passed, will return [num] samples from the array.
     * @example
     *
     *   [1,2,3,4,5].sample()  -> // Random element
     *   [1,2,3,4,5].sample(3) -> // Array of 3 random elements
     *
     ***/
    'sample': function(num) {
      var arr = this.randomize();
      return arguments.length > 0 ? arr.slice(0, num) : arr[0];
    },

    /***
     * @method each(<fn>, [index] = 0, [loop] = false)
     * @returns Array
     * @short Runs <fn> against each element in the array. Enhanced version of %Array#forEach%.
     * @extra Parameters passed to <fn> are identical to %forEach%, ie. the first parameter is the current element, second parameter is the current index, and third parameter is the array itself. If <fn> returns %false% at any time it will break out of the loop. Once %each% finishes, it will return the array. If [index] is passed, <fn> will begin at that index and work its way to the end. If [loop] is true, it will then start over from the beginning of the array and continue until it reaches [index] - 1.
     * @example
     *
     *   [1,2,3,4].each(function(n) {
     *     // Called 4 times: 1, 2, 3, 4
     *   });
     *   [1,2,3,4].each(function(n) {
     *     // Called 4 times: 3, 4, 1, 2
     *   }, 2, true);
     *
     ***/
    'each': function(fn, index, loop) {
      arrayEach(this, fn, index, loop);
      return this;
    },

    /***
     * @method add(<el>, [index])
     * @returns Array
     * @short Adds <el> to the array.
     * @extra If [index] is specified, it will add at [index], otherwise adds to the end of the array. %add% behaves like %concat% in that if <el> is an array it will be joined, not inserted. This method will change the array! Use %include% for a non-destructive alias. Also, %insert% is provided as an alias that reads better when using an index.
     * @example
     *
     *   [1,2,3,4].add(5)       -> [1,2,3,4,5]
     *   [1,2,3,4].add([5,6,7]) -> [1,2,3,4,5,6,7]
     *   [1,2,3,4].insert(8, 1) -> [1,8,2,3,4]
     *
     ***/
    'add': function(el, index) {
      if(!isNumber(number(index)) || isNaN(index)) index = this.length;
      array.prototype.splice.apply(this, [index, 0].concat(el));
      return this;
    },

    /***
     * @method remove([f1], [f2], ...)
     * @returns Array
     * @short Removes any element in the array that matches [f1], [f2], etc.
     * @extra Will match a string, number, array, object, or alternately test against a function or regex. This method will change the array! Use %exclude% for a non-destructive alias. This method implements @array_matching.
     * @example
     *
     *   [1,2,3].remove(3)         -> [1,2]
     *   ['a','b','c'].remove(/b/) -> ['a','c']
     +   [{a:1},{b:2}].remove(function(n) {
     *     return n['a'] == 1;
     *   });                       -> [{b:2}]
     *
     ***/
    'remove': function() {
      var arr = this;
      multiArgs(arguments, function(f) {
        var i = 0, matcher = getMatcher(f);
        while(i < arr.length) {
          if(matcher(arr[i], i, arr)) {
            arr.splice(i, 1);
          } else {
            i++;
          }
        }
      });
      return arr;
    },

    /***
     * @method compact([all] = false)
     * @returns Array
     * @short Removes all instances of %undefined%, %null%, and %NaN% from the array.
     * @extra If [all] is %true%, all "falsy" elements will be removed. This includes empty strings, 0, and false.
     * @example
     *
     *   [1,null,2,undefined,3].compact() -> [1,2,3]
     *   [1,'',2,false,3].compact()       -> [1,'',2,false,3]
     *   [1,'',2,false,3].compact(true)   -> [1,2,3]
     *
     ***/
    'compact': function(all) {
      var result = [];
      arrayEach(this, function(el, i) {
        if(isArray(el)) {
          result.push(el.compact());
        } else if(all && el) {
          result.push(el);
        } else if(!all && el != null && el.valueOf() === el.valueOf()) {
          result.push(el);
        }
      });
      return result;
    },

    /***
     * @method groupBy(<map>, [fn])
     * @returns Object
     * @short Groups the array by <map>.
     * @extra Will return an object with keys equal to the grouped values. <map> may be a mapping function, or a string acting as a shortcut. Optionally calls [fn] for each group.
     * @example
     *
     *   ['fee','fi','fum'].groupBy('length') -> { 2: ['fi'], 3: ['fee','fum'] }
     +   [{age:35,name:'ken'},{age:15,name:'bob'}].groupBy(function(n) {
     *     return n.age;
     *   });                                  -> { 35: [{age:35,name:'ken'}], 15: [{age:15,name:'bob'}] }
     *
     ***/
    'groupBy': function(map, fn) {
      var arr = this, result = {}, key;
      arrayEach(arr, function(el, index) {
        key = transformArgument(el, map, arr, [el, index, arr]);
        if(!result[key]) result[key] = [];
        result[key].push(el);
      });
      if(fn) {
        iterateOverObject(result, fn);
      }
      return result;
    },

    /***
     * @method none(<f>)
     * @returns Boolean
     * @short Returns true if none of the elements in the array match <f>.
     * @extra <f> will match a string, number, array, object, or alternately test against a function or regex. This method implements @array_matching.
     * @example
     *
     *   [1,2,3].none(5)         -> true
     *   ['a','b','c'].none(/b/) -> false
     +   [{a:1},{b:2}].none(function(n) {
     *     return n['a'] > 1;
     *   });                     -> true
     *
     ***/
    'none': function() {
      return !this.any.apply(this, arguments);
    }


  });


  // Aliases

  extend(array, true, true, {

    /***
     * @method all()
     * @alias every
     *
     ***/
    'all': array.prototype.every,

    /*** @method any()
     * @alias some
     *
     ***/
    'any': array.prototype.some,

    /***
     * @method insert()
     * @alias add
     *
     ***/
    'insert': array.prototype.add

  });


  /***
   * Object module
   * Enumerable methods on objects
   *
   ***/

   function keysWithObjectCoercion(obj) {
     return object.keys(coercePrimitiveToObject(obj));
   }

  /***
   * @method [enumerable](<obj>)
   * @returns Boolean
   * @short Enumerable methods in the Array package are also available to the Object class. They will perform their normal operations for every property in <obj>.
   * @extra In cases where a callback is used, instead of %element, index%, the callback will instead be passed %key, value%. Enumerable methods are also available to extended objects as instance methods.
   *
   * @set
   *   each
   *   map
   *   any
   *   all
   *   none
   *   count
   *   find
   *   findAll
   *   reduce
   *   isEmpty
   *   sum
   *   average
   *   min
   *   max
   *   least
   *   most
   *
   * @example
   *
   *   Object.any({foo:'bar'}, 'bar')            -> true
   *   Object.extended({foo:'bar'}).any('bar')   -> true
   *   Object.isEmpty({})                        -> true
   +   Object.map({ fred: { age: 52 } }, 'age'); -> { fred: 52 }
   *
   ***/

  function buildEnumerableMethods(names, mapping) {
    extendSimilar(object, false, true, names, function(methods, name) {
      methods[name] = function(obj, arg1, arg2) {
        var result, coerced = keysWithObjectCoercion(obj), matcher;
        if(!mapping) {
          matcher = getMatcher(arg1, true);
        }
        result = array.prototype[name].call(coerced, function(key) {
          var value = obj[key];
          if(mapping) {
            return transformArgument(value, arg1, obj, [key, value, obj]);
          } else {
            return matcher(value, key, obj);
          }
        }, arg2);
        if(isArray(result)) {
          // The method has returned an array of keys so use this array
          // to build up the resulting object in the form we want it in.
          result = result.reduce(function(o, key, i) {
            o[key] = obj[key];
            return o;
          }, {});
        }
        return result;
      };
    });
    buildObjectInstanceMethods(names, Hash);
  }

  function exportSortAlgorithm() {
    array[AlphanumericSort] = collateStrings;
  }

  extend(object, false, true, {

    'map': function(obj, map) {
      var result = {}, key, value;
      for(key in obj) {
        if(!hasOwnProperty(obj, key)) continue;
        value = obj[key];
        result[key] = transformArgument(value, map, obj, [key, value, obj]);
      }
      return result;
    },

    'reduce': function(obj) {
      var values = keysWithObjectCoercion(obj).map(function(key) {
        return obj[key];
      });
      return values.reduce.apply(values, multiArgs(arguments, null, 1));
    },

    'each': function(obj, fn) {
      checkCallback(fn);
      iterateOverObject(obj, fn);
      return obj;
    },

    /***
     * @method size(<obj>)
     * @returns Number
     * @short Returns the number of properties in <obj>.
     * @extra %size% is available as an instance method on extended objects.
     * @example
     *
     *   Object.size({ foo: 'bar' }) -> 1
     *
     ***/
    'size': function (obj) {
      return keysWithObjectCoercion(obj).length;
    }

  });

  var EnumerableFindingMethods = 'any,all,none,count,find,findAll,isEmpty'.split(',');
  var EnumerableMappingMethods = 'sum,average,min,max,least,most'.split(',');
  var EnumerableOtherMethods   = 'map,reduce,size'.split(',');
  var EnumerableMethods        = EnumerableFindingMethods.concat(EnumerableMappingMethods).concat(EnumerableOtherMethods);

  buildEnhancements();
  buildAlphanumericSort();
  buildEnumerableMethods(EnumerableFindingMethods);
  buildEnumerableMethods(EnumerableMappingMethods, true);
  buildObjectInstanceMethods(EnumerableOtherMethods, Hash);
  exportSortAlgorithm();


  /***
   * @package Date
   * @dependency core
   * @description Date parsing and formatting, relative formats like "1 minute ago", Number methods like "daysAgo", localization support with default English locale definition.
   *
   ***/

  var English;
  var CurrentLocalization;

  var TimeFormat = ['ampm','hour','minute','second','ampm','utc','offset_sign','offset_hours','offset_minutes','ampm']
  var DecimalReg = '(?:[,.]\\d+)?';
  var HoursReg   = '\\d{1,2}' + DecimalReg;
  var SixtyReg   = '[0-5]\\d' + DecimalReg;
  var RequiredTime = '({t})?\\s*('+HoursReg+')(?:{h}('+SixtyReg+')?{m}(?::?('+SixtyReg+'){s})?\\s*(?:({t})|(Z)|(?:([+-])(\\d{2,2})(?::?(\\d{2,2}))?)?)?|\\s*({t}))';

  var KanjiDigits = '〇一二三四五六七八九十百千万';
  var AsianDigitMap = {};
  var AsianDigitReg;

  var DateArgumentUnits;
  var DateUnitsReversed;
  var CoreDateFormats = [];
  var CompiledOutputFormats = {};

  var DateFormatTokens = {

    'yyyy': function(d) {
      return callDateGet(d, 'FullYear');
    },

    'yy': function(d) {
      return callDateGet(d, 'FullYear') % 100;
    },

    'ord': function(d) {
      var date = callDateGet(d, 'Date');
      return date + getOrdinalizedSuffix(date);
    },

    'tz': function(d) {
      return d.getUTCOffset();
    },

    'isotz': function(d) {
      return d.getUTCOffset(true);
    },

    'Z': function(d) {
      return d.getUTCOffset();
    },

    'ZZ': function(d) {
      return d.getUTCOffset().replace(/(\d{2})$/, ':$1');
    }

  };

  var DateUnits = [
    {
      name: 'year',
      method: 'FullYear',
      ambiguous: true,
      multiplier: function(d) {
        var adjust = d ? (d.isLeapYear() ? 1 : 0) : 0.25;
        return (365 + adjust) * 24 * 60 * 60 * 1000;
      }
    },
    {
      name: 'month',
      error: 0.919, // Feb 1-28 over 1 month
      method: 'Month',
      ambiguous: true,
      multiplier: function(d, ms) {
        var days = 30.4375, inMonth;
        if(d) {
          inMonth = d.daysInMonth();
          if(ms <= inMonth.days()) {
            days = inMonth;
          }
        }
        return days * 24 * 60 * 60 * 1000;
      }
    },
    {
      name: 'week',
      method: 'ISOWeek',
      multiplier: function() {
        return 7 * 24 * 60 * 60 * 1000;
      }
    },
    {
      name: 'day',
      error: 0.958, // DST traversal over 1 day
      method: 'Date',
      ambiguous: true,
      multiplier: function() {
        return 24 * 60 * 60 * 1000;
      }
    },
    {
      name: 'hour',
      method: 'Hours',
      multiplier: function() {
        return 60 * 60 * 1000;
      }
    },
    {
      name: 'minute',
      method: 'Minutes',
      multiplier: function() {
        return 60 * 1000;
      }
    },
    {
      name: 'second',
      method: 'Seconds',
      multiplier: function() {
        return 1000;
      }
    },
    {
      name: 'millisecond',
      method: 'Milliseconds',
      multiplier: function() {
        return 1;
      }
    }
  ];




  // Date Localization

  var Localizations = {};

  // Localization object

  function Localization(l) {
    simpleMerge(this, l);
    this.compiledFormats = CoreDateFormats.concat();
  }

  Localization.prototype = {

    getMonth: function(n) {
      if(isNumber(n)) {
        return n - 1;
      } else {
        return this['months'].indexOf(n) % 12;
      }
    },

    getWeekday: function(n) {
      return this['weekdays'].indexOf(n) % 7;
    },

    getNumber: function(n) {
      var i;
      if(isNumber(n)) {
        return n;
      } else if(n && (i = this['numbers'].indexOf(n)) !== -1) {
        return (i + 1) % 10;
      } else {
        return 1;
      }
    },

    getNumericDate: function(n) {
      var self = this;
      return n.replace(regexp(this['num'], 'g'), function(d) {
        var num = self.getNumber(d);
        return num || '';
      });
    },

    getUnitIndex: function(n) {
      return this['units'].indexOf(n) % 8;
    },

    getRelativeFormat: function(adu) {
      return this.convertAdjustedToFormat(adu, adu[2] > 0 ? 'future' : 'past');
    },

    getDuration: function(ms) {
      return this.convertAdjustedToFormat(getAdjustedUnit(ms), 'duration');
    },

    hasVariant: function(code) {
      code = code || this.code;
      return code === 'en' || code === 'en-US' ? true : this['variant'];
    },

    matchAM: function(str) {
      return str === this['ampm'][0];
    },

    matchPM: function(str) {
      return str && str === this['ampm'][1];
    },

    convertAdjustedToFormat: function(adu, mode) {
      var sign, unit, mult,
          num    = adu[0],
          u      = adu[1],
          ms     = adu[2],
          format = this[mode] || this['relative'];
      if(isFunction(format)) {
        return format.call(this, num, u, ms, mode);
      }
      mult = this['plural'] && num > 1 ? 1 : 0;
      unit = this['units'][mult * 8 + u] || this['units'][u];
      if(this['capitalizeUnit']) unit = simpleCapitalize(unit);
      sign = this['modifiers'].filter(function(m) { return m.name == 'sign' && m.value == (ms > 0 ? 1 : -1); })[0];
      return format.replace(/\{(.*?)\}/g, function(full, match) {
        switch(match) {
          case 'num': return num;
          case 'unit': return unit;
          case 'sign': return sign.src;
        }
      });
    },

    getFormats: function() {
      return this.cachedFormat ? [this.cachedFormat].concat(this.compiledFormats) : this.compiledFormats;
    },

    addFormat: function(src, allowsTime, match, variant, iso) {
      var to = match || [], loc = this, time, timeMarkers, lastIsNumeral;

      src = src.replace(/\s+/g, '[,. ]*');
      src = src.replace(/\{([^,]+?)\}/g, function(all, k) {
        var value, arr, result,
            opt   = k.match(/\?$/),
            nc    = k.match(/^(\d+)\??$/),
            slice = k.match(/(\d)(?:-(\d))?/),
            key   = k.replace(/[^a-z]+$/, '');
        if(nc) {
          value = loc['tokens'][nc[1]];
        } else if(loc[key]) {
          value = loc[key];
        } else if(loc[key + 's']) {
          value = loc[key + 's'];
          if(slice) {
            // Can't use filter here as Prototype hijacks the method and doesn't
            // pass an index, so use a simple loop instead!
            arr = [];
            value.forEach(function(m, i) {
              var mod = i % (loc['units'] ? 8 : value.length);
              if(mod >= slice[1] && mod <= (slice[2] || slice[1])) {
                arr.push(m);
              }
            });
            value = arr;
          }
          value = arrayToAlternates(value);
        }
        if(nc) {
          result = '(?:' + value + ')';
        } else {
          if(!match) {
            to.push(key);
          }
          result = '(' + value + ')';
        }
        if(opt) {
          result += '?';
        }
        return result;
      });
      if(allowsTime) {
        time = prepareTime(RequiredTime, loc, iso);
        timeMarkers = ['t','[\\s\\u3000]'].concat(loc['timeMarker']);
        lastIsNumeral = src.match(/\\d\{\d,\d\}\)+\??$/);
        addDateInputFormat(loc, '(?:' + time + ')[,\\s\\u3000]+?' + src, TimeFormat.concat(to), variant);
        addDateInputFormat(loc, src + '(?:[,\\s]*(?:' + timeMarkers.join('|') + (lastIsNumeral ? '+' : '*') +')' + time + ')?', to.concat(TimeFormat), variant);
      } else {
        addDateInputFormat(loc, src, to, variant);
      }
    }

  };


  // Localization helpers

  function getLocalization(localeCode, fallback) {
    var loc;
    if(!isString(localeCode)) localeCode = '';
    loc = Localizations[localeCode] || Localizations[localeCode.slice(0,2)];
    if(fallback === false && !loc) {
      throw new TypeError('Invalid locale.');
    }
    return loc || CurrentLocalization;
  }

  function setLocalization(localeCode, set) {
    var loc, canAbbreviate;

    function initializeField(name) {
      var val = loc[name];
      if(isString(val)) {
        loc[name] = val.split(',');
      } else if(!val) {
        loc[name] = [];
      }
    }

    function eachAlternate(str, fn) {
      str = str.split('+').map(function(split) {
        return split.replace(/(.+):(.+)$/, function(full, base, suffixes) {
          return suffixes.split('|').map(function(suffix) {
            return base + suffix;
          }).join('|');
        });
      }).join('|');
      return str.split('|').forEach(fn);
    }

    function setArray(name, abbreviate, multiple) {
      var arr = [];
      loc[name].forEach(function(full, i) {
        if(abbreviate) {
          full += '+' + full.slice(0,3);
        }
        eachAlternate(full, function(day, j) {
          arr[j * multiple + i] = day.toLowerCase();
        });
      });
      loc[name] = arr;
    }

    function getDigit(start, stop, allowNumbers) {
      var str = '\\d{' + start + ',' + stop + '}';
      if(allowNumbers) str += '|(?:' + arrayToAlternates(loc['numbers']) + ')+';
      return str;
    }

    function getNum() {
      var arr = ['-?\\d+'].concat(loc['articles']);
      if(loc['numbers']) arr = arr.concat(loc['numbers']);
      return arrayToAlternates(arr);
    }

    function setDefault(name, value) {
      loc[name] = loc[name] || value;
    }

    function setModifiers() {
      var arr = [];
      loc.modifiersByName = {};
      loc['modifiers'].push({ 'name': 'day', 'src': 'yesterday', 'value': -1 });
      loc['modifiers'].push({ 'name': 'day', 'src': 'today', 'value': 0 });
      loc['modifiers'].push({ 'name': 'day', 'src': 'tomorrow', 'value': 1 });
      loc['modifiers'].forEach(function(modifier) {
        var name = modifier.name;
        eachAlternate(modifier.src, function(t) {
          var locEntry = loc[name];
          loc.modifiersByName[t] = modifier;
          arr.push({ name: name, src: t, value: modifier.value });
          loc[name] = locEntry ? locEntry + '|' + t : t;
        });
      });
      loc['day'] += '|' + arrayToAlternates(loc['weekdays']);
      loc['modifiers'] = arr;
    }

    // Initialize the locale
    loc = new Localization(set);
    initializeField('modifiers');
    'months,weekdays,units,numbers,articles,tokens,timeMarker,ampm,timeSuffixes,dateParse,timeParse'.split(',').forEach(initializeField);

    canAbbreviate = !loc['monthSuffix'];

    setArray('months',   canAbbreviate, 12);
    setArray('weekdays', canAbbreviate, 7);
    setArray('units', false, 8);
    setArray('numbers', false, 10);

    setDefault('code', localeCode);
    setDefault('date', getDigit(1,2, loc['digitDate']));
    setDefault('year', "'\\d{2}|" + getDigit(4,4));
    setDefault('num', getNum());

    setModifiers();

    if(loc['monthSuffix']) {
      loc['month'] = getDigit(1,2);
      loc['months'] = '1,2,3,4,5,6,7,8,9,10,11,12'.split(',').map(function(n) { return n + loc['monthSuffix']; });
    }
    loc['full_month'] = getDigit(1,2) + '|' + arrayToAlternates(loc['months']);

    // The order of these formats is very important. Order is reversed so formats that come
    // later will take precedence over formats that come before. This generally means that
    // more specific formats should come later, however, the {year} format should come before
    // {day}, as 2011 needs to be parsed as a year (2011) and not date (20) + hours (11)

    // If the locale has time suffixes then add a time only format for that locale
    // that is separate from the core English-based one.
    if(loc['timeSuffixes'].length > 0) {
      loc.addFormat(prepareTime(RequiredTime, loc), false, TimeFormat)
    }

    loc.addFormat('{day}', true);
    loc.addFormat('{month}' + (loc['monthSuffix'] || ''));
    loc.addFormat('{year}' + (loc['yearSuffix'] || ''));

    loc['timeParse'].forEach(function(src) {
      loc.addFormat(src, true);
    });

    loc['dateParse'].forEach(function(src) {
      loc.addFormat(src);
    });

    return Localizations[localeCode] = loc;
  }


  // General helpers

  function addDateInputFormat(locale, format, match, variant) {
    locale.compiledFormats.unshift({
      variant: variant,
      locale: locale,
      reg: regexp('^' + format + '$', 'i'),
      to: match
    });
  }

  function simpleCapitalize(str) {
    return str.slice(0,1).toUpperCase() + str.slice(1);
  }

  function arrayToAlternates(arr) {
    return arr.filter(function(el) {
      return !!el;
    }).join('|');
  }

  function getNewDate() {
    var fn = date.SugarNewDate;
    return fn ? fn() : new date;
  }

  // Date argument helpers

  function collectDateArguments(args, allowDuration) {
    var obj;
    if(isObjectType(args[0])) {
      return args;
    } else if (isNumber(args[0]) && !isNumber(args[1])) {
      return [args[0]];
    } else if (isString(args[0]) && allowDuration) {
      return [getDateParamsFromString(args[0]), args[1]];
    }
    obj = {};
    DateArgumentUnits.forEach(function(u,i) {
      obj[u.name] = args[i];
    });
    return [obj];
  }

  function getDateParamsFromString(str, num) {
    var match, params = {};
    match = str.match(/^(\d+)?\s?(\w+?)s?$/i);
    if(match) {
      if(isUndefined(num)) {
        num = parseInt(match[1]) || 1;
      }
      params[match[2].toLowerCase()] = num;
    }
    return params;
  }

  // Date iteration helpers

  function iterateOverDateUnits(fn, from, to) {
    var i, unit;
    if(isUndefined(to)) to = DateUnitsReversed.length;
    for(i = from || 0; i < to; i++) {
      unit = DateUnitsReversed[i];
      if(fn(unit.name, unit, i) === false) {
        break;
      }
    }
  }

  // Date parsing helpers

  function getFormatMatch(match, arr) {
    var obj = {}, value, num;
    arr.forEach(function(key, i) {
      value = match[i + 1];
      if(isUndefined(value) || value === '') return;
      if(key === 'year') {
        obj.yearAsString = value.replace(/'/, '');
      }
      num = parseFloat(value.replace(/'/, '').replace(/,/, '.'));
      obj[key] = !isNaN(num) ? num : value.toLowerCase();
    });
    return obj;
  }

  function cleanDateInput(str) {
    str = str.trim().replace(/^just (?=now)|\.+$/i, '');
    return convertAsianDigits(str);
  }

  function convertAsianDigits(str) {
    return str.replace(AsianDigitReg, function(full, disallowed, match) {
      var sum = 0, place = 1, lastWasHolder, lastHolder;
      if(disallowed) return full;
      match.split('').reverse().forEach(function(letter) {
        var value = AsianDigitMap[letter], holder = value > 9;
        if(holder) {
          if(lastWasHolder) sum += place;
          place *= value / (lastHolder || 1);
          lastHolder = value;
        } else {
          if(lastWasHolder === false) {
            place *= 10;
          }
          sum += place * value;
        }
        lastWasHolder = holder;
      });
      if(lastWasHolder) sum += place;
      return sum;
    });
  }

  function getExtendedDate(f, localeCode, prefer, forceUTC) {
    var d, relative, baseLocalization, afterCallbacks, loc, set, unit, unitIndex, weekday, num, tmp;

    d = getNewDate();
    afterCallbacks = [];

    function afterDateSet(fn) {
      afterCallbacks.push(fn);
    }

    function fireCallbacks() {
      afterCallbacks.forEach(function(fn) {
        fn.call();
      });
    }

    function setWeekdayOfMonth() {
      var w = d.getWeekday();
      d.setWeekday((7 * (set['num'] - 1)) + (w > weekday ? weekday + 7 : weekday));
    }

    function setUnitEdge() {
      var modifier = loc.modifiersByName[set['edge']];
      iterateOverDateUnits(function(name) {
        if(isDefined(set[name])) {
          unit = name;
          return false;
        }
      }, 4);
      if(unit === 'year') set.specificity = 'month';
      else if(unit === 'month' || unit === 'week') set.specificity = 'day';
      d[(modifier.value < 0 ? 'endOf' : 'beginningOf') + simpleCapitalize(unit)]();
      // This value of -2 is arbitrary but it's a nice clean way to hook into this system.
      if(modifier.value === -2) d.reset();
    }

    function separateAbsoluteUnits() {
      var params;
      iterateOverDateUnits(function(name, u, i) {
        if(name === 'day') name = 'date';
        if(isDefined(set[name])) {
          // If there is a time unit set that is more specific than
          // the matched unit we have a string like "5:30am in 2 minutes",
          // which is meaningless, so invalidate the date...
          if(i >= unitIndex) {
            invalidateDate(d);
            return false;
          }
          // ...otherwise set the params to set the absolute date
          // as a callback after the relative date has been set.
          params = params || {};
          params[name] = set[name];
          delete set[name];
        }
      });
      if(params) {
        afterDateSet(function() {
          d.set(params, true);
        });
      }
    }

    d.utc(forceUTC);

    if(isDate(f)) {
      // If the source here is already a date object, then the operation
      // is the same as cloning the date, which preserves the UTC flag.
      d.utc(f.isUTC()).setTime(f.getTime());
    } else if(isNumber(f)) {
      d.setTime(f);
    } else if(isObjectType(f)) {
      d.set(f, true);
      set = f;
    } else if(isString(f)) {

      // The act of getting the localization will pre-initialize
      // if it is missing and add the required formats.
      baseLocalization = getLocalization(localeCode);

      // Clean the input and convert Kanji based numerals if they exist.
      f = cleanDateInput(f);

      if(baseLocalization) {
        iterateOverObject(baseLocalization.getFormats(), function(i, dif) {
          var match = f.match(dif.reg);
          if(match) {

            loc = dif.locale;
            set = getFormatMatch(match, dif.to, loc);
            loc.cachedFormat = dif;


            if(set['utc']) {
              d.utc();
            }

            if(set.timestamp) {
              set = set.timestamp;
              return false;
            }

            // If there's a variant (crazy Endian American format), swap the month and day.
            if(dif.variant && !isString(set['month']) && (isString(set['date']) || baseLocalization.hasVariant(localeCode))) {
              tmp = set['month'];
              set['month'] = set['date'];
              set['date']  = tmp;
            }

            // If the year is 2 digits then get the implied century.
            if(set['year'] && set.yearAsString.length === 2) {
              set['year'] = getYearFromAbbreviation(set['year']);
            }

            // Set the month which may be localized.
            if(set['month']) {
              set['month'] = loc.getMonth(set['month']);
              if(set['shift'] && !set['unit']) set['unit'] = loc['units'][7];
            }

            // If there is both a weekday and a date, the date takes precedence.
            if(set['weekday'] && set['date']) {
              delete set['weekday'];
            // Otherwise set a localized weekday.
            } else if(set['weekday']) {
              set['weekday'] = loc.getWeekday(set['weekday']);
              if(set['shift'] && !set['unit']) set['unit'] = loc['units'][5];
            }

            // Relative day localizations such as "today" and "tomorrow".
            if(set['day'] && (tmp = loc.modifiersByName[set['day']])) {
              set['day'] = tmp.value;
              d.reset();
              relative = true;
            // If the day is a weekday, then set that instead.
            } else if(set['day'] && (weekday = loc.getWeekday(set['day'])) > -1) {
              delete set['day'];
              if(set['num'] && set['month']) {
                // If we have "the 2nd tuesday of June", set the day to the beginning of the month, then
                // set the weekday after all other properties have been set. The weekday needs to be set
                // after the actual set because it requires overriding the "prefer" argument which
                // could unintentionally send the year into the future, past, etc.
                afterDateSet(setWeekdayOfMonth);
                set['day'] = 1;
              } else {
                set['weekday'] = weekday;
              }
            }

            if(set['date'] && !isNumber(set['date'])) {
              set['date'] = loc.getNumericDate(set['date']);
            }

            // If the time is 1pm-11pm advance the time by 12 hours.
            if(loc.matchPM(set['ampm']) && set['hour'] < 12) {
              set['hour'] += 12;
            } else if(loc.matchAM(set['ampm']) && set['hour'] === 12) {
              set['hour'] = 0;
            }

            // Adjust for timezone offset
            if('offset_hours' in set || 'offset_minutes' in set) {
              d.utc();
              set['offset_minutes'] = set['offset_minutes'] || 0;
              set['offset_minutes'] += set['offset_hours'] * 60;
              if(set['offset_sign'] === '-') {
                set['offset_minutes'] *= -1;
              }
              set['minute'] -= set['offset_minutes'];
            }

            // Date has a unit like "days", "months", etc. are all relative to the current date.
            if(set['unit']) {
              relative  = true;
              num       = loc.getNumber(set['num']);
              unitIndex = loc.getUnitIndex(set['unit']);
              unit      = English['units'][unitIndex];

              // Formats like "the 15th of last month" or "6:30pm of next week"
              // contain absolute units in addition to relative ones, so separate
              // them here, remove them from the params, and set up a callback to
              // set them after the relative ones have been set.
              separateAbsoluteUnits();

              // Shift and unit, ie "next month", "last week", etc.
              if(set['shift']) {
                num *= (tmp = loc.modifiersByName[set['shift']]) ? tmp.value : 0;
              }

              // Unit and sign, ie "months ago", "weeks from now", etc.
              if(set['sign'] && (tmp = loc.modifiersByName[set['sign']])) {
                num *= tmp.value;
              }

              // Units can be with non-relative dates, set here. ie "the day after monday"
              if(isDefined(set['weekday'])) {
                d.set({'weekday': set['weekday'] }, true);
                delete set['weekday'];
              }

              // Finally shift the unit.
              set[unit] = (set[unit] || 0) + num;
            }

            // If there is an "edge" it needs to be set after the
            // other fields are set. ie "the end of February"
            if(set['edge']) {
              afterDateSet(setUnitEdge);
            }

            if(set['year_sign'] === '-') {
              set['year'] *= -1;
            }

            iterateOverDateUnits(function(name, unit, i) {
              var value = set[name], fraction = value % 1;
              if(fraction) {
                set[DateUnitsReversed[i - 1].name] = round(fraction * (name === 'second' ? 1000 : 60));
                set[name] = floor(value);
              }
            }, 1, 4);
            return false;
          }
        });
      }
      if(!set) {
        // The Date constructor does something tricky like checking the number
        // of arguments so simply passing in undefined won't work.
        if(f !== 'now') {
          d = new date(f);
        }
        if(forceUTC) {
          // Falling back to system date here which cannot be parsed as UTC,
          // so if we're forcing UTC then simply add the offset.
          d.addMinutes(-d.getTimezoneOffset());
        }
      } else if(relative) {
        d.advance(set);
      } else {
        if(d._utc) {
          // UTC times can traverse into other days or even months,
          // so preemtively reset the time here to prevent this.
          d.reset();
        }
        updateDate(d, set, true, false, prefer);
      }
      fireCallbacks();
      // A date created by parsing a string presumes that the format *itself* is UTC, but
      // not that the date, once created, should be manipulated as such. In other words,
      // if you are creating a date object from a server time "2012-11-15T12:00:00Z",
      // in the majority of cases you are using it to create a date that will, after creation,
      // be manipulated as local, so reset the utc flag here.
      d.utc(false);
    }
    return {
      date: d,
      set: set
    }
  }

  // If the year is two digits, add the most appropriate century prefix.
  function getYearFromAbbreviation(year) {
    return round(callDateGet(getNewDate(), 'FullYear') / 100) * 100 - round(year / 100) * 100 + year;
  }

  function getShortHour(d) {
    var hours = callDateGet(d, 'Hours');
    return hours === 0 ? 12 : hours - (floor(hours / 13) * 12);
  }

  // weeksSince won't work here as the result needs to be floored, not rounded.
  function getWeekNumber(date) {
    date = date.clone();
    var dow = callDateGet(date, 'Day') || 7;
    date.addDays(4 - dow).reset();
    return 1 + floor(date.daysSince(date.clone().beginningOfYear()) / 7);
  }

  function getAdjustedUnit(ms) {
    var next, ams = abs(ms), value = ams, unitIndex = 0;
    iterateOverDateUnits(function(name, unit, i) {
      next = floor(withPrecision(ams / unit.multiplier(), 1));
      if(next >= 1) {
        value = next;
        unitIndex = i;
      }
    }, 1);
    return [value, unitIndex, ms];
  }

  function getRelativeWithMonthFallback(date) {
    var adu = getAdjustedUnit(date.millisecondsFromNow());
    if(allowMonthFallback(date, adu)) {
      // If the adjusted unit is in months, then better to use
      // the "monthsfromNow" which applies a special error margin
      // for edge cases such as Jan-09 - Mar-09 being less than
      // 2 months apart (when using a strict numeric definition).
      // The third "ms" element in the array will handle the sign
      // (past or future), so simply take the absolute value here.
      adu[0] = abs(date.monthsFromNow());
      adu[1] = 6;
    }
    return adu;
  }

  function allowMonthFallback(date, adu) {
    // Allow falling back to monthsFromNow if the unit is in months...
    return adu[1] === 6 ||
    // ...or if it's === 4 weeks and there are more days than in the given month
    (adu[1] === 5 && adu[0] === 4 && date.daysFromNow() >= getNewDate().daysInMonth());
  }


  // Date format token helpers

  function createMeridianTokens(slice, caps) {
    var fn = function(d, localeCode) {
      var hours = callDateGet(d, 'Hours');
      return getLocalization(localeCode)['ampm'][floor(hours / 12)] || '';
    }
    createFormatToken('t', fn, 1);
    createFormatToken('tt', fn);
    createFormatToken('T', fn, 1, 1);
    createFormatToken('TT', fn, null, 2);
  }

  function createWeekdayTokens(slice, caps) {
    var fn = function(d, localeCode) {
      var dow = callDateGet(d, 'Day');
      return getLocalization(localeCode)['weekdays'][dow];
    }
    createFormatToken('dow', fn, 3);
    createFormatToken('Dow', fn, 3, 1);
    createFormatToken('weekday', fn);
    createFormatToken('Weekday', fn, null, 1);
  }

  function createMonthTokens(slice, caps) {
    createMonthToken('mon', 0, 3);
    createMonthToken('month', 0);

    // For inflected month forms, namely Russian.
    createMonthToken('month2', 1);
    createMonthToken('month3', 2);
  }

  function createMonthToken(token, multiplier, slice) {
    var fn = function(d, localeCode) {
      var month = callDateGet(d, 'Month');
      return getLocalization(localeCode)['months'][month + (multiplier * 12)];
    };
    createFormatToken(token, fn, slice);
    createFormatToken(simpleCapitalize(token), fn, slice, 1);
  }

  function createFormatToken(t, fn, slice, caps) {
    DateFormatTokens[t] = function(d, localeCode) {
      var str = fn(d, localeCode);
      if(slice) str = str.slice(0, slice);
      if(caps)  str = str.slice(0, caps).toUpperCase() + str.slice(caps);
      return str;
    }
  }

  function createPaddedToken(t, fn, ms) {
    DateFormatTokens[t] = fn;
    DateFormatTokens[t + t] = function (d, localeCode) {
      return padNumber(fn(d, localeCode), 2);
    };
    if(ms) {
      DateFormatTokens[t + t + t] = function (d, localeCode) {
        return padNumber(fn(d, localeCode), 3);
      };
      DateFormatTokens[t + t + t + t] = function (d, localeCode) {
        return padNumber(fn(d, localeCode), 4);
      };
    }
  }


  // Date formatting helpers

  function buildCompiledOutputFormat(format) {
    var match = format.match(/(\{\w+\})|[^{}]+/g);
    CompiledOutputFormats[format] = match.map(function(p) {
      p.replace(/\{(\w+)\}/, function(full, token) {
        p = DateFormatTokens[token] || token;
        return token;
      });
      return p;
    });
  }

  function executeCompiledOutputFormat(date, format, localeCode) {
    var compiledFormat, length, i, t, result = '';
    compiledFormat = CompiledOutputFormats[format];
    for(i = 0, length = compiledFormat.length; i < length; i++) {
      t = compiledFormat[i];
      result += isFunction(t) ? t(date, localeCode) : t;
    }
    return result;
  }

  function formatDate(date, format, relative, localeCode) {
    var adu;
    if(!date.isValid()) {
      return 'Invalid Date';
    } else if(Date[format]) {
      format = Date[format];
    } else if(isFunction(format)) {
      adu = getRelativeWithMonthFallback(date);
      format = format.apply(date, adu.concat(getLocalization(localeCode)));
    }
    if(!format && relative) {
      adu = adu || getRelativeWithMonthFallback(date);
      // Adjust up if time is in ms, as this doesn't
      // look very good for a standard relative date.
      if(adu[1] === 0) {
        adu[1] = 1;
        adu[0] = 1;
      }
      return getLocalization(localeCode).getRelativeFormat(adu);
    }
    format = format || 'long';
    if(format === 'short' || format === 'long' || format === 'full') {
      format = getLocalization(localeCode)[format];
    }

    if(!CompiledOutputFormats[format]) {
      buildCompiledOutputFormat(format);
    }

    return executeCompiledOutputFormat(date, format, localeCode);
  }

  // Date comparison helpers

  function compareDate(d, find, localeCode, buffer, forceUTC) {
    var p, t, min, max, override, capitalized, accuracy = 0, loBuffer = 0, hiBuffer = 0;
    p = getExtendedDate(find, localeCode, null, forceUTC);
    if(buffer > 0) {
      loBuffer = hiBuffer = buffer;
      override = true;
    }
    if(!p.date.isValid()) return false;
    if(p.set && p.set.specificity) {
      DateUnits.forEach(function(u, i) {
        if(u.name === p.set.specificity) {
          accuracy = u.multiplier(p.date, d - p.date) - 1;
        }
      });
      capitalized = simpleCapitalize(p.set.specificity);
      if(p.set['edge'] || p.set['shift']) {
        p.date['beginningOf' + capitalized]();
      }
      if(p.set.specificity === 'month') {
        max = p.date.clone()['endOf' + capitalized]().getTime();
      }
      if(!override && p.set['sign'] && p.set.specificity != 'millisecond') {
        // If the time is relative, there can occasionally be an disparity between the relative date
        // and "now", which it is being compared to, so set an extra buffer to account for this.
        loBuffer = 50;
        hiBuffer = -50;
      }
    }
    t   = d.getTime();
    min = p.date.getTime();
    max = max || (min + accuracy);
    max = compensateForTimezoneTraversal(d, min, max);
    return t >= (min - loBuffer) && t <= (max + hiBuffer);
  }

  function compensateForTimezoneTraversal(d, min, max) {
    var dMin, dMax, minOffset, maxOffset;
    dMin = new date(min);
    dMax = new date(max).utc(d.isUTC());
    if(callDateGet(dMax, 'Hours') !== 23) {
      minOffset = dMin.getTimezoneOffset();
      maxOffset = dMax.getTimezoneOffset();
      if(minOffset !== maxOffset) {
        max += (maxOffset - minOffset).minutes();
      }
    }
    return max;
  }

  function updateDate(d, params, reset, advance, prefer) {
    var weekday, specificityIndex;

    function getParam(key) {
      return isDefined(params[key]) ? params[key] : params[key + 's'];
    }

    function paramExists(key) {
      return isDefined(getParam(key));
    }

    function uniqueParamExists(key, isDay) {
      return paramExists(key) || (isDay && paramExists('weekday'));
    }

    function canDisambiguate() {
      switch(prefer) {
        case -1: return d > getNewDate();
        case  1: return d < getNewDate();
      }
    }

    if(isNumber(params) && advance) {
      // If param is a number and we're advancing, the number is presumed to be milliseconds.
      params = { 'milliseconds': params };
    } else if(isNumber(params)) {
      // Otherwise just set the timestamp and return.
      d.setTime(params);
      return d;
    }

    // "date" can also be passed for the day
    if(isDefined(params['date'])) {
      params['day'] = params['date'];
    }

    // Reset any unit lower than the least specific unit set. Do not do this for weeks
    // or for years. This needs to be performed before the acutal setting of the date
    // because the order needs to be reversed in order to get the lowest specificity,
    // also because higher order units can be overwritten by lower order units, such
    // as setting hour: 3, minute: 345, etc.
    iterateOverDateUnits(function(name, unit, i) {
      var isDay = name === 'day';
      if(uniqueParamExists(name, isDay)) {
        params.specificity = name;
        specificityIndex = +i;
        return false;
      } else if(reset && name !== 'week' && (!isDay || !paramExists('week'))) {
        // Days are relative to months, not weeks, so don't reset if a week exists.
        callDateSet(d, unit.method, (isDay ? 1 : 0));
      }
    });

    // Now actually set or advance the date in order, higher units first.
    DateUnits.forEach(function(u, i) {
      var name = u.name, method = u.method, higherUnit = DateUnits[i - 1], value;
      value = getParam(name)
      if(isUndefined(value)) return;
      if(advance) {
        if(name === 'week') {
          value  = (params['day'] || 0) + (value * 7);
          method = 'Date';
        }
        value = (value * advance) + callDateGet(d, method);
      } else if(name === 'month' && paramExists('day')) {
        // When setting the month, there is a chance that we will traverse into a new month.
        // This happens in DST shifts, for example June 1st DST jumping to January 1st
        // (non-DST) will have a shift of -1:00 which will traverse into the previous year.
        // Prevent this by proactively setting the day when we know it will be set again anyway.
        // It can also happen when there are not enough days in the target month. This second
        // situation is identical to checkMonthTraversal below, however when we are advancing
        // we want to reset the date to "the last date in the target month". In the case of
        // DST shifts, however, we want to avoid the "edges" of months as that is where this
        // unintended traversal can happen. This is the reason for the different handling of
        // two similar but slightly different situations.
        //
        // TL;DR This method avoids the edges of a month IF not advancing and the date is going
        // to be set anyway, while checkMonthTraversal resets the date to the last day if advancing.
        //
        callDateSet(d, 'Date', 15);
      }
      callDateSet(d, method, value);
      if(advance && name === 'month') {
        checkMonthTraversal(d, value);
      }
    });


    // If a weekday is included in the params, set it ahead of time and set the params
    // to reflect the updated date so that resetting works properly.
    if(!advance && !paramExists('day') && paramExists('weekday')) {
      var weekday = getParam('weekday'), isAhead, futurePreferred;
      d.setWeekday(weekday);
    }

    // If past or future is preferred, then the process of "disambiguation" will ensure that an
    // ambiguous time/date ("4pm", "thursday", "June", etc.) will be in the past or future.
    if(canDisambiguate()) {
      iterateOverDateUnits(function(name, unit) {
        var ambiguous = unit.ambiguous || (name === 'week' && paramExists('weekday'));
        if(ambiguous && !uniqueParamExists(name, name === 'day')) {
          d[unit.addMethod](prefer);
          return false;
        }
      }, specificityIndex + 1);
    }
    return d;
  }

  // The ISO format allows times strung together without a demarcating ":", so make sure
  // that these markers are now optional.
  function prepareTime(format, loc, iso) {
    var timeSuffixMapping = {'h':0,'m':1,'s':2}, add;
    loc = loc || English;
    return format.replace(/{([a-z])}/g, function(full, token) {
      var separators = [],
          isHours = token === 'h',
          tokenIsRequired = isHours && !iso;
      if(token === 't') {
        return loc['ampm'].join('|');
      } else {
        if(isHours) {
          separators.push(':');
        }
        if(add = loc['timeSuffixes'][timeSuffixMapping[token]]) {
          separators.push(add + '\\s*');
        }
        return separators.length === 0 ? '' : '(?:' + separators.join('|') + ')' + (tokenIsRequired ? '' : '?');
      }
    });
  }


  // If the month is being set, then we don't want to accidentally
  // traverse into a new month just because the target month doesn't have enough
  // days. In other words, "5 months ago" from July 30th is still February, even
  // though there is no February 30th, so it will of necessity be February 28th
  // (or 29th in the case of a leap year).

  function checkMonthTraversal(date, targetMonth) {
    if(targetMonth < 0) {
      targetMonth = targetMonth % 12 + 12;
    }
    if(targetMonth % 12 != callDateGet(date, 'Month')) {
      callDateSet(date, 'Date', 0);
    }
  }

  function createDate(args, prefer, forceUTC) {
    var f, localeCode;
    if(isNumber(args[1])) {
      // If the second argument is a number, then we have an enumerated constructor type as in "new Date(2003, 2, 12);"
      f = collectDateArguments(args)[0];
    } else {
      f          = args[0];
      localeCode = args[1];
    }
    return getExtendedDate(f, localeCode, prefer, forceUTC).date;
  }

  function invalidateDate(d) {
    d.setTime(NaN);
  }

  function buildDateUnits() {
    DateUnitsReversed = DateUnits.concat().reverse();
    DateArgumentUnits = DateUnits.concat();
    DateArgumentUnits.splice(2,1);
  }


  /***
   * @method [units]Since([d], [locale] = currentLocale)
   * @returns Number
   * @short Returns the time since [d] in the appropriate unit.
   * @extra [d] will accept a date object, timestamp, or text format. If not specified, [d] is assumed to be now. [locale] can be passed to specify the locale that the date is in. %[unit]Ago% is provided as an alias to make this more readable when [d] is assumed to be the current date. For more see @date_format.
   *
   * @set
   *   millisecondsSince
   *   secondsSince
   *   minutesSince
   *   hoursSince
   *   daysSince
   *   weeksSince
   *   monthsSince
   *   yearsSince
   *
   * @example
   *
   *   Date.create().millisecondsSince('1 hour ago') -> 3,600,000
   *   Date.create().daysSince('1 week ago')         -> 7
   *   Date.create().yearsSince('15 years ago')      -> 15
   *   Date.create('15 years ago').yearsAgo()        -> 15
   *
   ***
   * @method [units]Ago()
   * @returns Number
   * @short Returns the time ago in the appropriate unit.
   *
   * @set
   *   millisecondsAgo
   *   secondsAgo
   *   minutesAgo
   *   hoursAgo
   *   daysAgo
   *   weeksAgo
   *   monthsAgo
   *   yearsAgo
   *
   * @example
   *
   *   Date.create('last year').millisecondsAgo() -> 3,600,000
   *   Date.create('last year').daysAgo()         -> 7
   *   Date.create('last year').yearsAgo()        -> 15
   *
   ***
   * @method [units]Until([d], [locale] = currentLocale)
   * @returns Number
   * @short Returns the time until [d] in the appropriate unit.
   * @extra [d] will accept a date object, timestamp, or text format. If not specified, [d] is assumed to be now. [locale] can be passed to specify the locale that the date is in. %[unit]FromNow% is provided as an alias to make this more readable when [d] is assumed to be the current date. For more see @date_format.
   *
   * @set
   *   millisecondsUntil
   *   secondsUntil
   *   minutesUntil
   *   hoursUntil
   *   daysUntil
   *   weeksUntil
   *   monthsUntil
   *   yearsUntil
   *
   * @example
   *
   *   Date.create().millisecondsUntil('1 hour from now') -> 3,600,000
   *   Date.create().daysUntil('1 week from now')         -> 7
   *   Date.create().yearsUntil('15 years from now')      -> 15
   *   Date.create('15 years from now').yearsFromNow()    -> 15
   *
   ***
   * @method [units]FromNow()
   * @returns Number
   * @short Returns the time from now in the appropriate unit.
   *
   * @set
   *   millisecondsFromNow
   *   secondsFromNow
   *   minutesFromNow
   *   hoursFromNow
   *   daysFromNow
   *   weeksFromNow
   *   monthsFromNow
   *   yearsFromNow
   *
   * @example
   *
   *   Date.create('next year').millisecondsFromNow() -> 3,600,000
   *   Date.create('next year').daysFromNow()         -> 7
   *   Date.create('next year').yearsFromNow()        -> 15
   *
   ***
   * @method add[Units](<num>, [reset] = false)
   * @returns Date
   * @short Adds <num> of the unit to the date. If [reset] is true, all lower units will be reset.
   * @extra Note that "months" is ambiguous as a unit of time. If the target date falls on a day that does not exist (ie. August 31 -> February 31), the date will be shifted to the last day of the month. Don't use %addMonths% if you need precision.
   *
   * @set
   *   addMilliseconds
   *   addSeconds
   *   addMinutes
   *   addHours
   *   addDays
   *   addWeeks
   *   addMonths
   *   addYears
   *
   * @example
   *
   *   Date.create().addMilliseconds(5) -> current time + 5 milliseconds
   *   Date.create().addDays(5)         -> current time + 5 days
   *   Date.create().addYears(5)        -> current time + 5 years
   *
   ***
   * @method isLast[Unit]()
   * @returns Boolean
   * @short Returns true if the date is last week/month/year.
   *
   * @set
   *   isLastWeek
   *   isLastMonth
   *   isLastYear
   *
   * @example
   *
   *   Date.create('yesterday').isLastWeek()  -> true or false?
   *   Date.create('yesterday').isLastMonth() -> probably not...
   *   Date.create('yesterday').isLastYear()  -> even less likely...
   *
   ***
   * @method isThis[Unit]()
   * @returns Boolean
   * @short Returns true if the date is this week/month/year.
   *
   * @set
   *   isThisWeek
   *   isThisMonth
   *   isThisYear
   *
   * @example
   *
   *   Date.create('tomorrow').isThisWeek()  -> true or false?
   *   Date.create('tomorrow').isThisMonth() -> probably...
   *   Date.create('tomorrow').isThisYear()  -> signs point to yes...
   *
   ***
   * @method isNext[Unit]()
   * @returns Boolean
   * @short Returns true if the date is next week/month/year.
   *
   * @set
   *   isNextWeek
   *   isNextMonth
   *   isNextYear
   *
   * @example
   *
   *   Date.create('tomorrow').isNextWeek()  -> true or false?
   *   Date.create('tomorrow').isNextMonth() -> probably not...
   *   Date.create('tomorrow').isNextYear()  -> even less likely...
   *
   ***
   * @method beginningOf[Unit]()
   * @returns Date
   * @short Sets the date to the beginning of the appropriate unit.
   *
   * @set
   *   beginningOfDay
   *   beginningOfWeek
   *   beginningOfMonth
   *   beginningOfYear
   *
   * @example
   *
   *   Date.create().beginningOfDay()   -> the beginning of today (resets the time)
   *   Date.create().beginningOfWeek()  -> the beginning of the week
   *   Date.create().beginningOfMonth() -> the beginning of the month
   *   Date.create().beginningOfYear()  -> the beginning of the year
   *
   ***
   * @method endOf[Unit]()
   * @returns Date
   * @short Sets the date to the end of the appropriate unit.
   *
   * @set
   *   endOfDay
   *   endOfWeek
   *   endOfMonth
   *   endOfYear
   *
   * @example
   *
   *   Date.create().endOfDay()   -> the end of today (sets the time to 23:59:59.999)
   *   Date.create().endOfWeek()  -> the end of the week
   *   Date.create().endOfMonth() -> the end of the month
   *   Date.create().endOfYear()  -> the end of the year
   *
   ***/

  function buildDateMethods() {
    extendSimilar(date, true, true, DateUnits, function(methods, u, i) {
      var name = u.name, caps = simpleCapitalize(name), multiplier = u.multiplier(), since, until;
      u.addMethod = 'add' + caps + 's';
      // "since/until now" only count "past" an integer, i.e. "2 days ago" is
      // anything between 2 - 2.999 days. The default margin of error is 0.999,
      // but "months" have an inherently larger margin, as the number of days
      // in a given month may be significantly less than the number of days in
      // the average month, so for example "30 days" before March 15 may in fact
      // be 1 month ago. Years also have a margin of error due to leap years,
      // but this is roughly 0.999 anyway (365 / 365.25). Other units do not
      // technically need the error margin applied to them but this accounts
      // for discrepancies like (15).hoursAgo() which technically creates the
      // current date first, then creates a date 15 hours before and compares
      // them, the discrepancy between the creation of the 2 dates means that
      // they may actually be 15.0001 hours apart. Milliseconds don't have
      // fractions, so they won't be subject to this error margin.
      function applyErrorMargin(ms) {
        var num      = ms / multiplier,
            fraction = num % 1,
            error    = u.error || 0.999;
        if(fraction && abs(fraction % 1) > error) {
          num = round(num);
        }
        return num < 0 ? ceil(num) : floor(num);
      }
      since = function(f, localeCode) {
        return applyErrorMargin(this.getTime() - date.create(f, localeCode).getTime());
      };
      until = function(f, localeCode) {
        return applyErrorMargin(date.create(f, localeCode).getTime() - this.getTime());
      };
      methods[name+'sAgo']     = until;
      methods[name+'sUntil']   = until;
      methods[name+'sSince']   = since;
      methods[name+'sFromNow'] = since;
      methods[u.addMethod] = function(num, reset) {
        var set = {};
        set[name] = num;
        return this.advance(set, reset);
      };
      buildNumberToDateAlias(u, multiplier);
      if(i < 3) {
        ['Last','This','Next'].forEach(function(shift) {
          methods['is' + shift + caps] = function() {
            return compareDate(this, shift + ' ' + name, 'en');
          };
        });
      }
      if(i < 4) {
        methods['beginningOf' + caps] = function() {
          var set = {};
          switch(name) {
            case 'year':  set['year']    = callDateGet(this, 'FullYear'); break;
            case 'month': set['month']   = callDateGet(this, 'Month');    break;
            case 'day':   set['day']     = callDateGet(this, 'Date');     break;
            case 'week':  set['weekday'] = 0; break;
          }
          return this.set(set, true);
        };
        methods['endOf' + caps] = function() {
          var set = { 'hours': 23, 'minutes': 59, 'seconds': 59, 'milliseconds': 999 };
          switch(name) {
            case 'year':  set['month']   = 11; set['day'] = 31; break;
            case 'month': set['day']     = this.daysInMonth();  break;
            case 'week':  set['weekday'] = 6;                   break;
          }
          return this.set(set, true);
        };
      }
    });
  }

  function buildCoreInputFormats() {
    English.addFormat('([+-])?(\\d{4,4})[-.]?{full_month}[-.]?(\\d{1,2})?', true, ['year_sign','year','month','date'], false, true);
    English.addFormat('(\\d{1,2})[-.\\/]{full_month}(?:[-.\\/](\\d{2,4}))?', true, ['date','month','year'], true);
    English.addFormat('{full_month}[-.](\\d{4,4})', false, ['month','year']);
    English.addFormat('\\/Date\\((\\d+(?:[+-]\\d{4,4})?)\\)\\/', false, ['timestamp'])
    English.addFormat(prepareTime(RequiredTime, English), false, TimeFormat)

    // When a new locale is initialized it will have the CoreDateFormats initialized by default.
    // From there, adding new formats will push them in front of the previous ones, so the core
    // formats will be the last to be reached. However, the core formats themselves have English
    // months in them, which means that English needs to first be initialized and creates a race
    // condition. I'm getting around this here by adding these generalized formats in the order
    // specific -> general, which will mean they will be added to the English localization in
    // general -> specific order, then chopping them off the front and reversing to get the correct
    // order. Note that there are 7 formats as 2 have times which adds a front and a back format.
    CoreDateFormats = English.compiledFormats.slice(0,7).reverse();
    English.compiledFormats = English.compiledFormats.slice(7).concat(CoreDateFormats);
  }

  function buildFormatTokens() {

    createPaddedToken('f', function(d) {
      return callDateGet(d, 'Milliseconds');
    }, true);

    createPaddedToken('s', function(d) {
      return callDateGet(d, 'Seconds');
    });

    createPaddedToken('m', function(d) {
      return callDateGet(d, 'Minutes');
    });

    createPaddedToken('h', function(d) {
      return callDateGet(d, 'Hours') % 12 || 12;
    });

    createPaddedToken('H', function(d) {
      return callDateGet(d, 'Hours');
    });

    createPaddedToken('d', function(d) {
      return callDateGet(d, 'Date');
    });

    createPaddedToken('M', function(d) {
      return callDateGet(d, 'Month') + 1;
    });

    createMeridianTokens();
    createWeekdayTokens();
    createMonthTokens();

    // Aliases
    DateFormatTokens['ms']           = DateFormatTokens['f'];
    DateFormatTokens['milliseconds'] = DateFormatTokens['f'];
    DateFormatTokens['seconds']      = DateFormatTokens['s'];
    DateFormatTokens['minutes']      = DateFormatTokens['m'];
    DateFormatTokens['hours']        = DateFormatTokens['h'];
    DateFormatTokens['24hr']         = DateFormatTokens['H'];
    DateFormatTokens['12hr']         = DateFormatTokens['h'];
    DateFormatTokens['date']         = DateFormatTokens['d'];
    DateFormatTokens['day']          = DateFormatTokens['d'];
    DateFormatTokens['year']         = DateFormatTokens['yyyy'];

  }

  function buildFormatShortcuts() {
    extendSimilar(date, true, true, 'short,long,full', function(methods, name) {
      methods[name] = function(localeCode) {
        return formatDate(this, name, false, localeCode);
      }
    });
  }

  function buildAsianDigits() {
    KanjiDigits.split('').forEach(function(digit, value) {
      var holder;
      if(value > 9) {
        value = pow(10, value - 9);
      }
      AsianDigitMap[digit] = value;
    });
    simpleMerge(AsianDigitMap, NumberNormalizeMap);
    // Kanji numerals may also be included in phrases which are text-based rather
    // than actual numbers such as Chinese weekdays (上周三), and "the day before
    // yesterday" (一昨日) in Japanese, so don't match these.
    AsianDigitReg = regexp('([期週周])?([' + KanjiDigits + FullWidthDigits + ']+)(?!昨)', 'g');
  }

   /***
   * @method is[Day]()
   * @returns Boolean
   * @short Returns true if the date falls on that day.
   * @extra Also available: %isYesterday%, %isToday%, %isTomorrow%, %isWeekday%, and %isWeekend%.
   *
   * @set
   *   isToday
   *   isYesterday
   *   isTomorrow
   *   isWeekday
   *   isWeekend
   *   isSunday
   *   isMonday
   *   isTuesday
   *   isWednesday
   *   isThursday
   *   isFriday
   *   isSaturday
   *
   * @example
   *
   *   Date.create('tomorrow').isToday() -> false
   *   Date.create('thursday').isTomorrow() -> ?
   *   Date.create('yesterday').isWednesday() -> ?
   *   Date.create('today').isWeekend() -> ?
   *
   ***
   * @method isFuture()
   * @returns Boolean
   * @short Returns true if the date is in the future.
   * @example
   *
   *   Date.create('next week').isFuture() -> true
   *   Date.create('last week').isFuture() -> false
   *
   ***
   * @method isPast()
   * @returns Boolean
   * @short Returns true if the date is in the past.
   * @example
   *
   *   Date.create('last week').isPast() -> true
   *   Date.create('next week').isPast() -> false
   *
   ***/
  function buildRelativeAliases() {
    var special  = 'today,yesterday,tomorrow,weekday,weekend,future,past'.split(',');
    var weekdays = English['weekdays'].slice(0,7);
    var months   = English['months'].slice(0,12);
    extendSimilar(date, true, true, special.concat(weekdays).concat(months), function(methods, name) {
      methods['is'+ simpleCapitalize(name)] = function(utc) {
       return this.is(name, 0, utc);
      };
    });
  }

  function buildUTCAliases() {
    // Don't want to use extend here as it will override
    // the actual "utc" method on the prototype.
    if(date['utc']) return;
    date['utc'] = {

        'create': function() {
          return createDate(arguments, 0, true);
        },

        'past': function() {
          return createDate(arguments, -1, true);
        },

        'future': function() {
          return createDate(arguments, 1, true);
        }
    };
  }

  function setDateProperties() {
    extend(date, false , true, {
      'RFC1123': '{Dow}, {dd} {Mon} {yyyy} {HH}:{mm}:{ss} {tz}',
      'RFC1036': '{Weekday}, {dd}-{Mon}-{yy} {HH}:{mm}:{ss} {tz}',
      'ISO8601_DATE': '{yyyy}-{MM}-{dd}',
      'ISO8601_DATETIME': '{yyyy}-{MM}-{dd}T{HH}:{mm}:{ss}.{fff}{isotz}'
    });
  }


  extend(date, false, true, {

     /***
     * @method Date.create(<d>, [locale] = currentLocale)
     * @returns Date
     * @short Alternate Date constructor which understands many different text formats, a timestamp, or another date.
     * @extra If no argument is given, date is assumed to be now. %Date.create% additionally can accept enumerated parameters as with the standard date constructor. [locale] can be passed to specify the locale that the date is in. When unspecified, the current locale (default is English) is assumed. UTC-based dates can be created through the %utc% object. For more see @date_format.
     * @set
     *   Date.utc.create
     *
     * @example
     *
     *   Date.create('July')          -> July of this year
     *   Date.create('1776')          -> 1776
     *   Date.create('today')         -> today
     *   Date.create('wednesday')     -> This wednesday
     *   Date.create('next friday')   -> Next friday
     *   Date.create('July 4, 1776')  -> July 4, 1776
     *   Date.create(-446806800000)   -> November 5, 1955
     *   Date.create(1776, 6, 4)      -> July 4, 1776
     *   Date.create('1776年07月04日', 'ja') -> July 4, 1776
     *   Date.utc.create('July 4, 1776', 'en')  -> July 4, 1776
     *
     ***/
    'create': function() {
      return createDate(arguments);
    },

     /***
     * @method Date.past(<d>, [locale] = currentLocale)
     * @returns Date
     * @short Alternate form of %Date.create% with any ambiguity assumed to be the past.
     * @extra For example %"Sunday"% can be either "the Sunday coming up" or "the Sunday last" depending on context. Note that dates explicitly in the future ("next Sunday") will remain in the future. This method simply provides a hint when ambiguity exists. UTC-based dates can be created through the %utc% object. For more, see @date_format.
     * @set
     *   Date.utc.past
     *
     * @example
     *
     *   Date.past('July')          -> July of this year or last depending on the current month
     *   Date.past('Wednesday')     -> This wednesday or last depending on the current weekday
     *
     ***/
    'past': function() {
      return createDate(arguments, -1);
    },

     /***
     * @method Date.future(<d>, [locale] = currentLocale)
     * @returns Date
     * @short Alternate form of %Date.create% with any ambiguity assumed to be the future.
     * @extra For example %"Sunday"% can be either "the Sunday coming up" or "the Sunday last" depending on context. Note that dates explicitly in the past ("last Sunday") will remain in the past. This method simply provides a hint when ambiguity exists. UTC-based dates can be created through the %utc% object. For more, see @date_format.
     * @set
     *   Date.utc.future
     *
     * @example
     *
     *   Date.future('July')          -> July of this year or next depending on the current month
     *   Date.future('Wednesday')     -> This wednesday or next depending on the current weekday
     *
     ***/
    'future': function() {
      return createDate(arguments, 1);
    },

     /***
     * @method Date.addLocale(<code>, <set>)
     * @returns Locale
     * @short Adds a locale <set> to the locales understood by Sugar.
     * @extra For more see @date_format.
     *
     ***/
    'addLocale': function(localeCode, set) {
      return setLocalization(localeCode, set);
    },

     /***
     * @method Date.setLocale(<code>)
     * @returns Locale
     * @short Sets the current locale to be used with dates.
     * @extra Sugar has support for 13 locales that are available through the "Date Locales" package. In addition you can define a new locale with %Date.addLocale%. For more see @date_format.
     *
     ***/
    'setLocale': function(localeCode, set) {
      var loc = getLocalization(localeCode, false);
      CurrentLocalization = loc;
      // The code is allowed to be more specific than the codes which are required:
      // i.e. zh-CN or en-US. Currently this only affects US date variants such as 8/10/2000.
      if(localeCode && localeCode != loc['code']) {
        loc['code'] = localeCode;
      }
      return loc;
    },

     /***
     * @method Date.getLocale([code] = current)
     * @returns Locale
     * @short Gets the locale for the given code, or the current locale.
     * @extra The resulting locale object can be manipulated to provide more control over date localizations. For more about locales, see @date_format.
     *
     ***/
    'getLocale': function(localeCode) {
      return !localeCode ? CurrentLocalization : getLocalization(localeCode, false);
    },

     /**
     * @method Date.addFormat(<format>, <match>, [code] = null)
     * @returns Nothing
     * @short Manually adds a new date input format.
     * @extra This method allows fine grained control for alternate formats. <format> is a string that can have regex tokens inside. <match> is an array of the tokens that each regex capturing group will map to, for example %year%, %date%, etc. For more, see @date_format.
     *
     **/
    'addFormat': function(format, match, localeCode) {
      addDateInputFormat(getLocalization(localeCode), format, match);
    }

  });

  extend(date, true, true, {

     /***
     * @method set(<set>, [reset] = false)
     * @returns Date
     * @short Sets the date object.
     * @extra This method can accept multiple formats including a single number as a timestamp, an object, or enumerated parameters (as with the Date constructor). If [reset] is %true%, any units more specific than those passed will be reset.
     *
     * @example
     *
     *   new Date().set({ year: 2011, month: 11, day: 31 }) -> December 31, 2011
     *   new Date().set(2011, 11, 31)                       -> December 31, 2011
     *   new Date().set(86400000)                           -> 1 day after Jan 1, 1970
     *   new Date().set({ year: 2004, month: 6 }, true)     -> June 1, 2004, 00:00:00.000
     *
     ***/
    'set': function() {
      var args = collectDateArguments(arguments);
      return updateDate(this, args[0], args[1])
    },

     /***
     * @method setWeekday()
     * @returns Nothing
     * @short Sets the weekday of the date.
     * @extra In order to maintain a parallel with %getWeekday% (which itself is an alias for Javascript native %getDay%), Sunday is considered day %0%. This contrasts with ISO-8601 standard (used in %getISOWeek% and %setISOWeek%) which places Sunday at the end of the week (day 7). This effectively means that passing %0% to this method while in the middle of a week will rewind the date, where passing %7% will advance it.
     *
     * @example
     *
     *   d = new Date(); d.setWeekday(1); d; -> Monday of this week
     *   d = new Date(); d.setWeekday(6); d; -> Saturday of this week
     *
     ***/
    'setWeekday': function(dow) {
      if(isUndefined(dow)) return;
      return callDateSet(this, 'Date', callDateGet(this, 'Date') + dow - callDateGet(this, 'Day'));
    },

     /***
     * @method setISOWeek()
     * @returns Nothing
     * @short Sets the week (of the year) as defined by the ISO-8601 standard.
     * @extra Note that this standard places Sunday at the end of the week (day 7).
     *
     * @example
     *
     *   d = new Date(); d.setISOWeek(15); d; -> 15th week of the year
     *
     ***/
    'setISOWeek': function(week) {
      var weekday = callDateGet(this, 'Day') || 7;
      if(isUndefined(week)) return;
      this.set({ 'month': 0, 'date': 4 });
      this.set({ 'weekday': 1 });
      if(week > 1) {
        this.addWeeks(week - 1);
      }
      if(weekday !== 1) {
        this.advance({ 'days': weekday - 1 });
      }
      return this.getTime();
    },

     /***
     * @method getISOWeek()
     * @returns Number
     * @short Gets the date's week (of the year) as defined by the ISO-8601 standard.
     * @extra Note that this standard places Sunday at the end of the week (day 7). If %utc% is set on the date, the week will be according to UTC time.
     *
     * @example
     *
     *   new Date().getISOWeek()    -> today's week of the year
     *
     ***/
    'getISOWeek': function() {
      return getWeekNumber(this);
    },

     /***
     * @method beginningOfISOWeek()
     * @returns Date
     * @short Set the date to the beginning of week as defined by this ISO-8601 standard.
     * @extra Note that this standard places Monday at the start of the week.
     * @example
     *
     *   Date.create().beginningOfISOWeek() -> Monday
     *
     ***/
    'beginningOfISOWeek': function() {
      var day = this.getDay();
      if(day === 0) {
        day = -6;
      } else if(day !== 1) {
        day = 1;
      }
      this.setWeekday(day);
      return this.reset();
    },

     /***
     * @method endOfISOWeek()
     * @returns Date
     * @short Set the date to the end of week as defined by this ISO-8601 standard.
     * @extra Note that this standard places Sunday at the end of the week.
     * @example
     *
     *   Date.create().endOfISOWeek() -> Sunday
     *
     ***/
    'endOfISOWeek': function() {
      if(this.getDay() !== 0) {
        this.setWeekday(7);
      }
      return this.endOfDay()
    },

     /***
     * @method getUTCOffset([iso])
     * @returns String
     * @short Returns a string representation of the offset from UTC time. If [iso] is true the offset will be in ISO8601 format.
     * @example
     *
     *   new Date().getUTCOffset()     -> "+0900"
     *   new Date().getUTCOffset(true) -> "+09:00"
     *
     ***/
    'getUTCOffset': function(iso) {
      var offset = this._utc ? 0 : this.getTimezoneOffset();
      var colon  = iso === true ? ':' : '';
      if(!offset && iso) return 'Z';
      return padNumber(floor(-offset / 60), 2, true) + colon + padNumber(abs(offset % 60), 2);
    },

     /***
     * @method utc([on] = true)
     * @returns Date
     * @short Sets the internal utc flag for the date. When on, UTC-based methods will be called internally.
     * @extra For more see @date_format.
     * @example
     *
     *   new Date().utc(true)
     *   new Date().utc(false)
     *
     ***/
    'utc': function(set) {
      defineProperty(this, '_utc', set === true || arguments.length === 0);
      return this;
    },

     /***
     * @method isUTC()
     * @returns Boolean
     * @short Returns true if the date has no timezone offset.
     * @extra This will also return true for utc-based dates (dates that have the %utc% method set true). Note that even if the utc flag is set, %getTimezoneOffset% will always report the same thing as Javascript always reports that based on the environment's locale.
     * @example
     *
     *   new Date().isUTC()           -> true or false?
     *   new Date().utc(true).isUTC() -> true
     *
     ***/
    'isUTC': function() {
      return !!this._utc || this.getTimezoneOffset() === 0;
    },

     /***
     * @method advance(<set>, [reset] = false)
     * @returns Date
     * @short Sets the date forward.
     * @extra This method can accept multiple formats including an object, a string in the format %3 days%, a single number as milliseconds, or enumerated parameters (as with the Date constructor). If [reset] is %true%, any units more specific than those passed will be reset. For more see @date_format.
     * @example
     *
     *   new Date().advance({ year: 2 }) -> 2 years in the future
     *   new Date().advance('2 days')    -> 2 days in the future
     *   new Date().advance(0, 2, 3)     -> 2 months 3 days in the future
     *   new Date().advance(86400000)    -> 1 day in the future
     *
     ***/
    'advance': function() {
      var args = collectDateArguments(arguments, true);
      return updateDate(this, args[0], args[1], 1);
    },

     /***
     * @method rewind(<set>, [reset] = false)
     * @returns Date
     * @short Sets the date back.
     * @extra This method can accept multiple formats including a single number as a timestamp, an object, or enumerated parameters (as with the Date constructor). If [reset] is %true%, any units more specific than those passed will be reset. For more see @date_format.
     * @example
     *
     *   new Date().rewind({ year: 2 }) -> 2 years in the past
     *   new Date().rewind(0, 2, 3)     -> 2 months 3 days in the past
     *   new Date().rewind(86400000)    -> 1 day in the past
     *
     ***/
    'rewind': function() {
      var args = collectDateArguments(arguments, true);
      return updateDate(this, args[0], args[1], -1);
    },

     /***
     * @method isValid()
     * @returns Boolean
     * @short Returns true if the date is valid.
     * @example
     *
     *   new Date().isValid()         -> true
     *   new Date('flexor').isValid() -> false
     *
     ***/
    'isValid': function() {
      return !isNaN(this.getTime());
    },

     /***
     * @method isAfter(<d>, [margin] = 0)
     * @returns Boolean
     * @short Returns true if the date is after the <d>.
     * @extra [margin] is to allow extra margin of error (in ms). <d> will accept a date object, timestamp, or text format. If not specified, <d> is assumed to be now. See @date_format for more.
     * @example
     *
     *   new Date().isAfter('tomorrow')  -> false
     *   new Date().isAfter('yesterday') -> true
     *
     ***/
    'isAfter': function(d, margin, utc) {
      return this.getTime() > date.create(d).getTime() - (margin || 0);
    },

     /***
     * @method isBefore(<d>, [margin] = 0)
     * @returns Boolean
     * @short Returns true if the date is before <d>.
     * @extra [margin] is to allow extra margin of error (in ms). <d> will accept a date object, timestamp, or text format. If not specified, <d> is assumed to be now. See @date_format for more.
     * @example
     *
     *   new Date().isBefore('tomorrow')  -> true
     *   new Date().isBefore('yesterday') -> false
     *
     ***/
    'isBefore': function(d, margin) {
      return this.getTime() < date.create(d).getTime() + (margin || 0);
    },

     /***
     * @method isBetween(<d1>, <d2>, [margin] = 0)
     * @returns Boolean
     * @short Returns true if the date falls between <d1> and <d2>.
     * @extra [margin] is to allow extra margin of error (in ms). <d1> and <d2> will accept a date object, timestamp, or text format. If not specified, they are assumed to be now. See @date_format for more.
     * @example
     *
     *   new Date().isBetween('yesterday', 'tomorrow')    -> true
     *   new Date().isBetween('last year', '2 years ago') -> false
     *
     ***/
    'isBetween': function(d1, d2, margin) {
      var t  = this.getTime();
      var t1 = date.create(d1).getTime();
      var t2 = date.create(d2).getTime();
      var lo = min(t1, t2);
      var hi = max(t1, t2);
      margin = margin || 0;
      return (lo - margin < t) && (hi + margin > t);
    },

     /***
     * @method isLeapYear()
     * @returns Boolean
     * @short Returns true if the date is a leap year.
     * @example
     *
     *   Date.create('2000').isLeapYear() -> true
     *
     ***/
    'isLeapYear': function() {
      var year = callDateGet(this, 'FullYear');
      return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
    },

     /***
     * @method daysInMonth()
     * @returns Number
     * @short Returns the number of days in the date's month.
     * @example
     *
     *   Date.create('May').daysInMonth()            -> 31
     *   Date.create('February, 2000').daysInMonth() -> 29
     *
     ***/
    'daysInMonth': function() {
      return 32 - callDateGet(new date(callDateGet(this, 'FullYear'), callDateGet(this, 'Month'), 32), 'Date');
    },

     /***
     * @method format(<format>, [locale] = currentLocale)
     * @returns String
     * @short Formats and outputs the date.
     * @extra <format> can be a number of pre-determined formats or a string of tokens. Locale-specific formats are %short%, %long%, and %full% which have their own aliases and can be called with %date.short()%, etc. If <format> is not specified the %long% format is assumed. [locale] specifies a locale code to use (if not specified the current locale is used). See @date_format for more details.
     *
     * @set
     *   short
     *   long
     *   full
     *
     * @example
     *
     *   Date.create().format()                                   -> ex. July 4, 2003
     *   Date.create().format('{Weekday} {d} {Month}, {yyyy}')    -> ex. Monday July 4, 2003
     *   Date.create().format('{hh}:{mm}')                        -> ex. 15:57
     *   Date.create().format('{12hr}:{mm}{tt}')                  -> ex. 3:57pm
     *   Date.create().format(Date.ISO8601_DATETIME)              -> ex. 2011-07-05 12:24:55.528Z
     *   Date.create('last week').format('short', 'ja')                -> ex. 先週
     *   Date.create('yesterday').format(function(value,unit,ms,loc) {
     *     // value = 1, unit = 3, ms = -86400000, loc = [current locale object]
     *   });                                                      -> ex. 1 day ago
     *
     ***/
    'format': function(f, localeCode) {
      return formatDate(this, f, false, localeCode);
    },

     /***
     * @method relative([fn], [locale] = currentLocale)
     * @returns String
     * @short Returns a relative date string offset to the current time.
     * @extra [fn] can be passed to provide for more granular control over the resulting string. [fn] is passed 4 arguments: the adjusted value, unit, offset in milliseconds, and a localization object. As an alternate syntax, [locale] can also be passed as the first (and only) parameter. For more, see @date_format.
     * @example
     *
     *   Date.create('90 seconds ago').relative() -> 1 minute ago
     *   Date.create('January').relative()        -> ex. 5 months ago
     *   Date.create('January').relative('ja')    -> 3ヶ月前
     *   Date.create('120 minutes ago').relative(function(val,unit,ms,loc) {
     *     // value = 2, unit = 3, ms = -7200, loc = [current locale object]
     *   });                                      -> ex. 5 months ago
     *
     ***/
    'relative': function(fn, localeCode) {
      if(isString(fn)) {
        localeCode = fn;
        fn = null;
      }
      return formatDate(this, fn, true, localeCode);
    },

     /***
     * @method is(<d>, [margin] = 0)
     * @returns Boolean
     * @short Returns true if the date is <d>.
     * @extra <d> will accept a date object, timestamp, or text format. %is% additionally understands more generalized expressions like month/weekday names, 'today', etc, and compares to the precision implied in <d>. [margin] allows an extra margin of error in milliseconds.  For more, see @date_format.
     * @example
     *
     *   Date.create().is('July')               -> true or false?
     *   Date.create().is('1776')               -> false
     *   Date.create().is('today')              -> true
     *   Date.create().is('weekday')            -> true or false?
     *   Date.create().is('July 4, 1776')       -> false
     *   Date.create().is(-6106093200000)       -> false
     *   Date.create().is(new Date(1776, 6, 4)) -> false
     *
     ***/
    'is': function(d, margin, utc) {
      var tmp, comp;
      if(!this.isValid()) return;
      if(isString(d)) {
        d = d.trim().toLowerCase();
        comp = this.clone().utc(utc);
        switch(true) {
          case d === 'future':  return this.getTime() > getNewDate().getTime();
          case d === 'past':    return this.getTime() < getNewDate().getTime();
          case d === 'weekday': return callDateGet(comp, 'Day') > 0 && callDateGet(comp, 'Day') < 6;
          case d === 'weekend': return callDateGet(comp, 'Day') === 0 || callDateGet(comp, 'Day') === 6;
          case (tmp = English['weekdays'].indexOf(d) % 7) > -1: return callDateGet(comp, 'Day') === tmp;
          case (tmp = English['months'].indexOf(d) % 12) > -1:  return callDateGet(comp, 'Month') === tmp;
        }
      }
      return compareDate(this, d, null, margin, utc);
    },

     /***
     * @method reset([unit] = 'hours')
     * @returns Date
     * @short Resets the unit passed and all smaller units. Default is "hours", effectively resetting the time.
     * @example
     *
     *   Date.create().reset('day')   -> Beginning of today
     *   Date.create().reset('month') -> 1st of the month
     *
     ***/
    'reset': function(unit) {
      var params = {}, recognized;
      unit = unit || 'hours';
      if(unit === 'date') unit = 'days';
      recognized = DateUnits.some(function(u) {
        return unit === u.name || unit === u.name + 's';
      });
      params[unit] = unit.match(/^days?/) ? 1 : 0;
      return recognized ? this.set(params, true) : this;
    },

     /***
     * @method clone()
     * @returns Date
     * @short Clones the date.
     * @example
     *
     *   Date.create().clone() -> Copy of now
     *
     ***/
    'clone': function() {
      var d = new date(this.getTime());
      d.utc(!!this._utc);
      return d;
    }

  });


  // Instance aliases
  extend(date, true, true, {

     /***
     * @method iso()
     * @alias toISOString
     *
     ***/
    'iso': function() {
      return this.toISOString();
    },

     /***
     * @method getWeekday()
     * @returns Number
     * @short Alias for %getDay%.
     * @set
     *   getUTCWeekday
     *
     * @example
     *
     +   Date.create().getWeekday();    -> (ex.) 3
     +   Date.create().getUTCWeekday();    -> (ex.) 3
     *
     ***/
    'getWeekday':    date.prototype.getDay,
    'getUTCWeekday':    date.prototype.getUTCDay

  });



  /***
   * Number module
   *
   ***/

  /***
   * @method [unit]()
   * @returns Number
   * @short Takes the number as a corresponding unit of time and converts to milliseconds.
   * @extra Method names can be singular or plural.  Note that as "a month" is ambiguous as a unit of time, %months% will be equivalent to 30.4375 days, the average number in a month. Be careful using %months% if you need exact precision.
   *
   * @set
   *   millisecond
   *   milliseconds
   *   second
   *   seconds
   *   minute
   *   minutes
   *   hour
   *   hours
   *   day
   *   days
   *   week
   *   weeks
   *   month
   *   months
   *   year
   *   years
   *
   * @example
   *
   *   (5).milliseconds() -> 5
   *   (10).hours()       -> 36000000
   *   (1).day()          -> 86400000
   *
   ***
   * @method [unit]Before([d], [locale] = currentLocale)
   * @returns Date
   * @short Returns a date that is <n> units before [d], where <n> is the number.
   * @extra [d] will accept a date object, timestamp, or text format. Note that "months" is ambiguous as a unit of time. If the target date falls on a day that does not exist (ie. August 31 -> February 31), the date will be shifted to the last day of the month. Be careful using %monthsBefore% if you need exact precision. See @date_format for more.
   *
   * @set
   *   millisecondBefore
   *   millisecondsBefore
   *   secondBefore
   *   secondsBefore
   *   minuteBefore
   *   minutesBefore
   *   hourBefore
   *   hoursBefore
   *   dayBefore
   *   daysBefore
   *   weekBefore
   *   weeksBefore
   *   monthBefore
   *   monthsBefore
   *   yearBefore
   *   yearsBefore
   *
   * @example
   *
   *   (5).daysBefore('tuesday')          -> 5 days before tuesday of this week
   *   (1).yearBefore('January 23, 1997') -> January 23, 1996
   *
   ***
   * @method [unit]Ago()
   * @returns Date
   * @short Returns a date that is <n> units ago.
   * @extra Note that "months" is ambiguous as a unit of time. If the target date falls on a day that does not exist (ie. August 31 -> February 31), the date will be shifted to the last day of the month. Be careful using %monthsAgo% if you need exact precision.
   *
   * @set
   *   millisecondAgo
   *   millisecondsAgo
   *   secondAgo
   *   secondsAgo
   *   minuteAgo
   *   minutesAgo
   *   hourAgo
   *   hoursAgo
   *   dayAgo
   *   daysAgo
   *   weekAgo
   *   weeksAgo
   *   monthAgo
   *   monthsAgo
   *   yearAgo
   *   yearsAgo
   *
   * @example
   *
   *   (5).weeksAgo() -> 5 weeks ago
   *   (1).yearAgo()  -> January 23, 1996
   *
   ***
   * @method [unit]After([d], [locale] = currentLocale)
   * @returns Date
   * @short Returns a date <n> units after [d], where <n> is the number.
   * @extra [d] will accept a date object, timestamp, or text format. Note that "months" is ambiguous as a unit of time. If the target date falls on a day that does not exist (ie. August 31 -> February 31), the date will be shifted to the last day of the month. Be careful using %monthsAfter% if you need exact precision. See @date_format for more.
   *
   * @set
   *   millisecondAfter
   *   millisecondsAfter
   *   secondAfter
   *   secondsAfter
   *   minuteAfter
   *   minutesAfter
   *   hourAfter
   *   hoursAfter
   *   dayAfter
   *   daysAfter
   *   weekAfter
   *   weeksAfter
   *   monthAfter
   *   monthsAfter
   *   yearAfter
   *   yearsAfter
   *
   * @example
   *
   *   (5).daysAfter('tuesday')          -> 5 days after tuesday of this week
   *   (1).yearAfter('January 23, 1997') -> January 23, 1998
   *
   ***
   * @method [unit]FromNow()
   * @returns Date
   * @short Returns a date <n> units from now.
   * @extra Note that "months" is ambiguous as a unit of time. If the target date falls on a day that does not exist (ie. August 31 -> February 31), the date will be shifted to the last day of the month. Be careful using %monthsFromNow% if you need exact precision.
   *
   * @set
   *   millisecondFromNow
   *   millisecondsFromNow
   *   secondFromNow
   *   secondsFromNow
   *   minuteFromNow
   *   minutesFromNow
   *   hourFromNow
   *   hoursFromNow
   *   dayFromNow
   *   daysFromNow
   *   weekFromNow
   *   weeksFromNow
   *   monthFromNow
   *   monthsFromNow
   *   yearFromNow
   *   yearsFromNow
   *
   * @example
   *
   *   (5).weeksFromNow() -> 5 weeks ago
   *   (1).yearFromNow()  -> January 23, 1998
   *
   ***/
  function buildNumberToDateAlias(u, multiplier) {
    var name = u.name, methods = {};
    function base() { return round(this * multiplier); }
    function after() { return createDate(arguments)[u.addMethod](this);  }
    function before() { return createDate(arguments)[u.addMethod](-this); }
    methods[name] = base;
    methods[name + 's'] = base;
    methods[name + 'Before'] = before;
    methods[name + 'sBefore'] = before;
    methods[name + 'Ago'] = before;
    methods[name + 'sAgo'] = before;
    methods[name + 'After'] = after;
    methods[name + 'sAfter'] = after;
    methods[name + 'FromNow'] = after;
    methods[name + 'sFromNow'] = after;
    number.extend(methods);
  }

  extend(number, true, true, {

     /***
     * @method duration([locale] = currentLocale)
     * @returns String
     * @short Takes the number as milliseconds and returns a unit-adjusted localized string.
     * @extra This method is the same as %Date#relative% without the localized equivalent of "from now" or "ago". [locale] can be passed as the first (and only) parameter. Note that this method is only available when the dates package is included.
     * @example
     *
     *   (500).duration() -> '500 milliseconds'
     *   (1200).duration() -> '1 second'
     *   (75).minutes().duration() -> '1 hour'
     *   (75).minutes().duration('es') -> '1 hora'
     *
     ***/
    'duration': function(localeCode) {
      return getLocalization(localeCode).getDuration(this);
    }

  });


  English = CurrentLocalization = date.addLocale('en', {
    'plural':     true,
    'timeMarker': 'at',
    'ampm':       'am,pm',
    'months':     'January,February,March,April,May,June,July,August,September,October,November,December',
    'weekdays':   'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday',
    'units':      'millisecond:|s,second:|s,minute:|s,hour:|s,day:|s,week:|s,month:|s,year:|s',
    'numbers':    'one,two,three,four,five,six,seven,eight,nine,ten',
    'articles':   'a,an,the',
    'tokens':     'the,st|nd|rd|th,of',
    'short':      '{Month} {d}, {yyyy}',
    'long':       '{Month} {d}, {yyyy} {h}:{mm}{tt}',
    'full':       '{Weekday} {Month} {d}, {yyyy} {h}:{mm}:{ss}{tt}',
    'past':       '{num} {unit} {sign}',
    'future':     '{num} {unit} {sign}',
    'duration':   '{num} {unit}',
    'modifiers': [
      { 'name': 'sign',  'src': 'ago|before', 'value': -1 },
      { 'name': 'sign',  'src': 'from now|after|from|in|later', 'value': 1 },
      { 'name': 'edge',  'src': 'last day', 'value': -2 },
      { 'name': 'edge',  'src': 'end', 'value': -1 },
      { 'name': 'edge',  'src': 'first day|beginning', 'value': 1 },
      { 'name': 'shift', 'src': 'last', 'value': -1 },
      { 'name': 'shift', 'src': 'the|this', 'value': 0 },
      { 'name': 'shift', 'src': 'next', 'value': 1 }
    ],
    'dateParse': [
      '{month} {year}',
      '{shift} {unit=5-7}',
      '{0?} {date}{1}',
      '{0?} {edge} of {shift?} {unit=4-7?}{month?}{year?}'
    ],
    'timeParse': [
      '{num} {unit} {sign}',
      '{sign} {num} {unit}',
      '{0} {num}{1} {day} of {month} {year?}',
      '{weekday?} {month} {date}{1?} {year?}',
      '{date} {month} {year}',
      '{date} {month}',
      '{shift} {weekday}',
      '{shift} week {weekday}',
      '{weekday} {2?} {shift} week',
      '{num} {unit=4-5} {sign} {day}',
      '{0?} {date}{1} of {month}',
      '{0?}{month?} {date?}{1?} of {shift} {unit=6-7}'
    ]
  });

  buildDateUnits();
  buildDateMethods();
  buildCoreInputFormats();
  buildFormatTokens();
  buildFormatShortcuts();
  buildAsianDigits();
  buildRelativeAliases();
  buildUTCAliases();
  setDateProperties();


  /***
   * @package Range
   * @dependency core
   * @description Ranges allow creating spans of numbers, strings, or dates. They can enumerate over specific points within that range, and be manipulated and compared.
   *
   ***/

  function Range(start, end) {
    this.start = cloneRangeMember(start);
    this.end   = cloneRangeMember(end);
  };

  function getRangeMemberNumericValue(m) {
    return isString(m) ? m.charCodeAt(0) : m;
  }

  function getRangeMemberPrimitiveValue(m) {
    if(m == null) return m;
    return isDate(m) ? m.getTime() : m.valueOf();
  }

  function cloneRangeMember(m) {
    if(isDate(m)) {
      return new date(m.getTime());
    } else {
      return getRangeMemberPrimitiveValue(m);
    }
  }

  function isValidRangeMember(m) {
    var val = getRangeMemberPrimitiveValue(m);
    return !!val || val === 0;
  }

  function getDuration(amt) {
    var match, val, unit;
    if(isNumber(amt)) {
      return amt;
    }
    match = amt.toLowerCase().match(/^(\d+)?\s?(\w+?)s?$/i);
    val = parseInt(match[1]) || 1;
    unit = match[2].slice(0,1).toUpperCase() + match[2].slice(1);
    if(unit.match(/hour|minute|second/i)) {
      unit += 's';
    } else if(unit === 'Year') {
      unit = 'FullYear';
    } else if(unit === 'Day') {
      unit = 'Date';
    }
    return [val, unit];
  }

  function incrementDate(current, amount) {
    var num, unit, val, d;
    if(isNumber(amount)) {
      return new date(current.getTime() + amount);
    }
    num  = amount[0];
    unit = amount[1];
    val  = callDateGet(current, unit);
    d    = new date(current.getTime());
    callDateSet(d, unit, val + num);
    return d;
  }

  function incrementString(current, amount) {
    return string.fromCharCode(current.charCodeAt(0) + amount);
  }

  function incrementNumber(current, amount) {
    return current + amount;
  }

  /***
   * @method toString()
   * @returns String
   * @short Returns a string representation of the range.
   * @example
   *
   *   Number.range(1, 5).toString()                               -> 1..5
   *   Date.range(new Date(2003, 0), new Date(2005, 0)).toString() -> January 1, 2003..January 1, 2005
   *
   ***/

  // Note: 'toString' doesn't appear in a for..in loop in IE even though
  // hasOwnProperty reports true, so extend() can't be used here.
  // Also tried simply setting the prototype = {} up front for all
  // methods but GCC very oddly started dropping properties in the
  // object randomly (maybe because of the global scope?) hence
  // the need for the split logic here.
  Range.prototype.toString = function() {
    return this.isValid() ? this.start + ".." + this.end : 'Invalid Range';
  };

  extend(Range, true, true, {

    /***
     * @method isValid()
     * @returns Boolean
     * @short Returns true if the range is valid, false otherwise.
     * @example
     *
     *   Date.range(new Date(2003, 0), new Date(2005, 0)).isValid() -> true
     *   Number.range(NaN, NaN).isValid()                           -> false
     *
     ***/
    'isValid': function() {
      return isValidRangeMember(this.start) && isValidRangeMember(this.end) && typeof this.start === typeof this.end;
    },

    /***
     * @method span()
     * @returns Number
     * @short Returns the span of the range. If the range is a date range, the value is in milliseconds.
     * @extra The span includes both the start and the end.
     * @example
     *
     *   Number.range(5, 10).span()                              -> 6
     *   Date.range(new Date(2003, 0), new Date(2005, 0)).span() -> 94694400000
     *
     ***/
    'span': function() {
      return this.isValid() ? abs(
        getRangeMemberNumericValue(this.end) - getRangeMemberNumericValue(this.start)
      ) + 1 : NaN;
    },

    /***
     * @method contains(<obj>)
     * @returns Boolean
     * @short Returns true if <obj> is contained inside the range. <obj> may be a value or another range.
     * @example
     *
     *   Number.range(5, 10).contains(7)                                              -> true
     *   Date.range(new Date(2003, 0), new Date(2005, 0)).contains(new Date(2004, 0)) -> true
     *
     ***/
    'contains': function(obj) {
      var self = this, arr;
      if(obj == null) return false;
      if(obj.start && obj.end) {
        return obj.start >= this.start && obj.start <= this.end &&
               obj.end   >= this.start && obj.end   <= this.end;
      } else {
        return obj >= this.start && obj <= this.end;
      }
    },

    /***
     * @method every(<amount>, [fn])
     * @returns Array
     * @short Iterates through the range for every <amount>, calling [fn] if it is passed. Returns an array of each increment visited.
     * @extra In the case of date ranges, <amount> can also be a string, in which case it will increment a number of  units. Note that %(2).months()% first resolves to a number, which will be interpreted as milliseconds and is an approximation, so stepping through the actual months by passing %"2 months"% is usually preferable.
     * @example
     *
     *   Number.range(2, 8).every(2)                                       -> [2,4,6,8]
     *   Date.range(new Date(2003, 1), new Date(2003,3)).every("2 months") -> [...]
     *
     ***/
    'every': function(amount, fn) {
      var increment,
          start   = this.start,
          end     = this.end,
          inverse = end < start,
          current = start,
          index   = 0,
          result  = [];

      if(isFunction(amount)) {
        fn = amount;
        amount = null;
      }
      amount = amount || 1;
      if(isNumber(start)) {
        increment = incrementNumber;
      } else if(isString(start)) {
        increment = incrementString;
      } else if(isDate(start)) {
        amount    = getDuration(amount);
        increment = incrementDate;
      }
      // Avoiding infinite loops
      if(inverse && amount > 0) {
        amount *= -1;
      }
      while(inverse ? current >= end : current <= end) {
        result.push(current);
        if(fn) {
          fn(current, index);
        }
        current = increment(current, amount);
        index++;
      }
      return result;
    },

    /***
     * @method union(<range>)
     * @returns Range
     * @short Returns a new range with the earliest starting point as its start, and the latest ending point as its end. If the two ranges do not intersect this will effectively remove the "gap" between them.
     * @example
     *
     *   Number.range(1, 3).union(Number.range(2, 5)) -> 1..5
     *   Date.range(new Date(2003, 1), new Date(2005, 1)).union(Date.range(new Date(2004, 1), new Date(2006, 1))) -> Jan 1, 2003..Jan 1, 2006
     *
     ***/
    'union': function(range) {
      return new Range(
        this.start < range.start ? this.start : range.start,
        this.end   > range.end   ? this.end   : range.end
      );
    },

    /***
     * @method intersect(<range>)
     * @returns Range
     * @short Returns a new range with the latest starting point as its start, and the earliest ending point as its end. If the two ranges do not intersect this will effectively produce an invalid range.
     * @example
     *
     *   Number.range(1, 5).intersect(Number.range(4, 8)) -> 4..5
     *   Date.range(new Date(2003, 1), new Date(2005, 1)).intersect(Date.range(new Date(2004, 1), new Date(2006, 1))) -> Jan 1, 2004..Jan 1, 2005
     *
     ***/
    'intersect': function(range) {
      if(range.start > this.end || range.end < this.start) {
        return new Range(NaN, NaN);
      }
      return new Range(
        this.start > range.start ? this.start : range.start,
        this.end   < range.end   ? this.end   : range.end
      );
    },

    /***
     * @method clone()
     * @returns Range
     * @short Clones the range.
     * @extra Members of the range will also be cloned.
     * @example
     *
     *   Number.range(1, 5).clone() -> Returns a copy of the range.
     *
     ***/
    'clone': function(range) {
      return new Range(this.start, this.end);
    },

    /***
     * @method clamp(<obj>)
     * @returns Mixed
     * @short Clamps <obj> to be within the range if it falls outside.
     * @example
     *
     *   Number.range(1, 5).clamp(8) -> 5
     *   Date.range(new Date(2010, 0), new Date(2012, 0)).clamp(new Date(2013, 0)) -> 2012-01
     *
     ***/
    'clamp': function(obj) {
      var clamped,
          start = this.start,
          end = this.end,
          min = end < start ? end : start,
          max = start > end ? start : end;
      if(obj < min) {
        clamped = min;
      } else if(obj > max) {
        clamped = max;
      } else {
        clamped = obj;
      }
      return cloneRangeMember(clamped);
    }

  });


  /***
   * Number module
   ***
   * @method Number.range([start], [end])
   * @returns Range
   * @short Creates a new range between [start] and [end]. See @ranges for more.
   * @example
   *
   *   Number.range(5, 10)
   *
   ***
   * String module
   ***
   * @method String.range([start], [end])
   * @returns Range
   * @short Creates a new range between [start] and [end]. See @ranges for more.
   * @example
   *
   *   String.range('a', 'z')
   *
   ***
   * Date module
   ***
   * @method Date.range([start], [end])
   * @returns Range
   * @short Creates a new range between [start] and [end].
   * @extra If either [start] or [end] are null, they will default to the current date. See @ranges for more.
   * @example
   *
   *   Date.range('today', 'tomorrow')
   *
   ***/
  [number, string, date].forEach(function(klass) {
     extend(klass, false, true, {

      'range': function(start, end) {
        if(klass.create) {
          start = klass.create(start);
          end   = klass.create(end);
        }
        return new Range(start, end);
      }

    });

  });

  /***
   * Number module
   *
   ***/

  extend(number, true, true, {

    /***
     * @method upto(<num>, [fn], [step] = 1)
     * @returns Array
     * @short Returns an array containing numbers from the number up to <num>.
     * @extra Optionally calls [fn] callback for each number in that array. [step] allows multiples greater than 1.
     * @example
     *
     *   (2).upto(6) -> [2, 3, 4, 5, 6]
     *   (2).upto(6, function(n) {
     *     // This function is called 5 times receiving n as the value.
     *   });
     *   (2).upto(8, null, 2) -> [2, 4, 6, 8]
     *
     ***/
    'upto': function(num, fn, step) {
      return number.range(this, num).every(step, fn);
    },

     /***
     * @method clamp([start] = Infinity, [end] = Infinity)
     * @returns Number
     * @short Constrains the number so that it is between [start] and [end].
     * @extra This will build a range object that has an equivalent %clamp% method.
     * @example
     *
     *   (3).clamp(50, 100)  -> 50
     *   (85).clamp(50, 100) -> 85
     *
     ***/
    'clamp': function(start, end) {
      return new Range(start, end).clamp(this);
    },

     /***
     * @method cap([max] = Infinity)
     * @returns Number
     * @short Constrains the number so that it is no greater than [max].
     * @extra This will build a range object that has an equivalent %cap% method.
     * @example
     *
     *   (100).cap(80) -> 80
     *
     ***/
    'cap': function(max) {
      return this.clamp(Undefined, max);
    }

  });

  extend(number, true, true, {

    /***
     * @method downto(<num>, [fn], [step] = 1)
     * @returns Array
     * @short Returns an array containing numbers from the number down to <num>.
     * @extra Optionally calls [fn] callback for each number in that array. [step] allows multiples greater than 1.
     * @example
     *
     *   (8).downto(3) -> [8, 7, 6, 5, 4, 3]
     *   (8).downto(3, function(n) {
     *     // This function is called 6 times receiving n as the value.
     *   });
     *   (8).downto(2, null, 2) -> [8, 6, 4, 2]
     *
     ***/
    'downto': number.prototype.upto

  });


  /***
   * Array module
   *
   ***/

  extend(array, false, function(a) { return a instanceof Range; }, {

    'create': function(range) {
      return range.every();
    }

  });


  /***
   * @package Function
   * @dependency core
   * @description Lazy, throttled, and memoized functions, delayed functions and handling of timers, argument currying.
   *
   ***/

  function setDelay(fn, ms, after, scope, args) {
    // Delay of infinity is never called of course...
    if(ms === Infinity) return;
    if(!fn.timers) fn.timers = [];
    if(!isNumber(ms)) ms = 1;
    // This is a workaround for <= IE8, which apparently has the
    // ability to call timeouts in the queue on the same tick (ms?)
    // even if functionally they have already been cleared.
    fn._canceled = false;
    fn.timers.push(setTimeout(function(){
      if(!fn._canceled) {
        after.apply(scope, args || []);
      }
    }, ms));
  }

  extend(Function, true, true, {

     /***
     * @method lazy([ms] = 1, [immediate] = false, [limit] = Infinity)
     * @returns Function
     * @short Creates a lazy function that, when called repeatedly, will queue execution and wait [ms] milliseconds to execute.
     * @extra If [immediate] is %true%, first execution will happen immediately, then lock. If [limit] is a fininte number, calls past [limit] will be ignored while execution is locked. Compare this to %throttle%, which will execute only once per [ms] milliseconds. Note that [ms] can also be a fraction. Calling %cancel% on a lazy function will clear the entire queue. For more see @functions.
     * @example
     *
     *   (function() {
     *     // Executes immediately.
     *   }).lazy()();
     *   (3).times(function() {
     *     // Executes 3 times, with each execution 20ms later than the last.
     *   }.lazy(20));
     *   (100).times(function() {
     *     // Executes 50 times, with each execution 20ms later than the last.
     *   }.lazy(20, false, 50));
     *
     ***/
    'lazy': function(ms, immediate, limit) {
      var fn = this, queue = [], locked = false, execute, rounded, perExecution, result;
      ms = ms || 1;
      limit = limit || Infinity;
      rounded = ceil(ms);
      perExecution = round(rounded / ms) || 1;
      execute = function() {
        var queueLength = queue.length, maxPerRound;
        if(queueLength == 0) return;
        // Allow fractions of a millisecond by calling
        // multiple times per actual timeout execution
        maxPerRound = max(queueLength - perExecution, 0);
        while(queueLength > maxPerRound) {
          // Getting uber-meta here...
          result = Function.prototype.apply.apply(fn, queue.shift());
          queueLength--;
        }
        setDelay(lazy, rounded, function() {
          locked = false;
          execute();
        });
      }
      function lazy() {
        // If the execution has locked and it's immediate, then
        // allow 1 less in the queue as 1 call has already taken place.
        if(queue.length < limit - (locked && immediate ? 1 : 0)) {
          queue.push([this, arguments]);
        }
        if(!locked) {
          locked = true;
          if(immediate) {
            execute();
          } else {
            setDelay(lazy, rounded, execute);
          }
        }
        // Return the memoized result
        return result;
      }
      return lazy;
    },

     /***
     * @method throttle([ms] = 1)
     * @returns Function
     * @short Creates a "throttled" version of the function that will only be executed once per <ms> milliseconds.
     * @extra This is functionally equivalent to calling %lazy% with a [limit] of %1% and [immediate] as %true%. %throttle% is appropriate when you want to make sure a function is only executed at most once for a given duration. For more see @functions.
     * @example
     *
     *   (3).times(function() {
     *     // called only once. will wait 50ms until it responds again
     *   }.throttle(50));
     *
     ***/
    'throttle': function(ms) {
      return this.lazy(ms, true, 1);
    },

     /***
     * @method debounce([ms] = 1)
     * @returns Function
     * @short Creates a "debounced" function that postpones its execution until after <ms> milliseconds have passed.
     * @extra This method is useful to execute a function after things have "settled down". A good example of this is when a user tabs quickly through form fields, execution of a heavy operation should happen after a few milliseconds when they have "settled" on a field. For more see @functions.
     * @example
     *
     *   var fn = (function(arg1) {
     *     // called once 50ms later
     *   }).debounce(50); fn() fn() fn();
     *
     ***/
    'debounce': function(ms) {
      var fn = this;
      function debounced() {
        debounced.cancel();
        setDelay(debounced, ms, fn, this, arguments);
      };
      return debounced;
    },

     /***
     * @method delay([ms] = 1, [arg1], ...)
     * @returns Function
     * @short Executes the function after <ms> milliseconds.
     * @extra Returns a reference to itself. %delay% is also a way to execute non-blocking operations that will wait until the CPU is free. Delayed functions can be canceled using the %cancel% method. Can also curry arguments passed in after <ms>.
     * @example
     *
     *   (function(arg1) {
     *     // called 1s later
     *   }).delay(1000, 'arg1');
     *
     ***/
    'delay': function(ms) {
      var fn = this;
      var args = multiArgs(arguments, null, 1);
      setDelay(fn, ms, fn, fn, args);
      return fn;
    },

     /***
     * @method every([ms] = 1, [arg1], ...)
     * @returns Function
     * @short Executes the function every <ms> milliseconds.
     * @extra Returns a reference to itself. Repeating functions with %every% can be canceled using the %cancel% method. Can also curry arguments passed in after <ms>.
     * @example
     *
     *   (function(arg1) {
     *     // called every 1s
     *   }).every(1000, 'arg1');
     *
     ***/
    'every': function(ms) {
      var fn = this, args = arguments;
      args = args.length > 1 ? multiArgs(args, null, 1) : [];
      function execute () {
        fn.apply(fn, args);
        setDelay(fn, ms, execute);
      }
      setDelay(fn, ms, execute);
      return fn;
    },

     /***
     * @method cancel()
     * @returns Function
     * @short Cancels a delayed function scheduled to be run.
     * @extra %delay%, %lazy%, %throttle%, and %debounce% can all set delays.
     * @example
     *
     *   (function() {
     *     alert('hay'); // Never called
     *   }).delay(500).cancel();
     *
     ***/
    'cancel': function() {
      var timers = this.timers, timer;
      if(isArray(timers)) {
        while(timer = timers.shift()) {
          clearTimeout(timer);
        }
      }
      this._canceled = true;
      return this;
    },

     /***
     * @method after([num] = 1)
     * @returns Function
     * @short Creates a function that will execute after [num] calls.
     * @extra %after% is useful for running a final callback after a series of asynchronous operations, when the order in which the operations will complete is unknown.
     * @example
     *
     *   var fn = (function() {
     *     // Will be executed once only
     *   }).after(3); fn(); fn(); fn();
     *
     ***/
    'after': function(num) {
      var fn = this, counter = 0, storedArguments = [];
      if(!isNumber(num)) {
        num = 1;
      } else if(num === 0) {
        fn.call();
        return fn;
      }
      return function() {
        var ret;
        storedArguments.push(multiArgs(arguments));
        counter++;
        if(counter == num) {
          ret = fn.call(this, storedArguments);
          counter = 0;
          storedArguments = [];
          return ret;
        }
      }
    },

     /***
     * @method once()
     * @returns Function
     * @short Creates a function that will execute only once and store the result.
     * @extra %once% is useful for creating functions that will cache the result of an expensive operation and use it on subsequent calls. Also it can be useful for creating initialization functions that only need to be run once.
     * @example
     *
     *   var fn = (function() {
     *     // Will be executed once only
     *   }).once(); fn(); fn(); fn();
     *
     ***/
    'once': function() {
      return this.throttle(Infinity, true);
    },

     /***
     * @method fill(<arg1>, <arg2>, ...)
     * @returns Function
     * @short Returns a new version of the function which when called will have some of its arguments pre-emptively filled in, also known as "currying".
     * @extra Arguments passed to a "filled" function are generally appended to the curried arguments. However, if %undefined% is passed as any of the arguments to %fill%, it will be replaced, when the "filled" function is executed. This allows currying of arguments even when they occur toward the end of an argument list (the example demonstrates this much more clearly).
     * @example
     *
     *   var delayOneSecond = setTimeout.fill(undefined, 1000);
     *   delayOneSecond(function() {
     *     // Will be executed 1s later
     *   });
     *
     ***/
    'fill': function() {
      var fn = this, curried = multiArgs(arguments);
      return function() {
        var args = multiArgs(arguments);
        curried.forEach(function(arg, index) {
          if(arg != null || index >= args.length) args.splice(index, 0, arg);
        });
        return fn.apply(this, args);
      }
    }


  });


  /***
   * @package Number
   * @dependency core
   * @description Number formatting, rounding (with precision), and ranges. Aliases to Math methods.
   *
   ***/


  function abbreviateNumber(num, roundTo, str, mid, limit, bytes) {
    var fixed        = num.toFixed(20),
        decimalPlace = fixed.search(/\./),
        numeralPlace = fixed.search(/[1-9]/),
        significant  = decimalPlace - numeralPlace,
        unit, i, divisor;
    if(significant > 0) {
      significant -= 1;
    }
    i = max(min(floor(significant / 3), limit === false ? str.length : limit), -mid);
    unit = str.charAt(i + mid - 1);
    if(significant < -9) {
      i = -3;
      roundTo = abs(significant) - 9;
      unit = str.slice(0,1);
    }
    divisor = bytes ? pow(2, 10 * i) : pow(10, i * 3);
    return withPrecision(num / divisor, roundTo || 0).format() + unit.trim();
  }


  extend(number, false, true, {

    /***
     * @method Number.random([n1], [n2])
     * @returns Number
     * @short Returns a random integer between [n1] and [n2].
     * @extra If only 1 number is passed, the other will be 0. If none are passed, the number will be either 0 or 1.
     * @example
     *
     *   Number.random(50, 100) -> ex. 85
     *   Number.random(50)      -> ex. 27
     *   Number.random()        -> ex. 0
     *
     ***/
    'random': function(n1, n2) {
      var minNum, maxNum;
      if(arguments.length == 1) n2 = n1, n1 = 0;
      minNum = min(n1 || 0, isUndefined(n2) ? 1 : n2);
      maxNum = max(n1 || 0, isUndefined(n2) ? 1 : n2) + 1;
      return floor((math.random() * (maxNum - minNum)) + minNum);
    }

  });

  extend(number, true, true, {

    /***
     * @method log(<base> = Math.E)
     * @returns Number
     * @short Returns the logarithm of the number with base <base>, or natural logarithm of the number if <base> is undefined.
     * @example
     *
     *   (64).log(2) -> 6
     *   (9).log(3)  -> 2
     *   (5).log()   -> 1.6094379124341003
     *
     ***/

    'log': function(base) {
       return math.log(this) / (base ? math.log(base) : 1);
     },

    /***
     * @method abbr([precision] = 0)
     * @returns String
     * @short Returns an abbreviated form of the number.
     * @extra [precision] will round to the given precision.
     * @example
     *
     *   (1000).abbr()    -> "1k"
     *   (1000000).abbr() -> "1m"
     *   (1280).abbr(1)   -> "1.3k"
     *
     ***/
    'abbr': function(precision) {
      return abbreviateNumber(this, precision, 'kmbt', 0, 4);
    },

    /***
     * @method metric([precision] = 0, [limit] = 1)
     * @returns String
     * @short Returns the number as a string in metric notation.
     * @extra [precision] will round to the given precision. Both very large numbers and very small numbers are supported. [limit] is the upper limit for the units. The default is %1%, which is "kilo". If [limit] is %false%, the upper limit will be "exa". The lower limit is "nano", and cannot be changed.
     * @example
     *
     *   (1000).metric()            -> "1k"
     *   (1000000).metric()         -> "1,000k"
     *   (1000000).metric(0, false) -> "1M"
     *   (1249).metric(2) + 'g'     -> "1.25kg"
     *   (0.025).metric() + 'm'     -> "25mm"
     *
     ***/
    'metric': function(precision, limit) {
      return abbreviateNumber(this, precision, 'nμm kMGTPE', 4, isUndefined(limit) ? 1 : limit);
    },

    /***
     * @method bytes([precision] = 0, [limit] = 4)
     * @returns String
     * @short Returns an abbreviated form of the number, considered to be "Bytes".
     * @extra [precision] will round to the given precision. [limit] is the upper limit for the units. The default is %4%, which is "terabytes" (TB). If [limit] is %false%, the upper limit will be "exa".
     * @example
     *
     *   (1000).bytes()                 -> "1kB"
     *   (1000).bytes(2)                -> "0.98kB"
     *   ((10).pow(20)).bytes()         -> "90,949,470TB"
     *   ((10).pow(20)).bytes(0, false) -> "87EB"
     *
     ***/
    'bytes': function(precision, limit) {
      return abbreviateNumber(this, precision, 'kMGTPE', 0, isUndefined(limit) ? 4 : limit, true) + 'B';
    },

    /***
     * @method isInteger()
     * @returns Boolean
     * @short Returns true if the number has no trailing decimal.
     * @example
     *
     *   (420).isInteger() -> true
     *   (4.5).isInteger() -> false
     *
     ***/
    'isInteger': function() {
      return this % 1 == 0;
    },

    /***
     * @method isOdd()
     * @returns Boolean
     * @short Returns true if the number is odd.
     * @example
     *
     *   (3).isOdd()  -> true
     *   (18).isOdd() -> false
     *
     ***/
    'isOdd': function() {
      return !isNaN(this) && !this.isMultipleOf(2);
    },

    /***
     * @method isEven()
     * @returns Boolean
     * @short Returns true if the number is even.
     * @example
     *
     *   (6).isEven()  -> true
     *   (17).isEven() -> false
     *
     ***/
    'isEven': function() {
      return this.isMultipleOf(2);
    },

    /***
     * @method isMultipleOf(<num>)
     * @returns Boolean
     * @short Returns true if the number is a multiple of <num>.
     * @example
     *
     *   (6).isMultipleOf(2)  -> true
     *   (17).isMultipleOf(2) -> false
     *   (32).isMultipleOf(4) -> true
     *   (34).isMultipleOf(4) -> false
     *
     ***/
    'isMultipleOf': function(num) {
      return this % num === 0;
    },


    /***
     * @method format([place] = 0, [thousands] = ',', [decimal] = '.')
     * @returns String
     * @short Formats the number to a readable string.
     * @extra If [place] is %undefined%, will automatically determine the place. [thousands] is the character used for the thousands separator. [decimal] is the character used for the decimal point.
     * @example
     *
     *   (56782).format()           -> '56,782'
     *   (56782).format(2)          -> '56,782.00'
     *   (4388.43).format(2, ' ')      -> '4 388.43'
     *   (4388.43).format(2, '.', ',') -> '4.388,43'
     *
     ***/
    'format': function(place, thousands, decimal) {
      var i, str, split, integer, fraction, result = '';
      if(isUndefined(thousands)) {
        thousands = ',';
      }
      if(isUndefined(decimal)) {
        decimal = '.';
      }
      str      = (isNumber(place) ? withPrecision(this, place || 0).toFixed(max(place, 0)) : this.toString()).replace(/^-/, '');
      split    = str.split('.');
      integer  = split[0];
      fraction = split[1];
      for(i = integer.length; i > 0; i -= 3) {
        if(i < integer.length) {
          result = thousands + result;
        }
        result = integer.slice(max(0, i - 3), i) + result;
      }
      if(fraction) {
        result += decimal + repeatString('0', (place || 0) - fraction.length) + fraction;
      }
      return (this < 0 ? '-' : '') + result;
    },

    /***
     * @method hex([pad] = 1)
     * @returns String
     * @short Converts the number to hexidecimal.
     * @extra [pad] will pad the resulting string to that many places.
     * @example
     *
     *   (255).hex()   -> 'ff';
     *   (255).hex(4)  -> '00ff';
     *   (23654).hex() -> '5c66';
     *
     ***/
    'hex': function(pad) {
      return this.pad(pad || 1, false, 16);
    },

    /***
     * @method times(<fn>)
     * @returns Number
     * @short Calls <fn> a number of times equivalent to the number.
     * @example
     *
     *   (8).times(function(i) {
     *     // This function is called 8 times.
     *   });
     *
     ***/
    'times': function(fn) {
      if(fn) {
        for(var i = 0; i < this; i++) {
          fn.call(this, i);
        }
      }
      return this.toNumber();
    },

    /***
     * @method chr()
     * @returns String
     * @short Returns a string at the code point of the number.
     * @example
     *
     *   (65).chr() -> "A"
     *   (75).chr() -> "K"
     *
     ***/
    'chr': function() {
      return string.fromCharCode(this);
    },

    /***
     * @method pad(<place> = 0, [sign] = false, [base] = 10)
     * @returns String
     * @short Pads a number with "0" to <place>.
     * @extra [sign] allows you to force the sign as well (+05, etc). [base] can change the base for numeral conversion.
     * @example
     *
     *   (5).pad(2)        -> '05'
     *   (-5).pad(4)       -> '-0005'
     *   (82).pad(3, true) -> '+082'
     *
     ***/
    'pad': function(place, sign, base) {
      return padNumber(this, place, sign, base);
    },

    /***
     * @method ordinalize()
     * @returns String
     * @short Returns an ordinalized (English) string, i.e. "1st", "2nd", etc.
     * @example
     *
     *   (1).ordinalize() -> '1st';
     *   (2).ordinalize() -> '2nd';
     *   (8).ordinalize() -> '8th';
     *
     ***/
    'ordinalize': function() {
      var suffix, num = abs(this), last = parseInt(num.toString().slice(-2));
      return this + getOrdinalizedSuffix(last);
    },

    /***
     * @method toNumber()
     * @returns Number
     * @short Returns a number. This is mostly for compatibility reasons.
     * @example
     *
     *   (420).toNumber() -> 420
     *
     ***/
    'toNumber': function() {
      return parseFloat(this, 10);
    }

  });

  /***
   * @method round(<precision> = 0)
   * @returns Number
   * @short Shortcut for %Math.round% that also allows a <precision>.
   *
   * @example
   *
   *   (3.241).round()  -> 3
   *   (-3.841).round() -> -4
   *   (3.241).round(2) -> 3.24
   *   (3748).round(-2) -> 3800
   *
   ***
   * @method ceil(<precision> = 0)
   * @returns Number
   * @short Shortcut for %Math.ceil% that also allows a <precision>.
   *
   * @example
   *
   *   (3.241).ceil()  -> 4
   *   (-3.241).ceil() -> -3
   *   (3.241).ceil(2) -> 3.25
   *   (3748).ceil(-2) -> 3800
   *
   ***
   * @method floor(<precision> = 0)
   * @returns Number
   * @short Shortcut for %Math.floor% that also allows a <precision>.
   *
   * @example
   *
   *   (3.241).floor()  -> 3
   *   (-3.841).floor() -> -4
   *   (3.241).floor(2) -> 3.24
   *   (3748).floor(-2) -> 3700
   *
   ***
   * @method [math]()
   * @returns Number
   * @short Math related functions are mapped as shortcuts to numbers and are identical. Note that %Number#log% provides some special defaults.
   *
   * @set
   *   abs
   *   sin
   *   asin
   *   cos
   *   acos
   *   tan
   *   atan
   *   sqrt
   *   exp
   *   pow
   *
   * @example
   *
   *   (3).pow(3) -> 27
   *   (-3).abs() -> 3
   *   (1024).sqrt() -> 32
   *
   ***/

  function buildNumber() {
    function createRoundingFunction(fn) {
      return function (precision) {
        return precision ? withPrecision(this, precision, fn) : fn(this);
      }
    }
    extend(number, true, true, {
      'ceil':   createRoundingFunction(ceil),
      'round':  createRoundingFunction(round),
      'floor':  createRoundingFunction(floor)
    });
    extendSimilar(number, true, true, 'abs,pow,sin,asin,cos,acos,tan,atan,exp,pow,sqrt', function(methods, name) {
      methods[name] = function(a, b) {
        return math[name](this, a, b);
      }
    });
  }

  buildNumber();


  /***
   * @package Object
   * @dependency core
   * @description Object manipulation, type checking (isNumber, isString, ...), extended objects with hash-like methods available as instance methods.
   *
   * Much thanks to kangax for his informative aricle about how problems with instanceof and constructor
   * http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
   *
   ***/

  var ObjectTypeMethods = 'isObject,isNaN'.split(',');
  var ObjectHashMethods = 'keys,values,select,reject,each,merge,clone,equal,watch,tap,has,toQueryString'.split(',');

  function setParamsObject(obj, param, value, castBoolean) {
    var reg = /^(.+?)(\[.*\])$/, paramIsArray, match, allKeys, key;
    if(match = param.match(reg)) {
      key = match[1];
      allKeys = match[2].replace(/^\[|\]$/g, '').split('][');
      allKeys.forEach(function(k) {
        paramIsArray = !k || k.match(/^\d+$/);
        if(!key && isArray(obj)) key = obj.length;
        if(!hasOwnProperty(obj, key)) {
          obj[key] = paramIsArray ? [] : {};
        }
        obj = obj[key];
        key = k;
      });
      if(!key && paramIsArray) key = obj.length.toString();
      setParamsObject(obj, key, value, castBoolean);
    } else if(castBoolean && value === 'true') {
      obj[param] = true;
    } else if(castBoolean && value === 'false') {
      obj[param] = false;
    } else {
      obj[param] = value;
    }
  }

  function objectToQueryString(base, obj) {
    var tmp;
    // If a custom toString exists bail here and use that instead
    if(isArray(obj) || (isObjectType(obj) && obj.toString === internalToString)) {
      tmp = [];
      iterateOverObject(obj, function(key, value) {
        if(base) {
          key = base + '[' + key + ']';
        }
        tmp.push(objectToQueryString(key, value));
      });
      return tmp.join('&');
    } else {
      if(!base) return '';
      return sanitizeURIComponent(base) + '=' + (isDate(obj) ? obj.getTime() : sanitizeURIComponent(obj));
    }
  }

  function sanitizeURIComponent(obj) {
    // undefined, null, and NaN are represented as a blank string,
    // while false and 0 are stringified. "+" is allowed in query string
    return !obj && obj !== false && obj !== 0 ? '' : encodeURIComponent(obj).replace(/%20/g, '+');
  }

  function matchInObject(match, key, value) {
    if(isRegExp(match)) {
      return match.test(key);
    } else if(isObjectType(match)) {
      return match[key] === value;
    } else {
      return key === string(match);
    }
  }

  function selectFromObject(obj, args, select) {
    var match, result = obj instanceof Hash ? new Hash : {};
    iterateOverObject(obj, function(key, value) {
      match = false;
      flattenedArgs(args, function(arg) {
        if(matchInObject(arg, key, value)) {
          match = true;
        }
      }, 1);
      if(match === select) {
        result[key] = value;
      }
    });
    return result;
  }


  /***
   * @method Object.is[Type](<obj>)
   * @returns Boolean
   * @short Returns true if <obj> is an object of that type.
   * @extra %isObject% will return false on anything that is not an object literal, including instances of inherited classes. Note also that %isNaN% will ONLY return true if the object IS %NaN%. It does not mean the same as browser native %isNaN%, which returns true for anything that is "not a number".
   *
   * @set
   *   isArray
   *   isObject
   *   isBoolean
   *   isDate
   *   isFunction
   *   isNaN
   *   isNumber
   *   isString
   *   isRegExp
   *
   * @example
   *
   *   Object.isArray([1,2,3])            -> true
   *   Object.isDate(3)                   -> false
   *   Object.isRegExp(/wasabi/)          -> true
   *   Object.isObject({ broken:'wear' }) -> true
   *
   ***/
  function buildTypeMethods() {
    extendSimilar(object, false, true, ClassNames, function(methods, name) {
      var method = 'is' + name;
      ObjectTypeMethods.push(method);
      methods[method] = typeChecks[name];
    });
  }

  function buildObjectExtend() {
    extend(object, false, function(){ return arguments.length === 0; }, {
      'extend': function() {
        var methods = ObjectTypeMethods.concat(ObjectHashMethods)
        if(typeof EnumerableMethods !== 'undefined') {
          methods = methods.concat(EnumerableMethods);
        }
        buildObjectInstanceMethods(methods, object);
      }
    });
  }

  extend(object, false, true, {
      /***
       * @method watch(<obj>, <prop>, <fn>)
       * @returns Nothing
       * @short Watches a property of <obj> and runs <fn> when it changes.
       * @extra <fn> is passed three arguments: the property <prop>, the old value, and the new value. The return value of [fn] will be set as the new value. This method is useful for things such as validating or cleaning the value when it is set. Warning: this method WILL NOT work in browsers that don't support %Object.defineProperty% (IE 8 and below). This is the only method in Sugar that is not fully compatible with all browsers. %watch% is available as an instance method on extended objects.
       * @example
       *
       *   Object.watch({ foo: 'bar' }, 'foo', function(prop, oldVal, newVal) {
       *     // Will be run when the property 'foo' is set on the object.
       *   });
       *   Object.extended().watch({ foo: 'bar' }, 'foo', function(prop, oldVal, newVal) {
       *     // Will be run when the property 'foo' is set on the object.
       *   });
       *
       ***/
    'watch': function(obj, prop, fn) {
      if(!definePropertySupport) return;
      var value = obj[prop];
      object.defineProperty(obj, prop, {
        'enumerable'  : true,
        'configurable': true,
        'get': function() {
          return value;
        },
        'set': function(to) {
          value = fn.call(obj, prop, value, to);
        }
      });
    }
  });

  extend(object, false, function() { return arguments.length > 1; }, {

    /***
     * @method keys(<obj>, [fn])
     * @returns Array
     * @short Returns an array containing the keys in <obj>. Optionally calls [fn] for each key.
     * @extra This method is provided for browsers that don't support it natively, and additionally is enhanced to accept the callback [fn]. Returned keys are in no particular order. %keys% is available as an instance method on extended objects.
     * @example
     *
     *   Object.keys({ broken: 'wear' }) -> ['broken']
     *   Object.keys({ broken: 'wear' }, function(key, value) {
     *     // Called once for each key.
     *   });
     *   Object.extended({ broken: 'wear' }).keys() -> ['broken']
     *
     ***/
    'keys': function(obj, fn) {
      var keys = object.keys(obj);
      keys.forEach(function(key) {
        fn.call(obj, key, obj[key]);
      });
      return keys;
    }

  });

  extend(object, false, true, {

    'isObject': function(obj) {
      return isPlainObject(obj);
    },

    'isNaN': function(obj) {
      // This is only true of NaN
      return isNumber(obj) && obj.valueOf() !== obj.valueOf();
    },

    /***
     * @method equal(<a>, <b>)
     * @returns Boolean
     * @short Returns true if <a> and <b> are equal.
     * @extra %equal% in Sugar is "egal", meaning the values are equal if they are "not observably distinguishable". Note that on extended objects the name is %equals% for readability.
     * @example
     *
     *   Object.equal({a:2}, {a:2}) -> true
     *   Object.equal({a:2}, {a:3}) -> false
     *   Object.extended({a:2}).equals({a:3}) -> false
     *
     ***/
    'equal': function(a, b) {
      return isEqual(a, b);
    },

    /***
     * @method Object.extended(<obj> = {})
     * @returns Extended object
     * @short Creates a new object, equivalent to %new Object()% or %{}%, but with extended methods.
     * @extra See extended objects for more.
     * @example
     *
     *   Object.extended()
     *   Object.extended({ happy:true, pappy:false }).keys() -> ['happy','pappy']
     *   Object.extended({ happy:true, pappy:false }).values() -> [true, false]
     *
     ***/
    'extended': function(obj) {
      return new Hash(obj);
    },

    /***
     * @method merge(<target>, <source>, [deep] = false, [resolve] = true)
     * @returns Merged object
     * @short Merges all the properties of <source> into <target>.
     * @extra Merges are shallow unless [deep] is %true%. Properties of <source> will win in the case of conflicts, unless [resolve] is %false%. [resolve] can also be a function that resolves the conflict. In this case it will be passed 3 arguments, %key%, %targetVal%, and %sourceVal%, with the context set to <source>. This will allow you to solve conflict any way you want, ie. adding two numbers together, etc. %merge% is available as an instance method on extended objects.
     * @example
     *
     *   Object.merge({a:1},{b:2}) -> { a:1, b:2 }
     *   Object.merge({a:1},{a:2}, false, false) -> { a:1 }
     +   Object.merge({a:1},{a:2}, false, function(key, a, b) {
     *     return a + b;
     *   }); -> { a:3 }
     *   Object.extended({a:1}).merge({b:2}) -> { a:1, b:2 }
     *
     ***/
    'merge': function(target, source, deep, resolve) {
      var key, sourceIsObject, targetIsObject, sourceVal, targetVal, conflict, result;
      // Strings cannot be reliably merged thanks to
      // their properties not being enumerable in < IE8.
      if(target && typeof source !== 'string') {
        for(key in source) {
          if(!hasOwnProperty(source, key) || !target) continue;
          sourceVal      = source[key];
          targetVal      = target[key];
          conflict       = isDefined(targetVal);
          sourceIsObject = isObjectType(sourceVal);
          targetIsObject = isObjectType(targetVal);
          result         = conflict && resolve === false ? targetVal : sourceVal;

          if(conflict) {
            if(isFunction(resolve)) {
              // Use the result of the callback as the result.
              result = resolve.call(source, key, targetVal, sourceVal)
            }
          }

          // Going deep
          if(deep && (sourceIsObject || targetIsObject)) {
            if(isDate(sourceVal)) {
              result = new date(sourceVal.getTime());
            } else if(isRegExp(sourceVal)) {
              result = new regexp(sourceVal.source, getRegExpFlags(sourceVal));
            } else {
              if(!targetIsObject) target[key] = array.isArray(sourceVal) ? [] : {};
              object.merge(target[key], sourceVal, deep, resolve);
              continue;
            }
          }
          target[key] = result;
        }
      }
      return target;
    },

    /***
     * @method values(<obj>, [fn])
     * @returns Array
     * @short Returns an array containing the values in <obj>. Optionally calls [fn] for each value.
     * @extra Returned values are in no particular order. %values% is available as an instance method on extended objects.
     * @example
     *
     *   Object.values({ broken: 'wear' }) -> ['wear']
     *   Object.values({ broken: 'wear' }, function(value) {
     *     // Called once for each value.
     *   });
     *   Object.extended({ broken: 'wear' }).values() -> ['wear']
     *
     ***/
    'values': function(obj, fn) {
      var values = [];
      iterateOverObject(obj, function(k,v) {
        values.push(v);
        if(fn) fn.call(obj,v);
      });
      return values;
    },

    /***
     * @method clone(<obj> = {}, [deep] = false)
     * @returns Cloned object
     * @short Creates a clone (copy) of <obj>.
     * @extra Default is a shallow clone, unless [deep] is true. %clone% is available as an instance method on extended objects.
     * @example
     *
     *   Object.clone({foo:'bar'})            -> { foo: 'bar' }
     *   Object.clone()                       -> {}
     *   Object.extended({foo:'bar'}).clone() -> { foo: 'bar' }
     *
     ***/
    'clone': function(obj, deep) {
      var target, klass;
      if(!isObjectType(obj)) {
        return obj;
      }
      klass = className(obj);
      if(isDate(obj, klass) && obj.clone) {
        // Preserve internal UTC flag when applicable.
        return obj.clone();
      } else if(isDate(obj, klass) || isRegExp(obj, klass)) {
        return new obj.constructor(obj);
      } else if(obj instanceof Hash) {
        target = new Hash;
      } else if(isArray(obj, klass)) {
        target = [];
      } else if(isPlainObject(obj, klass)) {
        target = {};
      } else {
        throw new TypeError('Clone must be a basic data type.');
      }
      return object.merge(target, obj, deep);
    },

    /***
     * @method Object.fromQueryString(<str>, [booleans] = false)
     * @returns Object
     * @short Converts the query string of a URL into an object.
     * @extra If [booleans] is true, then %"true"% and %"false"% will be cast into booleans. All other values, including numbers will remain their string values.
     * @example
     *
     *   Object.fromQueryString('foo=bar&broken=wear') -> { foo: 'bar', broken: 'wear' }
     *   Object.fromQueryString('foo[]=1&foo[]=2')     -> { foo: ['1','2'] }
     *   Object.fromQueryString('foo=true', true)      -> { foo: true }
     *
     ***/
    'fromQueryString': function(str, castBoolean) {
      var result = object.extended(), split;
      str = str && str.toString ? str.toString() : '';
      str.replace(/^.*?\?/, '').split('&').forEach(function(p) {
        var split = p.split('=');
        if(split.length !== 2) return;
        setParamsObject(result, split[0], decodeURIComponent(split[1]), castBoolean);
      });
      return result;
    },

    /***
     * @method Object.toQueryString(<obj>, [namespace] = null)
     * @returns Object
     * @short Converts the object into a query string.
     * @extra Accepts deep nested objects and arrays. If [namespace] is passed, it will be prefixed to all param names.
     * @example
     *
     *   Object.toQueryString({foo:'bar'})          -> 'foo=bar'
     *   Object.toQueryString({foo:['a','b','c']})  -> 'foo[0]=a&foo[1]=b&foo[2]=c'
     *   Object.toQueryString({name:'Bob'}, 'user') -> 'user[name]=Bob'
     *
     ***/
    'toQueryString': function(obj, namespace) {
      return objectToQueryString(namespace, obj);
    },

    /***
     * @method tap(<obj>, <fn>)
     * @returns Object
     * @short Runs <fn> and returns <obj>.
     * @extra  A string can also be used as a shortcut to a method. This method is used to run an intermediary function in the middle of method chaining. As a standalone method on the Object class it doesn't have too much use. The power of %tap% comes when using extended objects or modifying the Object prototype with Object.extend().
     * @example
     *
     *   Object.extend();
     *   [2,4,6].map(Math.exp).tap(function(arr) {
     *     arr.pop()
     *   });
     *   [2,4,6].map(Math.exp).tap('pop').map(Math.round); ->  [7,55]
     *
     ***/
    'tap': function(obj, arg) {
      var fn = arg;
      if(!isFunction(arg)) {
        fn = function() {
          if(arg) obj[arg]();
        }
      }
      fn.call(obj, obj);
      return obj;
    },

    /***
     * @method has(<obj>, <key>)
     * @returns Boolean
     * @short Checks if <obj> has <key> using hasOwnProperty from Object.prototype.
     * @extra This method is considered safer than %Object#hasOwnProperty% when using objects as hashes. See http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/ for more.
     * @example
     *
     *   Object.has({ foo: 'bar' }, 'foo') -> true
     *   Object.has({ foo: 'bar' }, 'baz') -> false
     *   Object.has({ hasOwnProperty: true }, 'foo') -> false
     *
     ***/
    'has': function (obj, key) {
      return hasOwnProperty(obj, key);
    },

    /***
     * @method select(<obj>, <find>, ...)
     * @returns Object
     * @short Builds a new object containing the values specified in <find>.
     * @extra When <find> is a string, that single key will be selected. It can also be a regex, selecting any key that matches, or an object which will match if the key also exists in that object, effectively doing an "intersect" operation on that object. Multiple selections may also be passed as an array or directly as enumerated arguments. %select% is available as an instance method on extended objects.
     * @example
     *
     *   Object.select({a:1,b:2}, 'a')        -> {a:1}
     *   Object.select({a:1,b:2}, /[a-z]/)    -> {a:1,ba:2}
     *   Object.select({a:1,b:2}, {a:1})      -> {a:1}
     *   Object.select({a:1,b:2}, 'a', 'b')   -> {a:1,b:2}
     *   Object.select({a:1,b:2}, ['a', 'b']) -> {a:1,b:2}
     *
     ***/
    'select': function (obj) {
      return selectFromObject(obj, arguments, true);
    },

    /***
     * @method reject(<obj>, <find>, ...)
     * @returns Object
     * @short Builds a new object containing all values except those specified in <find>.
     * @extra When <find> is a string, that single key will be rejected. It can also be a regex, rejecting any key that matches, or an object which will match if the key also exists in that object, effectively "subtracting" that object. Multiple selections may also be passed as an array or directly as enumerated arguments. %reject% is available as an instance method on extended objects.
     * @example
     *
     *   Object.reject({a:1,b:2}, 'a')        -> {b:2}
     *   Object.reject({a:1,b:2}, /[a-z]/)    -> {}
     *   Object.reject({a:1,b:2}, {a:1})      -> {b:2}
     *   Object.reject({a:1,b:2}, 'a', 'b')   -> {}
     *   Object.reject({a:1,b:2}, ['a', 'b']) -> {}
     *
     ***/
    'reject': function (obj) {
      return selectFromObject(obj, arguments, false);
    }

  });


  buildTypeMethods();
  buildObjectExtend();
  buildObjectInstanceMethods(ObjectHashMethods, Hash);

  /***
   * @package RegExp
   * @dependency core
   * @description Escaping regexes and manipulating their flags.
   *
   * Note here that methods on the RegExp class like .exec and .test will fail in the current version of SpiderMonkey being
   * used by CouchDB when using shorthand regex notation like /foo/. This is the reason for the intermixed use of shorthand
   * and compiled regexes here. If you're using JS in CouchDB, it is safer to ALWAYS compile your regexes from a string.
   *
   ***/

  extend(regexp, false, true, {

   /***
    * @method RegExp.escape(<str> = '')
    * @returns String
    * @short Escapes all RegExp tokens in a string.
    * @example
    *
    *   RegExp.escape('really?')      -> 'really\?'
    *   RegExp.escape('yes.')         -> 'yes\.'
    *   RegExp.escape('(not really)') -> '\(not really\)'
    *
    ***/
    'escape': function(str) {
      return escapeRegExp(str);
    }

  });

  extend(regexp, true, true, {

   /***
    * @method getFlags()
    * @returns String
    * @short Returns the flags of the regex as a string.
    * @example
    *
    *   /texty/gim.getFlags('testy') -> 'gim'
    *
    ***/
    'getFlags': function() {
      return getRegExpFlags(this);
    },

   /***
    * @method setFlags(<flags>)
    * @returns RegExp
    * @short Sets the flags on a regex and retuns a copy.
    * @example
    *
    *   /texty/.setFlags('gim') -> now has global, ignoreCase, and multiline set
    *
    ***/
    'setFlags': function(flags) {
      return regexp(this.source, flags);
    },

   /***
    * @method addFlag(<flag>)
    * @returns RegExp
    * @short Adds <flag> to the regex.
    * @example
    *
    *   /texty/.addFlag('g') -> now has global flag set
    *
    ***/
    'addFlag': function(flag) {
      return this.setFlags(getRegExpFlags(this, flag));
    },

   /***
    * @method removeFlag(<flag>)
    * @returns RegExp
    * @short Removes <flag> from the regex.
    * @example
    *
    *   /texty/g.removeFlag('g') -> now has global flag removed
    *
    ***/
    'removeFlag': function(flag) {
      return this.setFlags(getRegExpFlags(this).replace(flag, ''));
    }

  });



  /***
   * @package String
   * @dependency core
   * @description String manupulation, escaping, encoding, truncation, and:conversion.
   *
   ***/

  function getAcronym(word) {
    var inflector = string.Inflector;
    var word = inflector && inflector.acronyms[word];
    if(isString(word)) {
      return word;
    }
  }

  function checkRepeatRange(num) {
    num = +num;
    if(num < 0 || num === Infinity) {
      throw new RangeError('Invalid number');
    }
    return num;
  }

  function padString(num, padding) {
    return repeatString(isDefined(padding) ? padding : ' ', num);
  }

  function truncateString(str, length, from, ellipsis, split) {
    var str1, str2, len1, len2;
    if(str.length <= length) {
      return str.toString();
    }
    ellipsis = isUndefined(ellipsis) ? '...' : ellipsis;
    switch(from) {
      case 'left':
        str2 = split ? truncateOnWord(str, length, true) : str.slice(str.length - length);
        return ellipsis + str2;
      case 'middle':
        len1 = ceil(length / 2);
        len2 = floor(length / 2);
        str1 = split ? truncateOnWord(str, len1) : str.slice(0, len1);
        str2 = split ? truncateOnWord(str, len2, true) : str.slice(str.length - len2);
        return str1 + ellipsis + str2;
      default:
        str1 = split ? truncateOnWord(str, length) : str.slice(0, length);
        return str1 + ellipsis;
    }
  }

  function truncateOnWord(str, limit, fromLeft) {
    if(fromLeft) {
      return truncateOnWord(str.reverse(), limit).reverse();
    }
    var reg = regexp('(?=[' + getTrimmableCharacters() + '])');
    var words = str.split(reg);
    var count = 0;
    return words.filter(function(word) {
      count += word.length;
      return count <= limit;
    }).join('');
  }

  function numberOrIndex(str, n, from) {
    if(isString(n)) {
      n = str.indexOf(n);
      if(n === -1) {
        n = from ? str.length : 0;
      }
    }
    return n;
  }

  var btoa, atob;

  function buildBase64(key) {
    if(globalContext.btoa) {
      btoa = globalContext.btoa;
      atob = globalContext.atob;
      return;
    }
    var base64reg = /[^A-Za-z0-9\+\/\=]/g;
    btoa = function(str) {
      var output = '';
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      do {
        chr1 = str.charCodeAt(i++);
        chr2 = str.charCodeAt(i++);
        chr3 = str.charCodeAt(i++);
        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
        output = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);
        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';
      } while (i < str.length);
      return output;
    }
    atob = function(input) {
      var output = '';
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0;
      if(input.match(base64reg)) {
        throw new Error('String contains invalid base64 characters');
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
      do {
        enc1 = key.indexOf(input.charAt(i++));
        enc2 = key.indexOf(input.charAt(i++));
        enc3 = key.indexOf(input.charAt(i++));
        enc4 = key.indexOf(input.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        output = output + chr(chr1);
        if (enc3 != 64) {
          output = output + chr(chr2);
        }
        if (enc4 != 64) {
          output = output + chr(chr3);
        }
        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';
      } while (i < input.length);
      return output;
    }
  }

  extend(string, true, false, {
    /***
     * @method repeat([num] = 0)
     * @returns String
     * @short Returns the string repeated [num] times.
     * @example
     *
     *   'jumpy'.repeat(2) -> 'jumpyjumpy'
     *   'a'.repeat(5)     -> 'aaaaa'
     *   'a'.repeat(0)     -> ''
     *
     ***/
    'repeat': function(num) {
      num = checkRepeatRange(num);
      return repeatString(this, num);
    }

  });

  extend(string, true, function(reg) { return isRegExp(reg) || arguments.length > 2; }, {

    /***
     * @method startsWith(<find>, [pos] = 0, [case] = true)
     * @returns Boolean
     * @short Returns true if the string starts with <find>.
     * @extra <find> may be either a string or regex. Search begins at [pos], which defaults to the entire string. Case sensitive if [case] is true.
     * @example
     *
     *   'hello'.startsWith('hell')           -> true
     *   'hello'.startsWith(/[a-h]/)          -> true
     *   'hello'.startsWith('HELL')           -> false
     *   'hello'.startsWith('ell', 1)         -> true
     *   'hello'.startsWith('HELL', 0, false) -> true
     *
     ***/
    'startsWith': function(reg) {
      var args = arguments, pos = args[1], c = args[2], str = this, source;
      if(pos) str = str.slice(pos);
      if(isUndefined(c)) c = true;
      source = isRegExp(reg) ? reg.source.replace('^', '') : escapeRegExp(reg);
      return regexp('^' + source, c ? '' : 'i').test(str);
    },

    /***
     * @method endsWith(<find>, [pos] = length, [case] = true)
     * @returns Boolean
     * @short Returns true if the string ends with <find>.
     * @extra <find> may be either a string or regex. Search ends at [pos], which defaults to the entire string. Case sensitive if [case] is true.
     * @example
     *
     *   'jumpy'.endsWith('py')            -> true
     *   'jumpy'.endsWith(/[q-z]/)         -> true
     *   'jumpy'.endsWith('MPY')           -> false
     *   'jumpy'.endsWith('mp', 4)         -> false
     *   'jumpy'.endsWith('MPY', 5, false) -> true
     *
     ***/
    'endsWith': function(reg) {
      var args = arguments, pos = args[1], c = args[2], str = this, source;
      if(isDefined(pos)) str = str.slice(0, pos);
      if(isUndefined(c)) c = true;
      source = isRegExp(reg) ? reg.source.replace('$', '') : escapeRegExp(reg);
      return regexp(source + '$', c ? '' : 'i').test(str);
    }

  });

  extend(string, true, true, {

     /***
      * @method escapeRegExp()
      * @returns String
      * @short Escapes all RegExp tokens in the string.
      * @example
      *
      *   'really?'.escapeRegExp()       -> 'really\?'
      *   'yes.'.escapeRegExp()         -> 'yes\.'
      *   '(not really)'.escapeRegExp() -> '\(not really\)'
      *
      ***/
    'escapeRegExp': function() {
      return escapeRegExp(this);
    },

     /***
      * @method escapeURL([param] = false)
      * @returns String
      * @short Escapes characters in a string to make a valid URL.
      * @extra If [param] is true, it will also escape valid URL characters for use as a URL parameter.
      * @example
      *
      *   'http://foo.com/"bar"'.escapeURL()     -> 'http://foo.com/%22bar%22'
      *   'http://foo.com/"bar"'.escapeURL(true) -> 'http%3A%2F%2Ffoo.com%2F%22bar%22'
      *
      ***/
    'escapeURL': function(param) {
      return param ? encodeURIComponent(this) : encodeURI(this);
    },

     /***
      * @method unescapeURL([partial] = false)
      * @returns String
      * @short Restores escaped characters in a URL escaped string.
      * @extra If [partial] is true, it will only unescape non-valid URL characters. [partial] is included here for completeness, but should very rarely be needed.
      * @example
      *
      *   'http%3A%2F%2Ffoo.com%2Fthe%20bar'.unescapeURL()     -> 'http://foo.com/the bar'
      *   'http%3A%2F%2Ffoo.com%2Fthe%20bar'.unescapeURL(true) -> 'http%3A%2F%2Ffoo.com%2Fthe bar'
      *
      ***/
    'unescapeURL': function(param) {
      return param ? decodeURI(this) : decodeURIComponent(this);
    },

     /***
      * @method escapeHTML()
      * @returns String
      * @short Converts HTML characters to their entity equivalents.
      * @example
      *
      *   '<p>some text</p>'.escapeHTML() -> '&lt;p&gt;some text&lt;/p&gt;'
      *   'one & two'.escapeHTML()        -> 'one &amp; two'
      *
      ***/
    'escapeHTML': function() {
      return this.replace(/&/g,  '&amp;' )
                 .replace(/</g,  '&lt;'  )
                 .replace(/>/g,  '&gt;'  )
                 .replace(/"/g,  '&quot;')
                 .replace(/'/g,  '&apos;')
                 .replace(/\//g, '&#x2f;');
    },

     /***
      * @method unescapeHTML([partial] = false)
      * @returns String
      * @short Restores escaped HTML characters.
      * @example
      *
      *   '&lt;p&gt;some text&lt;/p&gt;'.unescapeHTML() -> '<p>some text</p>'
      *   'one &amp; two'.unescapeHTML()                -> 'one & two'
      *
      ***/
    'unescapeHTML': function() {
      return this.replace(/&lt;/g,   '<')
                 .replace(/&gt;/g,   '>')
                 .replace(/&quot;/g, '"')
                 .replace(/&apos;/g, "'")
                 .replace(/&#x2f;/g, '/')
                 .replace(/&amp;/g,  '&');
    },

     /***
      * @method encodeBase64()
      * @returns String
      * @short Encodes the string into base64 encoding.
      * @extra This method wraps the browser native %btoa% when available, and uses a custom implementation when not available. It can also handle Unicode string encodings.
      * @example
      *
      *   'gonna get encoded!'.encodeBase64()  -> 'Z29ubmEgZ2V0IGVuY29kZWQh'
      *   'http://twitter.com/'.encodeBase64() -> 'aHR0cDovL3R3aXR0ZXIuY29tLw=='
      *
      ***/
    'encodeBase64': function() {
      return btoa(unescape(encodeURIComponent(this)));
    },

     /***
      * @method decodeBase64()
      * @returns String
      * @short Decodes the string from base64 encoding.
      * @extra This method wraps the browser native %atob% when available, and uses a custom implementation when not available. It can also handle Unicode string encodings.
      * @example
      *
      *   'aHR0cDovL3R3aXR0ZXIuY29tLw=='.decodeBase64() -> 'http://twitter.com/'
      *   'anVzdCBnb3QgZGVjb2RlZA=='.decodeBase64()     -> 'just got decoded!'
      *
      ***/
    'decodeBase64': function() {
      return decodeURIComponent(escape(atob(this)));
    },

    /***
     * @method each([search] = single character, [fn])
     * @returns Array
     * @short Runs callback [fn] against each occurence of [search].
     * @extra Returns an array of matches. [search] may be either a string or regex, and defaults to every character in the string.
     * @example
     *
     *   'jumpy'.each() -> ['j','u','m','p','y']
     *   'jumpy'.each(/[r-z]/) -> ['u','y']
     *   'jumpy'.each(/[r-z]/, function(m) {
     *     // Called twice: "u", "y"
     *   });
     *
     ***/
    'each': function(search, fn) {
      var match, i, len;
      if(isFunction(search)) {
        fn = search;
        search = /[\s\S]/g;
      } else if(!search) {
        search = /[\s\S]/g
      } else if(isString(search)) {
        search = regexp(escapeRegExp(search), 'gi');
      } else if(isRegExp(search)) {
        search = regexp(search.source, getRegExpFlags(search, 'g'));
      }
      match = this.match(search) || [];
      if(fn) {
        for(i = 0, len = match.length; i < len; i++) {
          match[i] = fn.call(this, match[i], i, match) || match[i];
        }
      }
      return match;
    },

    /***
     * @method shift(<n>)
     * @returns Array
     * @short Shifts each character in the string <n> places in the character map.
     * @example
     *
     *   'a'.shift(1)  -> 'b'
     *   'ク'.shift(1) -> 'グ'
     *
     ***/
    'shift': function(n) {
      var result = '';
      n = n || 0;
      this.codes(function(c) {
        result += chr(c + n);
      });
      return result;
    },

    /***
     * @method codes([fn])
     * @returns Array
     * @short Runs callback [fn] against each character code in the string. Returns an array of character codes.
     * @example
     *
     *   'jumpy'.codes() -> [106,117,109,112,121]
     *   'jumpy'.codes(function(c) {
     *     // Called 5 times: 106, 117, 109, 112, 121
     *   });
     *
     ***/
    'codes': function(fn) {
      var codes = [], i, len;
      for(i = 0, len = this.length; i < len; i++) {
        var code = this.charCodeAt(i);
        codes.push(code);
        if(fn) fn.call(this, code, i);
      }
      return codes;
    },

    /***
     * @method chars([fn])
     * @returns Array
     * @short Runs callback [fn] against each character in the string. Returns an array of characters.
     * @example
     *
     *   'jumpy'.chars() -> ['j','u','m','p','y']
     *   'jumpy'.chars(function(c) {
     *     // Called 5 times: "j","u","m","p","y"
     *   });
     *
     ***/
    'chars': function(fn) {
      return this.each(fn);
    },

    /***
     * @method words([fn])
     * @returns Array
     * @short Runs callback [fn] against each word in the string. Returns an array of words.
     * @extra A "word" here is defined as any sequence of non-whitespace characters.
     * @example
     *
     *   'broken wear'.words() -> ['broken','wear']
     *   'broken wear'.words(function(w) {
     *     // Called twice: "broken", "wear"
     *   });
     *
     ***/
    'words': function(fn) {
      return this.trim().each(/\S+/g, fn);
    },

    /***
     * @method lines([fn])
     * @returns Array
     * @short Runs callback [fn] against each line in the string. Returns an array of lines.
     * @example
     *
     *   'broken wear\nand\njumpy jump'.lines() -> ['broken wear','and','jumpy jump']
     *   'broken wear\nand\njumpy jump'.lines(function(l) {
     *     // Called three times: "broken wear", "and", "jumpy jump"
     *   });
     *
     ***/
    'lines': function(fn) {
      return this.trim().each(/^.*$/gm, fn);
    },

    /***
     * @method paragraphs([fn])
     * @returns Array
     * @short Runs callback [fn] against each paragraph in the string. Returns an array of paragraphs.
     * @extra A paragraph here is defined as a block of text bounded by two or more line breaks.
     * @example
     *
     *   'Once upon a time.\n\nIn the land of oz...'.paragraphs() -> ['Once upon a time.','In the land of oz...']
     *   'Once upon a time.\n\nIn the land of oz...'.paragraphs(function(p) {
     *     // Called twice: "Once upon a time.", "In teh land of oz..."
     *   });
     *
     ***/
    'paragraphs': function(fn) {
      var paragraphs = this.trim().split(/[\r\n]{2,}/);
      paragraphs = paragraphs.map(function(p) {
        if(fn) var s = fn.call(p);
        return s ? s : p;
      });
      return paragraphs;
    },

    /***
     * @method isBlank()
     * @returns Boolean
     * @short Returns true if the string has a length of 0 or contains only whitespace.
     * @example
     *
     *   ''.isBlank()      -> true
     *   '   '.isBlank()   -> true
     *   'noway'.isBlank() -> false
     *
     ***/
    'isBlank': function() {
      return this.trim().length === 0;
    },

    /***
     * @method has(<find>)
     * @returns Boolean
     * @short Returns true if the string matches <find>.
     * @extra <find> may be a string or regex.
     * @example
     *
     *   'jumpy'.has('py')     -> true
     *   'broken'.has(/[a-n]/) -> true
     *   'broken'.has(/[s-z]/) -> false
     *
     ***/
    'has': function(find) {
      return this.search(isRegExp(find) ? find : escapeRegExp(find)) !== -1;
    },


    /***
     * @method add(<str>, [index] = length)
     * @returns String
     * @short Adds <str> at [index]. Negative values are also allowed.
     * @extra %insert% is provided as an alias, and is generally more readable when using an index.
     * @example
     *
     *   'schfifty'.add(' five')      -> schfifty five
     *   'dopamine'.insert('e', 3)       -> dopeamine
     *   'spelling eror'.insert('r', -3) -> spelling error
     *
     ***/
    'add': function(str, index) {
      index = isUndefined(index) ? this.length : index;
      return this.slice(0, index) + str + this.slice(index);
    },

    /***
     * @method remove(<f>)
     * @returns String
     * @short Removes any part of the string that matches <f>.
     * @extra <f> can be a string or a regex.
     * @example
     *
     *   'schfifty five'.remove('f')     -> 'schity ive'
     *   'schfifty five'.remove(/[a-f]/g) -> 'shity iv'
     *
     ***/
    'remove': function(f) {
      return this.replace(f, '');
    },

    /***
     * @method reverse()
     * @returns String
     * @short Reverses the string.
     * @example
     *
     *   'jumpy'.reverse()        -> 'ypmuj'
     *   'lucky charms'.reverse() -> 'smrahc ykcul'
     *
     ***/
    'reverse': function() {
      return this.split('').reverse().join('');
    },

    /***
     * @method compact()
     * @returns String
     * @short Compacts all white space in the string to a single space and trims the ends.
     * @example
     *
     *   'too \n much \n space'.compact() -> 'too much space'
     *   'enough \n '.compact()           -> 'enought'
     *
     ***/
    'compact': function() {
      return this.trim().replace(/([\r\n\s　])+/g, function(match, whitespace){
        return whitespace === '　' ? whitespace : ' ';
      });
    },

    /***
     * @method at(<index>, [loop] = true)
     * @returns String or Array
     * @short Gets the character(s) at a given index.
     * @extra When [loop] is true, overshooting the end of the string (or the beginning) will begin counting from the other end. As an alternate syntax, passing multiple indexes will get the characters at those indexes.
     * @example
     *
     *   'jumpy'.at(0)               -> 'j'
     *   'jumpy'.at(2)               -> 'm'
     *   'jumpy'.at(5)               -> 'j'
     *   'jumpy'.at(5, false)        -> ''
     *   'jumpy'.at(-1)              -> 'y'
     *   'lucky charms'.at(2,4,6,8) -> ['u','k','y',c']
     *
     ***/
    'at': function() {
      return getEntriesForIndexes(this, arguments, true);
    },

    /***
     * @method from([index] = 0)
     * @returns String
     * @short Returns a section of the string starting from [index].
     * @example
     *
     *   'lucky charms'.from()   -> 'lucky charms'
     *   'lucky charms'.from(7)  -> 'harms'
     *
     ***/
    'from': function(from) {
      return this.slice(numberOrIndex(this, from, true));
    },

    /***
     * @method to([index] = end)
     * @returns String
     * @short Returns a section of the string ending at [index].
     * @example
     *
     *   'lucky charms'.to()   -> 'lucky charms'
     *   'lucky charms'.to(7)  -> 'lucky ch'
     *
     ***/
    'to': function(to) {
      if(isUndefined(to)) to = this.length;
      return this.slice(0, numberOrIndex(this, to));
    },

    /***
     * @method dasherize()
     * @returns String
     * @short Converts underscores and camel casing to hypens.
     * @example
     *
     *   'a_farewell_to_arms'.dasherize() -> 'a-farewell-to-arms'
     *   'capsLock'.dasherize()           -> 'caps-lock'
     *
     ***/
    'dasherize': function() {
      return this.underscore().replace(/_/g, '-');
    },

    /***
     * @method underscore()
     * @returns String
     * @short Converts hyphens and camel casing to underscores.
     * @example
     *
     *   'a-farewell-to-arms'.underscore() -> 'a_farewell_to_arms'
     *   'capsLock'.underscore()           -> 'caps_lock'
     *
     ***/
    'underscore': function() {
      return this
        .replace(/[-\s]+/g, '_')
        .replace(string.Inflector && string.Inflector.acronymRegExp, function(acronym, index) {
          return (index > 0 ? '_' : '') + acronym.toLowerCase();
        })
        .replace(/([A-Z\d]+)([A-Z][a-z])/g,'$1_$2')
        .replace(/([a-z\d])([A-Z])/g,'$1_$2')
        .toLowerCase();
    },

    /***
     * @method camelize([first] = true)
     * @returns String
     * @short Converts underscores and hyphens to camel case. If [first] is true the first letter will also be capitalized.
     * @extra If the Inflections package is included acryonyms can also be defined that will be used when camelizing.
     * @example
     *
     *   'caps_lock'.camelize()              -> 'CapsLock'
     *   'moz-border-radius'.camelize()      -> 'MozBorderRadius'
     *   'moz-border-radius'.camelize(false) -> 'mozBorderRadius'
     *
     ***/
    'camelize': function(first) {
      return this.underscore().replace(/(^|_)([^_]+)/g, function(match, pre, word, index) {
        var acronym = getAcronym(word), capitalize = first !== false || index > 0;
        if(acronym) return capitalize ? acronym : acronym.toLowerCase();
        return capitalize ? word.capitalize() : word;
      });
    },

    /***
     * @method spacify()
     * @returns String
     * @short Converts camel case, underscores, and hyphens to a properly spaced string.
     * @example
     *
     *   'camelCase'.spacify()                         -> 'camel case'
     *   'an-ugly-string'.spacify()                    -> 'an ugly string'
     *   'oh-no_youDid-not'.spacify().capitalize(true) -> 'something else'
     *
     ***/
    'spacify': function() {
      return this.underscore().replace(/_/g, ' ');
    },

    /***
     * @method stripTags([tag1], [tag2], ...)
     * @returns String
     * @short Strips all HTML tags from the string.
     * @extra Tags to strip may be enumerated in the parameters, otherwise will strip all.
     * @example
     *
     *   '<p>just <b>some</b> text</p>'.stripTags()    -> 'just some text'
     *   '<p>just <b>some</b> text</p>'.stripTags('p') -> 'just <b>some</b> text'
     *
     ***/
    'stripTags': function() {
      var str = this, args = arguments.length > 0 ? arguments : [''];
      flattenedArgs(args, function(tag) {
        str = str.replace(regexp('<\/?' + escapeRegExp(tag) + '[^<>]*>', 'gi'), '');
      });
      return str;
    },

    /***
     * @method removeTags([tag1], [tag2], ...)
     * @returns String
     * @short Removes all HTML tags and their contents from the string.
     * @extra Tags to remove may be enumerated in the parameters, otherwise will remove all.
     * @example
     *
     *   '<p>just <b>some</b> text</p>'.removeTags()    -> ''
     *   '<p>just <b>some</b> text</p>'.removeTags('b') -> '<p>just text</p>'
     *
     ***/
    'removeTags': function() {
      var str = this, args = arguments.length > 0 ? arguments : ['\\S+'];
      flattenedArgs(args, function(t) {
        var reg = regexp('<(' + t + ')[^<>]*(?:\\/>|>.*?<\\/\\1>)', 'gi');
        str = str.replace(reg, '');
      });
      return str;
    },

    /***
     * @method truncate(<length>, [from] = 'right', [ellipsis] = '...')
     * @returns String
     * @short Truncates a string.
     * @extra [from] can be %'right'%, %'left'%, or %'middle'%. If the string is shorter than <length>, [ellipsis] will not be added.
     * @example
     *
     *   'sittin on the dock of the bay'.truncate(18)           -> 'just sittin on the do...'
     *   'sittin on the dock of the bay'.truncate(18, 'left')   -> '...the dock of the bay'
     *   'sittin on the dock of the bay'.truncate(18, 'middle') -> 'just sitt...of the bay'
     *
     ***/
    'truncate': function(length, from, ellipsis) {
      return truncateString(this, length, from, ellipsis);
    },

    /***
     * @method truncateOnWord(<length>, [from] = 'right', [ellipsis] = '...')
     * @returns String
     * @short Truncates a string without splitting up words.
     * @extra [from] can be %'right'%, %'left'%, or %'middle'%. If the string is shorter than <length>, [ellipsis] will not be added.
     * @example
     *
     *   'here we go'.truncateOnWord(5)               -> 'here...'
     *   'here we go'.truncateOnWord(5, 'left')       -> '...we go'
     *
     ***/
    'truncateOnWord': function(length, from, ellipsis) {
      return truncateString(this, length, from, ellipsis, true);
    },

    /***
     * @method pad[Side](<num> = null, [padding] = ' ')
     * @returns String
     * @short Pads the string out with [padding] to be exactly <num> characters.
     *
     * @set
     *   pad
     *   padLeft
     *   padRight
     *
     * @example
     *
     *   'wasabi'.pad(8)           -> ' wasabi '
     *   'wasabi'.padLeft(8)       -> '  wasabi'
     *   'wasabi'.padRight(8)      -> 'wasabi  '
     *   'wasabi'.padRight(8, '-') -> 'wasabi--'
     *
     ***/
    'pad': function(num, padding) {
      var half, front, back;
      num   = checkRepeatRange(num);
      half  = max(0, num - this.length) / 2;
      front = floor(half);
      back  = ceil(half);
      return padString(front, padding) + this + padString(back, padding);
    },

    'padLeft': function(num, padding) {
      num = checkRepeatRange(num);
      return padString(max(0, num - this.length), padding) + this;
    },

    'padRight': function(num, padding) {
      num = checkRepeatRange(num);
      return this + padString(max(0, num - this.length), padding);
    },

    /***
     * @method first([n] = 1)
     * @returns String
     * @short Returns the first [n] characters of the string.
     * @example
     *
     *   'lucky charms'.first()   -> 'l'
     *   'lucky charms'.first(3)  -> 'luc'
     *
     ***/
    'first': function(num) {
      if(isUndefined(num)) num = 1;
      return this.substr(0, num);
    },

    /***
     * @method last([n] = 1)
     * @returns String
     * @short Returns the last [n] characters of the string.
     * @example
     *
     *   'lucky charms'.last()   -> 's'
     *   'lucky charms'.last(3)  -> 'rms'
     *
     ***/
    'last': function(num) {
      if(isUndefined(num)) num = 1;
      var start = this.length - num < 0 ? 0 : this.length - num;
      return this.substr(start);
    },

    /***
     * @method toNumber([base] = 10)
     * @returns Number
     * @short Converts the string into a number.
     * @extra Any value with a "." fill be converted to a floating point value, otherwise an integer.
     * @example
     *
     *   '153'.toNumber()    -> 153
     *   '12,000'.toNumber() -> 12000
     *   '10px'.toNumber()   -> 10
     *   'ff'.toNumber(16)   -> 255
     *
     ***/
    'toNumber': function(base) {
      return stringToNumber(this, base);
    },

    /***
     * @method capitalize([all] = false)
     * @returns String
     * @short Capitalizes the first character in the string and downcases all other letters.
     * @extra If [all] is true, all words in the string will be capitalized.
     * @example
     *
     *   'hello'.capitalize()           -> 'Hello'
     *   'hello kitty'.capitalize()     -> 'Hello kitty'
     *   'hello kitty'.capitalize(true) -> 'Hello Kitty'
     *
     *
     ***/
    'capitalize': function(all) {
      var lastResponded;
      return this.toLowerCase().replace(all ? /[^']/g : /^\S/, function(lower) {
        var upper = lower.toUpperCase(), result;
        result = lastResponded ? lower : upper;
        lastResponded = upper !== lower;
        return result;
      });
    },

    /***
     * @method assign(<obj1>, <obj2>, ...)
     * @returns String
     * @short Assigns variables to tokens in a string, demarcated with `{}`.
     * @extra If an object is passed, it's properties can be assigned using the object's keys (i.e. {name}). If a non-object (string, number, etc.) is passed it can be accessed by the argument number beginning with {1} (as with regex tokens). Multiple objects can be passed and will be merged together (original objects are unaffected).
     * @example
     *
     *   'Welcome, Mr. {name}.'.assign({ name: 'Franklin' })   -> 'Welcome, Mr. Franklin.'
     *   'You are {1} years old today.'.assign(14)             -> 'You are 14 years old today.'
     *   '{n} and {r}'.assign({ n: 'Cheech' }, { r: 'Chong' }) -> 'Cheech and Chong'
     *
     ***/
    'assign': function() {
      var assign = {};
      flattenedArgs(arguments, function(a, i) {
        if(isObjectType(a)) {
          simpleMerge(assign, a);
        } else {
          assign[i + 1] = a;
        }
      });
      return this.replace(/\{([^{]+?)\}/g, function(m, key) {
        return hasOwnProperty(assign, key) ? assign[key] : m;
      });
    }

  });


  // Aliases

  extend(string, true, true, {

    /***
     * @method insert()
     * @alias add
     *
     ***/
    'insert': string.prototype.add
  });

  buildBase64('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=');


  /***
   *
   * @package Inflections
   * @dependency string
   * @description Pluralization similar to ActiveSupport including uncountable words and acronyms. Humanized and URL-friendly strings.
   *
   ***/

  /***
   * String module
   *
   ***/


  var plurals      = [],
      singulars    = [],
      uncountables = [],
      humans       = [],
      acronyms     = {},
      Downcased,
      Inflector;

  function removeFromArray(arr, find) {
    var index = arr.indexOf(find);
    if(index > -1) {
      arr.splice(index, 1);
    }
  }

  function removeFromUncountablesAndAddTo(arr, rule, replacement) {
    if(isString(rule)) {
      removeFromArray(uncountables, rule);
    }
    removeFromArray(uncountables, replacement);
    arr.unshift({ rule: rule, replacement: replacement })
  }

  function paramMatchesType(param, type) {
    return param == type || param == 'all' || !param;
  }

  function isUncountable(word) {
    return uncountables.some(function(uncountable) {
      return new regexp('\\b' + uncountable + '$', 'i').test(word);
    });
  }

  function inflect(word, pluralize) {
    word = isString(word) ? word.toString() : '';
    if(word.isBlank() || isUncountable(word)) {
      return word;
    } else {
      return runReplacements(word, pluralize ? plurals : singulars);
    }
  }

  function runReplacements(word, table) {
    iterateOverObject(table, function(i, inflection) {
      if(word.match(inflection.rule)) {
        word = word.replace(inflection.rule, inflection.replacement);
        return false;
      }
    });
    return word;
  }

  function capitalize(word) {
    return word.replace(/^\W*[a-z]/, function(w){
      return w.toUpperCase();
    });
  }

  Inflector = {

    /*
     * Specifies a new acronym. An acronym must be specified as it will appear in a camelized string.  An underscore
     * string that contains the acronym will retain the acronym when passed to %camelize%, %humanize%, or %titleize%.
     * A camelized string that contains the acronym will maintain the acronym when titleized or humanized, and will
     * convert the acronym into a non-delimited single lowercase word when passed to String#underscore.
     *
     * Examples:
     *   String.Inflector.acronym('HTML')
     *   'html'.titleize()     -> 'HTML'
     *   'html'.camelize()     -> 'HTML'
     *   'MyHTML'.underscore() -> 'my_html'
     *
     * The acronym, however, must occur as a delimited unit and not be part of another word for conversions to recognize it:
     *
     *   String.Inflector.acronym('HTTP')
     *   'my_http_delimited'.camelize() -> 'MyHTTPDelimited'
     *   'https'.camelize()             -> 'Https', not 'HTTPs'
     *   'HTTPS'.underscore()           -> 'http_s', not 'https'
     *
     *   String.Inflector.acronym('HTTPS')
     *   'https'.camelize()   -> 'HTTPS'
     *   'HTTPS'.underscore() -> 'https'
     *
     * Note: Acronyms that are passed to %pluralize% will no longer be recognized, since the acronym will not occur as
     * a delimited unit in the pluralized result. To work around this, you must specify the pluralized form as an
     * acronym as well:
     *
     *    String.Inflector.acronym('API')
     *    'api'.pluralize().camelize() -> 'Apis'
     *
     *    String.Inflector.acronym('APIs')
     *    'api'.pluralize().camelize() -> 'APIs'
     *
     * %acronym% may be used to specify any word that contains an acronym or otherwise needs to maintain a non-standard
     * capitalization. The only restriction is that the word must begin with a capital letter.
     *
     * Examples:
     *   String.Inflector.acronym('RESTful')
     *   'RESTful'.underscore()           -> 'restful'
     *   'RESTfulController'.underscore() -> 'restful_controller'
     *   'RESTfulController'.titleize()   -> 'RESTful Controller'
     *   'restful'.camelize()             -> 'RESTful'
     *   'restful_controller'.camelize()  -> 'RESTfulController'
     *
     *   String.Inflector.acronym('McDonald')
     *   'McDonald'.underscore() -> 'mcdonald'
     *   'mcdonald'.camelize()   -> 'McDonald'
     */
    'acronym': function(word) {
      acronyms[word.toLowerCase()] = word;
      var all = object.keys(acronyms).map(function(key) {
        return acronyms[key];
      });
      Inflector.acronymRegExp = regexp(all.join('|'), 'g');
    },

    /*
     * Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.
     * The replacement should always be a string that may include references to the matched data from the rule.
     */
    'plural': function(rule, replacement) {
      removeFromUncountablesAndAddTo(plurals, rule, replacement);
    },

    /*
     * Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.
     * The replacement should always be a string that may include references to the matched data from the rule.
     */
    'singular': function(rule, replacement) {
      removeFromUncountablesAndAddTo(singulars, rule, replacement);
    },

    /*
     * Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used
     * for strings, not regular expressions. You simply pass the irregular in singular and plural form.
     *
     * Examples:
     *   String.Inflector.irregular('octopus', 'octopi')
     *   String.Inflector.irregular('person', 'people')
     */
    'irregular': function(singular, plural) {
      var singularFirst      = singular.first(),
          singularRest       = singular.from(1),
          pluralFirst        = plural.first(),
          pluralRest         = plural.from(1),
          pluralFirstUpper   = pluralFirst.toUpperCase(),
          pluralFirstLower   = pluralFirst.toLowerCase(),
          singularFirstUpper = singularFirst.toUpperCase(),
          singularFirstLower = singularFirst.toLowerCase();
      removeFromArray(uncountables, singular);
      removeFromArray(uncountables, plural);
      if(singularFirstUpper == pluralFirstUpper) {
        Inflector.plural(new regexp('({1}){2}$'.assign(singularFirst, singularRest), 'i'), '$1' + pluralRest);
        Inflector.plural(new regexp('({1}){2}$'.assign(pluralFirst, pluralRest), 'i'), '$1' + pluralRest);
        Inflector.singular(new regexp('({1}){2}$'.assign(pluralFirst, pluralRest), 'i'), '$1' + singularRest);
      } else {
        Inflector.plural(new regexp('{1}{2}$'.assign(singularFirstUpper, singularRest)), pluralFirstUpper + pluralRest);
        Inflector.plural(new regexp('{1}{2}$'.assign(singularFirstLower, singularRest)), pluralFirstLower + pluralRest);
        Inflector.plural(new regexp('{1}{2}$'.assign(pluralFirstUpper, pluralRest)), pluralFirstUpper + pluralRest);
        Inflector.plural(new regexp('{1}{2}$'.assign(pluralFirstLower, pluralRest)), pluralFirstLower + pluralRest);
        Inflector.singular(new regexp('{1}{2}$'.assign(pluralFirstUpper, pluralRest)), singularFirstUpper + singularRest);
        Inflector.singular(new regexp('{1}{2}$'.assign(pluralFirstLower, pluralRest)), singularFirstLower + singularRest);
      }
    },

    /*
     * Add uncountable words that shouldn't be attempted inflected.
     *
     * Examples:
     *   String.Inflector.uncountable('money')
     *   String.Inflector.uncountable('money', 'information')
     *   String.Inflector.uncountable(['money', 'information', 'rice'])
     */
    'uncountable': function(first) {
      var add = array.isArray(first) ? first : multiArgs(arguments);
      uncountables = uncountables.concat(add);
    },

    /*
     * Specifies a humanized form of a string by a regular expression rule or by a string mapping.
     * When using a regular expression based replacement, the normal humanize formatting is called after the replacement.
     * When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name')
     *
     * Examples:
     *   String.Inflector.human(/_cnt$/i, '_count')
     *   String.Inflector.human('legacy_col_person_name', 'Name')
     */
    'human': function(rule, replacement) {
      humans.unshift({ rule: rule, replacement: replacement })
    },


    /*
     * Clears the loaded inflections within a given scope (default is 'all').
     * Options are: 'all', 'plurals', 'singulars', 'uncountables', 'humans'.
     *
     * Examples:
     *   String.Inflector.clear('all')
     *   String.Inflector.clear('plurals')
     */
    'clear': function(type) {
      if(paramMatchesType(type, 'singulars'))    singulars    = [];
      if(paramMatchesType(type, 'plurals'))      plurals      = [];
      if(paramMatchesType(type, 'uncountables')) uncountables = [];
      if(paramMatchesType(type, 'humans'))       humans       = [];
      if(paramMatchesType(type, 'acronyms'))     acronyms     = {};
    }

  };

  Downcased = [
    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at',
    'by', 'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over',
    'with', 'for'
  ];

  Inflector.plural(/$/, 's');
  Inflector.plural(/s$/gi, 's');
  Inflector.plural(/(ax|test)is$/gi, '$1es');
  Inflector.plural(/(octop|vir|fung|foc|radi|alumn)(i|us)$/gi, '$1i');
  Inflector.plural(/(census|alias|status)$/gi, '$1es');
  Inflector.plural(/(bu)s$/gi, '$1ses');
  Inflector.plural(/(buffal|tomat)o$/gi, '$1oes');
  Inflector.plural(/([ti])um$/gi, '$1a');
  Inflector.plural(/([ti])a$/gi, '$1a');
  Inflector.plural(/sis$/gi, 'ses');
  Inflector.plural(/f+e?$/gi, 'ves');
  Inflector.plural(/(cuff|roof)$/gi, '$1s');
  Inflector.plural(/([ht]ive)$/gi, '$1s');
  Inflector.plural(/([^aeiouy]o)$/gi, '$1es');
  Inflector.plural(/([^aeiouy]|qu)y$/gi, '$1ies');
  Inflector.plural(/(x|ch|ss|sh)$/gi, '$1es');
  Inflector.plural(/(matr|vert|ind)(?:ix|ex)$/gi, '$1ices');
  Inflector.plural(/([ml])ouse$/gi, '$1ice');
  Inflector.plural(/([ml])ice$/gi, '$1ice');
  Inflector.plural(/^(ox)$/gi, '$1en');
  Inflector.plural(/^(oxen)$/gi, '$1');
  Inflector.plural(/(quiz)$/gi, '$1zes');
  Inflector.plural(/(phot|cant|hom|zer|pian|portic|pr|quart|kimon)o$/gi, '$1os');
  Inflector.plural(/(craft)$/gi, '$1');
  Inflector.plural(/([ft])[eo]{2}(th?)$/gi, '$1ee$2');

  Inflector.singular(/s$/gi, '');
  Inflector.singular(/([pst][aiu]s)$/gi, '$1');
  Inflector.singular(/([aeiouy])ss$/gi, '$1ss');
  Inflector.singular(/(n)ews$/gi, '$1ews');
  Inflector.singular(/([ti])a$/gi, '$1um');
  Inflector.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/gi, '$1$2sis');
  Inflector.singular(/(^analy)ses$/gi, '$1sis');
  Inflector.singular(/(i)(f|ves)$/i, '$1fe');
  Inflector.singular(/([aeolr]f?)(f|ves)$/i, '$1f');
  Inflector.singular(/([ht]ive)s$/gi, '$1');
  Inflector.singular(/([^aeiouy]|qu)ies$/gi, '$1y');
  Inflector.singular(/(s)eries$/gi, '$1eries');
  Inflector.singular(/(m)ovies$/gi, '$1ovie');
  Inflector.singular(/(x|ch|ss|sh)es$/gi, '$1');
  Inflector.singular(/([ml])(ous|ic)e$/gi, '$1ouse');
  Inflector.singular(/(bus)(es)?$/gi, '$1');
  Inflector.singular(/(o)es$/gi, '$1');
  Inflector.singular(/(shoe)s?$/gi, '$1');
  Inflector.singular(/(cris|ax|test)[ie]s$/gi, '$1is');
  Inflector.singular(/(octop|vir|fung|foc|radi|alumn)(i|us)$/gi, '$1us');
  Inflector.singular(/(census|alias|status)(es)?$/gi, '$1');
  Inflector.singular(/^(ox)(en)?/gi, '$1');
  Inflector.singular(/(vert|ind)(ex|ices)$/gi, '$1ex');
  Inflector.singular(/(matr)(ix|ices)$/gi, '$1ix');
  Inflector.singular(/(quiz)(zes)?$/gi, '$1');
  Inflector.singular(/(database)s?$/gi, '$1');
  Inflector.singular(/ee(th?)$/gi, 'oo$1');

  Inflector.irregular('person', 'people');
  Inflector.irregular('man', 'men');
  Inflector.irregular('child', 'children');
  Inflector.irregular('sex', 'sexes');
  Inflector.irregular('move', 'moves');
  Inflector.irregular('save', 'saves');
  Inflector.irregular('cow', 'kine');
  Inflector.irregular('goose', 'geese');
  Inflector.irregular('zombie', 'zombies');

  Inflector.uncountable('equipment,information,rice,money,species,series,fish,sheep,jeans'.split(','));


  extend(string, true, true, {

    /***
     * @method pluralize()
     * @returns String
     * @short Returns the plural form of the word in the string.
     * @example
     *
     *   'post'.pluralize()         -> 'posts'
     *   'octopus'.pluralize()      -> 'octopi'
     *   'sheep'.pluralize()        -> 'sheep'
     *   'words'.pluralize()        -> 'words'
     *   'CamelOctopus'.pluralize() -> 'CamelOctopi'
     *
     ***/
    'pluralize': function() {
      return inflect(this, true);
    },

    /***
     * @method singularize()
     * @returns String
     * @short The reverse of String#pluralize. Returns the singular form of a word in a string.
     * @example
     *
     *   'posts'.singularize()       -> 'post'
     *   'octopi'.singularize()      -> 'octopus'
     *   'sheep'.singularize()       -> 'sheep'
     *   'word'.singularize()        -> 'word'
     *   'CamelOctopi'.singularize() -> 'CamelOctopus'
     *
     ***/
    'singularize': function() {
      return inflect(this, false);
    },

    /***
     * @method humanize()
     * @returns String
     * @short Creates a human readable string.
     * @extra Capitalizes the first word and turns underscores into spaces and strips a trailing '_id', if any. Like String#titleize, this is meant for creating pretty output.
     * @example
     *
     *   'employee_salary'.humanize() -> 'Employee salary'
     *   'author_id'.humanize()       -> 'Author'
     *
     ***/
    'humanize': function() {
      var str = runReplacements(this, humans), acronym;
      str = str.replace(/_id$/g, '');
      str = str.replace(/(_)?([a-z\d]*)/gi, function(match, _, word){
        acronym = hasOwnProperty(acronyms, word) ? acronyms[word] : null;
        return (_ ? ' ' : '') + (acronym || word.toLowerCase());
      });
      return capitalize(str);
    },

    /***
     * @method titleize()
     * @returns String
     * @short Creates a title version of the string.
     * @extra Capitalizes all the words and replaces some characters in the string to create a nicer looking title. String#titleize is meant for creating pretty output.
     * @example
     *
     *   'man from the boondocks'.titleize() -> 'Man from the Boondocks'
     *   'x-men: the last stand'.titleize() -> 'X Men: The Last Stand'
     *   'TheManWithoutAPast'.titleize() -> 'The Man Without a Past'
     *   'raiders_of_the_lost_ark'.titleize() -> 'Raiders of the Lost Ark'
     *
     ***/
    'titleize': function() {
      var fullStopPunctuation = /[.:;!]$/, hasPunctuation, lastHadPunctuation, isFirstOrLast;
      return this.spacify().humanize().words(function(word, index, words) {
        hasPunctuation = fullStopPunctuation.test(word);
        isFirstOrLast = index == 0 || index == words.length - 1 || hasPunctuation || lastHadPunctuation;
        lastHadPunctuation = hasPunctuation;
        if(isFirstOrLast || Downcased.indexOf(word) === -1) {
          return capitalize(word);
        } else {
          return word;
        }
      }).join(' ');
    },

    /***
     * @method parameterize()
     * @returns String
     * @short Replaces special characters in a string so that it may be used as part of a pretty URL.
     * @example
     *
     *   'hell, no!'.parameterize() -> 'hell-no'
     *
     ***/
    'parameterize': function(separator) {
      var str = this;
      if(separator === undefined) separator = '-';
      if(str.normalize) {
        str = str.normalize();
      }
      str = str.replace(/[^a-z0-9\-_]+/gi, separator)
      if(separator) {
        str = str.replace(new regexp('^{sep}+|{sep}+$|({sep}){sep}+'.assign({ 'sep': escapeRegExp(separator) }), 'g'), '$1');
      }
      return encodeURI(str.toLowerCase());
    }

  });

  string.Inflector = Inflector;
  string.Inflector.acronyms = acronyms;


  /***
   *
   * @package Language
   * @dependency string
   * @description Detecting language by character block. Full-width <-> half-width character conversion. Hiragana and Katakana conversions.
   *
   ***/

  /***
   * String module
   *
   ***/


  /***
   * @method has[Script]()
   * @returns Boolean
   * @short Returns true if the string contains any characters in that script.
   *
   * @set
   *   hasArabic
   *   hasCyrillic
   *   hasGreek
   *   hasHangul
   *   hasHan
   *   hasKanji
   *   hasHebrew
   *   hasHiragana
   *   hasKana
   *   hasKatakana
   *   hasLatin
   *   hasThai
   *   hasDevanagari
   *
   * @example
   *
   *   'أتكلم'.hasArabic()          -> true
   *   'визит'.hasCyrillic()        -> true
   *   '잘 먹겠습니다!'.hasHangul() -> true
   *   'ミックスです'.hasKatakana() -> true
   *   "l'année".hasLatin()         -> true
   *
   ***
   * @method is[Script]()
   * @returns Boolean
   * @short Returns true if the string contains only characters in that script. Whitespace is ignored.
   *
   * @set
   *   isArabic
   *   isCyrillic
   *   isGreek
   *   isHangul
   *   isHan
   *   isKanji
   *   isHebrew
   *   isHiragana
   *   isKana
   *   isKatakana
   *   isKatakana
   *   isThai
   *   isDevanagari
   *
   * @example
   *
   *   'أتكلم'.isArabic()          -> true
   *   'визит'.isCyrillic()        -> true
   *   '잘 먹겠습니다!'.isHangul() -> true
   *   'ミックスです'.isKatakana() -> false
   *   "l'année".isLatin()         -> true
   *
   ***/
  var unicodeScripts = [
    { names: ['Arabic'],      source: '\u0600-\u06FF' },
    { names: ['Cyrillic'],    source: '\u0400-\u04FF' },
    { names: ['Devanagari'],  source: '\u0900-\u097F' },
    { names: ['Greek'],       source: '\u0370-\u03FF' },
    { names: ['Hangul'],      source: '\uAC00-\uD7AF\u1100-\u11FF' },
    { names: ['Han','Kanji'], source: '\u4E00-\u9FFF\uF900-\uFAFF' },
    { names: ['Hebrew'],      source: '\u0590-\u05FF' },
    { names: ['Hiragana'],    source: '\u3040-\u309F\u30FB-\u30FC' },
    { names: ['Kana'],        source: '\u3040-\u30FF\uFF61-\uFF9F' },
    { names: ['Katakana'],    source: '\u30A0-\u30FF\uFF61-\uFF9F' },
    { names: ['Latin'],       source: '\u0001-\u007F\u0080-\u00FF\u0100-\u017F\u0180-\u024F' },
    { names: ['Thai'],        source: '\u0E00-\u0E7F' }
  ];

  function buildUnicodeScripts() {
    unicodeScripts.forEach(function(s) {
      var is = regexp('^['+s.source+'\\s]+$');
      var has = regexp('['+s.source+']');
      s.names.forEach(function(name) {
        defineProperty(string.prototype, 'is' + name, function() { return is.test(this.trim()); });
        defineProperty(string.prototype, 'has' + name, function() { return has.test(this); });
      });
    });
  }

  // Support for converting character widths and katakana to hiragana.

  var HALF_WIDTH_TO_FULL_WIDTH_TRAVERSAL = 65248;

  var widthConversionRanges = [
    { type: 'a', start: 65,  end: 90  },
    { type: 'a', start: 97,  end: 122 },
    { type: 'n', start: 48,  end: 57  },
    { type: 'p', start: 33,  end: 47  },
    { type: 'p', start: 58,  end: 64  },
    { type: 'p', start: 91,  end: 96  },
    { type: 'p', start: 123, end: 126 }
  ];

  var WidthConversionTable;
  var allHankaku   = /[\u0020-\u00A5]|[\uFF61-\uFF9F][ﾞﾟ]?/g;
  var allZenkaku   = /[\u3000-\u301C]|[\u301A-\u30FC]|[\uFF01-\uFF60]|[\uFFE0-\uFFE6]/g;
  var hankakuPunctuation  = '｡､｢｣¥¢£';
  var zenkakuPunctuation  = '。、「」￥￠￡';
  var voicedKatakana      = /[カキクケコサシスセソタチツテトハヒフヘホ]/;
  var semiVoicedKatakana  = /[ハヒフヘホヲ]/;
  var hankakuKatakana     = 'ｱｲｳｴｵｧｨｩｪｫｶｷｸｹｺｻｼｽｾｿﾀﾁﾂｯﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔｬﾕｭﾖｮﾗﾘﾙﾚﾛﾜｦﾝｰ･';
  var zenkakuKatakana     = 'アイウエオァィゥェォカキクケコサシスセソタチツッテトナニヌネノハヒフヘホマミムメモヤャユュヨョラリルレロワヲンー・';

  function convertCharacterWidth(str, args, reg, type) {
    if(!WidthConversionTable) {
      buildWidthConversionTables();
    }
    var mode = multiArgs(args).join(''), table = WidthConversionTable[type];
    mode = mode.replace(/all/, '').replace(/(\w)lphabet|umbers?|atakana|paces?|unctuation/g, '$1');
    return str.replace(reg, function(c) {
      if(table[c] && (!mode || mode.has(table[c].type))) {
        return table[c].to;
      } else {
        return c;
      }
    });
  }

  function buildWidthConversionTables() {
    var hankaku;
    WidthConversionTable = {
      'zenkaku': {},
      'hankaku': {}
    };
    widthConversionRanges.forEach(function(r) {
      simpleRepeat(r.end - r.start + 1, function(n) {
        n += r.start;
        setWidthConversion(r.type, chr(n), chr(n + HALF_WIDTH_TO_FULL_WIDTH_TRAVERSAL));
      });
    });
    zenkakuKatakana.each(function(c, i) {
      hankaku = hankakuKatakana.charAt(i);
      setWidthConversion('k', hankaku, c);
      if(c.match(voicedKatakana)) {
        setWidthConversion('k', hankaku + 'ﾞ', c.shift(1));
      }
      if(c.match(semiVoicedKatakana)) {
        setWidthConversion('k', hankaku + 'ﾟ', c.shift(2));
      }
    });
    zenkakuPunctuation.each(function(c, i) {
      setWidthConversion('p', hankakuPunctuation.charAt(i), c);
    });
    setWidthConversion('k', 'ｳﾞ', 'ヴ');
    setWidthConversion('k', 'ｦﾞ', 'ヺ');
    setWidthConversion('s', ' ', '　');
  }

  function setWidthConversion(type, half, full) {
    WidthConversionTable['zenkaku'][half] = { type: type, to: full };
    WidthConversionTable['hankaku'][full] = { type: type, to: half };
  }


  extend(string, true, true, {

    /***
     * @method hankaku([mode] = 'all')
     * @returns String
     * @short Converts full-width characters (zenkaku) to half-width (hankaku).
     * @extra [mode] accepts any combination of "a" (alphabet), "n" (numbers), "k" (katakana), "s" (spaces), "p" (punctuation), or "all".
     * @example
     *
     *   'タロウ　ＹＡＭＡＤＡです！'.hankaku()                      -> 'ﾀﾛｳ YAMADAです!'
     *   'タロウ　ＹＡＭＡＤＡです！'.hankaku('a')                   -> 'タロウ　YAMADAです！'
     *   'タロウ　ＹＡＭＡＤＡです！'.hankaku('alphabet')            -> 'タロウ　YAMADAです！'
     *   'タロウです！　２５歳です！'.hankaku('katakana', 'numbers') -> 'ﾀﾛｳです！　25歳です！'
     *   'タロウです！　２５歳です！'.hankaku('k', 'n')              -> 'ﾀﾛｳです！　25歳です！'
     *   'タロウです！　２５歳です！'.hankaku('kn')                  -> 'ﾀﾛｳです！　25歳です！'
     *   'タロウです！　２５歳です！'.hankaku('sp')                  -> 'タロウです! ２５歳です!'
     *
     ***/
    'hankaku': function() {
      return convertCharacterWidth(this, arguments, allZenkaku, 'hankaku');
    },

    /***
     * @method zenkaku([mode] = 'all')
     * @returns String
     * @short Converts half-width characters (hankaku) to full-width (zenkaku).
     * @extra [mode] accepts any combination of "a" (alphabet), "n" (numbers), "k" (katakana), "s" (spaces), "p" (punctuation), or "all".
     * @example
     *
     *   'ﾀﾛｳ YAMADAです!'.zenkaku()                         -> 'タロウ　ＹＡＭＡＤＡです！'
     *   'ﾀﾛｳ YAMADAです!'.zenkaku('a')                      -> 'ﾀﾛｳ ＹＡＭＡＤＡです!'
     *   'ﾀﾛｳ YAMADAです!'.zenkaku('alphabet')               -> 'ﾀﾛｳ ＹＡＭＡＤＡです!'
     *   'ﾀﾛｳです! 25歳です!'.zenkaku('katakana', 'numbers') -> 'タロウです! ２５歳です!'
     *   'ﾀﾛｳです! 25歳です!'.zenkaku('k', 'n')              -> 'タロウです! ２５歳です!'
     *   'ﾀﾛｳです! 25歳です!'.zenkaku('kn')                  -> 'タロウです! ２５歳です!'
     *   'ﾀﾛｳです! 25歳です!'.zenkaku('sp')                  -> 'ﾀﾛｳです！　25歳です！'
     *
     ***/
    'zenkaku': function() {
      return convertCharacterWidth(this, arguments, allHankaku, 'zenkaku');
    },

    /***
     * @method hiragana([all] = true)
     * @returns String
     * @short Converts katakana into hiragana.
     * @extra If [all] is false, only full-width katakana will be converted.
     * @example
     *
     *   'カタカナ'.hiragana()   -> 'かたかな'
     *   'コンニチハ'.hiragana() -> 'こんにちは'
     *   'ｶﾀｶﾅ'.hiragana()       -> 'かたかな'
     *   'ｶﾀｶﾅ'.hiragana(false)  -> 'ｶﾀｶﾅ'
     *
     ***/
    'hiragana': function(all) {
      var str = this;
      if(all !== false) {
        str = str.zenkaku('k');
      }
      return str.replace(/[\u30A1-\u30F6]/g, function(c) {
        return c.shift(-96);
      });
    },

    /***
     * @method katakana()
     * @returns String
     * @short Converts hiragana into katakana.
     * @example
     *
     *   'かたかな'.katakana()   -> 'カタカナ'
     *   'こんにちは'.katakana() -> 'コンニチハ'
     *
     ***/
    'katakana': function() {
      return this.replace(/[\u3041-\u3096]/g, function(c) {
        return c.shift(96);
      });
    }


  });

  buildUnicodeScripts();

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('da');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('da', {
  'plural': true,
  'months': 'januar,februar,marts,april,maj,juni,juli,august,september,oktober,november,december',
  'weekdays': 'søndag|sondag,mandag,tirsdag,onsdag,torsdag,fredag,lørdag|lordag',
  'units': 'millisekund:|er,sekund:|er,minut:|ter,tim:e|er,dag:|e,ug:e|er|en,måned:|er|en+maaned:|er|en,år:||et+aar:||et',
  'numbers': 'en|et,to,tre,fire,fem,seks,syv,otte,ni,ti',
  'tokens': 'den,for',
  'articles': 'den',
  'short':'d. {d}. {month} {yyyy}',
  'long': 'den {d}. {month} {yyyy} {H}:{mm}',
  'full': '{Weekday} den {d}. {month} {yyyy} {H}:{mm}:{ss}',
  'past': '{num} {unit} {sign}',
  'future': '{sign} {num} {unit}',
  'duration': '{num} {unit}',
  'ampm': 'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'forgårs|i forgårs|forgaars|i forgaars', 'value': -2 },
    { 'name': 'day', 'src': 'i går|igår|i gaar|igaar', 'value': -1 },
    { 'name': 'day', 'src': 'i dag|idag', 'value': 0 },
    { 'name': 'day', 'src': 'i morgen|imorgen', 'value': 1 },
    { 'name': 'day', 'src': 'over morgon|overmorgen|i over morgen|i overmorgen|iovermorgen', 'value': 2 },
    { 'name': 'sign', 'src': 'siden', 'value': -1 },
    { 'name': 'sign', 'src': 'om', 'value':  1 },
    { 'name': 'shift', 'src': 'i sidste|sidste', 'value': -1 },
    { 'name': 'shift', 'src': 'denne', 'value': 0 },
    { 'name': 'shift', 'src': 'næste|naeste', 'value': 1 }
  ],
  'dateParse': [
    '{num} {unit} {sign}',
    '{sign} {num} {unit}',
    '{1?} {num} {unit} {sign}',
    '{shift} {unit=5-7}'
  ],
  'timeParse': [
    '{0?} {weekday?} {date?} {month} {year}',
    '{date} {month}',
    '{shift} {weekday}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('de');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('de', {
  'plural': true,
   'capitalizeUnit': true,
  'months': 'Januar,Februar,März|Marz,April,Mai,Juni,Juli,August,September,Oktober,November,Dezember',
  'weekdays': 'Sonntag,Montag,Dienstag,Mittwoch,Donnerstag,Freitag,Samstag',
  'units': 'Millisekunde:|n,Sekunde:|n,Minute:|n,Stunde:|n,Tag:|en,Woche:|n,Monat:|en,Jahr:|en',
  'numbers': 'ein:|e|er|en|em,zwei,drei,vier,fuenf,sechs,sieben,acht,neun,zehn',
  'tokens': 'der',
  'short':'{d}. {Month} {yyyy}',
  'long': '{d}. {Month} {yyyy} {H}:{mm}',
  'full': '{Weekday} {d}. {Month} {yyyy} {H}:{mm}:{ss}',
  'past': '{sign} {num} {unit}',
  'future': '{sign} {num} {unit}',
  'duration': '{num} {unit}',
  'timeMarker': 'um',
  'ampm': 'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'vorgestern', 'value': -2 },
    { 'name': 'day', 'src': 'gestern', 'value': -1 },
    { 'name': 'day', 'src': 'heute', 'value': 0 },
    { 'name': 'day', 'src': 'morgen', 'value': 1 },
    { 'name': 'day', 'src': 'übermorgen|ubermorgen|uebermorgen', 'value': 2 },
    { 'name': 'sign', 'src': 'vor:|her', 'value': -1 },
    { 'name': 'sign', 'src': 'in', 'value': 1 },
    { 'name': 'shift', 'src': 'letzte:|r|n|s', 'value': -1 },
    { 'name': 'shift', 'src': 'nächste:|r|n|s+nachste:|r|n|s+naechste:|r|n|s+kommende:n|r', 'value': 1 }
  ],
  'dateParse': [
    '{sign} {num} {unit}',
    '{num} {unit} {sign}',
    '{shift} {unit=5-7}'
  ],
  'timeParse': [
    '{weekday?} {date?} {month} {year?}',
    '{shift} {weekday}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('es');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('es', {
  'plural': true,
  'months': 'enero,febrero,marzo,abril,mayo,junio,julio,agosto,septiembre,octubre,noviembre,diciembre',
  'weekdays': 'domingo,lunes,martes,miércoles|miercoles,jueves,viernes,sábado|sabado',
  'units': 'milisegundo:|s,segundo:|s,minuto:|s,hora:|s,día|días|dia|dias,semana:|s,mes:|es,año|años|ano|anos',
  'numbers': 'uno,dos,tres,cuatro,cinco,seis,siete,ocho,nueve,diez',
  'tokens': 'el,la,de',
  'short':'{d} {month} {yyyy}',
  'long': '{d} {month} {yyyy} {H}:{mm}',
  'full': '{Weekday} {d} {month} {yyyy} {H}:{mm}:{ss}',
  'past': '{sign} {num} {unit}',
  'future': '{sign} {num} {unit}',
  'duration': '{num} {unit}',
  'timeMarker': 'a las',
  'ampm': 'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'anteayer', 'value': -2 },
    { 'name': 'day', 'src': 'ayer', 'value': -1 },
    { 'name': 'day', 'src': 'hoy', 'value': 0 },
    { 'name': 'day', 'src': 'mañana|manana', 'value': 1 },
    { 'name': 'sign', 'src': 'hace', 'value': -1 },
    { 'name': 'sign', 'src': 'dentro de', 'value': 1 },
    { 'name': 'shift', 'src': 'pasad:o|a', 'value': -1 },
    { 'name': 'shift', 'src': 'próximo|próxima|proximo|proxima', 'value': 1 }
  ],
  'dateParse': [
    '{sign} {num} {unit}',
    '{num} {unit} {sign}',
    '{0?}{1?} {unit=5-7} {shift}',
    '{0?}{1?} {shift} {unit=5-7}'
  ],
  'timeParse': [
    '{shift} {weekday}',
    '{weekday} {shift}',
    '{date?} {2?} {month} {2?} {year?}'
  ]
});
Date.addLocale('fi', {
    'plural':     true,
    'timeMarker': 'kello',
    'ampm':       ',',
    'months':     'tammikuu,helmikuu,maaliskuu,huhtikuu,toukokuu,kesäkuu,heinäkuu,elokuu,syyskuu,lokakuu,marraskuu,joulukuu',
    'weekdays':   'sunnuntai,maanantai,tiistai,keskiviikko,torstai,perjantai,lauantai',
    'units':      'millisekun:ti|tia|teja|tina|nin,sekun:ti|tia|teja|tina|nin,minuut:ti|tia|teja|tina|in,tun:ti|tia|teja|tina|nin,päiv:ä|ää|iä|änä|än,viik:ko|koa|koja|on|kona,kuukau:si|sia|tta|den|tena,vuo:si|sia|tta|den|tena',
    'numbers':    'yksi|ensimmäinen,kaksi|toinen,kolm:e|as,neljä:s,vii:si|des,kuu:si|des,seitsemä:n|s,kahdeksa:n|s,yhdeksä:n|s,kymmene:n|s',
    'articles':   '',
    'optionals':  '',
    'short':      '{d}. {month}ta {yyyy}',
    'long':       '{d}. {month}ta {yyyy} kello {H}.{mm}',
    'full':       '{Weekday}na {d}. {month}ta {yyyy} kello {H}.{mm}',
    'relative':       function(num, unit, ms, format) {
      var units = this['units'];
      function numberWithUnit(mult) {
        return (num === 1 ? '' : num + ' ') + units[(8 * mult) + unit];
      }
      switch(format) {
        case 'duration':  return numberWithUnit(0);
        case 'past':      return numberWithUnit(num > 1 ? 1 : 0) + ' sitten';
        case 'future':    return numberWithUnit(4) + ' päästä';
      }
    },
    'modifiers': [
        { 'name': 'day',   'src': 'toissa päivänä|toissa päiväistä', 'value': -2 },
        { 'name': 'day',   'src': 'eilen|eilistä', 'value': -1 },
        { 'name': 'day',   'src': 'tänään', 'value': 0 },
        { 'name': 'day',   'src': 'huomenna|huomista', 'value': 1 },
        { 'name': 'day',   'src': 'ylihuomenna|ylihuomista', 'value': 2 },
        { 'name': 'sign',  'src': 'sitten|aiemmin', 'value': -1 },
        { 'name': 'sign',  'src': 'päästä|kuluttua|myöhemmin', 'value': 1 },
        { 'name': 'edge',  'src': 'viimeinen|viimeisenä', 'value': -2 },
        { 'name': 'edge',  'src': 'lopussa', 'value': -1 },
        { 'name': 'edge',  'src': 'ensimmäinen|ensimmäisenä', 'value': 1 },
        { 'name': 'shift', 'src': 'edellinen|edellisenä|edeltävä|edeltävänä|viime|toissa', 'value': -1 },
        { 'name': 'shift', 'src': 'tänä|tämän', 'value': 0 },
        { 'name': 'shift', 'src': 'seuraava|seuraavana|tuleva|tulevana|ensi', 'value': 1 }
    ],
    'dateParse': [
        '{num} {unit} {sign}',
        '{sign} {num} {unit}',
        '{num} {unit=4-5} {sign} {day}',
        '{month} {year}',
        '{shift} {unit=5-7}'
    ],
    'timeParse': [
        '{0} {num}{1} {day} of {month} {year?}',
        '{weekday?} {month} {date}{1} {year?}',
        '{date} {month} {year}',
        '{shift} {weekday}',
        '{shift} week {weekday}',
        '{weekday} {2} {shift} week',
        '{0} {date}{1} of {month}',
        '{0}{month?} {date?}{1} of {shift} {unit=6-7}'
    ]
});
/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('fr');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('fr', {
  'plural': true,
  'months': 'janvier,février|fevrier,mars,avril,mai,juin,juillet,août,septembre,octobre,novembre,décembre|decembre',
  'weekdays': 'dimanche,lundi,mardi,mercredi,jeudi,vendredi,samedi',
  'units': 'milliseconde:|s,seconde:|s,minute:|s,heure:|s,jour:|s,semaine:|s,mois,an:|s|née|nee',
  'numbers': 'un:|e,deux,trois,quatre,cinq,six,sept,huit,neuf,dix',
  'tokens': "l'|la|le",
  'short':'{d} {month} {yyyy}',
  'long': '{d} {month} {yyyy} {H}:{mm}',
  'full': '{Weekday} {d} {month} {yyyy} {H}:{mm}:{ss}',
  'past': '{sign} {num} {unit}',
  'future': '{sign} {num} {unit}',
  'duration': '{num} {unit}',
  'timeMarker': 'à',
  'ampm': 'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'hier', 'value': -1 },
    { 'name': 'day', 'src': "aujourd'hui", 'value': 0 },
    { 'name': 'day', 'src': 'demain', 'value': 1 },
    { 'name': 'sign', 'src': 'il y a', 'value': -1 },
    { 'name': 'sign', 'src': "dans|d'ici", 'value': 1 },
    { 'name': 'shift', 'src': 'derni:èr|er|ère|ere', 'value': -1 },
    { 'name': 'shift', 'src': 'prochain:|e', 'value': 1 }
  ],
  'dateParse': [
    '{sign} {num} {unit}',
    '{sign} {num} {unit}',
    '{0?} {unit=5-7} {shift}'
  ],
  'timeParse': [
    '{weekday?} {0?} {date?} {month} {year?}',
    '{0?} {weekday} {shift}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('it');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('it', {
  'plural': true,
  'months': 'Gennaio,Febbraio,Marzo,Aprile,Maggio,Giugno,Luglio,Agosto,Settembre,Ottobre,Novembre,Dicembre',
  'weekdays': 'Domenica,Luned:ì|i,Marted:ì|i,Mercoled:ì|i,Gioved:ì|i,Venerd:ì|i,Sabato',
  'units': 'millisecond:o|i,second:o|i,minut:o|i,or:a|e,giorn:o|i,settiman:a|e,mes:e|i,ann:o|i',
  'numbers': "un:|a|o|',due,tre,quattro,cinque,sei,sette,otto,nove,dieci",
  'tokens': "l'|la|il",
  'short':'{d} {Month} {yyyy}',
  'long': '{d} {Month} {yyyy} {H}:{mm}',
  'full': '{Weekday} {d} {Month} {yyyy} {H}:{mm}:{ss}',
  'past': '{num} {unit} {sign}',
  'future': '{num} {unit} {sign}',
  'duration': '{num} {unit}',
  'timeMarker': 'alle',
  'ampm': 'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'ieri', 'value': -1 },
    { 'name': 'day', 'src': 'oggi', 'value': 0 },
    { 'name': 'day', 'src': 'domani', 'value': 1 },
    { 'name': 'day', 'src': 'dopodomani', 'value': 2 },
    { 'name': 'sign', 'src': 'fa', 'value': -1 },
    { 'name': 'sign', 'src': 'da adesso', 'value': 1 },
    { 'name': 'shift', 'src': 'scors:o|a', 'value': -1 },
    { 'name': 'shift', 'src': 'prossim:o|a', 'value': 1 }
  ],
  'dateParse': [
    '{num} {unit} {sign}',
    '{0?} {unit=5-7} {shift}',
    '{0?} {shift} {unit=5-7}'
  ],
  'timeParse': [
    '{weekday?} {date?} {month} {year?}',
    '{shift} {weekday}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('ja');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('ja', {
  'monthSuffix': '月',
  'weekdays': '日曜日,月曜日,火曜日,水曜日,木曜日,金曜日,土曜日',
  'units': 'ミリ秒,秒,分,時間,日,週間|週,ヶ月|ヵ月|月,年',
  'short': '{yyyy}年{M}月{d}日',
  'long': '{yyyy}年{M}月{d}日 {H}時{mm}分',
  'full': '{yyyy}年{M}月{d}日 {Weekday} {H}時{mm}分{ss}秒',
  'past': '{num}{unit}{sign}',
  'future': '{num}{unit}{sign}',
  'duration': '{num}{unit}',
  'timeSuffixes': '時,分,秒',
  'ampm': '午前,午後',
  'modifiers': [
    { 'name': 'day', 'src': '一昨日', 'value': -2 },
    { 'name': 'day', 'src': '昨日', 'value': -1 },
    { 'name': 'day', 'src': '今日', 'value': 0 },
    { 'name': 'day', 'src': '明日', 'value': 1 },
    { 'name': 'day', 'src': '明後日', 'value': 2 },
    { 'name': 'sign', 'src': '前', 'value': -1 },
    { 'name': 'sign', 'src': '後', 'value':  1 },
    { 'name': 'shift', 'src': '去|先', 'value': -1 },
    { 'name': 'shift', 'src': '来', 'value':  1 }
  ],
  'dateParse': [
    '{num}{unit}{sign}'
  ],
  'timeParse': [
    '{shift}{unit=5-7}{weekday?}',
    '{year}年{month?}月?{date?}日?',
    '{month}月{date?}日?',
    '{date}日'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('ko');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('ko', {
  'digitDate': true,
  'monthSuffix': '월',
  'weekdays': '일요일,월요일,화요일,수요일,목요일,금요일,토요일',
  'units': '밀리초,초,분,시간,일,주,개월|달,년',
  'numbers': '일|한,이,삼,사,오,육,칠,팔,구,십',
  'short': '{yyyy}년{M}월{d}일',
  'long': '{yyyy}년{M}월{d}일 {H}시{mm}분',
  'full': '{yyyy}년{M}월{d}일 {Weekday} {H}시{mm}분{ss}초',
  'past': '{num}{unit} {sign}',
  'future': '{num}{unit} {sign}',
  'duration': '{num}{unit}',
  'timeSuffixes': '시,분,초',
  'ampm': '오전,오후',
  'modifiers': [
    { 'name': 'day', 'src': '그저께', 'value': -2 },
    { 'name': 'day', 'src': '어제', 'value': -1 },
    { 'name': 'day', 'src': '오늘', 'value': 0 },
    { 'name': 'day', 'src': '내일', 'value': 1 },
    { 'name': 'day', 'src': '모레', 'value': 2 },
    { 'name': 'sign', 'src': '전', 'value': -1 },
    { 'name': 'sign', 'src': '후', 'value':  1 },
    { 'name': 'shift', 'src': '지난|작', 'value': -1 },
    { 'name': 'shift', 'src': '이번', 'value': 0 },
    { 'name': 'shift', 'src': '다음|내', 'value': 1 }
  ],
  'dateParse': [
    '{num}{unit} {sign}',
    '{shift?} {unit=5-7}'
  ],
  'timeParse': [
    '{shift} {unit=5?} {weekday}',
    '{year}년{month?}월?{date?}일?',
    '{month}월{date?}일?',
    '{date}일'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('nl');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('nl', {
  'plural': true,
  'months': 'januari,februari,maart,april,mei,juni,juli,augustus,september,oktober,november,december',
  'weekdays': 'zondag|zo,maandag|ma,dinsdag|di,woensdag|woe|wo,donderdag|do,vrijdag|vrij|vr,zaterdag|za',
  'units': 'milliseconde:|n,seconde:|n,minu:ut|ten,uur,dag:|en,we:ek|ken,maand:|en,jaar',
  'numbers': 'een,twee,drie,vier,vijf,zes,zeven,acht,negen',
  'tokens': '',
  'short':'{d} {Month} {yyyy}',
  'long': '{d} {Month} {yyyy} {H}:{mm}',
  'full': '{Weekday} {d} {Month} {yyyy} {H}:{mm}:{ss}',
  'past': '{num} {unit} {sign}',
  'future': '{num} {unit} {sign}',
  'duration': '{num} {unit}',
  'timeMarker': "'s|om",
  'modifiers': [
    { 'name': 'day', 'src': 'gisteren', 'value': -1 },
    { 'name': 'day', 'src': 'vandaag', 'value': 0 },
    { 'name': 'day', 'src': 'morgen', 'value': 1 },
    { 'name': 'day', 'src': 'overmorgen', 'value': 2 },
    { 'name': 'sign', 'src': 'geleden', 'value': -1 },
    { 'name': 'sign', 'src': 'vanaf nu', 'value': 1 },
    { 'name': 'shift', 'src': 'laatste|vorige|afgelopen', 'value': -1 },
    { 'name': 'shift', 'src': 'volgend:|e', 'value': 1 }
  ],
  'dateParse': [
    '{num} {unit} {sign}',
    '{0?} {unit=5-7} {shift}',
    '{0?} {shift} {unit=5-7}'
  ],
  'timeParse': [
    '{weekday?} {date?} {month} {year?}',
    '{shift} {weekday}'
  ]
});
/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('pl');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.optionals. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('pl', {
  'plural':    true,
  'months':    'Styczeń|Stycznia,Luty|Lutego,Marzec|Marca,Kwiecień|Kwietnia,Maj|Maja,Czerwiec|Czerwca,Lipiec|Lipca,Sierpień|Sierpnia,Wrzesień|Września,Październik|Października,Listopad|Listopada,Grudzień|Grudnia',
  'weekdays':  'Niedziela|Niedzielę,Poniedziałek,Wtorek,Środ:a|ę,Czwartek,Piątek,Sobota|Sobotę',
  'units':     'milisekund:a|y|,sekund:a|y|,minut:a|y|,godzin:a|y|,dzień|dni,tydzień|tygodnie|tygodni,miesiące|miesiące|miesięcy,rok|lata|lat',
  'numbers':   'jeden|jedną,dwa|dwie,trzy,cztery,pięć,sześć,siedem,osiem,dziewięć,dziesięć',
  'optionals': 'w|we,roku',
  'short':     '{d} {Month} {yyyy}',
  'long':      '{d} {Month} {yyyy} {H}:{mm}',
  'full' :     '{Weekday}, {d} {Month} {yyyy} {H}:{mm}:{ss}',
  'past':      '{num} {unit} {sign}',
  'future':    '{sign} {num} {unit}',
  'duration':  '{num} {unit}',
  'timeMarker':'o',
  'ampm':      'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'przedwczoraj', 'value': -2 },
    { 'name': 'day', 'src': 'wczoraj', 'value': -1 },
    { 'name': 'day', 'src': 'dzisiaj|dziś', 'value': 0 },
    { 'name': 'day', 'src': 'jutro', 'value': 1 },
    { 'name': 'day', 'src': 'pojutrze', 'value': 2 },
    { 'name': 'sign', 'src': 'temu|przed', 'value': -1 },
    { 'name': 'sign', 'src': 'za', 'value': 1 },
    { 'name': 'shift', 'src': 'zeszły|zeszła|ostatni|ostatnia', 'value': -1 },
    { 'name': 'shift', 'src': 'następny|następna|następnego|przyszły|przyszła|przyszłego', 'value': 1 }
  ],
  'dateParse': [
    '{num} {unit} {sign}',
    '{sign} {num} {unit}',
    '{month} {year}',
    '{shift} {unit=5-7}',
    '{0} {shift?} {weekday}'
  ],
  'timeParse': [
    '{date} {month} {year?} {1}',
    '{0} {shift?} {weekday}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('pt');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('pt', {
  'plural': true,
  'months': 'janeiro,fevereiro,março,abril,maio,junho,julho,agosto,setembro,outubro,novembro,dezembro',
  'weekdays': 'domingo,segunda-feira,terça-feira,quarta-feira,quinta-feira,sexta-feira,sábado|sabado',
  'units': 'milisegundo:|s,segundo:|s,minuto:|s,hora:|s,dia:|s,semana:|s,mês|mêses|mes|meses,ano:|s',
  'numbers': 'um,dois,três|tres,quatro,cinco,seis,sete,oito,nove,dez,uma,duas',
  'tokens': 'a,de',
  'short':'{d} de {month} de {yyyy}',
  'long': '{d} de {month} de {yyyy} {H}:{mm}',
  'full': '{Weekday}, {d} de {month} de {yyyy} {H}:{mm}:{ss}',
  'past': '{num} {unit} {sign}',
  'future': '{sign} {num} {unit}',
  'duration': '{num} {unit}',
  'timeMarker': 'às',
  'ampm': 'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'anteontem', 'value': -2 },
    { 'name': 'day', 'src': 'ontem', 'value': -1 },
    { 'name': 'day', 'src': 'hoje', 'value': 0 },
    { 'name': 'day', 'src': 'amanh:ã|a', 'value': 1 },
    { 'name': 'sign', 'src': 'atrás|atras|há|ha', 'value': -1 },
    { 'name': 'sign', 'src': 'daqui a', 'value': 1 },
    { 'name': 'shift', 'src': 'passad:o|a', 'value': -1 },
    { 'name': 'shift', 'src': 'próximo|próxima|proximo|proxima', 'value': 1 }
  ],
  'dateParse': [
    '{num} {unit} {sign}',
    '{sign} {num} {unit}',
    '{0?} {unit=5-7} {shift}',
    '{0?} {shift} {unit=5-7}'
  ],
  'timeParse': [
    '{date?} {1?} {month} {1?} {year?}',
    '{0?} {shift} {weekday}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('ru');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('ru', {
  'months': 'Январ:я|ь,Феврал:я|ь,Март:а|,Апрел:я|ь,Ма:я|й,Июн:я|ь,Июл:я|ь,Август:а|,Сентябр:я|ь,Октябр:я|ь,Ноябр:я|ь,Декабр:я|ь',
  'weekdays': 'Воскресенье,Понедельник,Вторник,Среда,Четверг,Пятница,Суббота',
  'units': 'миллисекунд:а|у|ы|,секунд:а|у|ы|,минут:а|у|ы|,час:||а|ов,день|день|дня|дней,недел:я|ю|и|ь|е,месяц:||а|ев|е,год|год|года|лет|году',
  'numbers': 'од:ин|ну,дв:а|е,три,четыре,пять,шесть,семь,восемь,девять,десять',
  'tokens': 'в|на,года',
  'short':'{d} {month} {yyyy} года',
  'long': '{d} {month} {yyyy} года {H}:{mm}',
  'full': '{Weekday} {d} {month} {yyyy} года {H}:{mm}:{ss}',
  'relative': function(num, unit, ms, format) {
    var numberWithUnit, last = num.toString().slice(-1), mult;
    switch(true) {
      case num >= 11 && num <= 15: mult = 3; break;
      case last == 1: mult = 1; break;
      case last >= 2 && last <= 4: mult = 2; break;
      default: mult = 3;
    }
    numberWithUnit = num + ' ' + this['units'][(mult * 8) + unit];
    switch(format) {
      case 'duration':  return numberWithUnit;
      case 'past':      return numberWithUnit + ' назад';
      case 'future':    return 'через ' + numberWithUnit;
    }
  },
  'timeMarker': 'в',
  'ampm': ' утра, вечера',
  'modifiers': [
    { 'name': 'day', 'src': 'позавчера', 'value': -2 },
    { 'name': 'day', 'src': 'вчера', 'value': -1 },
    { 'name': 'day', 'src': 'сегодня', 'value': 0 },
    { 'name': 'day', 'src': 'завтра', 'value': 1 },
    { 'name': 'day', 'src': 'послезавтра', 'value': 2 },
    { 'name': 'sign', 'src': 'назад', 'value': -1 },
    { 'name': 'sign', 'src': 'через', 'value': 1 },
    { 'name': 'shift', 'src': 'прошл:ый|ой|ом', 'value': -1 },
    { 'name': 'shift', 'src': 'следующ:ий|ей|ем', 'value': 1 }
  ],
  'dateParse': [
    '{num} {unit} {sign}',
    '{sign} {num} {unit}',
    '{month} {year}',
    '{0?} {shift} {unit=5-7}'
  ],
  'timeParse': [
    '{date} {month} {year?} {1?}',
    '{0?} {shift} {weekday}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('sv');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('sv', {
  'plural': true,
  'months': 'januari,februari,mars,april,maj,juni,juli,augusti,september,oktober,november,december',
  'weekdays': 'söndag|sondag,måndag:|en+mandag:|en,tisdag,onsdag,torsdag,fredag,lördag|lordag',
  'units': 'millisekund:|er,sekund:|er,minut:|er,timm:e|ar,dag:|ar,veck:a|or|an,månad:|er|en+manad:|er|en,år:||et+ar:||et',
  'numbers': 'en|ett,två|tva,tre,fyra,fem,sex,sju,åtta|atta,nio,tio',
  'tokens': 'den,för|for',
  'articles': 'den',
  'short':'den {d} {month} {yyyy}',
  'long': 'den {d} {month} {yyyy} {H}:{mm}',
  'full': '{Weekday} den {d} {month} {yyyy} {H}:{mm}:{ss}',
  'past': '{num} {unit} {sign}',
  'future': '{sign} {num} {unit}',
  'duration': '{num} {unit}',
  'ampm': 'am,pm',
  'modifiers': [
    { 'name': 'day', 'src': 'förrgår|i förrgår|iförrgår|forrgar|i forrgar|iforrgar', 'value': -2 },
    { 'name': 'day', 'src': 'går|i går|igår|gar|i gar|igar', 'value': -1 },
    { 'name': 'day', 'src': 'dag|i dag|idag', 'value': 0 },
    { 'name': 'day', 'src': 'morgon|i morgon|imorgon', 'value': 1 },
    { 'name': 'day', 'src': 'över morgon|övermorgon|i över morgon|i övermorgon|iövermorgon|over morgon|overmorgon|i over morgon|i overmorgon|iovermorgon', 'value': 2 },
    { 'name': 'sign', 'src': 'sedan|sen', 'value': -1 },
    { 'name': 'sign', 'src': 'om', 'value':  1 },
    { 'name': 'shift', 'src': 'i förra|förra|i forra|forra', 'value': -1 },
    { 'name': 'shift', 'src': 'denna', 'value': 0 },
    { 'name': 'shift', 'src': 'nästa|nasta', 'value': 1 }
  ],
  'dateParse': [
    '{num} {unit} {sign}',
    '{sign} {num} {unit}',
    '{1?} {num} {unit} {sign}',
    '{shift} {unit=5-7}'
  ],
  'timeParse': [
    '{0?} {weekday?} {date?} {month} {year}',
    '{date} {month}',
    '{shift} {weekday}'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('zh-CN');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

Date.addLocale('zh-CN', {
  'variant': true,
  'monthSuffix': '月',
  'weekdays': '星期日|周日,星期一|周一,星期二|周二,星期三|周三,星期四|周四,星期五|周五,星期六|周六',
  'units': '毫秒,秒钟,分钟,小时,天,个星期|周,个月,年',
  'tokens': '日|号',
  'short':'{yyyy}年{M}月{d}日',
  'long': '{yyyy}年{M}月{d}日 {tt}{h}:{mm}',
  'full': '{yyyy}年{M}月{d}日 {weekday} {tt}{h}:{mm}:{ss}',
  'past': '{num}{unit}{sign}',
  'future': '{num}{unit}{sign}',
  'duration': '{num}{unit}',
  'timeSuffixes': '点|时,分钟?,秒',
  'ampm': '上午,下午',
  'modifiers': [
    { 'name': 'day', 'src': '前天', 'value': -2 },
    { 'name': 'day', 'src': '昨天', 'value': -1 },
    { 'name': 'day', 'src': '今天', 'value': 0 },
    { 'name': 'day', 'src': '明天', 'value': 1 },
    { 'name': 'day', 'src': '后天', 'value': 2 },
    { 'name': 'sign', 'src': '前', 'value': -1 },
    { 'name': 'sign', 'src': '后', 'value':  1 },
    { 'name': 'shift', 'src': '上|去', 'value': -1 },
    { 'name': 'shift', 'src': '这', 'value':  0 },
    { 'name': 'shift', 'src': '下|明', 'value':  1 }
  ],
  'dateParse': [
    '{num}{unit}{sign}',
    '{shift}{unit=5-7}'
  ],
  'timeParse': [
    '{shift}{weekday}',
    '{year}年{month?}月?{date?}{0?}',
    '{month}月{date?}{0?}',
    '{date}[日号]'
  ]
});

/*
 *
 * Date.addLocale(<code>) adds this locale to Sugar.
 * To set the locale globally, simply call:
 *
 * Date.setLocale('zh-TW');
 *
 * var locale = Date.getLocale(<code>) will return this object, which
 * can be tweaked to change the behavior of parsing/formatting in the locales.
 *
 * locale.addFormat adds a date format (see this file for examples).
 * Special tokens in the date format will be parsed out into regex tokens:
 *
 * {0} is a reference to an entry in locale.tokens. Output: (?:the)?
 * {unit} is a reference to all units. Output: (day|week|month|...)
 * {unit3} is a reference to a specific unit. Output: (hour)
 * {unit3-5} is a reference to a subset of the units array. Output: (hour|day|week)
 * {unit?} "?" makes that token optional. Output: (day|week|month)?
 *
 * {day} Any reference to tokens in the modifiers array will include all with the same name. Output: (yesterday|today|tomorrow)
 *
 * All spaces are optional and will be converted to "\s*"
 *
 * Locale arrays months, weekdays, units, numbers, as well as the "src" field for
 * all entries in the modifiers array follow a special format indicated by a colon:
 *
 * minute:|s  = minute|minutes
 * thicke:n|r = thicken|thicker
 *
 * Additionally in the months, weekdays, units, and numbers array these will be added at indexes that are multiples
 * of the relevant number for retrieval. For example having "sunday:|s" in the units array will result in:
 *
 * units: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sundays']
 *
 * When matched, the index will be found using:
 *
 * units.indexOf(match) % 7;
 *
 * Resulting in the correct index with any number of alternates for that entry.
 *
 */

  //'zh-TW': '1;月;年;;星期日|週日,星期一|週一,星期二|週二,星期三|週三,星期四|週四,星期五|週五,星期六|週六;毫秒,秒鐘,分鐘,小時,天,個星期|週,個月,年;;;日|號;;上午,下午;點|時,分鐘?,秒;{num}{unit}{sign},{shift}{unit=5-7};{shift}{weekday},{year}年{month?}月?{date?}{0},{month}月{date?}{0},{date}{0};{yyyy}年{M}月{d}日 {Weekday};{tt}{h}:{mm}:{ss};前天,昨天,今天,明天,後天;,前,,後;,上|去,這,下|明',

Date.addLocale('zh-TW', {
  'monthSuffix': '月',
  'weekdays': '星期日|週日,星期一|週一,星期二|週二,星期三|週三,星期四|週四,星期五|週五,星期六|週六',
  'units': '毫秒,秒鐘,分鐘,小時,天,個星期|週,個月,年',
  'tokens': '日|號',
  'short':'{yyyy}年{M}月{d}日',
  'long': '{yyyy}年{M}月{d}日 {tt}{h}:{mm}',
  'full': '{yyyy}年{M}月{d}日 {Weekday} {tt}{h}:{mm}:{ss}',
  'past': '{num}{unit}{sign}',
  'future': '{num}{unit}{sign}',
  'duration': '{num}{unit}',
  'timeSuffixes': '點|時,分鐘?,秒',
  'ampm': '上午,下午',
  'modifiers': [
    { 'name': 'day', 'src': '前天', 'value': -2 },
    { 'name': 'day', 'src': '昨天', 'value': -1 },
    { 'name': 'day', 'src': '今天', 'value': 0 },
    { 'name': 'day', 'src': '明天', 'value': 1 },
    { 'name': 'day', 'src': '後天', 'value': 2 },
    { 'name': 'sign', 'src': '前', 'value': -1 },
    { 'name': 'sign', 'src': '後', 'value': 1 },
    { 'name': 'shift', 'src': '上|去', 'value': -1 },
    { 'name': 'shift', 'src': '這', 'value':  0 },
    { 'name': 'shift', 'src': '下|明', 'value':  1 }
  ],
  'dateParse': [
    '{num}{unit}{sign}',
    '{shift}{unit=5-7}'
  ],
  'timeParse': [
    '{shift}{weekday}',
    '{year}年{month?}月?{date?}{0?}',
    '{month}月{date?}{0?}',
    '{date}[日號]'
  ]
});


}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],42:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],43:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":42,"_process":24,"inherits":12}],44:[function(require,module,exports){
// require('angular-aria');
// require('angular-messages');
require('ng-annotate');
require('firebase');
require('angularfire/dist/angularfire');
require('sugar/release/sugar-full.development');

// Ionic Starter App

// angular.module is a global place for creating, registering and retrieving Angular modules
// 'starter' is the name of this angular module example (also set in a <body> attribute in index.html)
// the 2nd parameter is an array of 'requires'
// 'starter.services' is found in services.js
// 'starter.controllers' is found in controllers.js
angular.module('app', [
  'ionic',
  'firebase',
  require('./controllers').name,
  require('./routes').name,
  // 'app.services',
  // 'app.directives'
])

.run(function($ionicPlatform) {
  $ionicPlatform.ready(function() {
    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
    // for form inputs)
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      cordova.plugins.Keyboard.disableScroll(true);
    }
    if (window.StatusBar) {
      // org.apache.cordova.statusbar required
      StatusBar.styleDefault();
    }
  });
})
},{"./controllers":45,"./routes":46,"angularfire/dist/angularfire":3,"firebase":10,"ng-annotate":15,"sugar/release/sugar-full.development":41}],45:[function(require,module,exports){
module.exports = angular.module('app.controllers', [])
  
.controller('hashnoteCtrl', function($scope) {

})
   
.controller('newNoteCtrl', function($scope) {

})
   
.controller('myTagsCtrl', function($scope) {

})

.controller('loginCtrl', function($scope) {

})
    
},{}],46:[function(require,module,exports){
module.exports = angular.module('app.routes', [])

.config(function($stateProvider, $urlRouterProvider) {

  // Ionic uses AngularUI Router which uses the concept of states
  // Learn more here: https://github.com/angular-ui/ui-router
  // Set up the various states which the app can be in.
  // Each state's controller can be found in controllers.js
  $stateProvider
  .state('menu.login', {
    url: '/login',
    views: {
      'login': {
        templateUrl: 'templates/login.html',
        controller: 'loginCtrl'
      }
    }
  })
  .state('menu.hashnote', {
    url: '/page1',
    views: {
      'side-menu21': {
        templateUrl: 'templates/hashnote.html',
        controller: 'hashnoteCtrl'
      }
    }
  })

  .state('menu.newNote', {
    url: '/page2',
    views: {
      'side-menu21': {
        templateUrl: 'templates/newNote.html',
        controller: 'newNoteCtrl'
      }
    }
  })

  .state('menu.myTags', {
    url: '/page3',
    views: {
      'side-menu21': {
        templateUrl: 'templates/myTags.html',
        controller: 'myTagsCtrl'
      }
    }
  })

  .state('menu', {
    url: '/side-menu21',
    templateUrl: 'templates/menu.html',
    abstract:true
  })

$urlRouterProvider.otherwise('/login/login')

});
},{}]},{},[44])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcyIsIm5vZGVfbW9kdWxlcy9hbHRlci9hbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyZmlyZS9kaXN0L2FuZ3VsYXJmaXJlLmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29udmVydC1zb3VyY2UtbWFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZpcmViYXNlL2xpYi9maXJlYmFzZS13ZWIuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL25nLWFubm90YXRlL2J1aWxkL2VzNS9nZW5lcmF0ZS1zb3VyY2VtYXAuanMiLCJub2RlX21vZHVsZXMvbmctYW5ub3RhdGUvYnVpbGQvZXM1L2x1dC5qcyIsIm5vZGVfbW9kdWxlcy9uZy1hbm5vdGF0ZS9idWlsZC9lczUvbmctYW5ub3RhdGUtbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9uZy1hbm5vdGF0ZS9idWlsZC9lczUvbmdpbmplY3QuanMiLCJub2RlX21vZHVsZXMvbmctYW5ub3RhdGUvYnVpbGQvZXM1L29wdGlvbmFscy9hbmd1bGFyLWRhc2hib2FyZC1mcmFtZXdvcmsuanMiLCJub2RlX21vZHVsZXMvbmctYW5ub3RhdGUvYnVpbGQvZXM1L3Njb3BlLmpzIiwibm9kZV9tb2R1bGVzL25nLWFubm90YXRlL2J1aWxkL2VzNS9zY29wZXRvb2xzLmpzIiwibm9kZV9tb2R1bGVzL29yZGVyZWQtYXN0LXRyYXZlcnNlL29yZGVyZWQtYXN0LXRyYXZlcnNlLmpzIiwibm9kZV9tb2R1bGVzL29yZGVyZWQtZXNwcmltYS1wcm9wcy9vcmRlcmVkLWVzcHJpbWEtcHJvcHMuanMiLCJub2RlX21vZHVsZXMvb3MtYnJvd3NlcmlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLWZtdC9zaW1wbGUtZm10LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1pcy9zaW1wbGUtaXMuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2JpbmFyeS1zZWFyY2guanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9zdGFibGUvc3RhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ21hcC9zdHJpbmdtYXAuanMiLCJub2RlX21vZHVsZXMvc3RyaW5nc2V0L3N0cmluZ3NldC5qcyIsIm5vZGVfbW9kdWxlcy9zdWdhci9yZWxlYXNlL3N1Z2FyLWZ1bGwuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3d3cvanMvYXBwLmpzIiwid3d3L2pzL2NvbnRyb2xsZXJzLmpzIiwid3d3L2pzL3JvdXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqd0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3R1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1Z0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3aFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmFjb3JuID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQSByZWN1cnNpdmUgZGVzY2VudCBwYXJzZXIgb3BlcmF0ZXMgYnkgZGVmaW5pbmcgZnVuY3Rpb25zIGZvciBhbGxcbi8vIHN5bnRhY3RpYyBlbGVtZW50cywgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhvc2UsIGVhY2ggZnVuY3Rpb25cbi8vIGFkdmFuY2luZyB0aGUgaW5wdXQgc3RyZWFtIGFuZCByZXR1cm5pbmcgYW4gQVNUIG5vZGUuIFByZWNlZGVuY2Vcbi8vIG9mIGNvbnN0cnVjdHMgKGZvciBleGFtcGxlLCB0aGUgZmFjdCB0aGF0IGAheFsxXWAgbWVhbnMgYCEoeFsxXSlgXG4vLyBpbnN0ZWFkIG9mIGAoIXgpWzFdYCBpcyBoYW5kbGVkIGJ5IHRoZSBmYWN0IHRoYXQgdGhlIHBhcnNlclxuLy8gZnVuY3Rpb24gdGhhdCBwYXJzZXMgdW5hcnkgcHJlZml4IG9wZXJhdG9ycyBpcyBjYWxsZWQgZmlyc3QsIGFuZFxuLy8gaW4gdHVybiBjYWxscyB0aGUgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYFtdYCBzdWJzY3JpcHRzIOKAlCB0aGF0XG4vLyB3YXksIGl0J2xsIHJlY2VpdmUgdGhlIG5vZGUgZm9yIGB4WzFdYCBhbHJlYWR5IHBhcnNlZCwgYW5kIHdyYXBzXG4vLyAqdGhhdCogaW4gdGhlIHVuYXJ5IG9wZXJhdG9yIG5vZGUuXG4vL1xuLy8gQWNvcm4gdXNlcyBhbiBbb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzZXJdW29wcF0gdG8gaGFuZGxlIGJpbmFyeVxuLy8gb3BlcmF0b3IgcHJlY2VkZW5jZSwgYmVjYXVzZSBpdCBpcyBtdWNoIG1vcmUgY29tcGFjdCB0aGFuIHVzaW5nXG4vLyB0aGUgdGVjaG5pcXVlIG91dGxpbmVkIGFib3ZlLCB3aGljaCB1c2VzIGRpZmZlcmVudCwgbmVzdGluZ1xuLy8gZnVuY3Rpb25zIHRvIHNwZWNpZnkgcHJlY2VkZW5jZSwgZm9yIGFsbCBvZiB0aGUgdGVuIGJpbmFyeVxuLy8gcHJlY2VkZW5jZSBsZXZlbHMgdGhhdCBKYXZhU2NyaXB0IGRlZmluZXMuXG4vL1xuLy8gW29wcF06IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0b3ItcHJlY2VkZW5jZV9wYXJzZXJcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdG9rZW50eXBlID0gX2RlcmVxXyhcIi4vdG9rZW50eXBlXCIpO1xuXG52YXIgX3N0YXRlID0gX2RlcmVxXyhcIi4vc3RhdGVcIik7XG5cbnZhciBwcCA9IF9zdGF0ZS5QYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuLy8gZWl0aGVyIHdpdGggZWFjaCBvdGhlciBvciB3aXRoIGFuIGluaXQgcHJvcGVydHkg4oCUIGFuZCBpblxuLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxucHAuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbiAocHJvcCwgcHJvcEhhc2gpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIChwcm9wLmNvbXB1dGVkIHx8IHByb3AubWV0aG9kIHx8IHByb3Auc2hvcnRoYW5kKSkgcmV0dXJuO1xuICB2YXIga2V5ID0gcHJvcC5rZXk7dmFyIG5hbWUgPSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgbmFtZSA9IGtleS5uYW1lO2JyZWFrO1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6XG4gICAgICBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7YnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcblxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpO1xuICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gIGlmIChvdGhlcikge1xuICAgIHZhciBpc0dldFNldCA9IGtpbmQgIT09IFwiaW5pdFwiO1xuICAgIGlmICgodGhpcy5zdHJpY3QgfHwgaXNHZXRTZXQpICYmIG90aGVyW2tpbmRdIHx8ICEoaXNHZXRTZXQgXiBvdGhlci5pbml0KSkgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpO1xuICB9IGVsc2Uge1xuICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGdldDogZmFsc2UsXG4gICAgICBzZXQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBvdGhlcltraW5kXSA9IHRydWU7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbi8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbi8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4vLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbi8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbnBwLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsXG4gICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5jb21tYSkpIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59O1xuXG4vLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4vLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG5wcC5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24gKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gIGlmICh0aGlzLnR5cGUgPT0gX3Rva2VudHlwZS50eXBlcy5feWllbGQgJiYgdGhpcy5pbkdlbmVyYXRvcikgcmV0dXJuIHRoaXMucGFyc2VZaWVsZCgpO1xuXG4gIHZhciB2YWxpZGF0ZURlc3RydWN0dXJpbmcgPSBmYWxzZTtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IHsgc2hvcnRoYW5kQXNzaWduOiAwLCB0cmFpbGluZ0NvbW1hOiAwIH07XG4gICAgdmFsaWRhdGVEZXN0cnVjdHVyaW5nID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBpZiAodGhpcy50eXBlID09IF90b2tlbnR5cGUudHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PSBfdG9rZW50eXBlLnR5cGVzLm5hbWUpIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7XG4gIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmIChhZnRlckxlZnRQYXJzZSkgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgIGlmICh2YWxpZGF0ZURlc3RydWN0dXJpbmcpIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQpIDogbGVmdDtcbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IDA7IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgdGhpcy5jaGVja0xWYWwobGVmdCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbGlkYXRlRGVzdHJ1Y3R1cmluZykgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGxlZnQ7XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcC5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHJldHVybiBleHByO1xuICBpZiAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuY29sb24pO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59O1xuXG4vLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbnBwLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uIChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsXG4gICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgcmV0dXJuIGV4cHI7XG4gIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pO1xufTtcblxuLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbi8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4vLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbi8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbi8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxucHAucGFyc2VFeHByT3AgPSBmdW5jdGlvbiAobGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gX3Rva2VudHlwZS50eXBlcy5faW4pKSB7XG4gICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MpO1xuICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgdmFyIG9wID0gdGhpcy50eXBlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KCksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgbm9Jbik7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgb3AgPT09IF90b2tlbnR5cGUudHlwZXMubG9naWNhbE9SIHx8IG9wID09PSBfdG9rZW50eXBlLnR5cGVzLmxvZ2ljYWxBTkQgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIik7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZWZ0O1xufTtcblxuLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxucHAucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24gKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksXG4gICAgICAgIHVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5pbmNEZWM7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIGlmICh1cGRhdGUpIHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpO2Vsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiYgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIikgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgfVxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSByZXR1cm4gZXhwcjtcbiAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5wcmVmaXggPSBmYWxzZTtcbiAgICBub2RlLmFyZ3VtZW50ID0gZXhwcjtcbiAgICB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICByZXR1cm4gZXhwcjtcbn07XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcC5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24gKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCxcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHZhciBza2lwQXJyb3dTdWJzY3JpcHRzID0gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCI7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB8fCBza2lwQXJyb3dTdWJzY3JpcHRzKSByZXR1cm4gZXhwcjtcbiAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG59O1xuXG5wcC5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbiAoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5kb3QpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgbm9kZS5jb21wdXRlZCA9IHRydWU7XG4gICAgICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5wYXJlbkwpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KF90b2tlbnR5cGUudHlwZXMucGFyZW5SLCBmYWxzZSk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuYmFja1F1b3RlKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGFnID0gYmFzZTtcbiAgICAgIG5vZGUucXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGUoKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24g4oCUIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4vLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuLy8gYG5ld2AsIG9yIGFuIGV4cHJlc3Npb24gd3JhcHBlZCBpbiBwdW5jdHVhdGlvbiBsaWtlIGAoKWAsIGBbXWAsXG4vLyBvciBge31gLlxuXG5wcC5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24gKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB1bmRlZmluZWQsXG4gICAgICBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09IHRoaXMuc3RhcnQ7XG4gIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl9zdXBlcjpcbiAgICAgIGlmICghdGhpcy5pbkZ1bmN0aW9uKSB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBvdXRzaWRlIG9mIGZ1bmN0aW9uIG9yIGNsYXNzXCIpO1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5fdGhpczpcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl90aGlzID8gXCJUaGlzRXhwcmVzc2lvblwiIDogXCJTdXBlclwiO1xuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG5cbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuX3lpZWxkOlxuICAgICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IpIHRoaXMudW5leHBlY3RlZCgpO1xuXG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLm5hbWU6XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudCh0aGlzLnR5cGUgIT09IF90b2tlbnR5cGUudHlwZXMubmFtZSk7XG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmFycm93KSkgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdKTtcbiAgICAgIHJldHVybiBpZDtcblxuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5yZWdleHA6XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICAgIG5vZGUucmVnZXggPSB7IHBhdHRlcm46IHZhbHVlLnBhdHRlcm4sIGZsYWdzOiB2YWx1ZS5mbGFncyB9O1xuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMubnVtOmNhc2UgX3Rva2VudHlwZS50eXBlcy5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSk7XG5cbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuX251bGw6Y2FzZSBfdG9rZW50eXBlLnR5cGVzLl90cnVlOmNhc2UgX3Rva2VudHlwZS50eXBlcy5fZmFsc2U6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuX251bGwgPyBudWxsIDogdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl90cnVlO1xuICAgICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMucGFyZW5MOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcblxuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5icmFja2V0TDpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaXMgYXJyYXkgY29tcHJlaGVuc2lvbiBvciByZWd1bGFyIGFycmF5XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl9mb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb21wcmVoZW5zaW9uKG5vZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QoX3Rva2VudHlwZS50eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpO1xuXG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcblxuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5fZnVuY3Rpb246XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBmYWxzZSk7XG5cbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSk7XG5cbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuX25ldzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KCk7XG5cbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuYmFja1F1b3RlOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZSgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcC5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcbn07XG5cbnBwLnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLnBhcmVuTCk7XG4gIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLnBhcmVuUik7XG4gIHJldHVybiB2YWw7XG59O1xuXG5wcC5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24gKGNhbkJlQXJyb3cpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCxcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYyxcbiAgICAgIHZhbCA9IHVuZGVmaW5lZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl9mb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29tcHJlaGVuc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCxcbiAgICAgICAgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHJMaXN0ID0gW10sXG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IHsgc2hvcnRoYW5kQXNzaWduOiAwLCB0cmFpbGluZ0NvbW1hOiAwIH0sXG4gICAgICAgIHNwcmVhZFN0YXJ0ID0gdW5kZWZpbmVkLFxuICAgICAgICBpbm5lclBhcmVuU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gX3Rva2VudHlwZS50eXBlcy5wYXJlblIpIHtcbiAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5lbGxpcHNpcykge1xuICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlUmVzdCgpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5wYXJlbkwgJiYgIWlubmVyUGFyZW5TdGFydCkge1xuICAgICAgICAgIGlubmVyUGFyZW5TdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5zdGFydCxcbiAgICAgICAgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuYXJyb3cpKSB7XG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIGlmIChpbm5lclBhcmVuU3RhcnQpIHRoaXMudW5leHBlY3RlZChpbm5lclBhcmVuU3RhcnQpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KTtcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICBpZiAoc3ByZWFkU3RhcnQpIHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG5cbiAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcblxucHAucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICByZXR1cm4gaXRlbTtcbn07XG5cbnBwLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0KTtcbn07XG5cbi8vIE5ldydzIHByZWNlZGVuY2UgaXMgc2xpZ2h0bHkgdHJpY2t5LiBJdCBtdXN0IGFsbG93IGl0cyBhcmd1bWVudFxuLy8gdG8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0XG4vLyBsZWFzdCwgbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlXG5cbnZhciBlbXB0eSA9IFtdO1xuXG5wcC5wYXJzZU5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiKSB0aGlzLnJhaXNlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIG5ldy50YXJnZXRcIik7XG4gICAgaWYgKCF0aGlzLmluRnVuY3Rpb24pIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIik7XG4gIH1cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCxcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgaWYgKHRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMucGFyZW5MKSkgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QoX3Rva2VudHlwZS50eXBlcy5wYXJlblIsIGZhbHNlKTtlbHNlIG5vZGUuYXJndW1lbnRzID0gZW1wdHk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpO1xufTtcblxuLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxucHAucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgZWxlbS52YWx1ZSA9IHtcbiAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpLFxuICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICB9O1xuICB0aGlzLm5leHQoKTtcbiAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmJhY2tRdW90ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbn07XG5cbnBwLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoKTtcbiAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCgpKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKTtcbn07XG5cbi8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxucHAucGFyc2VPYmogPSBmdW5jdGlvbiAoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSxcbiAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgIHByb3BIYXNoID0ge307XG4gIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICB0aGlzLm5leHQoKTtcbiAgd2hpbGUgKCF0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShfdG9rZW50eXBlLnR5cGVzLmJyYWNlUikpIGJyZWFrO1xuICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpLFxuICAgICAgICBpc0dlbmVyYXRvciA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRQb3MgPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0TG9jID0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGF0dGVybikgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLnN0YXIpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgdGhpcy5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCk7XG4gICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2godGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIikpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIik7XG59O1xuXG5wcC5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIGlmICh0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmNvbG9uKSkge1xuICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMucGFyZW5MKSB7XG4gICAgaWYgKGlzUGF0dGVybikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yKTtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJiAodGhpcy50eXBlICE9IF90b2tlbnR5cGUudHlwZXMuY29tbWEgJiYgdGhpcy50eXBlICE9IF90b2tlbnR5cGUudHlwZXMuYnJhY2VSKSkge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIikgdGhpcy5yYWlzZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpO2Vsc2UgdGhpcy5yYWlzZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgaWYgKHRoaXMua2V5d29yZHMudGVzdChwcm9wLmtleS5uYW1lKSB8fCAodGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kIDogdGhpcy5yZXNlcnZlZFdvcmRzKS50ZXN0KHByb3Aua2V5Lm5hbWUpKSB0aGlzLnJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIkJpbmRpbmcgXCIgKyBwcm9wLmtleS5uYW1lKTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24pIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxucHAucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAocHJvcCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBpZiAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuYnJhY2tldFIpO1xuICAgICAgcmV0dXJuIHByb3Aua2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRydWUpO1xufTtcblxuLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG5wcC5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlLmlkID0gbnVsbDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSBmYWxzZTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgfVxufTtcblxuLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxucHAucGFyc2VNZXRob2QgPSBmdW5jdGlvbiAoaXNHZW5lcmF0b3IpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChfdG9rZW50eXBlLnR5cGVzLnBhcmVuUiwgZmFsc2UsIGZhbHNlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbn07XG5cbi8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG5wcC5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJhbXMpIHtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKTtcbn07XG5cbi8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbnBwLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24gKG5vZGUsIGlzQXJyb3dGdW5jdGlvbikge1xuICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gX3Rva2VudHlwZS50eXBlcy5icmFjZUw7XG5cbiAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICB2YXIgb2xkSW5GdW5jID0gdGhpcy5pbkZ1bmN0aW9uLFxuICAgICAgICBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3IsXG4gICAgICAgIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHRoaXMuaW5GdW5jdGlvbiA9IHRydWU7dGhpcy5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yO3RoaXMubGFiZWxzID0gW107XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKHRydWUpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuaW5GdW5jdGlvbiA9IG9sZEluRnVuYzt0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47dGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cblxuICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gIC8vIG9yIGBhcmd1bWVudHNgLlxuICBpZiAodGhpcy5zdHJpY3QgfHwgIWlzRXhwcmVzc2lvbiAmJiBub2RlLmJvZHkuYm9keS5sZW5ndGggJiYgdGhpcy5pc1VzZVN0cmljdChub2RlLmJvZHkuYm9keVswXSkpIHtcbiAgICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gICAgdGhpcy5zdHJpY3QgPSB0cnVlO1xuICAgIGlmIChub2RlLmlkKSB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCB0cnVlKTtcbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUpO1xuICAgIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICB9IGVsc2UgaWYgKGlzQXJyb3dGdW5jdGlvbikge1xuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSk7XG4gIH1cbn07XG5cbi8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4vLyBvciBcImFyZ3VtZW50c1wiIGFuZCBkdXBsaWNhdGUgcGFyYW1ldGVycy5cblxucHAuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgbmFtZUhhc2ggPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUucGFyYW1zW2ldLCB0cnVlLCBuYW1lSGFzaCk7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4vLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4vLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG5wcC5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24gKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIGVsdHMgPSBbXSxcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IGNsb3NlICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLmxhc3RUb2tTdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSBicmVhaztcbiAgICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuICAgIHZhciBlbHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmNvbW1hKSBlbHQgPSBudWxsO2Vsc2UgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5lbGxpcHNpcykgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtlbHNlIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgZWx0cy5wdXNoKGVsdCk7XG4gIH1cbiAgcmV0dXJuIGVsdHM7XG59O1xuXG4vLyBQYXJzZSB0aGUgbmV4dCB0b2tlbiBhcyBhbiBpZGVudGlmaWVyLiBJZiBgbGliZXJhbGAgaXMgdHJ1ZSAodXNlZFxuLy8gd2hlbiBwYXJzaW5nIHByb3BlcnRpZXMpLCBpdCB3aWxsIGFsc28gY29udmVydCBrZXl3b3JkcyBpbnRvXG4vLyBpZGVudGlmaWVycy5cblxucHAucGFyc2VJZGVudCA9IGZ1bmN0aW9uIChsaWJlcmFsKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKGxpYmVyYWwgJiYgdGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gXCJuZXZlclwiKSBsaWJlcmFsID0gZmFsc2U7XG4gIGlmICh0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMubmFtZSkge1xuICAgIGlmICghbGliZXJhbCAmJiAodGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHMpLnRlc3QodGhpcy52YWx1ZSkgJiYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2IHx8IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLmluZGV4T2YoXCJcXFxcXCIpID09IC0xKSkgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlRoZSBrZXl3b3JkICdcIiArIHRoaXMudmFsdWUgKyBcIicgaXMgcmVzZXJ2ZWRcIik7XG4gICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgfSBlbHNlIGlmIChsaWJlcmFsICYmIHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xufTtcblxuLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxucHAucGFyc2VZaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PSBfdG9rZW50eXBlLnR5cGVzLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCB0aGlzLnR5cGUgIT0gX3Rva2VudHlwZS50eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikge1xuICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5zdGFyKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbn07XG5cbi8vIFBhcnNlcyBhcnJheSBhbmQgZ2VuZXJhdG9yIGNvbXByZWhlbnNpb25zLlxuXG5wcC5wYXJzZUNvbXByZWhlbnNpb24gPSBmdW5jdGlvbiAobm9kZSwgaXNHZW5lcmF0b3IpIHtcbiAgbm9kZS5ibG9ja3MgPSBbXTtcbiAgd2hpbGUgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fZm9yKSB7XG4gICAgdmFyIGJsb2NrID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLnBhcmVuTCk7XG4gICAgYmxvY2subGVmdCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGJsb2NrLmxlZnQsIHRydWUpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcIm9mXCIpO1xuICAgIGJsb2NrLnJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLnBhcmVuUik7XG4gICAgbm9kZS5ibG9ja3MucHVzaCh0aGlzLmZpbmlzaE5vZGUoYmxvY2ssIFwiQ29tcHJlaGVuc2lvbkJsb2NrXCIpKTtcbiAgfVxuICBub2RlLmZpbHRlciA9IHRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuX2lmKSA/IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKSA6IG51bGw7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KGlzR2VuZXJhdG9yID8gX3Rva2VudHlwZS50eXBlcy5wYXJlblIgOiBfdG9rZW50eXBlLnR5cGVzLmJyYWNrZXRSKTtcbiAgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbXByZWhlbnNpb25FeHByZXNzaW9uXCIpO1xufTtcblxufSx7XCIuL3N0YXRlXCI6MTAsXCIuL3Rva2VudHlwZVwiOjE0fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGlzIGlzIGEgdHJpY2sgdGFrZW4gZnJvbSBFc3ByaW1hLiBJdCB0dXJucyBvdXQgdGhhdCwgb25cbi8vIG5vbi1DaHJvbWUgYnJvd3NlcnMsIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmcgaXMgaW4gYSBzZXQsIGFcbi8vIHByZWRpY2F0ZSBjb250YWluaW5nIGEgYmlnIHVnbHkgYHN3aXRjaGAgc3RhdGVtZW50IGlzIGZhc3RlciB0aGFuXG4vLyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYW5kIG9uIENocm9tZSB0aGUgdHdvIGFyZSBhYm91dCBvbiBwYXIuXG4vLyBUaGlzIGZ1bmN0aW9uIHVzZXMgYGV2YWxgIChub24tbGV4aWNhbCkgdG8gcHJvZHVjZSBzdWNoIGFcbi8vIHByZWRpY2F0ZSBmcm9tIGEgc3BhY2Utc2VwYXJhdGVkIHN0cmluZyBvZiB3b3Jkcy5cbi8vXG4vLyBJdCBzdGFydHMgYnkgc29ydGluZyB0aGUgd29yZHMgYnkgbGVuZ3RoLlxuXG4vLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbmV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGlzSWRlbnRpZmllckNoYXI7XG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgNjogXCJlbnVtXCIsXG4gIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxufTtcblxuZXhwb3J0cy5yZXNlcnZlZFdvcmRzID0gcmVzZXJ2ZWRXb3Jkcztcbi8vIEFuZCB0aGUga2V5d29yZHNcblxudmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxudmFyIGtleXdvcmRzID0ge1xuICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBsZXQgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHlpZWxkIHN1cGVyXCJcbn07XG5cbmV4cG9ydHMua2V5d29yZHMgPSBrZXl3b3Jkcztcbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuLy8gR2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCLCqsK1wrrDgC3DlsOYLcO2w7gty4HLhi3LkcugLcuky6zLrs2wLc20zbbNt826Lc29zb/Ohs6ILc6KzozOji3Ooc6jLc+1z7ct0oHSii3Ur9SxLdWW1ZnVoS3Wh9eQLdeq17At17LYoC3Zitmu2a/ZsS3bk9uV26Xbptuu26/bui3bvNu/3JDcki3cr92NLd6l3rHfii3fqt+037XfuuCggC3goJXgoJrgoKTgoKjgoYAt4KGY4KKgLeCisuCkhC3gpLngpL3gpZDgpZgt4KWh4KWxLeCmgOCmhS3gpozgpo/gppDgppMt4Kao4KaqLeCmsOCmsuCmti3gprngpr3gp47gp5zgp53gp58t4Keh4Kew4Kex4KiFLeCoiuCoj+CokOCoky3gqKjgqKot4Kiw4Kiy4Kiz4Ki14Ki24Ki44Ki54KmZLeCpnOCpnuCpsi3gqbTgqoUt4KqN4KqPLeCqkeCqky3gqqjgqqot4Kqw4Kqy4Kqz4Kq1LeCqueCqveCrkOCroOCroeCshS3grIzgrI/grJDgrJMt4Kyo4KyqLeCssOCssuCss+CstS3grLngrL3grZzgrZ3grZ8t4K2h4K2x4K6D4K6FLeCuiuCuji3grpDgrpIt4K6V4K6Z4K6a4K6c4K6e4K6f4K6j4K6k4K6oLeCuquCuri3grrngr5DgsIUt4LCM4LCOLeCwkOCwki3gsKjgsKot4LC54LC94LGY4LGZ4LGg4LGh4LKFLeCyjOCyji3gspDgspIt4LKo4LKqLeCys+CytS3gsrngsr3gs57gs6Dgs6Hgs7Hgs7LgtIUt4LSM4LSOLeC0kOC0ki3gtLrgtL3gtY7gtaDgtaHgtbot4LW/4LaFLeC2luC2mi3gtrHgtrMt4La74La94LeALeC3huC4gS3guLDguLLguLPguYAt4LmG4LqB4LqC4LqE4LqH4LqI4LqK4LqN4LqULeC6l+C6mS3gup/guqEt4Lqj4Lql4Lqn4Lqq4Lqr4LqtLeC6sOC6suC6s+C6veC7gC3gu4Tgu4bgu5wt4Luf4LyA4L2ALeC9h+C9iS3gvazgvogt4L6M4YCALeGAquGAv+GBkC3hgZXhgZot4YGd4YGh4YGl4YGm4YGuLeGBsOGBtS3hgoHhgo7hgqAt4YOF4YOH4YON4YOQLeGDuuGDvC3hiYjhiYot4YmN4YmQLeGJluGJmOGJmi3hiZ3hiaAt4YqI4YqKLeGKjeGKkC3hirDhirIt4Yq14Yq4LeGKvuGLgOGLgi3hi4Xhi4gt4YuW4YuYLeGMkOGMki3hjJXhjJgt4Y2a4Y6ALeGOj+GOoC3hj7ThkIEt4Zms4ZmvLeGZv+GagS3hmprhmqAt4Zuq4ZuuLeGbuOGcgC3hnIzhnI4t4ZyR4ZygLeGcseGdgC3hnZHhnaAt4Z2s4Z2uLeGdsOGegC3hnrPhn5fhn5zhoKAt4aG34aKALeGiqOGiquGisC3ho7XhpIAt4aSe4aWQLeGlreGlsC3hpbThpoAt4aar4aeBLeGnh+GogC3hqJbhqKAt4amU4aqn4ayFLeGss+GthS3hrYvhroMt4a6g4a6u4a6v4a66LeGvpeGwgC3hsKPhsY0t4bGP4bGaLeGxveGzqS3hs6zhs64t4bOx4bO14bO24bSALeG2v+G4gC3hvJXhvJgt4byd4bygLeG9heG9iC3hvY3hvZAt4b2X4b2Z4b2b4b2d4b2fLeG9veG+gC3hvrThvrYt4b684b6+4b+CLeG/hOG/hi3hv4zhv5At4b+T4b+WLeG/m+G/oC3hv6zhv7It4b+04b+2LeG/vOKBseKBv+KCkC3igpzihILihIfihIot4oST4oSV4oSYLeKEneKEpOKEpuKEqOKEqi3ihLnihLwt4oS/4oWFLeKFieKFjuKFoC3ihojisIAt4rCu4rCwLeKxnuKxoC3is6Tis6st4rOu4rOy4rOz4rSALeK0peK0p+K0reK0sC3itafita/itoAt4raW4ragLeK2puK2qC3itq7itrAt4ra24ra4LeK2vuK3gC3it4bit4gt4reO4reQLeK3luK3mC3it57jgIUt44CH44ChLeOAqeOAsS3jgLXjgLgt44C844GBLeOCluOCmy3jgp/jgqEt44O644O8LeODv+OEhS3jhK3jhLEt44aO44agLeOGuuOHsC3jh7/jkIAt5La15LiALem/jOqAgC3qkozqk5At6pO96pSALeqYjOqYkC3qmJ/qmKrqmKvqmYAt6pmu6pm/LeqaneqaoC3qm6/qnJct6pyf6pyiLeqeiOqeiy3qno7qnpAt6p6t6p6w6p6x6p+3Leqggeqggy3qoIXqoIct6qCK6qCMLeqgouqhgC3qobPqooIt6qKz6qOyLeqjt+qju+qkii3qpKXqpLAt6qWG6qWgLeqlvOqmhC3qprLqp4/qp6At6qek6qemLeqnr+qnui3qp77qqIAt6qio6qmALeqpguqphC3qqYvqqaAt6qm26qm66qm+Leqqr+qqseqqteqqtuqquS3qqr3qq4Dqq4Lqq5st6qud6qugLeqrquqrsi3qq7TqrIEt6qyG6qyJLeqsjuqskS3qrJbqrKAt6qym6qyoLeqsruqssC3qrZrqrZwt6q2f6q2k6q2l6q+ALeqvouqwgC3tnqPtnrAt7Z+G7Z+LLe2fu++kgC3vqa3vqbAt76uZ76yALe+shu+sky3vrJfvrJ3vrJ8t76yo76yqLe+stu+suC3vrLzvrL7vrYDvrYHvrYPvrYTvrYYt766x76+TLe+0ve+1kC3vto/vtpIt77eH77ewLe+3u++5sC3vubTvubYt77u877yhLe+8uu+9gS3vvZrvvaYt776+77+CLe+/h++/ii3vv4/vv5It77+X77+aLe+/nFwiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCLigIzigI3Ct8yALc2vzofSgy3Sh9aRLda91r/XgdeC14TXhdeH2JAt2JrZiy3Zqdmw25Yt25zbny3bpNun26jbqi3brduwLdu53JHcsC3dit6mLd6w34At34nfqy3fs+Cgli3goJngoJst4KCj4KClLeCgp+CgqS3goK3goZkt4KGb4KOkLeCkg+Ckui3gpLzgpL4t4KWP4KWRLeCll+ClouClo+Clpi3gpa/gpoEt4KaD4Ka84Ka+LeCnhOCnh+CniOCniy3gp43gp5fgp6Lgp6Pgp6Yt4Kev4KiBLeCog+CovOCovi3gqYLgqYfgqYjgqYst4KmN4KmR4KmmLeCpseCpteCqgS3gqoPgqrzgqr4t4KuF4KuHLeCrieCriy3gq43gq6Lgq6Pgq6Yt4Kuv4KyBLeCsg+CsvOCsvi3grYTgrYfgrYjgrYst4K2N4K2W4K2X4K2i4K2j4K2mLeCtr+CuguCuvi3gr4Lgr4Yt4K+I4K+KLeCvjeCvl+Cvpi3gr6/gsIAt4LCD4LC+LeCxhOCxhi3gsYjgsYot4LGN4LGV4LGW4LGi4LGj4LGmLeCxr+CygS3gsoPgsrzgsr4t4LOE4LOGLeCziOCzii3gs43gs5Xgs5bgs6Lgs6Pgs6Yt4LOv4LSBLeC0g+C0vi3gtYTgtYYt4LWI4LWKLeC1jeC1l+C1ouC1o+C1pi3gta/gtoLgtoPgt4rgt48t4LeU4LeW4LeYLeC3n+C3pi3gt6/gt7Lgt7PguLHguLQt4Li64LmHLeC5juC5kC3guZngurHgurQt4Lq54Lq74Lq84LuILeC7jeC7kC3gu5ngvJjgvJngvKAt4Lyp4Ly14Ly34Ly54Ly+4Ly/4L2xLeC+hOC+huC+h+C+jS3gvpfgvpkt4L684L+G4YCrLeGAvuGBgC3hgYnhgZYt4YGZ4YGeLeGBoOGBoi3hgaThgact4YGt4YGxLeGBtOGCgi3hgo3hgo8t4YKd4Y2dLeGNn+GNqS3hjbHhnJIt4ZyU4ZyyLeGctOGdkuGdk+GdsuGds+GetC3hn5Phn53hn6At4Z+p4aCLLeGgjeGgkC3hoJnhoqnhpKAt4aSr4aSwLeGku+Glhi3hpY/hprAt4aeA4aeI4aeJ4aeQLeGnmuGoly3hqJvhqZUt4ame4amgLeGpvOGpvy3hqonhqpAt4aqZ4aqwLeGqveGsgC3hrIThrLQt4a2E4a2QLeGtmeGtqy3hrbPhroAt4a6C4a6hLeGureGusC3hrrnhr6Yt4a+z4bCkLeGwt+GxgC3hsYnhsZAt4bGZ4bOQLeGzkuGzlC3hs6jhs63hs7It4bO04bO44bO54beALeG3teG3vC3ht7/igL/igYDigZTig5At4oOc4oOh4oOlLeKDsOKzry3is7Hitb/it6At4re/44CqLeOAr+OCmeOCmuqYoC3qmKnqma/qmbQt6pm96pqf6puw6pux6qCC6qCG6qCL6qCjLeqgp+qigOqigeqitC3qo4Tqo5At6qOZ6qOgLeqjseqkgC3qpInqpKYt6qSt6qWHLeqlk+qmgC3qpoPqprMt6qeA6qeQLeqnmeqnpeqnsC3qp7nqqKkt6qi26qmD6qmM6qmN6qmQLeqpmeqpuy3qqb3qqrDqqrIt6qq06qq36qq46qq+6qq/6quB6qurLeqrr+qrteqrtuqvoy3qr6rqr6zqr63qr7At6q+576ye77iALe+4j++4oC3vuK3vuLPvuLTvuY0t77mP77yQLe+8me+8v1wiO1xuXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG5ub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG4vLyBUaGVzZSBhcmUgYSBydW4tbGVuZ3RoIGFuZCBvZmZzZXQgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbi8vID4weGZmZmYgY29kZSBwb2ludHMgdGhhdCBhcmUgYSB2YWxpZCBwYXJ0IG9mIGlkZW50aWZpZXJzLiBUaGVcbi8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbi8vIG9mZnNldCB0byB0aGUgbmV4dCByYW5nZSwgYW5kIHRoZW4gYSBzaXplIG9mIHRoZSByYW5nZS4gVGhleSB3ZXJlXG4vLyBnZW5lcmF0ZWQgYnkgdG9vbHMvZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc1xudmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNywgMjYsIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCA5OSwgMzksIDksIDUxLCAxNTcsIDMxMCwgMTAsIDIxLCAxMSwgNywgMTUzLCA1LCAzLCAwLCAyLCA0MywgMiwgMSwgNCwgMCwgMywgMjIsIDExLCAyMiwgMTAsIDMwLCA5OCwgMjEsIDExLCAyNSwgNzEsIDU1LCA3LCAxLCA2NSwgMCwgMTYsIDMsIDIsIDIsIDIsIDI2LCA0NSwgMjgsIDQsIDI4LCAzNiwgNywgMiwgMjcsIDI4LCA1MywgMTEsIDIxLCAxMSwgMTgsIDE0LCAxNywgMTExLCA3MiwgOTU1LCA1MiwgNzYsIDQ0LCAzMywgMjQsIDI3LCAzNSwgNDIsIDM0LCA0LCAwLCAxMywgNDcsIDE1LCAzLCAyMiwgMCwgMzgsIDE3LCAyLCAyNCwgMTMzLCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAzMiwgNCwgMjg3LCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDgyLCA0NywgMjEsIDAsIDYwLCA0MiwgNTAyLCA2MywgMzIsIDAsIDQ0OSwgNTYsIDEyODgsIDkyMCwgMTA0LCAxMTAsIDI5NjIsIDEwNzAsIDEzMjY2LCA1NjgsIDgsIDMwLCAxMTQsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA4ODEsIDY4LCAxMiwgMCwgNjcsIDEyLCAxNjQ4MSwgMSwgMzA3MSwgMTA2LCA2LCAxMiwgNCwgOCwgOCwgOSwgNTk5MSwgODQsIDIsIDcwLCAyLCAxLCAzLCAwLCAzLCAxLCAzLCAzLCAyLCAxMSwgMiwgMCwgMiwgNiwgMiwgNjQsIDIsIDMsIDMsIDcsIDIsIDYsIDIsIDI3LCAyLCAzLCAyLCA0LCAyLCAwLCA0LCA2LCAyLCAzMzksIDMsIDI0LCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCA3LCA0MTQ5LCAxOTYsIDEzNDAsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzEwLCA0MiwgNDE0OCwgMTIsIDIyMSwgMTYzNTUsIDU0MV07XG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgMTMwNiwgMiwgNTQsIDE0LCAzMiwgOSwgMTYsIDMsIDQ2LCAxMCwgNTQsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNTIsIDAsIDEzLCAyLCA0OSwgMTMsIDE2LCA5LCA4MywgMTEsIDE2OCwgMTEsIDYsIDksIDgsIDIsIDU3LCAwLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDMxNiwgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDExMiwgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDUzNSwgOSwgMjA4NTUsIDksIDEzNSwgNCwgNjAsIDYsIDI2LCA5LCAxMDE2LCA0NSwgMTcsIDMsIDE5NzIzLCAxLCA1MzE5LCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNDMwNSwgNiwgNzkyNjE4LCAyMzldO1xuXG4vLyBUaGlzIGhhcyBhIGNvbXBsZXhpdHkgbGluZWFyIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29kZS4gVGhlXG4vLyBhc3N1bXB0aW9uIGlzIHRoYXQgbG9va2luZyB1cCBhc3RyYWwgaWRlbnRpZmllciBjaGFyYWN0ZXJzIGlzXG4vLyByYXJlLlxuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgdmFyIHBvcyA9IDB4MTAwMDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcG9zICs9IHNldFtpXTtcbiAgICBpZiAocG9zID4gY29kZSkgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIGFzdHJhbCkge1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKTtcbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKTtcbn1cblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UsIEluZ3ZhciBTdGVwYW55YW4sIGFuZFxuLy8gdmFyaW91cyBjb250cmlidXRvcnMgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vdGVybmpzL2Fjb3JuLmdpdFxuLy9cbi8vIFBsZWFzZSB1c2UgdGhlIFtnaXRodWIgYnVnIHRyYWNrZXJdW2doYnRdIHRvIHJlcG9ydCBpc3N1ZXMuXG4vL1xuLy8gW2doYnRdOiBodHRwczovL2dpdGh1Yi5jb20vdGVybmpzL2Fjb3JuL2lzc3Vlc1xuLy9cbi8vIFRoaXMgZmlsZSBkZWZpbmVzIHRoZSBtYWluIHBhcnNlciBpbnRlcmZhY2UuIFRoZSBsaWJyYXJ5IGFsc28gY29tZXNcbi8vIHdpdGggYSBbZXJyb3ItdG9sZXJhbnQgcGFyc2VyXVtkYW1taXRdIGFuZCBhblxuLy8gW2Fic3RyYWN0IHN5bnRheCB0cmVlIHdhbGtlcl1bd2Fsa10sIGRlZmluZWQgaW4gb3RoZXIgZmlsZXMuXG4vL1xuLy8gW2RhbW1pdF06IGFjb3JuX2xvb3NlLmpzXG4vLyBbd2Fsa106IHV0aWwvd2Fsay5qc1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucGFyc2VFeHByZXNzaW9uQXQgPSBwYXJzZUV4cHJlc3Npb25BdDtcbmV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuXG52YXIgX3N0YXRlID0gX2RlcmVxXyhcIi4vc3RhdGVcIik7XG5cbl9kZXJlcV8oXCIuL3BhcnNldXRpbFwiKTtcblxuX2RlcmVxXyhcIi4vc3RhdGVtZW50XCIpO1xuXG5fZGVyZXFfKFwiLi9sdmFsXCIpO1xuXG5fZGVyZXFfKFwiLi9leHByZXNzaW9uXCIpO1xuXG5fZGVyZXFfKFwiLi9sb2NhdGlvblwiKTtcblxuZXhwb3J0cy5QYXJzZXIgPSBfc3RhdGUuUGFyc2VyO1xuZXhwb3J0cy5wbHVnaW5zID0gX3N0YXRlLnBsdWdpbnM7XG5cbnZhciBfb3B0aW9ucyA9IF9kZXJlcV8oXCIuL29wdGlvbnNcIik7XG5cbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfb3B0aW9ucy5kZWZhdWx0T3B0aW9ucztcblxudmFyIF9sb2N1dGlsID0gX2RlcmVxXyhcIi4vbG9jdXRpbFwiKTtcblxuZXhwb3J0cy5Qb3NpdGlvbiA9IF9sb2N1dGlsLlBvc2l0aW9uO1xuZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IF9sb2N1dGlsLlNvdXJjZUxvY2F0aW9uO1xuZXhwb3J0cy5nZXRMaW5lSW5mbyA9IF9sb2N1dGlsLmdldExpbmVJbmZvO1xuXG52YXIgX25vZGUgPSBfZGVyZXFfKFwiLi9ub2RlXCIpO1xuXG5leHBvcnRzLk5vZGUgPSBfbm9kZS5Ob2RlO1xuXG52YXIgX3Rva2VudHlwZSA9IF9kZXJlcV8oXCIuL3Rva2VudHlwZVwiKTtcblxuZXhwb3J0cy5Ub2tlblR5cGUgPSBfdG9rZW50eXBlLlRva2VuVHlwZTtcbmV4cG9ydHMudG9rVHlwZXMgPSBfdG9rZW50eXBlLnR5cGVzO1xuXG52YXIgX3Rva2VuY29udGV4dCA9IF9kZXJlcV8oXCIuL3Rva2VuY29udGV4dFwiKTtcblxuZXhwb3J0cy5Ub2tDb250ZXh0ID0gX3Rva2VuY29udGV4dC5Ub2tDb250ZXh0O1xuZXhwb3J0cy50b2tDb250ZXh0cyA9IF90b2tlbmNvbnRleHQudHlwZXM7XG5cbnZhciBfaWRlbnRpZmllciA9IF9kZXJlcV8oXCIuL2lkZW50aWZpZXJcIik7XG5cbmV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IF9pZGVudGlmaWVyLmlzSWRlbnRpZmllckNoYXI7XG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyU3RhcnQ7XG5cbnZhciBfdG9rZW5pemUgPSBfZGVyZXFfKFwiLi90b2tlbml6ZVwiKTtcblxuZXhwb3J0cy5Ub2tlbiA9IF90b2tlbml6ZS5Ub2tlbjtcblxudmFyIF93aGl0ZXNwYWNlID0gX2RlcmVxXyhcIi4vd2hpdGVzcGFjZVwiKTtcblxuZXhwb3J0cy5pc05ld0xpbmUgPSBfd2hpdGVzcGFjZS5pc05ld0xpbmU7XG5leHBvcnRzLmxpbmVCcmVhayA9IF93aGl0ZXNwYWNlLmxpbmVCcmVhaztcbmV4cG9ydHMubGluZUJyZWFrRyA9IF93aGl0ZXNwYWNlLmxpbmVCcmVha0c7XG52YXIgdmVyc2lvbiA9IFwiMi42LjRcIjtcblxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbi8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4vLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4vLyBBUEldW2FwaV0uXG4vL1xuLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBfc3RhdGUuUGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgYSBnaXZlblxuLy8gb2Zmc2V0IGluIGEgc3RyaW5nLiBVc2VmdWwgZm9yIHBhcnNpbmcgbWl4ZWQtbGFuZ3VhZ2UgZm9ybWF0c1xuLy8gdGhhdCBlbWJlZCBKYXZhU2NyaXB0IGV4cHJlc3Npb25zLlxuXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gIHZhciBwID0gbmV3IF9zdGF0ZS5QYXJzZXIob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gIHAubmV4dFRva2VuKCk7XG4gIHJldHVybiBwLnBhcnNlRXhwcmVzc2lvbigpO1xufVxuXG4vLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgX3N0YXRlLlBhcnNlcihvcHRpb25zLCBpbnB1dCk7XG59XG5cbn0se1wiLi9leHByZXNzaW9uXCI6MSxcIi4vaWRlbnRpZmllclwiOjIsXCIuL2xvY2F0aW9uXCI6NCxcIi4vbG9jdXRpbFwiOjUsXCIuL2x2YWxcIjo2LFwiLi9ub2RlXCI6NyxcIi4vb3B0aW9uc1wiOjgsXCIuL3BhcnNldXRpbFwiOjksXCIuL3N0YXRlXCI6MTAsXCIuL3N0YXRlbWVudFwiOjExLFwiLi90b2tlbmNvbnRleHRcIjoxMixcIi4vdG9rZW5pemVcIjoxMyxcIi4vdG9rZW50eXBlXCI6MTQsXCIuL3doaXRlc3BhY2VcIjoxNn1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc3RhdGUgPSBfZGVyZXFfKFwiLi9zdGF0ZVwiKTtcblxudmFyIF9sb2N1dGlsID0gX2RlcmVxXyhcIi4vbG9jdXRpbFwiKTtcblxudmFyIHBwID0gX3N0YXRlLlBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcC5yYWlzZSA9IGZ1bmN0aW9uIChwb3MsIG1lc3NhZ2UpIHtcbiAgdmFyIGxvYyA9IF9sb2N1dGlsLmdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnBvcyA9IHBvcztlcnIubG9jID0gbG9jO2Vyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICB0aHJvdyBlcnI7XG59O1xuXG5wcC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IF9sb2N1dGlsLlBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydCk7XG4gIH1cbn07XG5cbn0se1wiLi9sb2N1dGlsXCI6NSxcIi4vc3RhdGVcIjoxMH1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmdldExpbmVJbmZvID0gZ2V0TGluZUluZm87XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfd2hpdGVzcGFjZSA9IF9kZXJlcV8oXCIuL3doaXRlc3BhY2VcIik7XG5cbi8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxudmFyIFBvc2l0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc2l0aW9uKTtcblxuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2w7XG4gIH1cblxuICBQb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKTtcbiAgfTtcblxuICByZXR1cm4gUG9zaXRpb247XG59KSgpO1xuXG5leHBvcnRzLlBvc2l0aW9uID0gUG9zaXRpb247XG5cbnZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdXJjZUxvY2F0aW9uKTtcblxuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xuICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTtcbn1cblxuLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3Vcbi8vIHdhbnQgdG8gZmluZCB0aGUgbGluZS9jb2x1bW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4vLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4vLyBpbnRvLlxuXG47XG5cbmV4cG9ydHMuU291cmNlTG9jYXRpb24gPSBTb3VyY2VMb2NhdGlvbjtcblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgX3doaXRlc3BhY2UubGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gX3doaXRlc3BhY2UubGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cik7XG4gICAgfVxuICB9XG59XG5cbn0se1wiLi93aGl0ZXNwYWNlXCI6MTZ9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3Rva2VudHlwZSA9IF9kZXJlcV8oXCIuL3Rva2VudHlwZVwiKTtcblxudmFyIF9zdGF0ZSA9IF9kZXJlcV8oXCIuL3N0YXRlXCIpO1xuXG52YXIgX3V0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG52YXIgcHAgPSBfc3RhdGUuUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24gKG5vZGUsIGlzQmluZGluZykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIGlmIChwcm9wLmtpbmQgIT09IFwiaW5pdFwiKSB0aGlzLnJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTtcbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSBcIj1cIikge1xuICAgICAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoIHRvIEFzc2lnbm1lbnRQYXR0ZXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICBpZiAobm9kZS5yaWdodC50eXBlID09PSBcIllpZWxkRXhwcmVzc2lvblwiKSB0aGlzLnJhaXNlKG5vZGUucmlnaHQuc3RhcnQsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICghaXNCaW5kaW5nKSBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufTtcblxuLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG5wcC50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24gKGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC50eXBlID09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgLS1lbmQ7XG4gICAgfSBlbHNlIGlmIChsYXN0ICYmIGxhc3QudHlwZSA9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgbGFzdC50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdmFyIGFyZyA9IGxhc3QuYXJndW1lbnQ7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShhcmcsIGlzQmluZGluZyk7XG4gICAgICBpZiAoYXJnLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGFyZy50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBhcmcudHlwZSAhPT0gXCJBcnJheVBhdHRlcm5cIikgdGhpcy51bmV4cGVjdGVkKGFyZy5zdGFydCk7XG4gICAgICAtLWVuZDtcbiAgICB9XG5cbiAgICBpZiAoaXNCaW5kaW5nICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgIGlmIChlbHQpIHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTtcbiAgfVxuICByZXR1cm4gZXhwckxpc3Q7XG59O1xuXG4vLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbnBwLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24gKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIik7XG59O1xuXG5wcC5wYXJzZVJlc3QgPSBmdW5jdGlvbiAoYWxsb3dOb25JZGVudCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgaWYgKGFsbG93Tm9uSWRlbnQpIG5vZGUuYXJndW1lbnQgPSB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogdGhpcy51bmV4cGVjdGVkKCk7ZWxzZSBub2RlLmFyZ3VtZW50ID0gdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLm5hbWUgfHwgdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmJyYWNrZXRMID8gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIik7XG59O1xuXG4vLyBQYXJzZXMgbHZhbHVlIChhc3NpZ25hYmxlKSBhdG9tLlxuXG5wcC5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpO1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5uYW1lOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpO1xuXG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KF90b2tlbnR5cGUudHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKTtcblxuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uIChjbG9zZSwgYWxsb3dFbXB0eSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd05vbklkZW50KSB7XG4gIHZhciBlbHRzID0gW10sXG4gICAgICBmaXJzdCA9IHRydWU7XG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlO2Vsc2UgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5jb21tYSk7XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmNvbW1hKSB7XG4gICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5lbGxpcHNpcykge1xuICAgICAgdmFyIHJlc3QgPSB0aGlzLnBhcnNlUmVzdChhbGxvd05vbklkZW50KTtcbiAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsdHM7XG59O1xuXG5wcC5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICByZXR1cm4gcGFyYW07XG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcC5wYXJzZU1heWJlRGVmYXVsdCA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmVxKSkgcmV0dXJuIGxlZnQ7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKTtcbn07XG5cbi8vIFZlcmlmeSB0aGF0IGEgbm9kZSBpcyBhbiBsdmFsIOKAlCBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYXNzaWduZWRcbi8vIHRvLlxuXG5wcC5jaGVja0xWYWwgPSBmdW5jdGlvbiAoZXhwciwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMpIHtcbiAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKSB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmRpbmcgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgIGlmIChjaGVja0NsYXNoZXMpIHtcbiAgICAgICAgaWYgKF91dGlsLmhhcyhjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpIHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpO1xuICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoaXNCaW5kaW5nKSB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmRpbmcgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgbWVtYmVyIGV4cHJlc3Npb25cIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByLnByb3BlcnRpZXNbaV0udmFsdWUsIGlzQmluZGluZywgY2hlY2tDbGFzaGVzKTtcbiAgICAgIH1icmVhaztcblxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbSA9IGV4cHIuZWxlbWVudHNbaV07XG4gICAgICAgIGlmIChlbGVtKSB0aGlzLmNoZWNrTFZhbChlbGVtLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5sZWZ0LCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5hcmd1bWVudCwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoaXNCaW5kaW5nID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgfVxufTtcblxufSx7XCIuL3N0YXRlXCI6MTAsXCIuL3Rva2VudHlwZVwiOjE0LFwiLi91dGlsXCI6MTV9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3N0YXRlID0gX2RlcmVxXyhcIi4vc3RhdGVcIik7XG5cbnZhciBfbG9jdXRpbCA9IF9kZXJlcV8oXCIuL2xvY3V0aWxcIik7XG5cbnZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcblxuICB0aGlzLnR5cGUgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gcG9zO1xuICB0aGlzLmVuZCA9IDA7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpIHRoaXMubG9jID0gbmV3IF9sb2N1dGlsLlNvdXJjZUxvY2F0aW9uKHBhcnNlciwgbG9jKTtcbiAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpIHRoaXMuc291cmNlRmlsZSA9IHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpIHRoaXMucmFuZ2UgPSBbcG9zLCAwXTtcbn1cblxuLy8gU3RhcnQgYW4gQVNUIG5vZGUsIGF0dGFjaGluZyBhIHN0YXJ0IG9mZnNldC5cblxuO1xuXG5leHBvcnRzLk5vZGUgPSBOb2RlO1xudmFyIHBwID0gX3N0YXRlLlBhcnNlci5wcm90b3R5cGU7XG5cbnBwLnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xufTtcblxucHAuc3RhcnROb2RlQXQgPSBmdW5jdGlvbiAocG9zLCBsb2MpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKTtcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgbm9kZS5sb2MuZW5kID0gbG9jO1xuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgbm9kZS5yYW5nZVsxXSA9IHBvcztcbiAgcmV0dXJuIG5vZGU7XG59XG5cbnBwLmZpbmlzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpO1xufTtcblxuLy8gRmluaXNoIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cblxucHAuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24gKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYyk7XG59O1xuXG59LHtcIi4vbG9jdXRpbFwiOjUsXCIuL3N0YXRlXCI6MTB9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5nZXRPcHRpb25zID0gZ2V0T3B0aW9ucztcblxudmFyIF91dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxudmFyIF9sb2N1dGlsID0gX2RlcmVxXyhcIi4vbG9jdXRpbFwiKTtcblxuLy8gQSBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQgY2FuIGJlIGdpdmVuIHRvIGZ1cnRoZXIgY29uZmlndXJlXG4vLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdFxuICAvLyBiZSBlaXRoZXIgMywgb3IgNSwgb3IgNi4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnQgZm9yIHN0cmljdFxuICAvLyBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBzdXBwb3J0IGZvciBnZXR0ZXJzIGFuZFxuICAvLyBzZXR0ZXJzIGFuZCBvdGhlciBmZWF0dXJlcy5cbiAgZWNtYVZlcnNpb246IDUsXG4gIC8vIFNvdXJjZSB0eXBlIChcInNjcmlwdFwiIG9yIFwibW9kdWxlXCIpIGZvciBkaWZmZXJlbnQgc2VtYW50aWNzXG4gIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgLy8gdGggcG9zaXRpb24gb2YgdGhlIGNvbW1hIGFzIGFuIG9mZnNldCwgYW5kIGlmIGBsb2NhdGlvbnNgIGlzXG4gIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gIC8vIGlzIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuXG4gIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Db21tZW50OiBudWxsLFxuICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgLy8gYHRydWVgLlxuICAvL1xuICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgcmFuZ2VzOiBmYWxzZSxcbiAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgcHJvZ3JhbTogbnVsbCxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICBzb3VyY2VGaWxlOiBudWxsLFxuICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gIHByZXNlcnZlUGFyZW5zOiBmYWxzZSxcbiAgcGx1Z2luczoge31cbn07XG5cbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbi8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBfdXRpbC5oYXMob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07XG4gIH1pZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpIG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1O1xuXG4gIGlmIChfdXRpbC5pc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICB9XG4gIGlmIChfdXRpbC5pc0FycmF5KG9wdGlvbnMub25Db21tZW50KSkgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHB1c2hDb21tZW50KG9wdGlvbnMsIGFycmF5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gJ0Jsb2NrJyA6ICdMaW5lJyxcbiAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmRcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgY29tbWVudC5sb2MgPSBuZXcgX2xvY3V0aWwuU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKSBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gIH07XG59XG5cbn0se1wiLi9sb2N1dGlsXCI6NSxcIi4vdXRpbFwiOjE1fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF90b2tlbnR5cGUgPSBfZGVyZXFfKFwiLi90b2tlbnR5cGVcIik7XG5cbnZhciBfc3RhdGUgPSBfZGVyZXFfKFwiLi9zdGF0ZVwiKTtcblxudmFyIF93aGl0ZXNwYWNlID0gX2RlcmVxXyhcIi4vd2hpdGVzcGFjZVwiKTtcblxudmFyIHBwID0gX3N0YXRlLlBhcnNlci5wcm90b3R5cGU7XG5cbi8vICMjIFBhcnNlciB1dGlsaXRpZXNcblxuLy8gVGVzdCB3aGV0aGVyIGEgc3RhdGVtZW50IG5vZGUgaXMgdGhlIHN0cmluZyBsaXRlcmFsIGBcInVzZSBzdHJpY3RcImAuXG5cbnBwLmlzVXNlU3RyaWN0ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHN0bXQuZXhwcmVzc2lvbi5yYXcuc2xpY2UoMSwgLTEpID09PSBcInVzZSBzdHJpY3RcIjtcbn07XG5cbi8vIFByZWRpY2F0ZSB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuXG4vLyB0eXBlLCBhbmQgaWYgeWVzLCBjb25zdW1lcyBpdCBhcyBhIHNpZGUgZWZmZWN0LlxuXG5wcC5lYXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBUZXN0cyB3aGV0aGVyIHBhcnNlZCB0b2tlbiBpcyBhIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWU7XG59O1xuXG4vLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbnBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiB0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLm5hbWUpO1xufTtcblxuLy8gQXNzZXJ0cyB0aGF0IGZvbGxvd2luZyB0b2tlbiBpcyBnaXZlbiBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG5wcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuZW9mIHx8IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5icmFjZVIgfHwgX3doaXRlc3BhY2UubGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKTtcbn07XG5cbnBwLmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pIHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4vLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxucHAuc2VtaWNvbG9uID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxucHAuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24gKHRva1R5cGUpIHtcbiAgaWYgKHRoaXMudHlwZSA9PSB0b2tUeXBlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpIHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAuZXhwZWN0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG4vLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG5wcC51bmV4cGVjdGVkID0gZnVuY3Rpb24gKHBvcykge1xuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xufTtcblxucHAuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24gKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gIHZhciBwb3MgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgaWYgKCFhbmRUaHJvdykgcmV0dXJuICEhcG9zO1xuICBpZiAocG9zKSB0aGlzLnJhaXNlKHBvcywgXCJUcmFpbGluZyBjb21tYSBpcyBub3QgcGVybWl0dGVkIGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7XG59O1xuXG5wcC5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgdmFyIHBvcyA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gIGlmICghYW5kVGhyb3cpIHJldHVybiAhIXBvcztcbiAgaWYgKHBvcykgdGhpcy5yYWlzZShwb3MsIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7XG59O1xuXG59LHtcIi4vc3RhdGVcIjoxMCxcIi4vdG9rZW50eXBlXCI6MTQsXCIuL3doaXRlc3BhY2VcIjoxNn1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX2lkZW50aWZpZXIgPSBfZGVyZXFfKFwiLi9pZGVudGlmaWVyXCIpO1xuXG52YXIgX3Rva2VudHlwZSA9IF9kZXJlcV8oXCIuL3Rva2VudHlwZVwiKTtcblxudmFyIF93aGl0ZXNwYWNlID0gX2RlcmVxXyhcIi4vd2hpdGVzcGFjZVwiKTtcblxudmFyIF9vcHRpb25zID0gX2RlcmVxXyhcIi4vb3B0aW9uc1wiKTtcblxuLy8gUmVnaXN0ZXJlZCBwbHVnaW5zXG52YXIgcGx1Z2lucyA9IHt9O1xuXG5leHBvcnRzLnBsdWdpbnMgPSBwbHVnaW5zO1xuZnVuY3Rpb24ga2V5d29yZFJlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oXCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIik7XG59XG5cbnZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNlcik7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gX29wdGlvbnMuZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gICAgdGhpcy5rZXl3b3JkcyA9IGtleXdvcmRSZWdleHAoX2lkZW50aWZpZXIua2V5d29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IDVdKTtcbiAgICB2YXIgcmVzZXJ2ZWQgPSBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPyBcIlwiIDogX2lkZW50aWZpZXIucmVzZXJ2ZWRXb3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uXSArIChvcHRpb25zLnNvdXJjZVR5cGUgPT0gXCJtb2R1bGVcIiA/IFwiIGF3YWl0XCIgOiBcIlwiKTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHMgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkKTtcbiAgICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyBfaWRlbnRpZmllci5yZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgX2lkZW50aWZpZXIucmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAgIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAgIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gICAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG5cbiAgICAvLyBMb2FkIHBsdWdpbnNcbiAgICB0aGlzLmxvYWRQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG5cbiAgICAvLyBTZXQgdXAgdG9rZW4gc3RhdGVcblxuICAgIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICAgIGlmIChzdGFydFBvcykge1xuICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcykpO1xuICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQoX3doaXRlc3BhY2UubGluZUJyZWFrKS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgICB9XG5cbiAgICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAgIC8vIEl0cyB0eXBlXG4gICAgdGhpcy50eXBlID0gX3Rva2VudHlwZS50eXBlcy5lb2Y7XG4gICAgLy8gRm9yIHRva2VucyB0aGF0IGluY2x1ZGUgbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZWlyIHR5cGUsIHRoZSB2YWx1ZVxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gICAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpO1xuXG4gICAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAgIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAgIC8vIGdpdmVuIHBvc2l0aW9uLlxuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgaXQncyBhIG1vZHVsZSBjb2RlLlxuICAgIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcblxuICAgIC8vIFVzZWQgdG8gc2lnbmlmeSB0aGUgc3RhcnQgb2YgYSBwb3RlbnRpYWwgYXJyb3cgZnVuY3Rpb25cbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAgIC8vIEZsYWdzIHRvIHRyYWNrIHdoZXRoZXIgd2UgYXJlIGluIGEgZnVuY3Rpb24sIGEgZ2VuZXJhdG9yLlxuICAgIHRoaXMuaW5GdW5jdGlvbiA9IHRoaXMuaW5HZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcblxuICAgIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICAgIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gJyMhJykgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEIEtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHVudGlsIDMuMCBpbiBjYXNlIGEgcGx1Z2luIHVzZXMgdGhlbVxuXG4gIFBhcnNlci5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gaXNLZXl3b3JkKHdvcmQpIHtcbiAgICByZXR1cm4gdGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaXNSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkV29yZCh3b3JkKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzZXJ2ZWRXb3Jkcy50ZXN0KHdvcmQpO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIGYpIHtcbiAgICB0aGlzW25hbWVdID0gZih0aGlzW25hbWVdKTtcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmxvYWRQbHVnaW5zID0gZnVuY3Rpb24gbG9hZFBsdWdpbnMocGx1Z2luQ29uZmlncykge1xuICAgIGZvciAodmFyIF9uYW1lIGluIHBsdWdpbkNvbmZpZ3MpIHtcbiAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW19uYW1lXTtcbiAgICAgIGlmICghcGx1Z2luKSB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gJ1wiICsgX25hbWUgKyBcIicgbm90IGZvdW5kXCIpO1xuICAgICAgcGx1Z2luKHRoaXMsIHBsdWdpbkNvbmZpZ3NbX25hbWVdKTtcbiAgICB9XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSk7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0pKCk7XG5cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuXG59LHtcIi4vaWRlbnRpZmllclwiOjIsXCIuL29wdGlvbnNcIjo4LFwiLi90b2tlbnR5cGVcIjoxNCxcIi4vd2hpdGVzcGFjZVwiOjE2fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdG9rZW50eXBlID0gX2RlcmVxXyhcIi4vdG9rZW50eXBlXCIpO1xuXG52YXIgX3N0YXRlID0gX2RlcmVxXyhcIi4vc3RhdGVcIik7XG5cbnZhciBfd2hpdGVzcGFjZSA9IF9kZXJlcV8oXCIuL3doaXRlc3BhY2VcIik7XG5cbnZhciBwcCA9IF9zdGF0ZS5QYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuLy8gUGFyc2UgYSBwcm9ncmFtLiBJbml0aWFsaXplcyB0aGUgcGFyc2VyLCByZWFkcyBhbnkgbnVtYmVyIG9mXG4vLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuLy8gdG8gaXRzIGJvZHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBub2RlLlxuXG5wcC5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgaWYgKCFub2RlLmJvZHkpIG5vZGUuYm9keSA9IFtdO1xuICB3aGlsZSAodGhpcy50eXBlICE9PSBfdG9rZW50eXBlLnR5cGVzLmVvZikge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudCh0cnVlLCB0cnVlKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGlmICh0aGlzLmlzVXNlU3RyaWN0KHN0bXQpKSB0aGlzLnNldFN0cmljdCh0cnVlKTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKTtcbn07XG5cbnZhciBsb29wTGFiZWwgPSB7IGtpbmQ6IFwibG9vcFwiIH0sXG4gICAgc3dpdGNoTGFiZWwgPSB7IGtpbmQ6IFwic3dpdGNoXCIgfTtcblxuLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuLy9cbi8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuLy8gZG9lcyBub3QgaGVscC5cblxucHAucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoZGVjbGFyYXRpb24sIHRvcExldmVsKSB7XG4gIHZhciBzdGFydHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5fYnJlYWs6Y2FzZSBfdG9rZW50eXBlLnR5cGVzLl9jb250aW51ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZCk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl9kZWJ1Z2dlcjpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl9kbzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl9mb3I6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgaWYgKCFkZWNsYXJhdGlvbiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5fY2xhc3M6XG4gICAgICBpZiAoIWRlY2xhcmF0aW9uKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl9pZjpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl9yZXR1cm46XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuX3N3aXRjaDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5fdGhyb3c6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5fdHJ5OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl9sZXQ6Y2FzZSBfdG9rZW50eXBlLnR5cGVzLl9jb25zdDpcbiAgICAgIGlmICghZGVjbGFyYXRpb24pIHRoaXMudW5leHBlY3RlZCgpOyAvLyBOT1RFOiBmYWxscyB0aHJvdWdoIHRvIF92YXJcbiAgICBjYXNlIF90b2tlbnR5cGUudHlwZXMuX3ZhcjpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZSk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl93aGlsZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLl93aXRoOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgY2FzZSBfdG9rZW50eXBlLnR5cGVzLnNlbWk6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5fZXhwb3J0OlxuICAgIGNhc2UgX3Rva2VudHlwZS50eXBlcy5faW1wb3J0OlxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICAgIGlmICghdG9wTGV2ZWwpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7XG4gICAgICAgIGlmICghdGhpcy5pbk1vZHVsZSkgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydHR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuX2ltcG9ydCA/IHRoaXMucGFyc2VJbXBvcnQobm9kZSkgOiB0aGlzLnBhcnNlRXhwb3J0KG5vZGUpO1xuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoc3RhcnR0eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmNvbG9uKSkgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwcik7ZWxzZSByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcik7XG4gIH1cbn07XG5cbnBwLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBrZXl3b3JkKSB7XG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSBub2RlLmxhYmVsID0gbnVsbDtlbHNlIGlmICh0aGlzLnR5cGUgIT09IF90b2tlbnR5cGUudHlwZXMubmFtZSkgdGhpcy51bmV4cGVjdGVkKCk7ZWxzZSB7XG4gICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgLy8gY29udGludWUgdG8uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGFiID0gdGhpcy5sYWJlbHNbaV07XG4gICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSBicmVhaztcbiAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSA9PT0gdGhpcy5sYWJlbHMubGVuZ3RoKSB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKTtcbn07XG5cbnBwLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO1xufTtcblxucHAucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5fd2hpbGUpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5zZW1pKTtlbHNlIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xufTtcblxuLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuLy8gbG9vcCBpcyBub24tdHJpdmlhbC4gQmFzaWNhbGx5LCB3ZSBoYXZlIHRvIHBhcnNlIHRoZSBpbml0IGB2YXJgXG4vLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuLy8gd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBgaW5gIG9yIGBvZmAuIFdoZW4gdGhlcmUgaXMgbm8gaW5pdFxuLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbi8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG5wcC5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMucGFyZW5MKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5zZW1pKSByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fbGV0IHx8IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fY29uc3QpIHtcbiAgICB2YXIgX2luaXQgPSB0aGlzLnN0YXJ0Tm9kZSgpLFxuICAgICAgICB2YXJLaW5kID0gdGhpcy50eXBlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoX2luaXQsIHRydWUsIHZhcktpbmQpO1xuICAgIHRoaXMuZmluaXNoTm9kZShfaW5pdCwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgIGlmICgodGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl9pbiB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSAmJiBfaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmICEodmFyS2luZCAhPT0gX3Rva2VudHlwZS50eXBlcy5fdmFyICYmIF9pbml0LmRlY2xhcmF0aW9uc1swXS5pbml0KSkgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBfaW5pdCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgX2luaXQpO1xuICB9XG4gIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0geyBzaG9ydGhhbmRBc3NpZ246IDAsIHRyYWlsaW5nQ29tbWE6IDAgfTtcbiAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5faW4gfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkge1xuICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGluaXQpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG59O1xuXG5wcC5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgdHJ1ZSk7XG59O1xuXG5wcC5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbn07XG5cbnBwLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbikgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgLy8gb3B0aW9uYWwgYXJndW1lbnRzLCB3ZSBlYWdlcmx5IGxvb2sgZm9yIGEgc2VtaWNvbG9uIG9yIHRoZVxuICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gIGlmICh0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIG5vZGUuYXJndW1lbnQgPSBudWxsO2Vsc2Uge1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO3RoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcbn07XG5cbnBwLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNhc2VzID0gW107XG4gIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIGZvciAodmFyIGN1ciwgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT0gX3Rva2VudHlwZS50eXBlcy5icmFjZVI7KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuX2RlZmF1bHQpIHtcbiAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuX2Nhc2U7XG4gICAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzYXdEZWZhdWx0KSB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTtcbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuY29sb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSkpO1xuICAgIH1cbiAgfVxuICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpO1xufTtcblxucHAucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAoX3doaXRlc3BhY2UubGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93XCIpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpO1xufTtcblxuLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbnZhciBlbXB0eSA9IFtdO1xuXG5wcC5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gIGlmICh0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuX2NhdGNoKSB7XG4gICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5wYXJlbkwpO1xuICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgdHJ1ZSk7XG4gICAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5wYXJlblIpO1xuICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpO1xufTtcblxucHAucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwga2luZCkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xufTtcblxucHAucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG59O1xuXG5wcC5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodGhpcy5zdHJpY3QpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpO1xufTtcblxucHAucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG59O1xuXG5wcC5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgbWF5YmVOYW1lLCBleHByKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcy5sYWJlbHNbaV0ubmFtZSA9PT0gbWF5YmVOYW1lKSB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gIH12YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYWJlbCA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbC5zdGF0ZW1lbnRTdGFydCA9PSBub2RlLnN0YXJ0KSB7XG4gICAgICBsYWJlbC5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICBsYWJlbC5raW5kID0ga2luZDtcbiAgICB9IGVsc2UgYnJlYWs7XG4gIH1cbiAgdGhpcy5sYWJlbHMucHVzaCh7IG5hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnQgfSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICBub2RlLmxhYmVsID0gZXhwcjtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIik7XG59O1xuXG5wcC5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgZXhwcikge1xuICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbn07XG5cbi8vIFBhcnNlIGEgc2VtaWNvbG9uLWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHMsIGhhbmRsaW5nIGBcInVzZVxuLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3Jcbi8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbnBwLnBhcnNlQmxvY2sgPSBmdW5jdGlvbiAoYWxsb3dTdHJpY3QpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLFxuICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgb2xkU3RyaWN0ID0gdW5kZWZpbmVkO1xuICBub2RlLmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudCh0cnVlKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICBpZiAoZmlyc3QgJiYgYWxsb3dTdHJpY3QgJiYgdGhpcy5pc1VzZVN0cmljdChzdG10KSkge1xuICAgICAgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gICAgICB0aGlzLnNldFN0cmljdCh0aGlzLnN0cmljdCA9IHRydWUpO1xuICAgIH1cbiAgICBmaXJzdCA9IGZhbHNlO1xuICB9XG4gIGlmIChvbGRTdHJpY3QgPT09IGZhbHNlKSB0aGlzLnNldFN0cmljdChmYWxzZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbn07XG5cbi8vIFBhcnNlIGEgcmVndWxhciBgZm9yYCBsb29wLiBUaGUgZGlzYW1iaWd1YXRpb24gY29kZSBpblxuLy8gYHBhcnNlU3RhdGVtZW50YCB3aWxsIGFscmVhZHkgaGF2ZSBwYXJzZWQgdGhlIGluaXQgc3RhdGVtZW50IG9yXG4vLyBleHByZXNzaW9uLlxuXG5wcC5wYXJzZUZvciA9IGZ1bmN0aW9uIChub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuc2VtaSk7XG4gIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKTtcbn07XG5cbi8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4vLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbnBwLnBhcnNlRm9ySW4gPSBmdW5jdGlvbiAobm9kZSwgaW5pdCkge1xuICB2YXIgdHlwZSA9IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5faW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCI7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmxlZnQgPSBpbml0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5wYXJlblIpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG5wcC5wYXJzZVZhciA9IGZ1bmN0aW9uIChub2RlLCBpc0Zvciwga2luZCkge1xuICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICBub2RlLmtpbmQgPSBraW5kLmtleXdvcmQ7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5wYXJzZVZhcklkKGRlY2wpO1xuICAgIGlmICh0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmVxKSkge1xuICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IF90b2tlbnR5cGUudHlwZXMuX2NvbnN0ICYmICEodGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl9pbiB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmNvbW1hKSkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5wcC5wYXJzZVZhcklkID0gZnVuY3Rpb24gKGRlY2wpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCB0cnVlKTtcbn07XG5cbi8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcC5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5KSB7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5zdGFyKTtcbiAgaWYgKGlzU3RhdGVtZW50IHx8IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5uYW1lKSBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5KTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG59O1xuXG5wcC5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChfdG9rZW50eXBlLnR5cGVzLnBhcmVuUiwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbn07XG5cbi8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcC5wYXJzZUNsYXNzID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5zZW1pKSkgY29udGludWU7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5zdGFyKTtcbiAgICB2YXIgaXNNYXliZVN0YXRpYyA9IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IFwic3RhdGljXCI7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgIG1ldGhvZFtcInN0YXRpY1wiXSA9IGlzTWF5YmVTdGF0aWMgJiYgdGhpcy50eXBlICE9PSBfdG9rZW50eXBlLnR5cGVzLnBhcmVuTDtcbiAgICBpZiAobWV0aG9kW1wic3RhdGljXCJdKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLnN0YXIpO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgIH1cbiAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgdmFyIGlzR2V0U2V0ID0gZmFsc2U7XG4gICAgaWYgKCFtZXRob2QuY29tcHV0ZWQpIHtcbiAgICAgIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuXG4gICAgICBpZiAoIWlzR2VuZXJhdG9yICYmIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLnR5cGUgIT09IF90b2tlbnR5cGUudHlwZXMucGFyZW5MICYmIChrZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBrZXkubmFtZSA9PT0gXCJzZXRcIikpIHtcbiAgICAgICAgaXNHZXRTZXQgPSB0cnVlO1xuICAgICAgICBtZXRob2Qua2luZCA9IGtleS5uYW1lO1xuICAgICAgICBrZXkgPSB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZFtcInN0YXRpY1wiXSAmJiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHwga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTtcbiAgICAgICAgaWYgKGlzR2V0U2V0KSB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7XG4gICAgICAgIGlmIChpc0dlbmVyYXRvcikgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIik7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IpO1xuICAgIGlmIChpc0dldFNldCkge1xuICAgICAgdmFyIHBhcmFtQ291bnQgPSBtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgICAgaWYgKG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICAgIHZhciBzdGFydCA9IG1ldGhvZC52YWx1ZS5zdGFydDtcbiAgICAgICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiKSB0aGlzLnJhaXNlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7ZWxzZSB0aGlzLnJhaXNlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpO1xufTtcblxucHAucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IpIHtcbiAgbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvcik7XG4gIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpKTtcbn07XG5cbnBwLnBhcnNlQ2xhc3NJZCA9IGZ1bmN0aW9uIChub2RlLCBpc1N0YXRlbWVudCkge1xuICBub2RlLmlkID0gdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IGlzU3RhdGVtZW50ID8gdGhpcy51bmV4cGVjdGVkKCkgOiBudWxsO1xufTtcblxucHAucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG59O1xuXG4vLyBQYXJzZXMgbW9kdWxlIGV4cG9ydCBkZWNsYXJhdGlvbi5cblxucHAucGFyc2VFeHBvcnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICBpZiAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5zdGFyKSkge1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKTtcbiAgfVxuICBpZiAodGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5fZGVmYXVsdCkpIHtcbiAgICAvLyBleHBvcnQgZGVmYXVsdCAuLi5cbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHZhciBuZWVkc1NlbWkgPSB0cnVlO1xuICAgIGlmIChleHByLnR5cGUgPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBleHByLnR5cGUgPT0gXCJDbGFzc0V4cHJlc3Npb25cIikge1xuICAgICAgbmVlZHNTZW1pID0gZmFsc2U7XG4gICAgICBpZiAoZXhwci5pZCkge1xuICAgICAgICBleHByLnR5cGUgPSBleHByLnR5cGUgPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJDbGFzc0RlY2xhcmF0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuZGVjbGFyYXRpb24gPSBleHByO1xuICAgIGlmIChuZWVkc1NlbWkpIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKTtcbiAgfVxuICAvLyBleHBvcnQgdmFyfGNvbnN0fGxldHxmdW5jdGlvbnxjbGFzcyAuLi5cbiAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSkge1xuICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUpO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycygpO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnNwZWNpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMua2V5d29yZHMudGVzdChub2RlLnNwZWNpZmllcnNbaV0ubG9jYWwubmFtZSkgfHwgdGhpcy5yZXNlcnZlZFdvcmRzLnRlc3Qobm9kZS5zcGVjaWZpZXJzW2ldLmxvY2FsLm5hbWUpKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKG5vZGUuc3BlY2lmaWVyc1tpXS5sb2NhbC5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xufTtcblxucHAuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnR5cGUua2V5d29yZDtcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG5wcC5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlcyA9IFtdLFxuICAgICAgZmlyc3QgPSB0cnVlO1xuICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KF90b2tlbnR5cGUudHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KF90b2tlbnR5cGUudHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKF90b2tlbnR5cGUudHlwZXMuYnJhY2VSKSkgYnJlYWs7XG4gICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCh0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuX2RlZmF1bHQpO1xuICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCh0cnVlKSA6IG5vZGUubG9jYWw7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn07XG5cbi8vIFBhcnNlcyBpbXBvcnQgZGVjbGFyYXRpb24uXG5cbnBwLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLnN0cmluZykge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5O1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpO1xufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGltcG9ydHMuXG5cbnBwLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVzID0gW10sXG4gICAgICBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMubmFtZSkge1xuICAgIC8vIGltcG9ydCBkZWZhdWx0T2JqLCB7IHgsIHkgYXMgeiB9IGZyb20gJy4uLidcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUubG9jYWwsIHRydWUpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdChfdG9rZW50eXBlLnR5cGVzLmNvbW1hKSkgcmV0dXJuIG5vZGVzO1xuICB9XG4gIGlmICh0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuc3Rhcikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgdHJ1ZSk7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgIHJldHVybiBub2RlcztcbiAgfVxuICB0aGlzLmV4cGVjdChfdG9rZW50eXBlLnR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQoX3Rva2VudHlwZS50eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QoX3Rva2VudHlwZS50eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoX3Rva2VudHlwZS50eXBlcy5icmFjZVIpKSBicmVhaztcbiAgICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCgpIDogbm9kZS5pbXBvcnRlZDtcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCB0cnVlKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufTtcblxufSx7XCIuL3N0YXRlXCI6MTAsXCIuL3Rva2VudHlwZVwiOjE0LFwiLi93aGl0ZXNwYWNlXCI6MTZ9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYWxnb3JpdGhtIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSByZWdleHAgY2FuIGFwcGVhciBhdCBhXG4vLyBnaXZlbiBwb2ludCBpbiB0aGUgcHJvZ3JhbSBpcyBsb29zZWx5IGJhc2VkIG9uIHN3ZWV0LmpzJyBhcHByb2FjaC5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9zdGF0ZSA9IF9kZXJlcV8oXCIuL3N0YXRlXCIpO1xuXG52YXIgX3Rva2VudHlwZSA9IF9kZXJlcV8oXCIuL3Rva2VudHlwZVwiKTtcblxudmFyIF93aGl0ZXNwYWNlID0gX2RlcmVxXyhcIi4vd2hpdGVzcGFjZVwiKTtcblxudmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2tDb250ZXh0KTtcblxuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xufTtcblxuZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbnZhciB0eXBlcyA9IHtcbiAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIHRydWUpLFxuICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLnJlYWRUbXBsVG9rZW4oKTtcbiAgfSksXG4gIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKVxufTtcblxuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xudmFyIHBwID0gX3N0YXRlLlBhcnNlci5wcm90b3R5cGU7XG5cbnBwLmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3R5cGVzLmJfc3RhdF07XG59O1xuXG5wcC5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmNvbG9uKSB7XG4gICAgdmFyIF9wYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoX3BhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IF9wYXJlbnQgPT09IHR5cGVzLmJfZXhwcikgcmV0dXJuICFfcGFyZW50LmlzRXhwcjtcbiAgfVxuICBpZiAocHJldlR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMuX3JldHVybikgcmV0dXJuIF93aGl0ZXNwYWNlLmxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSk7XG4gIGlmIChwcmV2VHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fZWxzZSB8fCBwcmV2VHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5wYXJlblIpIHJldHVybiB0cnVlO1xuICBpZiAocHJldlR5cGUgPT0gX3Rva2VudHlwZS50eXBlcy5icmFjZUwpIHJldHVybiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYl9zdGF0O1xuICByZXR1cm4gIXRoaXMuZXhwckFsbG93ZWQ7XG59O1xuXG5wcC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUgPSB1bmRlZmluZWQsXG4gICAgICB0eXBlID0gdGhpcy50eXBlO1xuICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09IF90b2tlbnR5cGUudHlwZXMuZG90KSB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7ZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KSB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7ZWxzZSB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByO1xufTtcblxuLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG5fdG9rZW50eXBlLnR5cGVzLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gX3Rva2VudHlwZS50eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT0gMSkge1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICBpZiAob3V0ID09PSB0eXBlcy5iX3N0YXQgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLmZfZXhwcikge1xuICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ID09PSB0eXBlcy5iX3RtcGwpIHtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG4gIH1cbn07XG5cbl90b2tlbnR5cGUudHlwZXMuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgdGhpcy5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2socHJldlR5cGUpID8gdHlwZXMuYl9zdGF0IDogdHlwZXMuYl9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG5fdG9rZW50eXBlLnR5cGVzLmRvbGxhckJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5iX3RtcGwpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbl90b2tlbnR5cGUudHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl9pZiB8fCBwcmV2VHlwZSA9PT0gX3Rva2VudHlwZS50eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSBfdG9rZW50eXBlLnR5cGVzLl93aGlsZTtcbiAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMucF9zdGF0IDogdHlwZXMucF9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG5fdG9rZW50eXBlLnR5cGVzLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbn07XG5cbl90b2tlbnR5cGUudHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdHlwZXMuYl9zdGF0KSB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG5fdG9rZW50eXBlLnR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbCkgdGhpcy5jb250ZXh0LnBvcCgpO2Vsc2UgdGhpcy5jb250ZXh0LnB1c2godHlwZXMucV90bXBsKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxufSx7XCIuL3N0YXRlXCI6MTAsXCIuL3Rva2VudHlwZVwiOjE0LFwiLi93aGl0ZXNwYWNlXCI6MTZ9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9pZGVudGlmaWVyID0gX2RlcmVxXyhcIi4vaWRlbnRpZmllclwiKTtcblxudmFyIF90b2tlbnR5cGUgPSBfZGVyZXFfKFwiLi90b2tlbnR5cGVcIik7XG5cbnZhciBfc3RhdGUgPSBfZGVyZXFfKFwiLi9zdGF0ZVwiKTtcblxudmFyIF9sb2N1dGlsID0gX2RlcmVxXyhcIi4vbG9jdXRpbFwiKTtcblxudmFyIF93aGl0ZXNwYWNlID0gX2RlcmVxXyhcIi4vd2hpdGVzcGFjZVwiKTtcblxuLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbnZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRva2VuKTtcblxuICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpIHRoaXMubG9jID0gbmV3IF9sb2N1dGlsLlNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTtcbiAgaWYgKHAub3B0aW9ucy5yYW5nZXMpIHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdO1xufVxuXG4vLyAjIyBUb2tlbml6ZXJcblxuO1xuXG5leHBvcnRzLlRva2VuID0gVG9rZW47XG52YXIgcHAgPSBfc3RhdGUuUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQXJlIHdlIHJ1bm5pbmcgdW5kZXIgUmhpbm8/XG52YXIgaXNSaGlubyA9IHR5cGVvZiBQYWNrYWdlcyA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQYWNrYWdlcykgPT0gXCJbb2JqZWN0IEphdmFQYWNrYWdlXVwiO1xuXG4vLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbnBwLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbikgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTtcblxuICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB0aGlzLm5leHRUb2tlbigpO1xufTtcblxucHAuZ2V0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gbmV3IFRva2VuKHRoaXMpO1xufTtcblxuLy8gSWYgd2UncmUgaW4gYW4gRVM2IGVudmlyb25tZW50LCBtYWtlIHBhcnNlcnMgaXRlcmFibGVcbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKSBwcFtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB7IG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgdG9rZW4gPSBzZWxmLmdldFRva2VuKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSBfdG9rZW50eXBlLnR5cGVzLmVvZixcbiAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICB9O1xuICAgIH0gfTtcbn07XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxucHAuc2V0U3RyaWN0ID0gZnVuY3Rpb24gKHN0cmljdCkge1xuICB0aGlzLnN0cmljdCA9IHN0cmljdDtcbiAgaWYgKHRoaXMudHlwZSAhPT0gX3Rva2VudHlwZS50eXBlcy5udW0gJiYgdGhpcy50eXBlICE9PSBfdG9rZW50eXBlLnR5cGVzLnN0cmluZykgcmV0dXJuO1xuICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5saW5lU3RhcnQpIHtcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCB0aGlzLmxpbmVTdGFydCAtIDIpICsgMTtcbiAgICAgIC0tdGhpcy5jdXJMaW5lO1xuICAgIH1cbiAgfVxuICB0aGlzLm5leHRUb2tlbigpO1xufTtcblxucHAuY3VyQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV07XG59O1xuXG4vLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbi8vIHByb3BlcnRpZXMuXG5cbnBwLm5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHRoaXMuc2tpcFNwYWNlKCk7XG5cbiAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSByZXR1cm4gdGhpcy5maW5pc2hUb2tlbihfdG9rZW50eXBlLnR5cGVzLmVvZik7XG5cbiAgaWYgKGN1ckNvbnRleHQub3ZlcnJpZGUpIHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpO2Vsc2UgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTtcbn07XG5cbnBwLnJlYWRUb2tlbiA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgaWYgKF9pZGVudGlmaWVyLmlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKSByZXR1cm4gdGhpcy5yZWFkV29yZCgpO1xuXG4gIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG59O1xuXG5wcC5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHJldHVybiBjb2RlO1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMDtcbn07XG5cbnBwLnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcyxcbiAgICAgIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICBpZiAoZW5kID09PSAtMSkgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7XG4gIHRoaXMucG9zID0gZW5kICsgMjtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICBfd2hpdGVzcGFjZS5saW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHZhciBtYXRjaCA9IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAoKG1hdGNoID0gX3doaXRlc3BhY2UubGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KSB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpO1xufTtcblxucHAuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24gKHN0YXJ0U2tpcCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiBjaCAhPT0gMTAgJiYgY2ggIT09IDEzICYmIGNoICE9PSA4MjMyICYmIGNoICE9PSA4MjMzKSB7XG4gICAgKyt0aGlzLnBvcztcbiAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpIHRoaXMub3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMucG9zKSwgc3RhcnQsIHRoaXMucG9zLCBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTtcbn07XG5cbi8vIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhcnNlIGFuZCBhZnRlciBldmVyeSB0b2tlbi4gU2tpcHNcbi8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbnBwLnNraXBTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMzI6Y2FzZSAxNjA6XG4gICAgICAgIC8vICcgJ1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEwOmNhc2UgODIzMjpjYXNlIDgyMzM6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIC8vICcvJ1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIC8vICcqJ1xuICAgICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIF93aGl0ZXNwYWNlLm5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbi8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbi8vIHRoZSB0b2tlbiwgc28gdGhhdCB0aGUgbmV4dCBvbmUncyBgc3RhcnRgIHdpbGwgcG9pbnQgYXQgdGhlXG4vLyByaWdodCBwb3NpdGlvbi5cblxucHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbiAodHlwZSwgdmFsKSB7XG4gIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG59O1xuXG4vLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4vLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbi8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbi8vIGludG8gaXQuXG4vL1xuLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuLy9cbnBwLnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSk7XG4gIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbmV4dCA9PT0gNDYgJiYgbmV4dDIgPT09IDQ2KSB7XG4gICAgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbihfdG9rZW50eXBlLnR5cGVzLmVsbGlwc2lzKTtcbiAgfSBlbHNlIHtcbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMuZG90KTtcbiAgfVxufTtcblxucHAucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24gKCkge1xuICAvLyAnLydcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHtcbiAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLnJlYWRSZWdleHAoKTtcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKF90b2tlbnR5cGUudHlwZXMuYXNzaWduLCAyKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoX3Rva2VudHlwZS50eXBlcy5zbGFzaCwgMSk7XG59O1xuXG5wcC5yZWFkVG9rZW5fbXVsdF9tb2R1bG8gPSBmdW5jdGlvbiAoY29kZSkge1xuICAvLyAnJSonXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AoX3Rva2VudHlwZS50eXBlcy5hc3NpZ24sIDIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA0MiA/IF90b2tlbnR5cGUudHlwZXMuc3RhciA6IF90b2tlbnR5cGUudHlwZXMubW9kdWxvLCAxKTtcbn07XG5cbnBwLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gIC8vICd8JidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF90b2tlbnR5cGUudHlwZXMubG9naWNhbE9SIDogX3Rva2VudHlwZS50eXBlcy5sb2dpY2FsQU5ELCAyKTtcbiAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gdGhpcy5maW5pc2hPcChfdG9rZW50eXBlLnR5cGVzLmFzc2lnbiwgMik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF90b2tlbnR5cGUudHlwZXMuYml0d2lzZU9SIDogX3Rva2VudHlwZS50eXBlcy5iaXR3aXNlQU5ELCAxKTtcbn07XG5cbnBwLnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gJ14nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AoX3Rva2VudHlwZS50eXBlcy5hc3NpZ24sIDIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hPcChfdG9rZW50eXBlLnR5cGVzLmJpdHdpc2VYT1IsIDEpO1xufTtcblxucHAucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgLy8gJystJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmIChuZXh0ID09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09IDYyICYmIF93aGl0ZXNwYWNlLmxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSB7XG4gICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKF90b2tlbnR5cGUudHlwZXMuaW5jRGVjLCAyKTtcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKF90b2tlbnR5cGUudHlwZXMuYXNzaWduLCAyKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoX3Rva2VudHlwZS50eXBlcy5wbHVzTWluLCAxKTtcbn07XG5cbnBwLnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gIC8vICc8PidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgc2l6ZSkgPT09IDYxKSByZXR1cm4gdGhpcy5maW5pc2hPcChfdG9rZW50eXBlLnR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKF90b2tlbnR5cGUudHlwZXMuYml0U2hpZnQsIHNpemUpO1xuICB9XG4gIGlmIChuZXh0ID09IDMzICYmIGNvZGUgPT0gNjAgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT0gNDUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT0gNDUpIHtcbiAgICBpZiAodGhpcy5pbk1vZHVsZSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSBzaXplID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDI7XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKF90b2tlbnR5cGUudHlwZXMucmVsYXRpb25hbCwgc2l6ZSk7XG59O1xuXG5wcC5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gIC8vICc9ISdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gdGhpcy5maW5pc2hPcChfdG9rZW50eXBlLnR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG4gIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIC8vICc9PidcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMuYXJyb3cpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gX3Rva2VudHlwZS50eXBlcy5lcSA6IF90b2tlbnR5cGUudHlwZXMucHJlZml4LCAxKTtcbn07XG5cbnBwLmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gICAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICAgIGNhc2UgNDY6XG4gICAgICAvLyAnLidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKTtcblxuICAgIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgICBjYXNlIDQwOlxuICAgICAgKyt0aGlzLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihfdG9rZW50eXBlLnR5cGVzLnBhcmVuTCk7XG4gICAgY2FzZSA0MTpcbiAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5wYXJlblIpO1xuICAgIGNhc2UgNTk6XG4gICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMuc2VtaSk7XG4gICAgY2FzZSA0NDpcbiAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5jb21tYSk7XG4gICAgY2FzZSA5MTpcbiAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5icmFja2V0TCk7XG4gICAgY2FzZSA5MzpcbiAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5icmFja2V0Uik7XG4gICAgY2FzZSAxMjM6XG4gICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMuYnJhY2VMKTtcbiAgICBjYXNlIDEyNTpcbiAgICAgICsrdGhpcy5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5icmFjZVIpO1xuICAgIGNhc2UgNTg6XG4gICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMuY29sb24pO1xuICAgIGNhc2UgNjM6XG4gICAgICArK3RoaXMucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMucXVlc3Rpb24pO1xuXG4gICAgY2FzZSA5NjpcbiAgICAgIC8vICdgJ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIGJyZWFrO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMuYmFja1F1b3RlKTtcblxuICAgIGNhc2UgNDg6XG4gICAgICAvLyAnMCdcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpOyAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KTsgLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKTsgLy8gJzBiJywgJzBCJyAtIGJpbmFyeSBudW1iZXJcbiAgICAgIH1cbiAgICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICAgIGNhc2UgNDk6Y2FzZSA1MDpjYXNlIDUxOmNhc2UgNTI6Y2FzZSA1MzpjYXNlIDU0OmNhc2UgNTU6Y2FzZSA1NjpjYXNlIDU3OlxuICAgICAgLy8gMS05XG4gICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKTtcblxuICAgIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gICAgY2FzZSAzNDpjYXNlIDM5OlxuICAgICAgLy8gJ1wiJywgXCInXCJcbiAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSk7XG5cbiAgICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAgIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gICAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXG4gICAgY2FzZSA0NzpcbiAgICAgIC8vICcvJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKCk7XG5cbiAgICBjYXNlIDM3OmNhc2UgNDI6XG4gICAgICAvLyAnJSonXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG5cbiAgICBjYXNlIDEyNDpjYXNlIDM4OlxuICAgICAgLy8gJ3wmJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuXG4gICAgY2FzZSA5NDpcbiAgICAgIC8vICdeJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KCk7XG5cbiAgICBjYXNlIDQzOmNhc2UgNDU6XG4gICAgICAvLyAnKy0nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG5cbiAgICBjYXNlIDYwOmNhc2UgNjI6XG4gICAgICAvLyAnPD4nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSk7XG5cbiAgICBjYXNlIDYxOmNhc2UgMzM6XG4gICAgICAvLyAnPSEnXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKTtcblxuICAgIGNhc2UgMTI2OlxuICAgICAgLy8gJ34nXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcChfdG9rZW50eXBlLnR5cGVzLnByZWZpeCwgMSk7XG4gIH1cblxuICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xufTtcblxucHAuZmluaXNoT3AgPSBmdW5jdGlvbiAodHlwZSwgc2l6ZSkge1xuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbn07XG5cbi8vIFBhcnNlIGEgcmVndWxhciBleHByZXNzaW9uLiBTb21lIGNvbnRleHQtYXdhcmVuZXNzIGlzIG5lY2Vzc2FyeSxcbi8vIHNpbmNlIGEgJy8nIGluc2lkZSBhICdbXScgc2V0IGRvZXMgbm90IGVuZCB0aGUgZXhwcmVzc2lvbi5cblxuZnVuY3Rpb24gdHJ5Q3JlYXRlUmVnZXhwKHNyYywgZmxhZ3MsIHRocm93RXJyb3JBdCwgcGFyc2VyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc3JjLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhyb3dFcnJvckF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHBhcnNlci5yYWlzZSh0aHJvd0Vycm9yQXQsIFwiRXJyb3IgcGFyc2luZyByZWd1bGFyIGV4cHJlc3Npb246IFwiICsgZS5tZXNzYWdlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbnZhciByZWdleHBVbmljb2RlU3VwcG9ydCA9ICEhdHJ5Q3JlYXRlUmVnZXhwKFwi77+/XCIsIFwidVwiKTtcblxucHAucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgZXNjYXBlZCA9IHVuZGVmaW5lZCxcbiAgICAgIGluQ2xhc3MgPSB1bmRlZmluZWQsXG4gICAgICBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgIGlmIChfd2hpdGVzcGFjZS5saW5lQnJlYWsudGVzdChjaCkpIHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgIGlmIChjaCA9PT0gXCJbXCIpIGluQ2xhc3MgPSB0cnVlO2Vsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSBpbkNsYXNzID0gZmFsc2U7ZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSBicmVhaztcbiAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgfSBlbHNlIGVzY2FwZWQgPSBmYWxzZTtcbiAgICArK3RoaXMucG9zO1xuICB9XG4gIHZhciBjb250ZW50ID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICAvLyBOZWVkIHRvIHVzZSBgcmVhZFdvcmQxYCBiZWNhdXNlICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWRcbiAgLy8gaGVyZSAoZG9uJ3QgYXNrKS5cbiAgdmFyIG1vZHMgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICB2YXIgdG1wID0gY29udGVudDtcbiAgaWYgKG1vZHMpIHtcbiAgICB2YXIgdmFsaWRGbGFncyA9IC9eW2dtc2l5XSokLztcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHZhbGlkRmxhZ3MgPSAvXltnbXNpeXVdKiQvO1xuICAgIGlmICghdmFsaWRGbGFncy50ZXN0KG1vZHMpKSB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgaWYgKG1vZHMuaW5kZXhPZigndScpID49IDAgJiYgIXJlZ2V4cFVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgdGhhdFxuICAgICAgLy8gcG9zc2libHkgcmVwcmVzZW50cyBhbiBhc3RyYWwgc3ltYm9sIG9yIGEgcGFpcmVkIHN1cnJvZ2F0ZSB3aXRoIGFcbiAgICAgIC8vIHNpbmdsZSBBU0NJSSBzeW1ib2wgdG8gYXZvaWQgdGhyb3dpbmcgb24gcmVndWxhciBleHByZXNzaW9ucyB0aGF0XG4gICAgICAvLyBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBgL3VgIGZsYWcuXG4gICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCB0aGUgQVNDSUkgc3ltYm9sIGB4YCBtaWdodCBjYXVzZSBmYWxzZVxuICAgICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdCB3b3VsZFxuICAgICAgLy8gYmUgcmVwbGFjZWQgYnkgYFt4LWJdYCB3aGljaCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICB0bXAgPSB0bXAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfS9nLCBmdW5jdGlvbiAoX21hdGNoLCBjb2RlLCBvZmZzZXQpIHtcbiAgICAgICAgY29kZSA9IE51bWJlcihcIjB4XCIgKyBjb2RlKTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRikgX3RoaXMucmFpc2Uoc3RhcnQgKyBvZmZzZXQgKyAzLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgcmV0dXJuIFwieFwiO1xuICAgICAgfSk7XG4gICAgICB0bXAgPSB0bXAucmVwbGFjZSgvXFxcXHUoW2EtZkEtRjAtOV17NH0pfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgXCJ4XCIpO1xuICAgIH1cbiAgfVxuICAvLyBEZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICB2YXIgdmFsdWUgPSBudWxsO1xuICAvLyBSaGlubydzIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXJzZXIgaXMgZmxha3kgYW5kIHRocm93cyB1bmNhdGNoYWJsZSBleGNlcHRpb25zLFxuICAvLyBzbyBkb24ndCBkbyBkZXRlY3Rpb24gaWYgd2UgYXJlIHJ1bm5pbmcgdW5kZXIgUmhpbm9cbiAgaWYgKCFpc1JoaW5vKSB7XG4gICAgdHJ5Q3JlYXRlUmVnZXhwKHRtcCwgdW5kZWZpbmVkLCBzdGFydCwgdGhpcyk7XG4gICAgLy8gR2V0IGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3IgYG51bGxgIGluXG4gICAgLy8gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0IHVzZXMuXG4gICAgdmFsdWUgPSB0cnlDcmVhdGVSZWdleHAoY29udGVudCwgbW9kcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5yZWdleHAsIHsgcGF0dGVybjogY29udGVudCwgZmxhZ3M6IG1vZHMsIHZhbHVlOiB2YWx1ZSB9KTtcbn07XG5cbi8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4vLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuLy8gd2lsbCByZXR1cm4gYG51bGxgIHVubGVzcyB0aGUgaW50ZWdlciBoYXMgZXhhY3RseSBgbGVuYCBkaWdpdHMuXG5cbnBwLnJlYWRJbnQgPSBmdW5jdGlvbiAocmFkaXgsIGxlbikge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcyxcbiAgICAgIHRvdGFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLFxuICAgICAgICB2YWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNvZGUgPj0gOTcpIHZhbCA9IGNvZGUgLSA5NyArIDEwOyAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgdmFsID0gY29kZSAtIDY1ICsgMTA7IC8vIEFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgdmFsID0gY29kZSAtIDQ4OyAvLyAwLTlcbiAgICAgICAgZWxzZSB2YWwgPSBJbmZpbml0eTtcbiAgICBpZiAodmFsID49IHJhZGl4KSBicmVhaztcbiAgICArK3RoaXMucG9zO1xuICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgfVxuICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxucHAucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24gKHJhZGl4KSB7XG4gIHRoaXMucG9zICs9IDI7IC8vIDB4XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICBpZiAodmFsID09IG51bGwpIHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpO1xuICBpZiAoX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5udW0sIHZhbCk7XG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxucHAucmVhZE51bWJlciA9IGZ1bmN0aW9uIChzdGFydHNXaXRoRG90KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zLFxuICAgICAgaXNGbG9hdCA9IGZhbHNlLFxuICAgICAgb2N0YWwgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSA0ODtcbiAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgLy8gJy4nXG4gICAgKyt0aGlzLnBvcztcbiAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICB9XG4gIGlmIChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpIHtcbiAgICAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpICsrdGhpcy5wb3M7IC8vICcrLSdcbiAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcbiAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgfVxuICBpZiAoX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcblxuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLFxuICAgICAgdmFsID0gdW5kZWZpbmVkO1xuICBpZiAoaXNGbG9hdCkgdmFsID0gcGFyc2VGbG9hdChzdHIpO2Vsc2UgaWYgKCFvY3RhbCB8fCBzdHIubGVuZ3RoID09PSAxKSB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpIHx8IHRoaXMuc3RyaWN0KSB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO2Vsc2UgdmFsID0gcGFyc2VJbnQoc3RyLCA4KTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5udW0sIHZhbCk7XG59O1xuXG4vLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbnBwLnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksXG4gICAgICBjb2RlID0gdW5kZWZpbmVkO1xuXG4gIGlmIChjaCA9PT0gMTIzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoJ30nLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB0aGlzLnJhaXNlKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpO1xuICB9IGVsc2Uge1xuICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICB9XG4gIHJldHVybiBjb2RlO1xufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApO1xufVxuXG5wcC5yZWFkU3RyaW5nID0gZnVuY3Rpb24gKHF1b3RlKSB7XG4gIHZhciBvdXQgPSBcIlwiLFxuICAgICAgY2h1bmtTdGFydCA9ICsrdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSBxdW90ZSkgYnJlYWs7XG4gICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF93aGl0ZXNwYWNlLmlzTmV3TGluZShjaCkpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gIH1cbiAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKF90b2tlbnR5cGUudHlwZXMuc3RyaW5nLCBvdXQpO1xufTtcblxuLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxucHAucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFwiXCIsXG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7XG4gICAgICAvLyAnYCcsICckeydcbiAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5zdGFydCAmJiB0aGlzLnR5cGUgPT09IF90b2tlbnR5cGUudHlwZXMudGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oX3Rva2VudHlwZS50eXBlcy5iYWNrUXVvdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbihfdG9rZW50eXBlLnR5cGVzLnRlbXBsYXRlLCBvdXQpO1xuICAgIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7XG4gICAgICAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChfd2hpdGVzcGFjZS5pc05ld0xpbmUoY2gpKSB7XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgKyt0aGlzLnBvcztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxucHAucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24gKGluVGVtcGxhdGUpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAxMTA6XG4gICAgICByZXR1cm4gXCJcXG5cIjsgLy8gJ24nIC0+ICdcXG4nXG4gICAgY2FzZSAxMTQ6XG4gICAgICByZXR1cm4gXCJcXHJcIjsgLy8gJ3InIC0+ICdcXHInXG4gICAgY2FzZSAxMjA6XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKTsgLy8gJ3gnXG4gICAgY2FzZSAxMTc6XG4gICAgICByZXR1cm4gY29kZVBvaW50VG9TdHJpbmcodGhpcy5yZWFkQ29kZVBvaW50KCkpOyAvLyAndSdcbiAgICBjYXNlIDExNjpcbiAgICAgIHJldHVybiBcIlxcdFwiOyAvLyAndCcgLT4gJ1xcdCdcbiAgICBjYXNlIDk4OlxuICAgICAgcmV0dXJuIFwiXFxiXCI7IC8vICdiJyAtPiAnXFxiJ1xuICAgIGNhc2UgMTE4OlxuICAgICAgcmV0dXJuIFwiXFx1MDAwYlwiOyAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgY2FzZSAxMDI6XG4gICAgICByZXR1cm4gXCJcXGZcIjsgLy8gJ2YnIC0+ICdcXGYnXG4gICAgY2FzZSAxMzpcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgKyt0aGlzLnBvczsgLy8gJ1xcclxcbidcbiAgICBjYXNlIDEwOlxuICAgICAgLy8gJyBcXG4nXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOysrdGhpcy5jdXJMaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9jdGFsID4gMCAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgfVxufTtcblxuLy8gVXNlZCB0byByZWFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzICgnXFx4JywgJ1xcdScsICdcXFUnKS5cblxucHAucmVhZEhleENoYXIgPSBmdW5jdGlvbiAobGVuKSB7XG4gIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICBpZiAobiA9PT0gbnVsbCkgdGhpcy5yYWlzZShjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpO1xuICByZXR1cm4gbjtcbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2Bcbi8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuLy9cbi8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbi8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG5wcC5yZWFkV29yZDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgdmFyIHdvcmQgPSBcIlwiLFxuICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgIGlmIChfaWRlbnRpZmllci5pc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgLy8gXCJcXFwiXG4gICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT0gMTE3KSAvLyBcInVcIlxuICAgICAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgaWYgKCEoZmlyc3QgPyBfaWRlbnRpZmllci5pc0lkZW50aWZpZXJTdGFydCA6IF9pZGVudGlmaWVyLmlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSkgdGhpcy5yYWlzZShlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyhlc2MpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4vLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxucHAucmVhZFdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgdmFyIHR5cGUgPSBfdG9rZW50eXBlLnR5cGVzLm5hbWU7XG4gIGlmICgodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgfHwgIXRoaXMuY29udGFpbnNFc2MpICYmIHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkgdHlwZSA9IF90b2tlbnR5cGUua2V5d29yZHNbd29yZF07XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpO1xufTtcblxufSx7XCIuL2lkZW50aWZpZXJcIjoyLFwiLi9sb2N1dGlsXCI6NSxcIi4vc3RhdGVcIjoxMCxcIi4vdG9rZW50eXBlXCI6MTQsXCIuL3doaXRlc3BhY2VcIjoxNn1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vICMjIFRva2VuIHR5cGVzXG5cbi8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4vLyBhbGxvd3MgdGhlIHRva2VuaXplciB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gaXQgaGFzIGFib3V0IGFcbi8vIHRva2VuIGluIGEgd2F5IHRoYXQgaXMgdmVyeSBjaGVhcCBmb3IgdGhlIHBhcnNlciB0byBsb29rIHVwLlxuXG4vLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbi8vIGVhc3kgdG8gcmVjb2duaXplLlxuXG4vLyBUaGUgYGJlZm9yZUV4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gcmVndWxhclxuLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuLy8gYmUgZm9sbG93ZWQgYnkgYW4gZXhwcmVzc2lvbiAodGh1cywgYSBzbGFzaCBhZnRlciB0aGVtIHdvdWxkIGJlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbikuXG4vL1xuLy8gVGhlIGBzdGFydHNFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGNoZWNrIGlmIHRoZSB0b2tlbiBlbmRzIGFcbi8vIGB5aWVsZGAgZXhwcmVzc2lvbi4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGVpdGhlciBjYW5cbi8vIGRpcmVjdGx5IHN0YXJ0IGFuIGV4cHJlc3Npb24gKGxpa2UgYSBxdW90YXRpb24gbWFyaykgb3IgY2FuXG4vLyBjb250aW51ZSBhbiBleHByZXNzaW9uIChsaWtlIHRoZSBib2R5IG9mIGEgc3RyaW5nKS5cbi8vXG4vLyBgaXNMb29wYCBtYXJrcyBhIGtleXdvcmQgYXMgc3RhcnRpbmcgYSBsb29wLCB3aGljaCBpcyBpbXBvcnRhbnRcbi8vIHRvIGtub3cgd2hlbiBwYXJzaW5nIGEgbGFiZWwsIGluIG9yZGVyIHRvIGFsbG93IG9yIGRpc2FsbG93XG4vLyBjb250aW51ZSBqdW1wcyB0byB0aGF0IGxhYmVsLlxuXG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFRva2VuVHlwZSA9IGZ1bmN0aW9uIFRva2VuVHlwZShsYWJlbCkge1xuICB2YXIgY29uZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2tlblR5cGUpO1xuXG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgfHwgbnVsbDtcbiAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbn07XG5cbmV4cG9ydHMuVG9rZW5UeXBlID0gVG9rZW5UeXBlO1xuXG5mdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWMgfSk7XG59XG52YXIgYmVmb3JlRXhwciA9IHsgYmVmb3JlRXhwcjogdHJ1ZSB9LFxuICAgIHN0YXJ0c0V4cHIgPSB7IHN0YXJ0c0V4cHI6IHRydWUgfTtcblxudmFyIHR5cGVzID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2VuIHR5cGVzLlxuICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pLFxuICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pLFxuICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KSxcbiAgcGFyZW5SOiBuZXcgVG9rZW5UeXBlKFwiKVwiKSxcbiAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgY29sb246IG5ldyBUb2tlblR5cGUoXCI6XCIsIGJlZm9yZUV4cHIpLFxuICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7IGJlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWUgfSksXG5cbiAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgLy9cbiAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAvL1xuICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWUgfSksXG4gIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWUgfSksXG4gIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHsgcHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pLFxuICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCJwcmVmaXhcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWUgfSksXG4gIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPVwiLCA2KSxcbiAgcmVsYXRpb25hbDogYmlub3AoXCI8Lz5cIiwgNyksXG4gIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+XCIsIDgpLFxuICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KSxcbiAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKVxufTtcblxuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbnZhciBrZXl3b3JkcyA9IHt9O1xuXG5leHBvcnRzLmtleXdvcmRzID0ga2V5d29yZHM7XG4vLyBTdWNjaW5jdCBkZWZpbml0aW9ucyBvZiBrZXl3b3JkIHRva2VuIHR5cGVzXG5mdW5jdGlvbiBrdyhuYW1lKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAga2V5d29yZHNbbmFtZV0gPSB0eXBlc1tcIl9cIiArIG5hbWVdID0gbmV3IFRva2VuVHlwZShuYW1lLCBvcHRpb25zKTtcbn1cblxua3coXCJicmVha1wiKTtcbmt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKTtcbmt3KFwiY2F0Y2hcIik7XG5rdyhcImNvbnRpbnVlXCIpO1xua3coXCJkZWJ1Z2dlclwiKTtcbmt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKTtcbmt3KFwiZG9cIiwgeyBpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWUgfSk7XG5rdyhcImVsc2VcIiwgYmVmb3JlRXhwcik7XG5rdyhcImZpbmFsbHlcIik7XG5rdyhcImZvclwiLCB7IGlzTG9vcDogdHJ1ZSB9KTtcbmt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwcik7XG5rdyhcImlmXCIpO1xua3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwcik7XG5rdyhcInN3aXRjaFwiKTtcbmt3KFwidGhyb3dcIiwgYmVmb3JlRXhwcik7XG5rdyhcInRyeVwiKTtcbmt3KFwidmFyXCIpO1xua3coXCJsZXRcIik7XG5rdyhcImNvbnN0XCIpO1xua3coXCJ3aGlsZVwiLCB7IGlzTG9vcDogdHJ1ZSB9KTtcbmt3KFwid2l0aFwiKTtcbmt3KFwibmV3XCIsIHsgYmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KTtcbmt3KFwidGhpc1wiLCBzdGFydHNFeHByKTtcbmt3KFwic3VwZXJcIiwgc3RhcnRzRXhwcik7XG5rdyhcImNsYXNzXCIpO1xua3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpO1xua3coXCJleHBvcnRcIik7XG5rdyhcImltcG9ydFwiKTtcbmt3KFwieWllbGRcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlIH0pO1xua3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpO1xua3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpO1xua3coXCJmYWxzZVwiLCBzdGFydHNFeHByKTtcbmt3KFwiaW5cIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogNyB9KTtcbmt3KFwiaW5zdGFuY2VvZlwiLCB7IGJlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3IH0pO1xua3coXCJ0eXBlb2ZcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWUgfSk7XG5rdyhcInZvaWRcIiwgeyBiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWUgfSk7XG5rdyhcImRlbGV0ZVwiLCB7IGJlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZSB9KTtcblxufSx7fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5oYXMgPSBoYXM7XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufVxuXG4vLyBDaGVja3MgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuXG5mdW5jdGlvbiBoYXMob2JqLCBwcm9wTmFtZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpO1xufVxuXG59LHt9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmlzTmV3TGluZSA9IGlzTmV3TGluZTtcbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbmV4cG9ydHMubGluZUJyZWFrID0gbGluZUJyZWFrO1xudmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuZXhwb3J0cy5saW5lQnJlYWtHID0gbGluZUJyZWFrRztcblxuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8IGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09IDB4MjAyOTtcbn1cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5leHBvcnRzLm5vbkFTQ0lJd2hpdGVzcGFjZSA9IG5vbkFTQ0lJd2hpdGVzcGFjZTtcblxufSx7fV19LHt9LFszXSkoMylcbn0pOyIsIi8vIGFsdGVyLmpzXG4vLyBNSVQgbGljZW5zZWQsIHNlZSBMSUNFTlNFIGZpbGVcbi8vIENvcHlyaWdodCAoYykgMjAxMyBPbG92IExhc3N1cyA8b2xvdi5sYXNzdXNAZ21haWwuY29tPlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZShcInN0YWJsZVwiKTtcblxuLy8gZnJhZ21lbnRzIGlzIGEgbGlzdCBvZiB7c3RhcnQ6IGluZGV4LCBlbmQ6IGluZGV4LCBzdHI6IHN0cmluZyB0byByZXBsYWNlIHdpdGh9XG5mdW5jdGlvbiBhbHRlcihzdHIsIGZyYWdtZW50cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH07O1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpO1xuICAgIGFzc2VydChpc0FycmF5KGZyYWdtZW50cykpO1xuXG4gICAgLy8gc3RhYmxlU29ydCBpc24ndCBpbi1wbGFjZSBzbyBubyBuZWVkIHRvIGNvcHkgYXJyYXkgZmlyc3RcbiAgICB2YXIgc29ydGVkRnJhZ21lbnRzID0gc3RhYmxlU29ydChmcmFnbWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgIH0pO1xuXG4gICAgdmFyIG91dHMgPSBbXTtcblxuICAgIHZhciBwb3MgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkRnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmcmFnID0gc29ydGVkRnJhZ21lbnRzW2ldO1xuXG4gICAgICAgIGFzc2VydChwb3MgPD0gZnJhZy5zdGFydCk7XG4gICAgICAgIGFzc2VydChmcmFnLnN0YXJ0IDw9IGZyYWcuZW5kKTtcbiAgICAgICAgb3V0cy5wdXNoKHN0ci5zbGljZShwb3MsIGZyYWcuc3RhcnQpKTtcbiAgICAgICAgb3V0cy5wdXNoKGZyYWcuc3RyKTtcbiAgICAgICAgcG9zID0gZnJhZy5lbmQ7XG4gICAgfVxuICAgIGlmIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIG91dHMucHVzaChzdHIuc2xpY2UocG9zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHMuam9pbihcIlwiKTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhbHRlcjtcbn1cbiIsIi8qIVxuICogQW5ndWxhckZpcmUgaXMgdGhlIG9mZmljaWFsbHkgc3VwcG9ydGVkIEFuZ3VsYXJKUyBiaW5kaW5nIGZvciBGaXJlYmFzZS4gRmlyZWJhc2VcbiAqIGlzIGEgZnVsbCBiYWNrZW5kIHNvIHlvdSBkb24ndCBuZWVkIHNlcnZlcnMgdG8gYnVpbGQgeW91ciBBbmd1bGFyIGFwcC4gQW5ndWxhckZpcmVcbiAqIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSAkZmlyZWJhc2Ugc2VydmljZSB3aGljaCBhbGxvd3MgeW91IHRvIGVhc2lseSBrZWVwIHlvdXIgJHNjb3BlXG4gKiB2YXJpYWJsZXMgaW4gc3luYyB3aXRoIHlvdXIgRmlyZWJhc2UgYmFja2VuZC5cbiAqXG4gKiBBbmd1bGFyRmlyZSAxLjEuNFxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2FuZ3VsYXJmaXJlL1xuICogRGF0ZTogMDIvMjIvMjAxNlxuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4vLyBEZWZpbmUgdGhlIGBmaXJlYmFzZWAgbW9kdWxlIHVuZGVyIHdoaWNoIGFsbCBBbmd1bGFyRmlyZVxuLy8gc2VydmljZXMgd2lsbCBsaXZlLlxuICBhbmd1bGFyLm1vZHVsZShcImZpcmViYXNlXCIsIFtdKVxuICAgIC8vdG9kbyB1c2UgJHdpbmRvd1xuICAgIC52YWx1ZShcIkZpcmViYXNlXCIsIGV4cG9ydHMuRmlyZWJhc2UpO1xuXG59KSh3aW5kb3cpO1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBtYWludGFpbnMgYSBzeW5jaHJvbml6ZWQgbGlzdCBvZiBkYXRhLiBUaGlzIGlzIGEgcHNldWRvLXJlYWQtb25seSBhcnJheS4gT25lIHNob3VsZFxuICAgKiBub3QgY2FsbCBzcGxpY2UoKSwgcHVzaCgpLCBwb3AoKSwgZXQgYWwgZGlyZWN0bHkgb24gdGhpcyBhcnJheSwgYnV0IHNob3VsZCBpbnN0ZWFkIHVzZSB0aGVcbiAgICogJHJlbW92ZSBhbmQgJGFkZCBtZXRob2RzLlxuICAgKlxuICAgKiBJdCBpcyBhY2NlcHRhYmxlIHRvIC5zb3J0KCkgdGhpcyBhcnJheSwgYnV0IGl0IGlzIGltcG9ydGFudCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoXG4gICAqICR3YXRjaCgpLCBzbyB0aGF0IGl0IHdpbGwgYmUgcmUtc29ydGVkIGFueSB0aW1lIHRoZSBzZXJ2ZXIgZGF0YSBjaGFuZ2VzLiBFeGFtcGxlcyBvZiB0aGlzIGFyZVxuICAgKiBpbmNsdWRlZCBpbiB0aGUgJHdhdGNoIGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIEludGVybmFsbHksIHRoZSAkZmlyZWJhc2Ugb2JqZWN0IGRlcGVuZHMgb24gdGhpcyBjbGFzcyB0byBwcm92aWRlIHNldmVyYWwgJCQgKGkuZS4gcHJvdGVjdGVkKVxuICAgKiBtZXRob2RzLCB3aGljaCBpdCBpbnZva2VzIHRvIG5vdGlmeSB0aGUgYXJyYXkgd2hlbmV2ZXIgYSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBhdCB0aGUgc2VydmVyOlxuICAgKiAgICAkJGFkZGVkIC0gY2FsbGVkIHdoZW5ldmVyIGEgY2hpbGRfYWRkZWQgZXZlbnQgb2NjdXJzXG4gICAqICAgICQkdXBkYXRlZCAtIGNhbGxlZCB3aGVuZXZlciBhIGNoaWxkX2NoYW5nZWQgZXZlbnQgb2NjdXJzXG4gICAqICAgICQkbW92ZWQgLSBjYWxsZWQgd2hlbmV2ZXIgYSBjaGlsZF9tb3ZlZCBldmVudCBvY2N1cnNcbiAgICogICAgJCRyZW1vdmVkIC0gY2FsbGVkIHdoZW5ldmVyIGEgY2hpbGRfcmVtb3ZlZCBldmVudCBvY2N1cnNcbiAgICogICAgJCRlcnJvciAtIGNhbGxlZCB3aGVuIGxpc3RlbmVycyBhcmUgY2FuY2VsZWQgZHVlIHRvIGEgc2VjdXJpdHkgZXJyb3JcbiAgICogICAgJCRwcm9jZXNzIC0gY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyICQkYWRkZWQvJCR1cGRhdGVkLyQkbW92ZWQvJCRyZW1vdmVkXG4gICAqICAgICAgICAgICAgICAgIChhc3N1bWluZyB0aGF0IHRoZXNlIG1ldGhvZHMgZG8gbm90IGFib3J0IGJ5IHJldHVybmluZyBmYWxzZSBvciBudWxsKVxuICAgKiAgICAgICAgICAgICAgICB0byBzcGxpY2UvbWFuaXB1bGF0ZSB0aGUgYXJyYXkgYW5kIGludm9rZSAkJG5vdGlmeVxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHRoZXNlIG1ldGhvZHMgbWF5IGJlIG9mIGludGVyZXN0IHRvIGRldnMgZXh0ZW5kaW5nIHRoaXMgY2xhc3M6XG4gICAqICAgICQkbm90aWZ5IC0gdHJpZ2dlcnMgbm90aWZpY2F0aW9ucyB0byBhbnkgJHdhdGNoIGxpc3RlbmVycywgY2FsbGVkIGJ5ICQkcHJvY2Vzc1xuICAgKiAgICAkJGdldEtleSAtIGRldGVybWluZXMgaG93IHRvIGxvb2sgdXAgYSByZWNvcmQncyBrZXkgKHJldHVybnMgJGlkIGJ5IGRlZmF1bHQpXG4gICAqXG4gICAqIEluc3RlYWQgb2YgZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgY2xhc3MsIG9uZSBzaG91bGQgZ2VuZXJhbGx5IHVzZSB0aGUgJGV4dGVuZFxuICAgKiBtZXRob2QgdG8gYWRkIG9yIGNoYW5nZSBob3cgbWV0aG9kcyBiZWhhdmUuICRleHRlbmQgbW9kaWZpZXMgdGhlIHByb3RvdHlwZSBvZlxuICAgKiB0aGUgYXJyYXkgY2xhc3MgYnkgcmV0dXJuaW5nIGEgY2xvbmUgb2YgJGZpcmViYXNlQXJyYXkuXG4gICAqXG4gICAqIDxwcmU+PGNvZGU+XG4gICAqIHZhciBFeHRlbmRlZEFycmF5ID0gJGZpcmViYXNlQXJyYXkuJGV4dGVuZCh7XG4gICAqICAgIC8vIGFkZCBhIG5ldyBtZXRob2QgdG8gdGhlIHByb3RvdHlwZVxuICAgKiAgICBmb286IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2Jhcic7IH0sXG4gICAqXG4gICAqICAgIC8vIGNoYW5nZSBob3cgcmVjb3JkcyBhcmUgY3JlYXRlZFxuICAgKiAgICAkJGFkZGVkOiBmdW5jdGlvbihzbmFwLCBwcmV2Q2hpbGQpIHtcbiAgICogICAgICAgcmV0dXJuIG5ldyBXaWRnZXQoc25hcCwgcHJldkNoaWxkKTtcbiAgICogICAgfSxcbiAgICpcbiAgICogICAgLy8gY2hhbmdlIGhvdyByZWNvcmRzIGFyZSB1cGRhdGVkXG4gICAqICAgICQkdXBkYXRlZDogZnVuY3Rpb24oc25hcCkge1xuICAgKiAgICAgIHJldHVybiB0aGlzLiRnZXRSZWNvcmQoc25hcC5rZXkoKSkudXBkYXRlKHNuYXApO1xuICAgKiAgICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgbGlzdCA9IG5ldyBFeHRlbmRlZEFycmF5KHJlZik7XG4gICAqIDwvY29kZT48L3ByZT5cbiAgICovXG4gIGFuZ3VsYXIubW9kdWxlKCdmaXJlYmFzZScpLmZhY3RvcnkoJyRmaXJlYmFzZUFycmF5JywgW1wiJGxvZ1wiLCBcIiRmaXJlYmFzZVV0aWxzXCIsIFwiJHFcIixcbiAgICBmdW5jdGlvbigkbG9nLCAkZmlyZWJhc2VVdGlscywgJHEpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBjb25zdHJ1Y3RvciBzaG91bGQgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkIG1hbnVhbGx5LiBJdCBpcyB1c2VkIGludGVybmFsbHkgYnlcbiAgICAgICAqIDxjb2RlPiRmaXJlYmFzZS4kYXNBcnJheSgpPC9jb2RlPi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ZpcmViYXNlfSByZWZcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBGaXJlYmFzZUFycmF5KHJlZikge1xuICAgICAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgRmlyZWJhc2VBcnJheSkgKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGaXJlYmFzZUFycmF5KHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy4kbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9yZWYgPSByZWY7XG4gICAgICAgIHRoaXMuX3N5bmMgPSBuZXcgQXJyYXlTeW5jTWFuYWdlcih0aGlzKTtcblxuICAgICAgICAkZmlyZWJhc2VVdGlscy5hc3NlcnRWYWxpZFJlZihyZWYsICdNdXN0IHBhc3MgYSB2YWxpZCBGaXJlYmFzZSByZWZlcmVuY2UgJyArXG4gICAgICAgICd0byAkZmlyZWJhc2VBcnJheSAobm90IGEgc3RyaW5nIG9yIFVSTCknKTtcblxuICAgICAgICAvLyBpbmRleENhY2hlIGlzIGEgd2VhayBoYXNobWFwIChhIGxhenkgbGlzdCkgb2Yga2V5cyB0byBhcnJheSBpbmRpY2VzLFxuICAgICAgICAvLyBpdGVtcyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gc3RheSB1cCB0byBkYXRlIGluIHRoaXMgbGlzdCAoc2luY2UgdGhlIGRhdGFcbiAgICAgICAgLy8gYXJyYXkgY2FuIGJlIG1hbnVhbGx5IGVkaXRlZCB3aXRob3V0IGNhbGxpbmcgdGhlICQgbWV0aG9kcykgYW5kIGl0IHNob3VsZFxuICAgICAgICAvLyBhbHdheXMgYmUgdXNlZCB3aXRoIHNrZXB0aWNpc20gcmVnYXJkaW5nIHdoZXRoZXIgaXQgaXMgYWNjdXJhdGVcbiAgICAgICAgLy8gKHNlZSAkaW5kZXhGb3IoKSBiZWxvdyBmb3IgcHJvcGVyIHVzYWdlKVxuICAgICAgICB0aGlzLl9pbmRleENhY2hlID0ge307XG5cbiAgICAgICAgLy8gQXJyYXkuaXNBcnJheSB3aWxsIG5vdCB3b3JrIG9uIG9iamVjdHMgd2hpY2ggZXh0ZW5kIHRoZSBBcnJheSBjbGFzcy5cbiAgICAgICAgLy8gU28gaW5zdGVhZCBvZiBleHRlbmRpbmcgdGhlIEFycmF5IGNsYXNzLCB3ZSBqdXN0IHJldHVybiBhbiBhY3R1YWwgYXJyYXkuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGl0J3Mgc3RpbGwgcG9zc2libGUgdG8gZXh0ZW5kIEZpcmViYXNlQXJyYXkgYW5kIGhhdmUgdGhlIHB1YmxpYyBtZXRob2RzXG4gICAgICAgIC8vIGFwcGVhciBvbiB0aGUgYXJyYXkgb2JqZWN0LiBXZSBkbyB0aGlzIGJ5IGl0ZXJhdGluZyB0aGUgcHJvdG90eXBlIGFuZCBiaW5kaW5nXG4gICAgICAgIC8vIGFueSBtZXRob2QgdGhhdCBpcyBub3QgcHJlZml4ZWQgd2l0aCBhbiB1bmRlcnNjb3JlIG9udG8gdGhlIGZpbmFsIGFycmF5LlxuICAgICAgICAkZmlyZWJhc2VVdGlscy5nZXRQdWJsaWNNZXRob2RzKHNlbGYsIGZ1bmN0aW9uKGZuLCBrZXkpIHtcbiAgICAgICAgICBzZWxmLiRsaXN0W2tleV0gPSBmbi5iaW5kKHNlbGYpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zeW5jLmluaXQodGhpcy4kbGlzdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJGxpc3Q7XG4gICAgICB9XG5cbiAgICAgIEZpcmViYXNlQXJyYXkucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHJlY29yZCB3aXRoIGEgdW5pcXVlIElEIGFuZCBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBBcnJheS5wcm90b3R5cGUucHVzaCwgc2luY2UgdGhvc2UgY2hhbmdlcyB3aWxsIG5vdCBiZVxuICAgICAgICAgKiBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgdmFsdWUsIGluY2x1ZGluZyBhIHByaW1pdGl2ZSwgY2FuIGJlIGFkZGVkIGluIHRoaXMgd2F5LiBOb3RlIHRoYXQgd2hlbiB0aGUgcmVjb3JkXG4gICAgICAgICAqIGlzIGNyZWF0ZWQsIHRoZSBwcmltaXRpdmUgdmFsdWUgd291bGQgYmUgc3RvcmVkIGluICR2YWx1ZSAocmVjb3JkcyBhcmUgYWx3YXlzIG9iamVjdHNcbiAgICAgICAgICogYnkgZGVmYXVsdCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYSBmdXR1cmUgd2hpY2ggaXMgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSBoYXMgc3VjY2Vzc2Z1bGx5IHNhdmVkIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqIFRoZSByZXNvbHZlIGNhbGxiYWNrIHdpbGwgYmUgcGFzc2VkIGEgRmlyZWJhc2UgcmVmIHJlcHJlc2VudGluZyB0aGUgbmV3IGRhdGEgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGFcbiAgICAgICAgICogQHJldHVybnMgYSBwcm9taXNlIHJlc29sdmVkIGFmdGVyIGRhdGEgaXMgYWRkZWRcbiAgICAgICAgICovXG4gICAgICAgICRhZGQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB0aGlzLl9hc3NlcnROb3REZXN0cm95ZWQoJyRhZGQnKTtcbiAgICAgICAgICB2YXIgZGVmID0gJGZpcmViYXNlVXRpbHMuZGVmZXIoKTtcbiAgICAgICAgICB2YXIgcmVmID0gdGhpcy4kcmVmKCkucmVmKCkucHVzaCgpO1xuICAgICAgICAgIHJlZi5zZXQoJGZpcmViYXNlVXRpbHMudG9KU09OKGRhdGEpLCAkZmlyZWJhc2VVdGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZikpO1xuICAgICAgICAgIHJldHVybiBkZWYucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFzcyBlaXRoZXIgYW4gaXRlbSBpbiB0aGUgYXJyYXkgb3IgdGhlIGluZGV4IG9mIGFuIGl0ZW0gYW5kIGl0IHdpbGwgYmUgc2F2ZWQgYmFja1xuICAgICAgICAgKiB0byBGaXJlYmFzZS4gV2hpbGUgdGhlIGFycmF5IGlzIHJlYWQtb25seSBhbmQgaXRzIHN0cnVjdHVyZSBzaG91bGQgbm90IGJlIGNoYW5nZWQsXG4gICAgICAgICAqIGl0IGlzIG9rYXkgdG8gbW9kaWZ5IHByb3BlcnRpZXMgb24gdGhlIG9iamVjdHMgaXQgY29udGFpbnMgYW5kIHRoZW4gc2F2ZSB0aG9zZSBiYWNrXG4gICAgICAgICAqIGluZGl2aWR1YWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyBhIGZ1dHVyZSB3aGljaCBpcyByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIGhhcyBzdWNjZXNzZnVsbHkgc2F2ZWQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICogVGhlIHJlc29sdmUgY2FsbGJhY2sgd2lsbCBiZSBwYXNzZWQgYSBGaXJlYmFzZSByZWYgcmVwcmVzZW50aW5nIHRoZSBzYXZlZCBlbGVtZW50LlxuICAgICAgICAgKiBJZiBwYXNzZWQgYW4gaW52YWxpZCBpbmRleCBvciBhbiBvYmplY3Qgd2hpY2ggaXMgbm90IGEgcmVjb3JkIGluIHRoaXMgYXJyYXksXG4gICAgICAgICAqIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7aW50fG9iamVjdH0gaW5kZXhPckl0ZW1cbiAgICAgICAgICogQHJldHVybnMgYSBwcm9taXNlIHJlc29sdmVkIGFmdGVyIGRhdGEgaXMgc2F2ZWRcbiAgICAgICAgICovXG4gICAgICAgICRzYXZlOiBmdW5jdGlvbihpbmRleE9ySXRlbSkge1xuICAgICAgICAgIHRoaXMuX2Fzc2VydE5vdERlc3Ryb3llZCgnJHNhdmUnKTtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBzZWxmLl9yZXNvbHZlSXRlbShpbmRleE9ySXRlbSk7XG4gICAgICAgICAgdmFyIGtleSA9IHNlbGYuJGtleUF0KGl0ZW0pO1xuICAgICAgICAgIGlmKCBrZXkgIT09IG51bGwgKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gc2VsZi4kcmVmKCkucmVmKCkuY2hpbGQoa2V5KTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gJGZpcmViYXNlVXRpbHMudG9KU09OKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuICRmaXJlYmFzZVV0aWxzLmRvU2V0KHJlZiwgZGF0YSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi4kJG5vdGlmeSgnY2hpbGRfY2hhbmdlZCcsIGtleSk7XG4gICAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJGZpcmViYXNlVXRpbHMucmVqZWN0KCdJbnZhbGlkIHJlY29yZDsgY291bGQgZGV0ZXJtaW5lIGtleSBmb3IgJytpbmRleE9ySXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIGVpdGhlciBhbiBleGlzdGluZyBpdGVtIGluIHRoaXMgYXJyYXkgb3IgdGhlIGluZGV4IG9mIHRoYXQgaXRlbSBhbmQgaXQgd2lsbFxuICAgICAgICAgKiBiZSByZW1vdmVkIGJvdGggbG9jYWxseSBhbmQgaW4gRmlyZWJhc2UuIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gcGxhY2Ugb2ZcbiAgICAgICAgICogQXJyYXkucHJvdG90eXBlLnNwbGljZSBmb3IgcmVtb3ZpbmcgaXRlbXMgb3V0IG9mIHRoZSBhcnJheSwgYXMgY2FsbGluZyBzcGxpY2VcbiAgICAgICAgICogd2lsbCBub3QgdXBkYXRlIHRoZSB2YWx1ZSBvbiB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIGEgZnV0dXJlIHdoaWNoIGlzIHJlc29sdmVkIHdoZW4gdGhlIGRhdGEgaGFzIHN1Y2Nlc3NmdWxseSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgICAqIHNlcnZlci4gVGhlIHJlc29sdmUgY2FsbGJhY2sgd2lsbCBiZSBwYXNzZWQgYSBGaXJlYmFzZSByZWYgcmVwcmVzZW50aW5nIHRoZSBkZWxldGVkXG4gICAgICAgICAqIGVsZW1lbnQuIElmIHBhc3NlZCBhbiBpbnZhbGlkIGluZGV4IG9yIGFuIG9iamVjdCB3aGljaCBpcyBub3QgYSByZWNvcmQgaW4gdGhpcyBhcnJheSxcbiAgICAgICAgICogdGhlIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtpbnR8b2JqZWN0fSBpbmRleE9ySXRlbVxuICAgICAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgYWZ0ZXIgZGF0YSBpcyByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICAkcmVtb3ZlOiBmdW5jdGlvbihpbmRleE9ySXRlbSkge1xuICAgICAgICAgIHRoaXMuX2Fzc2VydE5vdERlc3Ryb3llZCgnJHJlbW92ZScpO1xuICAgICAgICAgIHZhciBrZXkgPSB0aGlzLiRrZXlBdChpbmRleE9ySXRlbSk7XG4gICAgICAgICAgaWYoIGtleSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgIHZhciByZWYgPSB0aGlzLiRyZWYoKS5yZWYoKS5jaGlsZChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuICRmaXJlYmFzZVV0aWxzLmRvUmVtb3ZlKHJlZikudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkZmlyZWJhc2VVdGlscy5yZWplY3QoJ0ludmFsaWQgcmVjb3JkOyBjb3VsZCBub3QgZGV0ZXJtaW5lIGtleSBmb3IgJytpbmRleE9ySXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBpdGVtIGluIHRoaXMgYXJyYXkgb3IgdGhlIGluZGV4IG9mIGFuIGl0ZW0gaW4gdGhlIGFycmF5LCB0aGlzIHJldHVybnMgdGhlXG4gICAgICAgICAqIEZpcmViYXNlIGtleSAocmVjb3JkLiRpZCkgZm9yIHRoYXQgcmVjb3JkLiBJZiBwYXNzZWQgYW4gaW52YWxpZCBrZXkgb3IgYW4gaXRlbSB3aGljaFxuICAgICAgICAgKiBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGFycmF5LCBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2ludHxvYmplY3R9IGluZGV4T3JJdGVtXG4gICAgICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgICRrZXlBdDogZnVuY3Rpb24oaW5kZXhPckl0ZW0pIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3Jlc29sdmVJdGVtKGluZGV4T3JJdGVtKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kJGdldEtleShpdGVtKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGludmVyc2Ugb2YgJGtleUF0LCB0aGlzIG1ldGhvZCB0YWtlcyBhIEZpcmViYXNlIGtleSAocmVjb3JkLiRpZCkgYW5kIHJldHVybnMgdGhlXG4gICAgICAgICAqIGluZGV4IGluIHRoZSBhcnJheSB3aGVyZSB0aGF0IHJlY29yZCBpcyBzdG9yZWQuIElmIHRoZSByZWNvcmQgaXMgbm90IGluIHRoZSBhcnJheSxcbiAgICAgICAgICogdGhpcyBtZXRob2QgcmV0dXJucyAtMS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7aW50fSAtMSBpZiBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgICRpbmRleEZvcjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciBjYWNoZSA9IHNlbGYuX2luZGV4Q2FjaGU7XG4gICAgICAgICAgLy8gZXZhbHVhdGUgd2hldGhlciBvdXIga2V5IGlzIGNhY2hlZCBhbmQsIGlmIHNvLCB3aGV0aGVyIGl0IGlzIHVwIHRvIGRhdGVcbiAgICAgICAgICBpZiggIWNhY2hlLmhhc093blByb3BlcnR5KGtleSkgfHwgc2VsZi4ka2V5QXQoY2FjaGVba2V5XSkgIT09IGtleSApIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaGFzaG1hcFxuICAgICAgICAgICAgdmFyIHBvcyA9IHNlbGYuJGxpc3QuZmluZEluZGV4KGZ1bmN0aW9uKHJlYykgeyByZXR1cm4gc2VsZi4kJGdldEtleShyZWMpID09PSBrZXk7IH0pO1xuICAgICAgICAgICAgaWYoIHBvcyAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgIGNhY2hlW2tleV0gPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpPyBjYWNoZVtrZXldIDogLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2FkZWQgbWV0aG9kIGlzIGludm9rZWQgYWZ0ZXIgdGhlIGluaXRpYWwgYmF0Y2ggb2YgZGF0YSBhcnJpdmVzIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICogV2hlbiB0aGlzIHJlc29sdmVzLCBhbGwgZGF0YSB3aGljaCBleGlzdGVkIHByaW9yIHRvIGNhbGxpbmcgJGFzQXJyYXkoKSBpcyBub3cgY2FjaGVkXG4gICAgICAgICAqIGxvY2FsbHkgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBBcyBhIHNob3J0Y3V0IGlzIGFsc28gcG9zc2libGUgdG8gcGFzcyByZXNvbHZlL3JlamVjdCBtZXRob2RzIGRpcmVjdGx5IGludG8gdGhpc1xuICAgICAgICAgKiBtZXRob2QganVzdCBhcyB0aGV5IHdvdWxkIGJlIHBhc3NlZCB0byAudGhlbigpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICAgICAgICAgKiBAcmV0dXJucyBhIHByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgICRsb2FkZWQ6IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fc3luYy5yZWFkeSgpO1xuICAgICAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgLy8gYWxsb3cgdGhpcyBtZXRob2QgdG8gYmUgY2FsbGVkIGp1c3QgbGlrZSAudGhlblxuICAgICAgICAgICAgLy8gYnkgcGFzc2luZyBhbnkgYXJndW1lbnRzIG9uIHRvIC50aGVuXG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuLmNhbGwocHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtGaXJlYmFzZX0gdGhlIG9yaWdpbmFsIEZpcmViYXNlIHJlZiB1c2VkIHRvIGNyZWF0ZSB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgICRyZWY6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fcmVmOyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5lcnMgcGFzc2VkIGludG8gdGhpcyBtZXRob2QgYXJlIG5vdGlmaWVkIHdoZW5ldmVyIGEgbmV3IGNoYW5nZSAoYWRkLCB1cGRhdGVkLFxuICAgICAgICAgKiBtb3ZlLCByZW1vdmUpIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gRWFjaCBpbnZvY2F0aW9uIGlzIHNlbnQgYW4gb2JqZWN0XG4gICAgICAgICAqIGNvbnRhaW5pbmcgPGNvZGU+eyB0eXBlOiAnY2hpbGRfYWRkZWR8Y2hpbGRfdXBkYXRlZHxjaGlsZF9tb3ZlZHxjaGlsZF9yZW1vdmVkJyxcbiAgICAgICAgICoga2V5OiAna2V5X29mX2l0ZW1fYWZmZWN0ZWQnfTwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQWRkaXRpb25hbGx5LCBhZGRlZCBhbmQgbW92ZWQgZXZlbnRzIHJlY2VpdmUgYSBwcmV2Q2hpbGQgcGFyYW1ldGVyLCBjb250YWluaW5nIHRoZVxuICAgICAgICAgKiBrZXkgb2YgdGhlIGl0ZW0gYmVmb3JlIHRoaXMgb25lIGluIHRoZSBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBpbnZva2VkIHRvIHN0b3Agb2JzZXJ2aW5nIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IHVzZWQgdG8gc3RvcCBvYnNlcnZpbmdcbiAgICAgICAgICovXG4gICAgICAgICR3YXRjaDogZnVuY3Rpb24oY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX29ic2VydmVycztcbiAgICAgICAgICBsaXN0LnB1c2goW2NiLCBjb250ZXh0XSk7XG4gICAgICAgICAgLy8gYW4gb2ZmIGZ1bmN0aW9uIGZvciBjYW5jZWxsaW5nIHRoZSBsaXN0ZW5lclxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gbGlzdC5maW5kSW5kZXgoZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSBjYiAmJiBwYXJ0c1sxXSA9PT0gY29udGV4dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYoIGkgPiAtMSApIHtcbiAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5mb3JtcyAkZmlyZWJhc2UgdG8gc3RvcCBzZW5kaW5nIGV2ZW50cyBhbmQgY2xlYXJzIG1lbW9yeSBiZWluZyB1c2VkXG4gICAgICAgICAqIGJ5IHRoaXMgYXJyYXkgKGRlbGV0ZSdzIGl0cyBsb2NhbCBjb250ZW50KS5cbiAgICAgICAgICovXG4gICAgICAgICRkZXN0cm95OiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiggIXRoaXMuX2lzRGVzdHJveWVkICkge1xuICAgICAgICAgICAgdGhpcy5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3luYy5kZXN0cm95KGVycik7XG4gICAgICAgICAgICB0aGlzLiRsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZWNvcmQgZm9yIGEgZ2l2ZW4gRmlyZWJhc2Uga2V5IChyZWNvcmQuJGlkKS4gSWYgdGhlIHJlY29yZCBpcyBub3QgZm91bmRcbiAgICAgICAgICogdGhlbiByZXR1cm5zIG51bGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHJldHVybnMge09iamVjdHxudWxsfSBhIHJlY29yZCBpbiB0aGlzIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICAkZ2V0UmVjb3JkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuJGluZGV4Rm9yKGtleSk7XG4gICAgICAgICAgcmV0dXJuIGkgPiAtMT8gdGhpcy4kbGlzdFtpXSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB0byBpbmZvcm0gdGhlIGFycmF5IHdoZW4gYSBuZXcgaXRlbSBoYXMgYmVlbiBhZGRlZCBhdCB0aGUgc2VydmVyLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgcmV0dXJuIHRoZSByZWNvcmQgKGFuIG9iamVjdCkgdGhhdCB3aWxsIGJlIHBhc3NlZCBpbnRvICQkcHJvY2Vzc1xuICAgICAgICAgKiBhbG9uZyB3aXRoIHRoZSBhZGQgZXZlbnQuIEFsdGVybmF0ZWx5LCB0aGUgcmVjb3JkIHdpbGwgYmUgc2tpcHBlZCBpZiB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICAgICAqIGEgZmFsc2V5IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc25hcCBhIEZpcmViYXNlIHNuYXBzaG90XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmV2Q2hpbGRcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSB0aGUgcmVjb3JkIHRvIGJlIGluc2VydGVkIGludG8gdGhlIGFycmF5XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgICQkYWRkZWQ6IGZ1bmN0aW9uKHNuYXAvKiwgcHJldkNoaWxkKi8pIHtcbiAgICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgcmVjb3JkIGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLiRpbmRleEZvcigkZmlyZWJhc2VVdGlscy5nZXRLZXkoc25hcCkpO1xuICAgICAgICAgIGlmKCBpID09PSAtMSApIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIGRhdGEgYW5kIGNyZWF0ZSByZWNvcmRcbiAgICAgICAgICAgIHZhciByZWMgPSBzbmFwLnZhbCgpO1xuICAgICAgICAgICAgaWYoICFhbmd1bGFyLmlzT2JqZWN0KHJlYykgKSB7XG4gICAgICAgICAgICAgIHJlYyA9IHsgJHZhbHVlOiByZWMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYy4kaWQgPSAkZmlyZWJhc2VVdGlscy5nZXRLZXkoc25hcCk7XG4gICAgICAgICAgICByZWMuJHByaW9yaXR5ID0gc25hcC5nZXRQcmlvcml0eSgpO1xuICAgICAgICAgICAgJGZpcmViYXNlVXRpbHMuYXBwbHlEZWZhdWx0cyhyZWMsIHRoaXMuJCRkZWZhdWx0cyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZWM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW5ldmVyIGFuIGl0ZW0gaXMgcmVtb3ZlZCBhdCB0aGUgc2VydmVyLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBwaHlzaWNhbGx5IHJlbW92ZSB0aGUgb2JqZWN0cywgYnV0IGluc3RlYWRcbiAgICAgICAgICogcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGl0IHNob3VsZCBiZSByZW1vdmVkIChhbmRcbiAgICAgICAgICogdGFraW5nIGFueSBvdGhlciBkZXNpcmVkIGFjdGlvbnMgYmVmb3JlIHRoZSByZW1vdmUgY29tcGxldGVzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNuYXAgYSBGaXJlYmFzZSBzbmFwc2hvdFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGl0ZW0gc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgJCRyZW1vdmVkOiBmdW5jdGlvbihzbmFwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4Rm9yKCRmaXJlYmFzZVV0aWxzLmdldEtleShzbmFwKSkgPiAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW5ldmVyIGFuIGl0ZW0gaXMgY2hhbmdlZCBhdCB0aGUgc2VydmVyLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYXBwbHkgdGhlIGNoYW5nZXMsIGluY2x1ZGluZyBjaGFuZ2VzIHRvIGRhdGFcbiAgICAgICAgICogYW5kIHRvICRwcmlvcml0eSwgYW5kIHRoZW4gcmV0dXJuIHRydWUgaWYgYW55IGNoYW5nZXMgd2VyZSBtYWRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGlzIG1ldGhvZCByZXR1cm5zIGZhbHNlLCB0aGVuICQkcHJvY2VzcyB3aWxsIG5vdCBiZSBpbnZva2VkLFxuICAgICAgICAgKiB3aGljaCBtZWFucyB0aGF0ICQkbm90aWZ5IHdpbGwgbm90IHRha2UgcGxhY2UgYW5kIG5vICR3YXRjaCBldmVudHNcbiAgICAgICAgICogd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzbmFwIGEgRmlyZWJhc2Ugc25hcHNob3RcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbnkgZGF0YSBjaGFuZ2VkXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgICQkdXBkYXRlZDogZnVuY3Rpb24oc25hcCkge1xuICAgICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHJlYyA9IHRoaXMuJGdldFJlY29yZCgkZmlyZWJhc2VVdGlscy5nZXRLZXkoc25hcCkpO1xuICAgICAgICAgIGlmKCBhbmd1bGFyLmlzT2JqZWN0KHJlYykgKSB7XG4gICAgICAgICAgICAvLyBhcHBseSBjaGFuZ2VzIHRvIHRoZSByZWNvcmRcbiAgICAgICAgICAgIGNoYW5nZWQgPSAkZmlyZWJhc2VVdGlscy51cGRhdGVSZWMocmVjLCBzbmFwKTtcbiAgICAgICAgICAgICRmaXJlYmFzZVV0aWxzLmFwcGx5RGVmYXVsdHMocmVjLCB0aGlzLiQkZGVmYXVsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW5ldmVyIGFuIGl0ZW0gY2hhbmdlcyBvcmRlciAobW92ZXMpIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBzZXQgJHByaW9yaXR5IHRvIHRoZSB1cGRhdGVkIHZhbHVlIGFuZCByZXR1cm4gdHJ1ZSBpZlxuICAgICAgICAgKiB0aGUgcmVjb3JkIHNob3VsZCBhY3R1YWxseSBiZSBtb3ZlZC4gSXQgc2hvdWxkIG5vdCBhY3R1YWxseSBhcHBseSB0aGUgbW92ZVxuICAgICAgICAgKiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoaXMgbWV0aG9kIHJldHVybnMgZmFsc2UsIHRoZW4gdGhlIHJlY29yZCB3aWxsIG5vdCBiZSBtb3ZlZCBpbiB0aGUgYXJyYXlcbiAgICAgICAgICogYW5kIG5vICR3YXRjaCBsaXN0ZW5lcnMgd2lsbCBiZSBub3RpZmllZC4gKFdoZW4gdHJ1ZSwgJCRwcm9jZXNzIGlzIGludm9rZWRcbiAgICAgICAgICogd2hpY2ggaW52b2tlcyAkJG5vdGlmeSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNuYXAgYSBGaXJlYmFzZSBzbmFwc2hvdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldkNoaWxkXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgICQkbW92ZWQ6IGZ1bmN0aW9uKHNuYXAvKiwgcHJldkNoaWxkKi8pIHtcbiAgICAgICAgICB2YXIgcmVjID0gdGhpcy4kZ2V0UmVjb3JkKCRmaXJlYmFzZVV0aWxzLmdldEtleShzbmFwKSk7XG4gICAgICAgICAgaWYoIGFuZ3VsYXIuaXNPYmplY3QocmVjKSApIHtcbiAgICAgICAgICAgIHJlYy4kcHJpb3JpdHkgPSBzbmFwLmdldFByaW9yaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBzZWN1cml0eSBlcnJvciBvciBvdGhlciBwcm9ibGVtIGNhdXNlcyB0aGUgbGlzdGVuZXJzIHRvIGJlY29tZVxuICAgICAgICAgKiBpbnZhbGlkLiBUaGlzIGlzIGdlbmVyYWxseSBhbiB1bnJlY292ZXJhYmxlIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyIHdoaWNoIHdpbGwgaGF2ZSBhIGBjb2RlYCBwcm9wZXJ0eSBhbmQgcG9zc2libHkgYSBgbWVzc2FnZWBcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgJCRlcnJvcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgJGxvZy5lcnJvcihlcnIpO1xuICAgICAgICAgIHRoaXMuJGRlc3Ryb3koZXJyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBJRCBmb3IgYSBnaXZlbiByZWNvcmRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHJlY1xuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHxudWxsfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICAkJGdldEtleTogZnVuY3Rpb24ocmVjKSB7XG4gICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNPYmplY3QocmVjKT8gcmVjLiRpZCA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgcGxhY2VtZW50IG9mIHJlY3MgaW4gdGhlIGFycmF5LCBzZW5kaW5nIG5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAqIGFuZCBvdGhlciBpbnRlcm5hbHMuIENhbGxlZCBieSB0aGUgc3luY2hyb25pemF0aW9uIHByb2Nlc3NcbiAgICAgICAgICogYWZ0ZXIgJCRhZGRlZCwgJCR1cGRhdGVkLCAkJG1vdmVkLCBhbmQgJCRyZW1vdmVkIHJldHVybiBhIHRydXRoeSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IG9uZSBvZiBjaGlsZF9hZGRlZCwgY2hpbGRfcmVtb3ZlZCwgY2hpbGRfbW92ZWQsIG9yIGNoaWxkX2NoYW5nZWRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHJlY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZXZDaGlsZF1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgJCRwcm9jZXNzOiBmdW5jdGlvbihldmVudCwgcmVjLCBwcmV2Q2hpbGQpIHtcbiAgICAgICAgICB2YXIga2V5ID0gdGhpcy4kJGdldEtleShyZWMpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGN1clBvcztcbiAgICAgICAgICBzd2l0Y2goZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkX2FkZGVkJzpcbiAgICAgICAgICAgICAgY3VyUG9zID0gdGhpcy4kaW5kZXhGb3Ioa2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjaGlsZF9tb3ZlZCc6XG4gICAgICAgICAgICAgIGN1clBvcyA9IHRoaXMuJGluZGV4Rm9yKGtleSk7XG4gICAgICAgICAgICAgIHRoaXMuX3NwbGljZU91dChrZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NoaWxkX3JlbW92ZWQnOlxuICAgICAgICAgICAgICAvLyByZW1vdmUgcmVjb3JkIGZyb20gdGhlIGFycmF5XG4gICAgICAgICAgICAgIGNoYW5nZWQgPSB0aGlzLl9zcGxpY2VPdXQoa2V5KSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjaGlsZF9jaGFuZ2VkJzpcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV2ZW50IHR5cGU6ICcgKyBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCBhbmd1bGFyLmlzRGVmaW5lZChjdXJQb3MpICkge1xuICAgICAgICAgICAgLy8gYWRkIGl0IHRvIHRoZSBhcnJheVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuX2FkZEFmdGVyKHJlYywgcHJldkNoaWxkKSAhPT0gY3VyUG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiggY2hhbmdlZCApIHtcbiAgICAgICAgICAgIC8vIHNlbmQgbm90aWZpY2F0aW9ucyB0byBhbnlib2R5IG1vbml0b3JpbmcgJHdhdGNoXG4gICAgICAgICAgICB0aGlzLiQkbm90aWZ5KGV2ZW50LCBrZXksIHByZXZDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIHRyaWdnZXIgbm90aWZpY2F0aW9ucyBmb3IgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgdXNpbmcgJHdhdGNoLiBUaGlzIG1ldGhvZCBpc1xuICAgICAgICAgKiB0eXBpY2FsbHkgaW52b2tlZCBpbnRlcm5hbGx5IGJ5IHRoZSAkJHByb2Nlc3MgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZXZDaGlsZF1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgJCRub3RpZnk6IGZ1bmN0aW9uKGV2ZW50LCBrZXksIHByZXZDaGlsZCkge1xuICAgICAgICAgIHZhciBldmVudERhdGEgPSB7ZXZlbnQ6IGV2ZW50LCBrZXk6IGtleX07XG4gICAgICAgICAgaWYoIGFuZ3VsYXIuaXNEZWZpbmVkKHByZXZDaGlsZCkgKSB7XG4gICAgICAgICAgICBldmVudERhdGEucHJldkNoaWxkID0gcHJldkNoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2godGhpcy5fb2JzZXJ2ZXJzLCBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgICAgICAgcGFydHNbMF0uY2FsbChwYXJ0c1sxXSwgZXZlbnREYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBpbnNlcnQgYSBuZXcgcmVjb3JkIGludG8gdGhlIGFycmF5IGF0IGEgc3BlY2lmaWMgcG9zaXRpb24uIElmIHByZXZDaGlsZCBpc1xuICAgICAgICAgKiBudWxsLCBpcyBpbnNlcnRlZCBmaXJzdCwgaWYgcHJldkNoaWxkIGlzIG5vdCBmb3VuZCwgaXQgaXMgaW5zZXJ0ZWQgbGFzdCwgb3RoZXJ3aXNlLFxuICAgICAgICAgKiBpdCBnb2VzIGltbWVkaWF0ZWx5IGFmdGVyIHByZXZDaGlsZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHJlY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBwcmV2Q2hpbGRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hZGRBZnRlcjogZnVuY3Rpb24ocmVjLCBwcmV2Q2hpbGQpIHtcbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICBpZiggcHJldkNoaWxkID09PSBudWxsICkge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSA9IHRoaXMuJGluZGV4Rm9yKHByZXZDaGlsZCkrMTtcbiAgICAgICAgICAgIGlmKCBpID09PSAwICkgeyBpID0gdGhpcy4kbGlzdC5sZW5ndGg7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4kbGlzdC5zcGxpY2UoaSwgMCwgcmVjKTtcbiAgICAgICAgICB0aGlzLl9pbmRleENhY2hlW3RoaXMuJCRnZXRLZXkocmVjKV0gPSBpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgcmVjb3JkIGZyb20gdGhlIGFycmF5IGJ5IGNhbGxpbmcgc3BsaWNlLiBJZiB0aGUgaXRlbSBpcyBmb3VuZFxuICAgICAgICAgKiB0aGlzIG1ldGhvZCByZXR1cm5zIGl0LiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc3BsaWNlT3V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuJGluZGV4Rm9yKGtleSk7XG4gICAgICAgICAgaWYoIGkgPiAtMSApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRleENhY2hlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kbGlzdC5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhIHZhcmlhYmxlIHdoaWNoIG1heSBjb250YWluIGFuIGludGVnZXIgb3IgYW4gaXRlbSB0aGF0IGV4aXN0cyBpbiB0aGlzIGFycmF5LlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIG9yIG51bGwgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbmRleE9ySXRlbVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9yZXNvbHZlSXRlbTogZnVuY3Rpb24oaW5kZXhPckl0ZW0pIHtcbiAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuJGxpc3Q7XG4gICAgICAgICAgaWYoIGFuZ3VsYXIuaXNOdW1iZXIoaW5kZXhPckl0ZW0pICYmIGluZGV4T3JJdGVtID49IDAgJiYgbGlzdC5sZW5ndGggPj0gaW5kZXhPckl0ZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdFtpbmRleE9ySXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIGFuZ3VsYXIuaXNPYmplY3QoaW5kZXhPckl0ZW0pICkge1xuICAgICAgICAgICAgLy8gaXQgbXVzdCBiZSBhbiBpdGVtIGluIHRoaXMgYXJyYXk7IGl0J3Mgbm90IHN1ZmZpY2llbnQgZm9yIGl0IGp1c3QgdG8gaGF2ZVxuICAgICAgICAgICAgLy8gYSAkaWQgb3IgZXZlbiBhICRpZCB0aGF0IGlzIGluIHRoZSBhcnJheSwgaXQgbXVzdCBiZSBhbiBhY3R1YWwgcmVjb3JkXG4gICAgICAgICAgICAvLyB0aGUgZmFzdGVzdCB3YXkgdG8gZGV0ZXJtaW5lIHRoaXMgaXMgdG8gdXNlICRnZXRSZWNvcmQgKHRvIGF2b2lkIGl0ZXJhdGluZyBhbGwgcmVjcylcbiAgICAgICAgICAgIC8vIGFuZCBjb21wYXJlIHRoZSB0d29cbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLiQkZ2V0S2V5KGluZGV4T3JJdGVtKTtcbiAgICAgICAgICAgIHZhciByZWMgPSB0aGlzLiRnZXRSZWNvcmQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiByZWMgPT09IGluZGV4T3JJdGVtPyByZWMgOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3dzIGFuIGVycm9yIGlmICRkZXN0cm95IGhhcyBiZWVuIGNhbGxlZC4gU2hvdWxkIGJlIHVzZWQgZm9yIGFueSBmdW5jdGlvblxuICAgICAgICAgKiB3aGljaCB0cmllcyB0byB3cml0ZSBkYXRhIGJhY2sgdG8gJGZpcmViYXNlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYXNzZXJ0Tm90RGVzdHJveWVkOiBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICBpZiggdGhpcy5faXNEZXN0cm95ZWQgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsICcgKyBtZXRob2QgKyAnIG1ldGhvZCBvbiBhIGRlc3Ryb3llZCAkZmlyZWJhc2VBcnJheSBvYmplY3QnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBtZXRob2QgYWxsb3dzIEZpcmViYXNlQXJyYXkgdG8gYmUgaW5oZXJpdGVkIGJ5IGNoaWxkIGNsYXNzZXMuIE1ldGhvZHMgcGFzc2VkIGludG8gdGhpc1xuICAgICAgICogZnVuY3Rpb24gd2lsbCBiZSBhZGRlZCBvbnRvIHRoZSBhcnJheSdzIHByb3RvdHlwZS4gVGhleSBjYW4gb3ZlcnJpZGUgZXhpc3RpbmcgbWV0aG9kcyBhc1xuICAgICAgICogd2VsbC5cbiAgICAgICAqXG4gICAgICAgKiBJbiBhZGRpdGlvbiB0byBwYXNzaW5nIGFkZGl0aW9uYWwgbWV0aG9kcywgaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwYXNzIGluIGEgY2xhc3MgZnVuY3Rpb24uXG4gICAgICAgKiBUaGUgcHJvdG90eXBlIG9uIHRoYXQgY2xhc3MgZnVuY3Rpb24gd2lsbCBiZSBwcmVzZXJ2ZWQsIGFuZCBpdCB3aWxsIGluaGVyaXQgZnJvbVxuICAgICAgICogRmlyZWJhc2VBcnJheS4gSXQncyBhbHNvIHBvc3NpYmxlIHRvIGRvIGJvdGgsIHBhc3NpbmcgYSBjbGFzcyB0byBpbmhlcml0IGFuZCBhZGRpdGlvbmFsXG4gICAgICAgKiBtZXRob2RzIHRvIGFkZCBvbnRvIHRoZSBwcm90b3R5cGUuXG4gICAgICAgKlxuICAgICAgICogIDxwcmU+PGNvZGU+XG4gICAgICAgKiB2YXIgRXh0ZW5kZWRBcnJheSA9ICRmaXJlYmFzZUFycmF5LiRleHRlbmQoe1xuICAgICAgICogICAgLy8gYWRkIGEgbWV0aG9kIG9udG8gdGhlIHByb3RvdHlwZSB0aGF0IHN1bXMgYWxsIGl0ZW1zIGluIHRoZSBhcnJheVxuICAgICAgICogICAgZ2V0U3VtOiBmdW5jdGlvbigpIHtcbiAgICAgICAqICAgICAgIHZhciBjdCA9IDA7XG4gICAgICAgKiAgICAgICBhbmd1bGFyLmZvckVhY2godGhpcy4kbGlzdCwgZnVuY3Rpb24ocmVjKSB7IGN0ICs9IHJlYy54OyB9KTtcbiAgICAgICAgKiAgICAgIHJldHVybiBjdDtcbiAgICAgICAqICAgIH1cbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIC8vIHVzZSBvdXIgbmV3IGZhY3RvcnkgaW4gcGxhY2Ugb2YgJGZpcmViYXNlQXJyYXlcbiAgICAgICAqIHZhciBsaXN0ID0gbmV3IEV4dGVuZGVkQXJyYXkocmVmKTtcbiAgICAgICAqIDwvY29kZT48L3ByZT5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbQ2hpbGRDbGFzc10gYSBjaGlsZCBjbGFzcyB3aGljaCBzaG91bGQgaW5oZXJpdCBGaXJlYmFzZUFycmF5XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW21ldGhvZHNdIGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYWRkIG9udG8gdGhlIHByb3RvdHlwZVxuICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGNoaWxkIGNsYXNzIHN1aXRhYmxlIGZvciB1c2Ugd2l0aCAkZmlyZWJhc2UgKHRoaXMgd2lsbCBiZSBDaGlsZENsYXNzIGlmIHByb3ZpZGVkKVxuICAgICAgICogQHN0YXRpY1xuICAgICAgICovXG4gICAgICBGaXJlYmFzZUFycmF5LiRleHRlbmQgPSBmdW5jdGlvbihDaGlsZENsYXNzLCBtZXRob2RzKSB7XG4gICAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFuZ3VsYXIuaXNPYmplY3QoQ2hpbGRDbGFzcykgKSB7XG4gICAgICAgICAgbWV0aG9kcyA9IENoaWxkQ2xhc3M7XG4gICAgICAgICAgQ2hpbGRDbGFzcyA9IGZ1bmN0aW9uKHJlZikge1xuICAgICAgICAgICAgaWYoICEodGhpcyBpbnN0YW5jZW9mIENoaWxkQ2xhc3MpICkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkQ2xhc3MocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEZpcmViYXNlQXJyYXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRsaXN0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRmaXJlYmFzZVV0aWxzLmluaGVyaXQoQ2hpbGRDbGFzcywgRmlyZWJhc2VBcnJheSwgbWV0aG9kcyk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBBcnJheVN5bmNNYW5hZ2VyKGZpcmViYXNlQXJyYXkpIHtcbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveShlcnIpIHtcbiAgICAgICAgICBpZiggIXN5bmMuaXNEZXN0cm95ZWQgKSB7XG4gICAgICAgICAgICBzeW5jLmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByZWYgPSBmaXJlYmFzZUFycmF5LiRyZWYoKTtcbiAgICAgICAgICAgIHJlZi5vZmYoJ2NoaWxkX2FkZGVkJywgY3JlYXRlZCk7XG4gICAgICAgICAgICByZWYub2ZmKCdjaGlsZF9tb3ZlZCcsIG1vdmVkKTtcbiAgICAgICAgICAgIHJlZi5vZmYoJ2NoaWxkX2NoYW5nZWQnLCB1cGRhdGVkKTtcbiAgICAgICAgICAgIHJlZi5vZmYoJ2NoaWxkX3JlbW92ZWQnLCByZW1vdmVkKTtcbiAgICAgICAgICAgIGZpcmViYXNlQXJyYXkgPSBudWxsO1xuICAgICAgICAgICAgaW5pdENvbXBsZXRlKGVycnx8J2Rlc3Ryb3llZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoJGxpc3QpIHtcbiAgICAgICAgICB2YXIgcmVmID0gZmlyZWJhc2VBcnJheS4kcmVmKCk7XG5cbiAgICAgICAgICAvLyBsaXN0ZW4gZm9yIGNoYW5nZXMgYXQgdGhlIEZpcmViYXNlIGluc3RhbmNlXG4gICAgICAgICAgcmVmLm9uKCdjaGlsZF9hZGRlZCcsIGNyZWF0ZWQsIGVycm9yKTtcbiAgICAgICAgICByZWYub24oJ2NoaWxkX21vdmVkJywgbW92ZWQsIGVycm9yKTtcbiAgICAgICAgICByZWYub24oJ2NoaWxkX2NoYW5nZWQnLCB1cGRhdGVkLCBlcnJvcik7XG4gICAgICAgICAgcmVmLm9uKCdjaGlsZF9yZW1vdmVkJywgcmVtb3ZlZCwgZXJyb3IpO1xuXG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZW4gaW5pdGlhbCBsb2FkIGlzIGNvbXBsZXRlZFxuICAgICAgICAgIHJlZi5vbmNlKCd2YWx1ZScsIGZ1bmN0aW9uKHNuYXApIHtcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoc25hcC52YWwoKSkpIHtcbiAgICAgICAgICAgICAgJGxvZy53YXJuKCdTdG9yaW5nIGRhdGEgdXNpbmcgYXJyYXkgaW5kaWNlcyBpbiBGaXJlYmFzZSBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFNlZSBodHRwczovL3d3dy5maXJlYmFzZS5jb20vZG9jcy93ZWIvZ3VpZGUvdW5kZXJzdGFuZGluZy1kYXRhLmh0bWwjc2VjdGlvbi1hcnJheXMtaW4tZmlyZWJhc2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluaXRDb21wbGV0ZShudWxsLCAkbGlzdCk7XG4gICAgICAgICAgfSwgaW5pdENvbXBsZXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGwgaW5pdENvbXBsZXRlKCksIGRvIG5vdCBjYWxsIHRoaXMgZGlyZWN0bHlcbiAgICAgICAgZnVuY3Rpb24gX2luaXRDb21wbGV0ZShlcnIsIHJlc3VsdCkge1xuICAgICAgICAgIGlmKCAhaXNSZXNvbHZlZCApIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYoIGVyciApIHsgZGVmLnJlamVjdChlcnIpOyB9XG4gICAgICAgICAgICBlbHNlIHsgZGVmLnJlc29sdmUocmVzdWx0KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWYgICAgID0gJGZpcmViYXNlVXRpbHMuZGVmZXIoKTtcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmdW5jdGlvbihzbmFwLCBwcmV2Q2hpbGQpIHtcbiAgICAgICAgICB3YWl0Rm9yUmVzb2x1dGlvbihmaXJlYmFzZUFycmF5LiQkYWRkZWQoc25hcCwgcHJldkNoaWxkKSwgZnVuY3Rpb24ocmVjKSB7XG4gICAgICAgICAgICBmaXJlYmFzZUFycmF5LiQkcHJvY2VzcygnY2hpbGRfYWRkZWQnLCByZWMsIHByZXZDaGlsZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1cGRhdGVkID0gZnVuY3Rpb24oc25hcCkge1xuICAgICAgICAgIHZhciByZWMgPSBmaXJlYmFzZUFycmF5LiRnZXRSZWNvcmQoJGZpcmViYXNlVXRpbHMuZ2V0S2V5KHNuYXApKTtcbiAgICAgICAgICBpZiggcmVjICkge1xuICAgICAgICAgICAgd2FpdEZvclJlc29sdXRpb24oZmlyZWJhc2VBcnJheS4kJHVwZGF0ZWQoc25hcCksIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBmaXJlYmFzZUFycmF5LiQkcHJvY2VzcygnY2hpbGRfY2hhbmdlZCcsIHJlYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb3ZlZCAgID0gZnVuY3Rpb24oc25hcCwgcHJldkNoaWxkKSB7XG4gICAgICAgICAgdmFyIHJlYyA9IGZpcmViYXNlQXJyYXkuJGdldFJlY29yZCgkZmlyZWJhc2VVdGlscy5nZXRLZXkoc25hcCkpO1xuICAgICAgICAgIGlmKCByZWMgKSB7XG4gICAgICAgICAgICB3YWl0Rm9yUmVzb2x1dGlvbihmaXJlYmFzZUFycmF5LiQkbW92ZWQoc25hcCwgcHJldkNoaWxkKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGZpcmViYXNlQXJyYXkuJCRwcm9jZXNzKCdjaGlsZF9tb3ZlZCcsIHJlYywgcHJldkNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBmdW5jdGlvbihzbmFwKSB7XG4gICAgICAgICAgdmFyIHJlYyA9IGZpcmViYXNlQXJyYXkuJGdldFJlY29yZCgkZmlyZWJhc2VVdGlscy5nZXRLZXkoc25hcCkpO1xuICAgICAgICAgIGlmKCByZWMgKSB7XG4gICAgICAgICAgICB3YWl0Rm9yUmVzb2x1dGlvbihmaXJlYmFzZUFycmF5LiQkcmVtb3ZlZChzbmFwKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICBmaXJlYmFzZUFycmF5LiQkcHJvY2VzcygnY2hpbGRfcmVtb3ZlZCcsIHJlYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gd2FpdEZvclJlc29sdXRpb24obWF5YmVQcm9taXNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gJHEud2hlbihtYXliZVByb21pc2UpO1xuICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgcmVzb2x1dGlvblByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc29sdXRpb25Qcm9taXNlcyA9IFtdO1xuICAgICAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgICA9ICRmaXJlYmFzZVV0aWxzLmJhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIF9pbml0Q29tcGxldGUoZXJyKTtcbiAgICAgICAgICBpZiggZmlyZWJhc2VBcnJheSApIHtcbiAgICAgICAgICAgIGZpcmViYXNlQXJyYXkuJCRlcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbml0Q29tcGxldGUgPSAkZmlyZWJhc2VVdGlscy5iYXRjaChfaW5pdENvbXBsZXRlKTtcblxuICAgICAgICB2YXIgc3luYyA9IHtcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgICAgICBpbml0OiBpbml0LFxuICAgICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZi5wcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocmVzb2x1dGlvblByb21pc2VzKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTsgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzeW5jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRmlyZWJhc2VBcnJheTtcbiAgICB9XG4gIF0pO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBhbmd1bGFyLm1vZHVsZSgnZmlyZWJhc2UnKS5mYWN0b3J5KCckRmlyZWJhc2VBcnJheScsIFsnJGxvZycsICckZmlyZWJhc2VBcnJheScsXG4gICAgZnVuY3Rpb24oJGxvZywgJGZpcmViYXNlQXJyYXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy53YXJuKCckRmlyZWJhc2VBcnJheSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgJGZpcmViYXNlQXJyYXkgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuICRmaXJlYmFzZUFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgXSk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIEZpcmViYXNlQXV0aDtcblxuICAvLyBEZWZpbmUgYSBzZXJ2aWNlIHdoaWNoIHByb3ZpZGVzIHVzZXIgYXV0aGVudGljYXRpb24gYW5kIG1hbmFnZW1lbnQuXG4gIGFuZ3VsYXIubW9kdWxlKCdmaXJlYmFzZScpLmZhY3RvcnkoJyRmaXJlYmFzZUF1dGgnLCBbXG4gICAgJyRxJywgJyRmaXJlYmFzZVV0aWxzJywgZnVuY3Rpb24oJHEsICRmaXJlYmFzZVV0aWxzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZmFjdG9yeSByZXR1cm5zIGFuIG9iamVjdCBhbGxvd2luZyB5b3UgdG8gbWFuYWdlIHRoZSBjbGllbnQncyBhdXRoZW50aWNhdGlvbiBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ZpcmViYXNlfSByZWYgQSBGaXJlYmFzZSByZWZlcmVuY2UgdG8gYXV0aGVudGljYXRlLlxuICAgICAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBtZXRob2RzIGZvciBhdXRoZW50aWNhdGluZyBjbGllbnRzLCByZXRyaWV2aW5nXG4gICAgICAgKiBhdXRoZW50aWNhdGlvbiBzdGF0ZSwgYW5kIG1hbmFnaW5nIHVzZXJzLlxuICAgICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgIHZhciBhdXRoID0gbmV3IEZpcmViYXNlQXV0aCgkcSwgJGZpcmViYXNlVXRpbHMsIHJlZik7XG4gICAgICAgIHJldHVybiBhdXRoLmNvbnN0cnVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIF0pO1xuXG4gIEZpcmViYXNlQXV0aCA9IGZ1bmN0aW9uKCRxLCAkZmlyZWJhc2VVdGlscywgcmVmKSB7XG4gICAgdGhpcy5fcSA9ICRxO1xuICAgIHRoaXMuX3V0aWxzID0gJGZpcmViYXNlVXRpbHM7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgRmlyZWJhc2UgcmVmZXJlbmNlIGluc3RlYWQgb2YgYSBVUkwgd2hlbiBjcmVhdGluZyBhIGAkZmlyZWJhc2VBdXRoYCBvYmplY3QuJyk7XG4gICAgfVxuICAgIHRoaXMuX3JlZiA9IHJlZjtcbiAgICB0aGlzLl9pbml0aWFsQXV0aFJlc29sdmVyID0gdGhpcy5faW5pdEF1dGhSZXNvbHZlcigpO1xuICB9O1xuXG4gIEZpcmViYXNlQXV0aC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29iamVjdCA9IHtcbiAgICAgICAgLy8gQXV0aGVudGljYXRpb24gbWV0aG9kc1xuICAgICAgICAkYXV0aFdpdGhDdXN0b21Ub2tlbjogdGhpcy5hdXRoV2l0aEN1c3RvbVRva2VuLmJpbmQodGhpcyksXG4gICAgICAgICRhdXRoQW5vbnltb3VzbHk6IHRoaXMuYXV0aEFub255bW91c2x5LmJpbmQodGhpcyksXG4gICAgICAgICRhdXRoV2l0aFBhc3N3b3JkOiB0aGlzLmF1dGhXaXRoUGFzc3dvcmQuYmluZCh0aGlzKSxcbiAgICAgICAgJGF1dGhXaXRoT0F1dGhQb3B1cDogdGhpcy5hdXRoV2l0aE9BdXRoUG9wdXAuYmluZCh0aGlzKSxcbiAgICAgICAgJGF1dGhXaXRoT0F1dGhSZWRpcmVjdDogdGhpcy5hdXRoV2l0aE9BdXRoUmVkaXJlY3QuYmluZCh0aGlzKSxcbiAgICAgICAgJGF1dGhXaXRoT0F1dGhUb2tlbjogdGhpcy5hdXRoV2l0aE9BdXRoVG9rZW4uYmluZCh0aGlzKSxcbiAgICAgICAgJHVuYXV0aDogdGhpcy51bmF1dGguYmluZCh0aGlzKSxcblxuICAgICAgICAvLyBBdXRoZW50aWNhdGlvbiBzdGF0ZSBtZXRob2RzXG4gICAgICAgICRvbkF1dGg6IHRoaXMub25BdXRoLmJpbmQodGhpcyksXG4gICAgICAgICRnZXRBdXRoOiB0aGlzLmdldEF1dGguYmluZCh0aGlzKSxcbiAgICAgICAgJHJlcXVpcmVBdXRoOiB0aGlzLnJlcXVpcmVBdXRoLmJpbmQodGhpcyksXG4gICAgICAgICR3YWl0Rm9yQXV0aDogdGhpcy53YWl0Rm9yQXV0aC5iaW5kKHRoaXMpLFxuXG4gICAgICAgIC8vIFVzZXIgbWFuYWdlbWVudCBtZXRob2RzXG4gICAgICAgICRjcmVhdGVVc2VyOiB0aGlzLmNyZWF0ZVVzZXIuYmluZCh0aGlzKSxcbiAgICAgICAgJGNoYW5nZVBhc3N3b3JkOiB0aGlzLmNoYW5nZVBhc3N3b3JkLmJpbmQodGhpcyksXG4gICAgICAgICRjaGFuZ2VFbWFpbDogdGhpcy5jaGFuZ2VFbWFpbC5iaW5kKHRoaXMpLFxuICAgICAgICAkcmVtb3ZlVXNlcjogdGhpcy5yZW1vdmVVc2VyLmJpbmQodGhpcyksXG4gICAgICAgICRyZXNldFBhc3N3b3JkOiB0aGlzLnJlc2V0UGFzc3dvcmQuYmluZCh0aGlzKVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdDtcbiAgICB9LFxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyogIEF1dGhlbnRpY2F0aW9uICAqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEF1dGhlbnRpY2F0ZXMgdGhlIEZpcmViYXNlIHJlZmVyZW5jZSB3aXRoIGEgY3VzdG9tIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhUb2tlbiBBbiBhdXRoZW50aWNhdGlvbiB0b2tlbiBvciBhIEZpcmViYXNlIFNlY3JldC4gQSBGaXJlYmFzZSBTZWNyZXRcbiAgICAgKiBzaG91bGQgb25seSBiZSB1c2VkIGZvciBhdXRoZW50aWNhdGluZyBhIHNlcnZlciBwcm9jZXNzIGFuZCBwcm92aWRlcyBmdWxsIHJlYWQgLyB3cml0ZVxuICAgICAqIGFjY2VzcyB0byB0aGUgZW50aXJlIEZpcmViYXNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9uYWwgY2xpZW50IGFyZ3VtZW50cywgc3VjaCBhcyBjb25maWd1cmluZ1xuICAgICAqIHNlc3Npb24gcGVyc2lzdGVuY2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgZnVsZmlsbGVkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXV0aGVudGljYXRpb24gZGF0YS5cbiAgICAgKi9cbiAgICBhdXRoV2l0aEN1c3RvbVRva2VuOiBmdW5jdGlvbihhdXRoVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuX3EuZGVmZXIoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcmVmLmF1dGhXaXRoQ3VzdG9tVG9rZW4oYXV0aFRva2VuLCB0aGlzLl91dGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZmVycmVkKSwgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgRmlyZWJhc2UgcmVmZXJlbmNlIGFub255bW91c2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25hbCBjbGllbnQgYXJndW1lbnRzLCBzdWNoIGFzIGNvbmZpZ3VyaW5nXG4gICAgICogc2Vzc2lvbiBwZXJzaXN0ZW5jZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhdXRoZW50aWNhdGlvbiBkYXRhLlxuICAgICAqL1xuICAgIGF1dGhBbm9ueW1vdXNseTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGRlZmVycmVkID0gdGhpcy5fcS5kZWZlcigpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9yZWYuYXV0aEFub255bW91c2x5KHRoaXMuX3V0aWxzLm1ha2VOb2RlUmVzb2x2ZXIoZGVmZXJyZWQpLCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBGaXJlYmFzZSByZWZlcmVuY2Ugd2l0aCBhbiBlbWFpbC9wYXNzd29yZCB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNyZWRlbnRpYWxzIEFuIG9iamVjdCBjb250YWluaW5nIGVtYWlsIGFuZCBwYXNzd29yZCBhdHRyaWJ1dGVzIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB0byB0aGUgdXNlciBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9uYWwgY2xpZW50IGFyZ3VtZW50cywgc3VjaCBhcyBjb25maWd1cmluZ1xuICAgICAqIHNlc3Npb24gcGVyc2lzdGVuY2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgZnVsZmlsbGVkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXV0aGVudGljYXRpb24gZGF0YS5cbiAgICAgKi9cbiAgICBhdXRoV2l0aFBhc3N3b3JkOiBmdW5jdGlvbihjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgdmFyIGRlZmVycmVkID0gdGhpcy5fcS5kZWZlcigpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9yZWYuYXV0aFdpdGhQYXNzd29yZChjcmVkZW50aWFscywgdGhpcy5fdXRpbHMubWFrZU5vZGVSZXNvbHZlcihkZWZlcnJlZCksIG9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF1dGhlbnRpY2F0ZXMgdGhlIEZpcmViYXNlIHJlZmVyZW5jZSB3aXRoIHRoZSBPQXV0aCBwb3B1cCBmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyIFRoZSB1bmlxdWUgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBPQXV0aCBwcm92aWRlciB0byBhdXRoZW50aWNhdGVcbiAgICAgKiB3aXRoLCBlLmcuIGdvb2dsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIGNsaWVudCBhcmd1bWVudHMsIHN1Y2ggYXMgY29uZmlndXJpbmdcbiAgICAgKiBzZXNzaW9uIHBlcnNpc3RlbmNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGF1dGhlbnRpY2F0aW9uIGRhdGEuXG4gICAgICovXG4gICAgYXV0aFdpdGhPQXV0aFBvcHVwOiBmdW5jdGlvbihwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgdmFyIGRlZmVycmVkID0gdGhpcy5fcS5kZWZlcigpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9yZWYuYXV0aFdpdGhPQXV0aFBvcHVwKHByb3ZpZGVyLCB0aGlzLl91dGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZmVycmVkKSwgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgRmlyZWJhc2UgcmVmZXJlbmNlIHdpdGggdGhlIE9BdXRoIHJlZGlyZWN0IGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXIgVGhlIHVuaXF1ZSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIE9BdXRoIHByb3ZpZGVyIHRvIGF1dGhlbnRpY2F0ZVxuICAgICAqIHdpdGgsIGUuZy4gZ29vZ2xlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9uYWwgY2xpZW50IGFyZ3VtZW50cywgc3VjaCBhcyBjb25maWd1cmluZ1xuICAgICAqIHNlc3Npb24gcGVyc2lzdGVuY2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgZnVsZmlsbGVkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXV0aGVudGljYXRpb24gZGF0YS5cbiAgICAgKi9cbiAgICBhdXRoV2l0aE9BdXRoUmVkaXJlY3Q6IGZ1bmN0aW9uKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLl9xLmRlZmVyKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3JlZi5hdXRoV2l0aE9BdXRoUmVkaXJlY3QocHJvdmlkZXIsIHRoaXMuX3V0aWxzLm1ha2VOb2RlUmVzb2x2ZXIoZGVmZXJyZWQpLCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBGaXJlYmFzZSByZWZlcmVuY2Ugd2l0aCBhbiBPQXV0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlciBUaGUgdW5pcXVlIHN0cmluZyBpZGVudGlmeWluZyB0aGUgT0F1dGggcHJvdmlkZXIgdG8gYXV0aGVudGljYXRlXG4gICAgICogd2l0aCwgZS5nLiBnb29nbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBjcmVkZW50aWFscyBFaXRoZXIgYSBzdHJpbmcsIHN1Y2ggYXMgYW4gT0F1dGggMi4wIGFjY2VzcyB0b2tlbiwgb3IgYW5cbiAgICAgKiBPYmplY3Qgb2Yga2V5IC8gdmFsdWUgcGFpcnMsIHN1Y2ggYXMgYSBzZXQgb2YgT0F1dGggMS4wYSBjcmVkZW50aWFscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIGNsaWVudCBhcmd1bWVudHMsIHN1Y2ggYXMgY29uZmlndXJpbmdcbiAgICAgKiBzZXNzaW9uIHBlcnNpc3RlbmNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGF1dGhlbnRpY2F0aW9uIGRhdGEuXG4gICAgICovXG4gICAgYXV0aFdpdGhPQXV0aFRva2VuOiBmdW5jdGlvbihwcm92aWRlciwgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuX3EuZGVmZXIoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcmVmLmF1dGhXaXRoT0F1dGhUb2tlbihwcm92aWRlciwgY3JlZGVudGlhbHMsIHRoaXMuX3V0aWxzLm1ha2VOb2RlUmVzb2x2ZXIoZGVmZXJyZWQpLCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmF1dGhlbnRpY2F0ZXMgdGhlIEZpcmViYXNlIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICB1bmF1dGg6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZ2V0QXV0aCgpICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3JlZi51bmF1dGgoKTtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyogIEF1dGhlbnRpY2F0aW9uIFN0YXRlICAqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBmaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgd2l0aCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBkYXRhIGV2ZXJ5IHRpbWVcbiAgICAgKiB0aGUgYXV0aGVudGljYXRpb24gZGF0YSBjaGFuZ2VzLiBJdCBhbHNvIGZpcmVzIGFzIHNvb24gYXMgdGhlIGF1dGhlbnRpY2F0aW9uIGRhdGEgaXNcbiAgICAgKiByZXRyaWV2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQSBjYWxsYmFjayB0aGF0IGZpcmVzIHdoZW4gdGhlIGNsaWVudCdzIGF1dGhlbnRpY2F0ZSBzdGF0ZVxuICAgICAqIGNoYW5nZXMuIElmIGF1dGhlbnRpY2F0ZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIHBhc3NlZCBhbiBvYmplY3QgY29udGFpbmluZyBhdXRoZW50aWNhdGlvblxuICAgICAqIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlciB1c2VkIHRvIGF1dGhlbnRpY2F0ZS4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIHBhc3NlZCBudWxsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dF0gSWYgcHJvdmlkZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyB0aGlzIHdoZW4gY2FsbGluZyB5b3VyXG4gICAgICogY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IEEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gZGVyZWdpc3RlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICovXG4gICAgb25BdXRoOiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgZm4gPSB0aGlzLl91dGlscy5kZWJvdW5jZShjYWxsYmFjaywgY29udGV4dCwgMCk7XG4gICAgICB0aGlzLl9yZWYub25BdXRoKGZuKTtcblxuICAgICAgLy8gUmV0dXJuIGEgbWV0aG9kIHRvIGRldGFjaCB0aGUgYG9uQXV0aCgpYCBjYWxsYmFjay5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fcmVmLm9mZkF1dGgoZm4pO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXRyaWV2ZXMgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsaWVudCdzIGF1dGhlbnRpY2F0aW9uIGRhdGEuXG4gICAgICovXG4gICAgZ2V0QXV0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVmLmdldEF1dGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG9uQXV0aCgpIGNhbGxiYWNrIG1ldGhvZCBmb3IgdGhlIHR3byByb3V0ZXItcmVsYXRlZCBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZWplY3RJZkF1dGhEYXRhSXNOdWxsIERldGVybWluZXMgaWYgdGhlIHJldHVybmVkIHByb21pc2Ugc2hvdWxkIGJlXG4gICAgICogcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdXBvbiBhbiB1bmF1dGhlbnRpY2F0ZWQgY2xpZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSBjbGllbnQncyBhdXRoZW50aWNhdGlvbiBzdGF0ZSBvclxuICAgICAqIHJlamVjdGVkIGlmIHRoZSBjbGllbnQgaXMgdW5hdXRoZW50aWNhdGVkIGFuZCByZWplY3RJZkF1dGhEYXRhSXNOdWxsIGlzIHRydWUuXG4gICAgICovXG4gICAgX3JvdXRlck1ldGhvZE9uQXV0aFByb21pc2U6IGZ1bmN0aW9uKHJlamVjdElmQXV0aERhdGFJc051bGwpIHtcbiAgICAgIHZhciByZWYgPSB0aGlzLl9yZWYsIHV0aWxzID0gdGhpcy5fdXRpbHM7XG4gICAgICAvLyB3YWl0IGZvciB0aGUgaW5pdGlhbCBhdXRoIHN0YXRlIHRvIHJlc29sdmU7IG9uIHBhZ2UgbG9hZCB3ZSBoYXZlIHRvIHJlcXVlc3QgYXV0aCBzdGF0ZVxuICAgICAgLy8gYXN5bmNocm9ub3VzbHkgc28gd2UgZG9uJ3Qgd2FudCB0byByZXNvbHZlIHJvdXRlciBtZXRob2RzIG9yIGZsYXNoIHRoZSB3cm9uZyBzdGF0ZVxuICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxBdXRoUmVzb2x2ZXIudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYXV0aCBzdGF0ZSBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUgc28gcmF0aGVyIHRoYW4gZGVwZW5kIG9uIHRoZSBpbml0aWFsbHkgcmVzb2x2ZWQgc3RhdGVcbiAgICAgICAgLy8gd2UgYWxzbyBjaGVjayB0aGUgYXV0aCBkYXRhIChzeW5jaHJvbm91c2x5KSBpZiBhIG5ldyBwcm9taXNlIGlzIHJlcXVlc3RlZCwgZW5zdXJpbmcgd2UgcmVzb2x2ZVxuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBhdXRoIHN0YXRlIGFuZCBub3QgYSBzdGFsZS9pbml0aWFsIHN0YXRlXG4gICAgICAgIHZhciBhdXRoRGF0YSA9IHJlZi5nZXRBdXRoKCksIHJlcyA9IG51bGw7XG4gICAgICAgIGlmIChyZWplY3RJZkF1dGhEYXRhSXNOdWxsICYmIGF1dGhEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzID0gdXRpbHMucmVqZWN0KFwiQVVUSF9SRVFVSVJFRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXMgPSB1dGlscy5yZXNvbHZlKGF1dGhEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0aGF0IHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGluaXRpYWwgYXV0aCBzdGF0ZSBoYXMgYmVlblxuICAgICAqIGZldGNoZWQgZnJvbSB0aGUgRmlyZWJhc2Ugc2VydmVyLiBUaGlzIG5ldmVyIHJlamVjdHMgYW5kIHJlc29sdmVzIHRvIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgcmV0dXJucyBpbml0aWFsIGF1dGggc3RhdGUuXG4gICAgICovXG4gICAgX2luaXRBdXRoUmVzb2x2ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlZiA9IHRoaXMuX3JlZjtcbiAgICAgIHJldHVybiB0aGlzLl91dGlscy5wcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICAgICAgLy8gVHVybiBvZmYgdGhpcyBvbkF1dGgoKSBjYWxsYmFjayBzaW5jZSB3ZSBqdXN0IG5lZWRlZCB0byBnZXQgdGhlIGF1dGhlbnRpY2F0aW9uIGRhdGEgb25jZS5cbiAgICAgICAgICByZWYub2ZmQXV0aChjYWxsYmFjayk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlZi5vbkF1dGgoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIHdoaWNoIGNhbiBiZSB1c2VkIGluIGEgcm91dGUncyByZXNvbHZlKCkgbWV0aG9kIHRvIHJlcXVpcmUgdGhhdCBhIHJvdXRlIGhhc1xuICAgICAqIGEgbG9nZ2VkIGluIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB0aGUgY2xpZW50J3MgY3VycmVudCBhdXRoZW50aWNhdGlvblxuICAgICAqIHN0YXRlIG9yIHJlamVjdGVkIGlmIHRoZSBjbGllbnQgaXMgbm90IGF1dGhlbnRpY2F0ZWQuXG4gICAgICovXG4gICAgcmVxdWlyZUF1dGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlck1ldGhvZE9uQXV0aFByb21pc2UodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIHdoaWNoIGNhbiBiZSB1c2VkIGluIGEgcm91dGUncyByZXNvbHZlKCkgbWV0aG9kIHRvIGdyYWIgdGhlIGN1cnJlbnRcbiAgICAgKiBhdXRoZW50aWNhdGlvbiBkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSBBIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdGhlIGNsaWVudCdzIGN1cnJlbnQgYXV0aGVudGljYXRpb25cbiAgICAgKiBzdGF0ZSwgd2hpY2ggd2lsbCBiZSBudWxsIGlmIHRoZSBjbGllbnQgaXMgbm90IGF1dGhlbnRpY2F0ZWQuXG4gICAgICovXG4gICAgd2FpdEZvckF1dGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlck1ldGhvZE9uQXV0aFByb21pc2UoZmFsc2UpO1xuICAgIH0sXG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyogIFVzZXIgTWFuYWdlbWVudCAgKi9cbiAgICAvKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZW1haWwvcGFzc3dvcmQgdXNlci4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gb25seSBjcmVhdGVzIHRoZSB1c2VyLCBpZiB5b3VcbiAgICAgKiB3aXNoIHRvIGxvZyBpbiBhcyB0aGUgbmV3bHkgY3JlYXRlZCB1c2VyLCBjYWxsICRhdXRoV2l0aFBhc3N3b3JkKCkgYWZ0ZXIgdGhlIHByb21pc2UgZm9yXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGJlZW4gcmVzb2x2ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3JlZGVudGlhbHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVtYWlsIGFuZCBwYXNzd29yZCBvZiB0aGUgdXNlciB0byBjcmVhdGUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdGhlIHVzZXIgb2JqZWN0LCB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiB1aWQgb2YgdGhlIGNyZWF0ZWQgdXNlci5cbiAgICAgKi9cbiAgICBjcmVhdGVVc2VyOiBmdW5jdGlvbihjcmVkZW50aWFscykge1xuICAgICAgdmFyIGRlZmVycmVkID0gdGhpcy5fcS5kZWZlcigpO1xuXG4gICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiB0aGV5IGFyZSB0cnlpbmcgdG8gcGFzcyBpbiBzZXBhcmF0ZSBzdHJpbmcgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGNyZWRlbnRpYWxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRjcmVhdGVVc2VyKCkgZXhwZWN0cyBhbiBvYmplY3QgY29udGFpbmluZyAnZW1haWwnIGFuZCAncGFzc3dvcmQnLCBidXQgZ290IGEgc3RyaW5nLlwiKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcmVmLmNyZWF0ZVVzZXIoY3JlZGVudGlhbHMsIHRoaXMuX3V0aWxzLm1ha2VOb2RlUmVzb2x2ZXIoZGVmZXJyZWQpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBwYXNzd29yZCBmb3IgYW4gZW1haWwvcGFzc3dvcmQgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjcmVkZW50aWFscyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZW1haWwsIG9sZCBwYXNzd29yZCwgYW5kIG5ldyBwYXNzd29yZCBvZlxuICAgICAqIHRoZSB1c2VyIHdob3NlIHBhc3N3b3JkIGlzIHRvIGNoYW5nZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPD59IEFuIGVtcHR5IHByb21pc2UgZnVsZmlsbGVkIG9uY2UgdGhlIHBhc3N3b3JkIGNoYW5nZSBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBjaGFuZ2VQYXNzd29yZDogZnVuY3Rpb24oY3JlZGVudGlhbHMpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuX3EuZGVmZXIoKTtcblxuICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhleSBhcmUgdHJ5aW5nIHRvIHBhc3MgaW4gc2VwYXJhdGUgc3RyaW5nIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBjcmVkZW50aWFscyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkY2hhbmdlUGFzc3dvcmQoKSBleHBlY3RzIGFuIG9iamVjdCBjb250YWluaW5nICdlbWFpbCcsICdvbGRQYXNzd29yZCcsIGFuZCAnbmV3UGFzc3dvcmQnLCBidXQgZ290IGEgc3RyaW5nLlwiKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcmVmLmNoYW5nZVBhc3N3b3JkKGNyZWRlbnRpYWxzLCB0aGlzLl91dGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZmVycmVkKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgZW1haWwgZm9yIGFuIGVtYWlsL3Bhc3N3b3JkIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3JlZGVudGlhbHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9sZCBlbWFpbCwgbmV3IGVtYWlsLCBhbmQgcGFzc3dvcmQgb2ZcbiAgICAgKiB0aGUgdXNlciB3aG9zZSBlbWFpbCBpcyB0byBjaGFuZ2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTw+fSBBbiBlbXB0eSBwcm9taXNlIGZ1bGZpbGxlZCBvbmNlIHRoZSBlbWFpbCBjaGFuZ2UgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgY2hhbmdlRW1haWw6IGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLl9xLmRlZmVyKCk7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fcmVmLmNoYW5nZUVtYWlsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRmaXJlYmFzZUF1dGguJGNoYW5nZUVtYWlsKCkgcmVxdWlyZXMgRmlyZWJhc2UgdmVyc2lvbiAyLjEuMCBvciBncmVhdGVyLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNyZWRlbnRpYWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkY2hhbmdlRW1haWwoKSBleHBlY3RzIGFuIG9iamVjdCBjb250YWluaW5nICdvbGRFbWFpbCcsICduZXdFbWFpbCcsIGFuZCAncGFzc3dvcmQnLCBidXQgZ290IGEgc3RyaW5nLlwiKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcmVmLmNoYW5nZUVtYWlsKGNyZWRlbnRpYWxzLCB0aGlzLl91dGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZmVycmVkKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBlbWFpbC9wYXNzd29yZCB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNyZWRlbnRpYWxzIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBlbWFpbCBhbmQgcGFzc3dvcmQgb2YgdGhlIHVzZXIgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Pn0gQW4gZW1wdHkgcHJvbWlzZSBmdWxmaWxsZWQgb25jZSB0aGUgdXNlciBpcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZVVzZXI6IGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLl9xLmRlZmVyKCk7XG5cbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZXkgYXJlIHRyeWluZyB0byBwYXNzIGluIHNlcGFyYXRlIHN0cmluZyBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgY3JlZGVudGlhbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHJlbW92ZVVzZXIoKSBleHBlY3RzIGFuIG9iamVjdCBjb250YWluaW5nICdlbWFpbCcgYW5kICdwYXNzd29yZCcsIGJ1dCBnb3QgYSBzdHJpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9yZWYucmVtb3ZlVXNlcihjcmVkZW50aWFscywgdGhpcy5fdXRpbHMubWFrZU5vZGVSZXNvbHZlcihkZWZlcnJlZCkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCBlbWFpbCB0byBhbiBlbWFpbC9wYXNzd29yZCB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNyZWRlbnRpYWxzIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBlbWFpbCBvZiB0aGUgdXNlciB0byBzZW5kIGEgcmVzZXRcbiAgICAgKiBwYXNzd29yZCBlbWFpbCB0by5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPD59IEFuIGVtcHR5IHByb21pc2UgZnVsZmlsbGVkIG9uY2UgdGhlIHJlc2V0IHBhc3N3b3JkIGVtYWlsIGlzIHNlbnQuXG4gICAgICovXG4gICAgcmVzZXRQYXNzd29yZDogZnVuY3Rpb24oY3JlZGVudGlhbHMpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuX3EuZGVmZXIoKTtcblxuICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhleSBhcmUgdHJ5aW5nIHRvIHBhc3MgaW4gYSBzdHJpbmcgYXJndW1lbnRcbiAgICAgIGlmICh0eXBlb2YgY3JlZGVudGlhbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHJlc2V0UGFzc3dvcmQoKSBleHBlY3RzIGFuIG9iamVjdCBjb250YWluaW5nICdlbWFpbCcsIGJ1dCBnb3QgYSBzdHJpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9yZWYucmVzZXRQYXNzd29yZChjcmVkZW50aWFscywgdGhpcy5fdXRpbHMubWFrZU5vZGVSZXNvbHZlcihkZWZlcnJlZCkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBtYWludGFpbnMgYSBzeW5jaHJvbml6ZWQgb2JqZWN0LCB3aXRoIDItd2F5IGJpbmRpbmdzIGJldHdlZW4gQW5ndWxhciBhbmQgRmlyZWJhc2UuXG4gICAqXG4gICAqIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNsYXNzIGFyZSBjb250cmFjdGVkIHRvIHByb3ZpZGUgdGhlIGZvbGxvd2luZyBpbnRlcm5hbCBtZXRob2RzLFxuICAgKiB3aGljaCBhcmUgdXNlZCBieSB0aGUgc3luY2hyb25pemF0aW9uIHByb2Nlc3MgYW5kIDMtd2F5IGJpbmRpbmdzOlxuICAgKiAgICAkJHVwZGF0ZWQgLSBjYWxsZWQgd2hlbmV2ZXIgYSBjaGFuZ2Ugb2NjdXJzIChhIHZhbHVlIGV2ZW50IGZyb20gRmlyZWJhc2UpXG4gICAqICAgICQkZXJyb3IgLSBjYWxsZWQgd2hlbiBsaXN0ZW5lcnMgYXJlIGNhbmNlbGVkIGR1ZSB0byBhIHNlY3VyaXR5IGVycm9yXG4gICAqICAgICQkbm90aWZ5IC0gY2FsbGVkIHRvIHVwZGF0ZSAkd2F0Y2ggbGlzdGVuZXJzIGFuZCB0cmlnZ2VyIHVwZGF0ZXMgdG8gMy13YXkgYmluZGluZ3NcbiAgICogICAgJHJlZiAtIGNhbGxlZCB0byBvYnRhaW4gdGhlIHVuZGVybHlpbmcgRmlyZWJhc2UgcmVmZXJlbmNlXG4gICAqXG4gICAqIEluc3RlYWQgb2YgZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgY2xhc3MsIG9uZSBzaG91bGQgZ2VuZXJhbGx5IHVzZSB0aGUgJGV4dGVuZFxuICAgKiBtZXRob2QgdG8gYWRkIG9yIGNoYW5nZSBob3cgbWV0aG9kcyBiZWhhdmU6XG4gICAqXG4gICAqIDxwcmU+PGNvZGU+XG4gICAqIHZhciBFeHRlbmRlZE9iamVjdCA9ICRmaXJlYmFzZU9iamVjdC4kZXh0ZW5kKHtcbiAgICogICAgLy8gYWRkIGEgbmV3IG1ldGhvZCB0byB0aGUgcHJvdG90eXBlXG4gICAqICAgIGZvbzogZnVuY3Rpb24oKSB7IHJldHVybiAnYmFyJzsgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBvYmogPSBuZXcgRXh0ZW5kZWRPYmplY3QocmVmKTtcbiAgICogPC9jb2RlPjwvcHJlPlxuICAgKi9cbiAgYW5ndWxhci5tb2R1bGUoJ2ZpcmViYXNlJykuZmFjdG9yeSgnJGZpcmViYXNlT2JqZWN0JywgW1xuICAgICckcGFyc2UnLCAnJGZpcmViYXNlVXRpbHMnLCAnJGxvZycsXG4gICAgZnVuY3Rpb24oJHBhcnNlLCAkZmlyZWJhc2VVdGlscywgJGxvZykge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc3luY2hyb25pemVkIG9iamVjdCB3aXRoIDItd2F5IGJpbmRpbmdzIGJldHdlZW4gQW5ndWxhciBhbmQgRmlyZWJhc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGaXJlYmFzZX0gcmVmXG4gICAgICAgKiBAcmV0dXJucyB7RmlyZWJhc2VPYmplY3R9XG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gRmlyZWJhc2VPYmplY3QocmVmKSB7XG4gICAgICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBGaXJlYmFzZU9iamVjdCkgKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGaXJlYmFzZU9iamVjdChyZWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIGFyZSBwcml2YXRlIGNvbmZpZyBwcm9wcyBhbmQgZnVuY3Rpb25zIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICAvLyB0aGV5IGFyZSBjb2xsZWN0ZWQgaGVyZSB0byByZWR1Y2UgY2x1dHRlciBpbiBjb25zb2xlLmxvZyBhbmQgZm9yRWFjaFxuICAgICAgICB0aGlzLiQkY29uZiA9IHtcbiAgICAgICAgICAvLyBzeW5jaHJvbml6ZXMgZGF0YSB0byBGaXJlYmFzZVxuICAgICAgICAgIHN5bmM6IG5ldyBPYmplY3RTeW5jTWFuYWdlcih0aGlzLCByZWYpLFxuICAgICAgICAgIC8vIHN0b3JlcyB0aGUgRmlyZWJhc2UgcmVmXG4gICAgICAgICAgcmVmOiByZWYsXG4gICAgICAgICAgLy8gc3luY2hyb25pemVzICRzY29wZSB2YXJpYWJsZXMgd2l0aCB0aGlzIG9iamVjdFxuICAgICAgICAgIGJpbmRpbmc6IG5ldyBUaHJlZVdheUJpbmRpbmcodGhpcyksXG4gICAgICAgICAgLy8gc3RvcmVzIG9ic2VydmVycyByZWdpc3RlcmVkIHdpdGggJHdhdGNoXG4gICAgICAgICAgbGlzdGVuZXJzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoaXMgYml0IG9mIG1hZ2ljIG1ha2VzICQkY29uZiBub24tZW51bWVyYWJsZSBhbmQgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgICAvLyBhbmQgbm9uLXdyaXRhYmxlIChpdHMgcHJvcGVydGllcyBhcmUgc3RpbGwgd3JpdGFibGUgYnV0IHRoZSByZWYgY2Fubm90IGJlIHJlcGxhY2VkKVxuICAgICAgICAvLyB3ZSByZWR1bmRhbnRseSBhc3NpZ24gaXQgYWJvdmUgc28gdGhlIElERSBjYW4gcmVsYXhcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICckJGNvbmYnLCB7XG4gICAgICAgICAgdmFsdWU6IHRoaXMuJCRjb25mXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGlkID0gJGZpcmViYXNlVXRpbHMuZ2V0S2V5KHJlZi5yZWYoKSk7XG4gICAgICAgIHRoaXMuJHByaW9yaXR5ID0gbnVsbDtcblxuICAgICAgICAkZmlyZWJhc2VVdGlscy5hcHBseURlZmF1bHRzKHRoaXMsIHRoaXMuJCRkZWZhdWx0cyk7XG5cbiAgICAgICAgLy8gc3RhcnQgc3luY2hyb25pemluZyBkYXRhIHdpdGggRmlyZWJhc2VcbiAgICAgICAgdGhpcy4kJGNvbmYuc3luYy5pbml0KCk7XG4gICAgICB9XG5cbiAgICAgIEZpcmViYXNlT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmVzIGFsbCBkYXRhIG9uIHRoZSBGaXJlYmFzZU9iamVjdCBiYWNrIHRvIEZpcmViYXNlLlxuICAgICAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggd2lsbCByZXNvbHZlIGFmdGVyIHRoZSBzYXZlIGlzIGNvbXBsZXRlZC5cbiAgICAgICAgICovXG4gICAgICAgICRzYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciByZWYgPSBzZWxmLiRyZWYoKTtcbiAgICAgICAgICB2YXIgZGF0YSA9ICRmaXJlYmFzZVV0aWxzLnRvSlNPTihzZWxmKTtcbiAgICAgICAgICByZXR1cm4gJGZpcmViYXNlVXRpbHMuZG9TZXQocmVmLCBkYXRhKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi4kJG5vdGlmeSgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuJHJlZigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBrZXlzIGZyb20gdGhlIEZpcmViYXNlT2JqZWN0IGFuZCBhbHNvIHJlbW92ZXNcbiAgICAgICAgICogdGhlIHJlbW90ZSBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZSBhZnRlciB0aGUgb3AgY29tcGxldGVzXG4gICAgICAgICAqL1xuICAgICAgICAkcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgJGZpcmViYXNlVXRpbHMudHJpbUtleXMoc2VsZiwge30pO1xuICAgICAgICAgIHNlbGYuJHZhbHVlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gJGZpcmViYXNlVXRpbHMuZG9SZW1vdmUoc2VsZi4kcmVmKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLiQkbm90aWZ5KCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi4kcmVmKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2FkZWQgbWV0aG9kIGlzIGludm9rZWQgYWZ0ZXIgdGhlIGluaXRpYWwgYmF0Y2ggb2YgZGF0YSBhcnJpdmVzIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICogV2hlbiB0aGlzIHJlc29sdmVzLCBhbGwgZGF0YSB3aGljaCBleGlzdGVkIHByaW9yIHRvIGNhbGxpbmcgJGFzT2JqZWN0KCkgaXMgbm93IGNhY2hlZFxuICAgICAgICAgKiBsb2NhbGx5IGluIHRoZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFzIGEgc2hvcnRjdXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwYXNzIHJlc29sdmUvcmVqZWN0IG1ldGhvZHMgZGlyZWN0bHkgaW50byB0aGlzXG4gICAgICAgICAqIG1ldGhvZCBqdXN0IGFzIHRoZXkgd291bGQgYmUgcGFzc2VkIHRvIC50aGVuKClcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAgICAgICAgICogQHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIGFmdGVyIGluaXRpYWwgZGF0YSBpcyBkb3dubG9hZGVkIGZyb20gRmlyZWJhc2VcbiAgICAgICAgICovXG4gICAgICAgICRsb2FkZWQ6IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy4kJGNvbmYuc3luYy5yZWFkeSgpO1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyB0aGlzIG1ldGhvZCB0byBiZSBjYWxsZWQganVzdCBsaWtlIC50aGVuXG4gICAgICAgICAgICAvLyBieSBwYXNzaW5nIGFueSBhcmd1bWVudHMgb24gdG8gLnRoZW5cbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4uY2FsbChwcm9taXNlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge0ZpcmViYXNlfSB0aGUgb3JpZ2luYWwgRmlyZWJhc2UgaW5zdGFuY2UgdXNlZCB0byBjcmVhdGUgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICAkcmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJCRjb25mLnJlZjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIDMtd2F5IGRhdGEgc3luYyBiZXR3ZWVuIHRoaXMgb2JqZWN0LCB0aGUgRmlyZWJhc2Ugc2VydmVyLCBhbmQgYVxuICAgICAgICAgKiBzY29wZSB2YXJpYWJsZS4gVGhpcyBtZWFucyB0aGF0IGFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIHNjb3BlIHZhcmlhYmxlIGFyZVxuICAgICAgICAgKiBwdXNoZWQgdG8gRmlyZWJhc2UsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBzY29wZSBlbWl0cyBhICRkZXN0cm95IGV2ZW50LCB0aGUgYmluZGluZyBpcyBhdXRvbWF0aWNhbGx5IHNldmVyZWQuIE90aGVyd2lzZSxcbiAgICAgICAgICogaXQgaXMgcG9zc2libGUgdG8gdW5iaW5kIHRoZSBzY29wZSB2YXJpYWJsZSBieSB1c2luZyB0aGUgYHVuYmluZGAgZnVuY3Rpb25cbiAgICAgICAgICogcGFzc2VkIGludG8gdGhlIHJlc29sdmUgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYW4gb25seSBiZSBib3VuZCB0byBvbmUgc2NvcGUgdmFyaWFibGUgYXQgYSB0aW1lLiBJZiBhIHNlY29uZCBpcyBhdHRlbXB0ZWQsXG4gICAgICAgICAqIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNjb3BlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAgICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBhbiB1bmJpbmQgbWV0aG9kIGFmdGVyIGRhdGEgaXMgc2V0IGluIHNjb3BlXG4gICAgICAgICAqL1xuICAgICAgICAkYmluZFRvOiBmdW5jdGlvbiAoc2NvcGUsIHZhck5hbWUpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJGxvYWRlZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuJCRjb25mLmJpbmRpbmcuYmluZFRvKHNjb3BlLCB2YXJOYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuZXJzIHBhc3NlZCBpbnRvIHRoaXMgbWV0aG9kIGFyZSBub3RpZmllZCB3aGVuZXZlciBhIG5ldyBjaGFuZ2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgICogZnJvbSB0aGUgc2VydmVyLiBFYWNoIGludm9jYXRpb24gaXMgc2VudCBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAgICAgKiA8Y29kZT57IHR5cGU6ICd2YWx1ZScsIGtleTogJ215X2ZpcmViYXNlX2lkJyB9PC9jb2RlPlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIHVuYmluZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGFjaCB0aGUgbGlzdGVuZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBpbnZva2UgdG8gc3RvcCBvYnNlcnZpbmcgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICAkd2F0Y2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy4kJGNvbmYubGlzdGVuZXJzO1xuICAgICAgICAgIGxpc3QucHVzaChbY2IsIGNvbnRleHRdKTtcbiAgICAgICAgICAvLyBhbiBvZmYgZnVuY3Rpb24gZm9yIGNhbmNlbGxpbmcgdGhlIGxpc3RlbmVyXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpID0gbGlzdC5maW5kSW5kZXgoZnVuY3Rpb24gKHBhcnRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gY2IgJiYgcGFydHNbMV0gPT09IGNvbnRleHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5mb3JtcyAkZmlyZWJhc2UgdG8gc3RvcCBzZW5kaW5nIGV2ZW50cyBhbmQgY2xlYXJzIG1lbW9yeSBiZWluZyB1c2VkXG4gICAgICAgICAqIGJ5IHRoaXMgb2JqZWN0IChkZWxldGUncyBpdHMgbG9jYWwgY29udGVudCkuXG4gICAgICAgICAqL1xuICAgICAgICAkZGVzdHJveTogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIGlmICghc2VsZi4kaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHNlbGYuJGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYuJCRjb25mLnN5bmMuZGVzdHJveShlcnIpO1xuICAgICAgICAgICAgc2VsZi4kJGNvbmYuYmluZGluZy5kZXN0cm95KCk7XG4gICAgICAgICAgICAkZmlyZWJhc2VVdGlscy5lYWNoKHNlbGYsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxmW2tdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYnkgJGZpcmViYXNlIHdoZW5ldmVyIGFuIGl0ZW0gaXMgY2hhbmdlZCBhdCB0aGUgc2VydmVyLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGV4aXN0IG9uIGFueSBvYmplY3RGYWN0b3J5IHBhc3NlZCBpbnRvICRmaXJlYmFzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgc2hvdWxkIHJldHVybiB0cnVlIGlmIGFueSBjaGFuZ2VzIHdlcmUgbWFkZSwgb3RoZXJ3aXNlIGAkJG5vdGlmeWAgd2lsbFxuICAgICAgICAgKiBub3QgYmUgaW52b2tlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNuYXAgYSBGaXJlYmFzZSBzbmFwc2hvdFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFueSBjaGFuZ2VzIHdlcmUgbWFkZS5cbiAgICAgICAgICovXG4gICAgICAgICQkdXBkYXRlZDogZnVuY3Rpb24gKHNuYXApIHtcbiAgICAgICAgICAvLyBhcHBsaWVzIG5ldyBkYXRhIHRvIHRoaXMgb2JqZWN0XG4gICAgICAgICAgdmFyIGNoYW5nZWQgPSAkZmlyZWJhc2VVdGlscy51cGRhdGVSZWModGhpcywgc25hcCk7XG4gICAgICAgICAgLy8gYXBwbGllcyBhbnkgZGVmYXVsdHMgc2V0IHVzaW5nICQkZGVmYXVsdHNcbiAgICAgICAgICAkZmlyZWJhc2VVdGlscy5hcHBseURlZmF1bHRzKHRoaXMsIHRoaXMuJCRkZWZhdWx0cyk7XG4gICAgICAgICAgLy8gcmV0dXJuaW5nIHRydWUgaGVyZSBjYXVzZXMgJCRub3RpZnkgdG8gYmUgdHJpZ2dlcmVkXG4gICAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuZXZlciBhIHNlY3VyaXR5IGVycm9yIG9yIG90aGVyIHByb2JsZW0gY2F1c2VzIHRoZSBsaXN0ZW5lcnMgdG8gYmVjb21lXG4gICAgICAgICAqIGludmFsaWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFuIHVucmVjb3ZlcmFibGUgZXJyb3IuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgd2hpY2ggd2lsbCBoYXZlIGEgYGNvZGVgIHByb3BlcnR5IGFuZCBwb3NzaWJseSBhIGBtZXNzYWdlYFxuICAgICAgICAgKi9cbiAgICAgICAgJCRlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIC8vIHByaW50cyBhbiBlcnJvciB0byB0aGUgY29uc29sZSAodmlhIEFuZ3VsYXIncyBsb2dnZXIpXG4gICAgICAgICAgJGxvZy5lcnJvcihlcnIpO1xuICAgICAgICAgIC8vIGZyZWVzIG1lbW9yeSBhbmQgY2FuY2VscyBhbnkgcmVtYWluaW5nIGxpc3RlbmVyc1xuICAgICAgICAgIHRoaXMuJGRlc3Ryb3koZXJyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGludGVybmFsbHkgYnkgJGJpbmRUbyB3aGVuIGRhdGEgaXMgY2hhbmdlZCBpbiAkc2NvcGUuXG4gICAgICAgICAqIFNob3VsZCBhcHBseSB1cGRhdGVzIHRvIHRoaXMgcmVjb3JkIGJ1dCBzaG91bGQgbm90IGNhbGxcbiAgICAgICAgICogbm90aWZ5KCkuXG4gICAgICAgICAqL1xuICAgICAgICAkJHNjb3BlVXBkYXRlZDogZnVuY3Rpb24obmV3RGF0YSkge1xuICAgICAgICAgIC8vIHdlIHVzZSBhIG9uZS1kaXJlY3Rpb25hbCBsb29wIHRvIGF2b2lkIGZlZWRiYWNrIHdpdGggMy13YXkgYmluZGluZ3NcbiAgICAgICAgICAvLyBzaW5jZSBzZXQoKSBpcyBhcHBsaWVkIGxvY2FsbHkgYW55d2F5LCB0aGlzIGlzIHN0aWxsIHBlcmZvcm1hbnRcbiAgICAgICAgICB2YXIgZGVmID0gJGZpcmViYXNlVXRpbHMuZGVmZXIoKTtcbiAgICAgICAgICB0aGlzLiRyZWYoKS5zZXQoJGZpcmViYXNlVXRpbHMudG9KU09OKG5ld0RhdGEpLCAkZmlyZWJhc2VVdGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZikpO1xuICAgICAgICAgIHJldHVybiBkZWYucHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBhbnkgYm91bmQgc2NvcGUgdmFyaWFibGVzIGFuZFxuICAgICAgICAgKiBub3RpZmllcyBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCB3aXRoICR3YXRjaFxuICAgICAgICAgKi9cbiAgICAgICAgJCRub3RpZnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgbGlzdCA9IHRoaXMuJCRjb25mLmxpc3RlbmVycy5zbGljZSgpO1xuICAgICAgICAgIC8vIGJlIHN1cmUgdG8gZG8gdGhpcyBhZnRlciBzZXR0aW5nIHVwIGRhdGEgYW5kIGluaXQgc3RhdGVcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobGlzdCwgZnVuY3Rpb24gKHBhcnRzKSB7XG4gICAgICAgICAgICBwYXJ0c1swXS5jYWxsKHBhcnRzWzFdLCB7ZXZlbnQ6ICd2YWx1ZScsIGtleTogc2VsZi4kaWR9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIGhvdyBBbmd1bGFyLmZvckVhY2ggaXRlcmF0ZXMgcmVjb3JkcyBvbiB0aGlzIG9iamVjdCBzbyB0aGF0IG9ubHlcbiAgICAgICAgICogZmllbGRzIHN0b3JlZCBpbiBGaXJlYmFzZSBhcmUgcGFydCBvZiB0aGUgaXRlcmF0aW9uLiBUbyBpbmNsdWRlIG1ldGEgZmllbGRzIGxpa2VcbiAgICAgICAgICogJGlkIGFuZCAkcHJpb3JpdHkgaW4gdGhlIGl0ZXJhdGlvbiwgdXRpbGl6ZSBmb3Ioa2V5IGluIG9iaikgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uKGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuICRmaXJlYmFzZVV0aWxzLmVhY2godGhpcywgaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyBGaXJlYmFzZU9iamVjdCB0byBiZSBjb3BpZWQgaW50byBhIG5ldyBmYWN0b3J5LiBNZXRob2RzIHBhc3NlZCBpbnRvIHRoaXNcbiAgICAgICAqIGZ1bmN0aW9uIHdpbGwgYmUgYWRkZWQgb250byB0aGUgb2JqZWN0J3MgcHJvdG90eXBlLiBUaGV5IGNhbiBvdmVycmlkZSBleGlzdGluZyBtZXRob2RzIGFzXG4gICAgICAgKiB3ZWxsLlxuICAgICAgICpcbiAgICAgICAqIEluIGFkZGl0aW9uIHRvIHBhc3NpbmcgYWRkaXRpb25hbCBtZXRob2RzLCBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgaW4gYSBjbGFzcyBmdW5jdGlvbi5cbiAgICAgICAqIFRoZSBwcm90b3R5cGUgb24gdGhhdCBjbGFzcyBmdW5jdGlvbiB3aWxsIGJlIHByZXNlcnZlZCwgYW5kIGl0IHdpbGwgaW5oZXJpdCBmcm9tXG4gICAgICAgKiBGaXJlYmFzZU9iamVjdC4gSXQncyBhbHNvIHBvc3NpYmxlIHRvIGRvIGJvdGgsIHBhc3NpbmcgYSBjbGFzcyB0byBpbmhlcml0IGFuZCBhZGRpdGlvbmFsXG4gICAgICAgKiBtZXRob2RzIHRvIGFkZCBvbnRvIHRoZSBwcm90b3R5cGUuXG4gICAgICAgKlxuICAgICAgICogT25jZSBhIGZhY3RvcnkgaXMgb2J0YWluZWQgYnkgdGhpcyBtZXRob2QsIGl0IGNhbiBiZSBwYXNzZWQgaW50byAkZmlyZWJhc2UgYXMgdGhlXG4gICAgICAgKiBgb2JqZWN0RmFjdG9yeWAgcGFyYW1ldGVyOlxuICAgICAgICpcbiAgICAgICAqIDxwcmU+PGNvZGU+XG4gICAgICAgKiB2YXIgTXlGYWN0b3J5ID0gJGZpcmViYXNlT2JqZWN0LiRleHRlbmQoe1xuICAgICAgICogICAgLy8gYWRkIGEgbWV0aG9kIG9udG8gdGhlIHByb3RvdHlwZSB0aGF0IHByaW50cyBhIGdyZWV0aW5nXG4gICAgICAgKiAgICBnZXRHcmVldGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgKiAgICAgICByZXR1cm4gJ0hlbGxvICcgKyB0aGlzLmZpcnN0X25hbWUgKyAnICcgKyB0aGlzLmxhc3RfbmFtZSArICchJztcbiAgICAgICAqICAgIH1cbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIC8vIHVzZSBvdXIgbmV3IGZhY3RvcnkgaW4gcGxhY2Ugb2YgJGZpcmViYXNlT2JqZWN0XG4gICAgICAgKiB2YXIgb2JqID0gJGZpcmViYXNlKHJlZiwge29iamVjdEZhY3Rvcnk6IE15RmFjdG9yeX0pLiRhc09iamVjdCgpO1xuICAgICAgICogPC9jb2RlPjwvcHJlPlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtDaGlsZENsYXNzXSBhIGNoaWxkIGNsYXNzIHdoaWNoIHNob3VsZCBpbmhlcml0IEZpcmViYXNlT2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW21ldGhvZHNdIGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYWRkIG9udG8gdGhlIHByb3RvdHlwZVxuICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBmYWN0b3J5IHN1aXRhYmxlIGZvciB1c2Ugd2l0aCAkZmlyZWJhc2VcbiAgICAgICAqL1xuICAgICAgRmlyZWJhc2VPYmplY3QuJGV4dGVuZCA9IGZ1bmN0aW9uKENoaWxkQ2xhc3MsIG1ldGhvZHMpIHtcbiAgICAgICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYW5ndWxhci5pc09iamVjdChDaGlsZENsYXNzKSApIHtcbiAgICAgICAgICBtZXRob2RzID0gQ2hpbGRDbGFzcztcbiAgICAgICAgICBDaGlsZENsYXNzID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgQ2hpbGRDbGFzcykgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRDbGFzcyhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRmlyZWJhc2VPYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkZmlyZWJhc2VVdGlscy5pbmhlcml0KENoaWxkQ2xhc3MsIEZpcmViYXNlT2JqZWN0LCBtZXRob2RzKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHRocmVlLXdheSBkYXRhIGJpbmRpbmcgb24gYSBzY29wZSB2YXJpYWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0ZpcmViYXNlT2JqZWN0fSByZWNcbiAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIFRocmVlV2F5QmluZGluZyhyZWMpIHtcbiAgICAgICAgdGhpcy5zdWJzID0gW107XG4gICAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjID0gcmVjO1xuICAgICAgfVxuXG4gICAgICBUaHJlZVdheUJpbmRpbmcucHJvdG90eXBlID0ge1xuICAgICAgICBhc3NlcnROb3RCb3VuZDogZnVuY3Rpb24odmFyTmFtZSkge1xuICAgICAgICAgIGlmKCB0aGlzLnNjb3BlICkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdDYW5ub3QgYmluZCB0byAnICsgdmFyTmFtZSArICcgYmVjYXVzZSB0aGlzIGluc3RhbmNlIGlzIGFscmVhZHkgYm91bmQgdG8gJyArXG4gICAgICAgICAgICAgIHRoaXMua2V5ICsgJzsgb25lIGJpbmRpbmcgcGVyIGluc3RhbmNlICcgK1xuICAgICAgICAgICAgICAnKGNhbGwgdW5iaW5kIG1ldGhvZCBvciBjcmVhdGUgYW5vdGhlciBGaXJlYmFzZU9iamVjdCBpbnN0YW5jZSknO1xuICAgICAgICAgICAgJGxvZy5lcnJvcihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuICRmaXJlYmFzZVV0aWxzLnJlamVjdChtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kVG86IGZ1bmN0aW9uKHNjb3BlLCB2YXJOYW1lKSB7XG4gICAgICAgICAgZnVuY3Rpb24gX2JpbmQoc2VsZikge1xuICAgICAgICAgICAgdmFyIHNlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSAkcGFyc2UodmFyTmFtZSk7XG4gICAgICAgICAgICB2YXIgcmVjID0gc2VsZi5yZWM7XG4gICAgICAgICAgICBzZWxmLnNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICBzZWxmLnZhck5hbWUgPSB2YXJOYW1lO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBlcXVhbHMoc2NvcGVWYWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhci5lcXVhbHMoc2NvcGVWYWx1ZSwgcmVjKSAmJlxuICAgICAgICAgICAgICAgIHNjb3BlVmFsdWUuJHByaW9yaXR5ID09PSByZWMuJHByaW9yaXR5ICYmXG4gICAgICAgICAgICAgICAgc2NvcGVWYWx1ZS4kdmFsdWUgPT09IHJlYy4kdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldFNjb3BlKHJlYykge1xuICAgICAgICAgICAgICBwYXJzZWQuYXNzaWduKHNjb3BlLCAkZmlyZWJhc2VVdGlscy5zY29wZURhdGEocmVjKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZW5kID0gJGZpcmViYXNlVXRpbHMuZGVib3VuY2UoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIHZhciBzY29wZURhdGEgPSAkZmlyZWJhc2VVdGlscy5zY29wZURhdGEodmFsKTtcbiAgICAgICAgICAgICAgcmVjLiQkc2NvcGVVcGRhdGVkKHNjb3BlRGF0YSlcbiAgICAgICAgICAgICAgICBbJ2ZpbmFsbHknXShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmKCFzY29wZURhdGEuaGFzT3duUHJvcGVydHkoJyR2YWx1ZScpKXtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlYy4kdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJzZWQoc2NvcGUpLiR2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNldFNjb3BlKHJlYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSwgNTAsIDUwMCk7XG5cbiAgICAgICAgICAgIHZhciBzY29wZVVwZGF0ZWQgPSBmdW5jdGlvbihuZXdWYWwpIHtcbiAgICAgICAgICAgICAgbmV3VmFsID0gbmV3VmFsWzBdO1xuICAgICAgICAgICAgICBpZiggIWVxdWFscyhuZXdWYWwpICkge1xuICAgICAgICAgICAgICAgIHNlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbmQobmV3VmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJlY1VwZGF0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYoICFzZW5kaW5nICYmICFlcXVhbHMocGFyc2VkKHNjb3BlKSkgKSB7XG4gICAgICAgICAgICAgICAgc2V0U2NvcGUocmVjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gJHdhdGNoIHdpbGwgbm90IGNoZWNrIGFueSB2YXJzIHByZWZpeGVkIHdpdGggJCwgc28gd2VcbiAgICAgICAgICAgIC8vIG1hbnVhbGx5IGNoZWNrICRwcmlvcml0eSBhbmQgJHZhbHVlIHVzaW5nIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICBmdW5jdGlvbiB3YXRjaEV4cCgpe1xuICAgICAgICAgICAgICB2YXIgb2JqID0gcGFyc2VkKHNjb3BlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtvYmosIG9iai4kcHJpb3JpdHksIG9iai4kdmFsdWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRTY29wZShyZWMpO1xuICAgICAgICAgICAgc2VsZi5zdWJzLnB1c2goc2NvcGUuJG9uKCckZGVzdHJveScsIHNlbGYudW5iaW5kLmJpbmQoc2VsZikpKTtcblxuICAgICAgICAgICAgLy8gbW9uaXRvciBzY29wZSBmb3IgYW55IGNoYW5nZXNcbiAgICAgICAgICAgIHNlbGYuc3Vicy5wdXNoKHNjb3BlLiR3YXRjaCh3YXRjaEV4cCwgc2NvcGVVcGRhdGVkLCB0cnVlKSk7XG5cbiAgICAgICAgICAgIC8vIG1vbml0b3IgdGhlIG9iamVjdCBmb3IgY2hhbmdlc1xuICAgICAgICAgICAgc2VsZi5zdWJzLnB1c2gocmVjLiR3YXRjaChyZWNVcGRhdGVkKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLnVuYmluZC5iaW5kKHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmFzc2VydE5vdEJvdW5kKHZhck5hbWUpIHx8IF9iaW5kKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoIHRoaXMuc2NvcGUgKSB7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godGhpcy5zdWJzLCBmdW5jdGlvbih1bmJpbmQpIHtcbiAgICAgICAgICAgICAgdW5iaW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3VicyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgICAgdGhpcy5yZWMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBPYmplY3RTeW5jTWFuYWdlcihmaXJlYmFzZU9iamVjdCwgcmVmKSB7XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koZXJyKSB7XG4gICAgICAgICAgaWYoICFzeW5jLmlzRGVzdHJveWVkICkge1xuICAgICAgICAgICAgc3luYy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICByZWYub2ZmKCd2YWx1ZScsIGFwcGx5VXBkYXRlKTtcbiAgICAgICAgICAgIGZpcmViYXNlT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGluaXRDb21wbGV0ZShlcnJ8fCdkZXN0cm95ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgIHJlZi5vbigndmFsdWUnLCBhcHBseVVwZGF0ZSwgZXJyb3IpO1xuICAgICAgICAgIHJlZi5vbmNlKCd2YWx1ZScsIGZ1bmN0aW9uKHNuYXApIHtcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoc25hcC52YWwoKSkpIHtcbiAgICAgICAgICAgICAgJGxvZy53YXJuKCdTdG9yaW5nIGRhdGEgdXNpbmcgYXJyYXkgaW5kaWNlcyBpbiBGaXJlYmFzZSBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFNlZSBodHRwczovL3d3dy5maXJlYmFzZS5jb20vZG9jcy93ZWIvZ3VpZGUvdW5kZXJzdGFuZGluZy1kYXRhLmh0bWwjc2VjdGlvbi1hcnJheXMtaW4tZmlyZWJhc2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uIEFsc28gbm90ZSB0aGF0IHlvdSBwcm9iYWJseSB3YW50ZWQgJGZpcmViYXNlQXJyYXkgYW5kIG5vdCAkZmlyZWJhc2VPYmplY3QuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluaXRDb21wbGV0ZShudWxsKTtcbiAgICAgICAgICB9LCBpbml0Q29tcGxldGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbCBpbml0Q29tcGxldGUoKTsgZG8gbm90IGNhbGwgdGhpcyBkaXJlY3RseVxuICAgICAgICBmdW5jdGlvbiBfaW5pdENvbXBsZXRlKGVycikge1xuICAgICAgICAgIGlmKCAhaXNSZXNvbHZlZCApIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYoIGVyciApIHsgZGVmLnJlamVjdChlcnIpOyB9XG4gICAgICAgICAgICBlbHNlIHsgZGVmLnJlc29sdmUoZmlyZWJhc2VPYmplY3QpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRlZiA9ICRmaXJlYmFzZVV0aWxzLmRlZmVyKCk7XG4gICAgICAgIHZhciBhcHBseVVwZGF0ZSA9ICRmaXJlYmFzZVV0aWxzLmJhdGNoKGZ1bmN0aW9uKHNuYXApIHtcbiAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZpcmViYXNlT2JqZWN0LiQkdXBkYXRlZChzbmFwKTtcbiAgICAgICAgICBpZiggY2hhbmdlZCApIHtcbiAgICAgICAgICAgIC8vIG5vdGlmaWVzICR3YXRjaCBsaXN0ZW5lcnMgYW5kXG4gICAgICAgICAgICAvLyB1cGRhdGVzICRzY29wZSBpZiBib3VuZCB0byBhIHZhcmlhYmxlXG4gICAgICAgICAgICBmaXJlYmFzZU9iamVjdC4kJG5vdGlmeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlcnJvciA9ICRmaXJlYmFzZVV0aWxzLmJhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIF9pbml0Q29tcGxldGUoZXJyKTtcbiAgICAgICAgICBpZiggZmlyZWJhc2VPYmplY3QgKSB7XG4gICAgICAgICAgICBmaXJlYmFzZU9iamVjdC4kJGVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGluaXRDb21wbGV0ZSA9ICRmaXJlYmFzZVV0aWxzLmJhdGNoKF9pbml0Q29tcGxldGUpO1xuXG4gICAgICAgIHZhciBzeW5jID0ge1xuICAgICAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgICAgcmVhZHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmLnByb21pc2U7IH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN5bmM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBGaXJlYmFzZU9iamVjdDtcbiAgICB9XG4gIF0pO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBhbmd1bGFyLm1vZHVsZSgnZmlyZWJhc2UnKS5mYWN0b3J5KCckRmlyZWJhc2VPYmplY3QnLCBbJyRsb2cnLCAnJGZpcmViYXNlT2JqZWN0JyxcbiAgICBmdW5jdGlvbigkbG9nLCAkZmlyZWJhc2VPYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgJGxvZy53YXJuKCckRmlyZWJhc2VPYmplY3QgaGFzIGJlZW4gcmVuYW1lZC4gVXNlICRmaXJlYmFzZU9iamVjdCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gJGZpcmViYXNlT2JqZWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgXSk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBhbmd1bGFyLm1vZHVsZShcImZpcmViYXNlXCIpXG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAuZmFjdG9yeShcIiRmaXJlYmFzZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCckZmlyZWJhc2UgaGFzIGJlZW4gcmVtb3ZlZC4gWW91IG1heSBpbnN0YW50aWF0ZSAkZmlyZWJhc2VBcnJheSBhbmQgJGZpcmViYXNlT2JqZWN0ICcgK1xuICAgICAgICAnZGlyZWN0bHkgbm93LiBGb3Igc2ltcGxlIHdyaXRlIG9wZXJhdGlvbnMsIGp1c3QgdXNlIHRoZSBGaXJlYmFzZSByZWYgZGlyZWN0bHkuICcgK1xuICAgICAgICAnU2VlIHRoZSBBbmd1bGFyRmlyZSAxLjAuMCBjaGFuZ2Vsb2cgZm9yIGRldGFpbHM6IGh0dHBzOi8vd3d3LmZpcmViYXNlLmNvbS9kb2NzL3dlYi9saWJyYXJpZXMvYW5ndWxhci9jaGFuZ2Vsb2cuaHRtbCcpO1xuICAgICAgfTtcbiAgICB9KTtcblxufSkoKTtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTaGltIEFycmF5LmluZGV4T2YgZm9yIElFIGNvbXBhdGliaWxpdHkuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIid0aGlzJyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkXCIpO1xuICAgIH1cbiAgICAvLyBIYWNrIHRvIGNvbnZlcnQgb2JqZWN0Lmxlbmd0aCB0byBhIFVJbnQzMlxuICAgIC8vIGpzaGludCAtVzAxNlxuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMDtcbiAgICBmcm9tSW5kZXggPSArZnJvbUluZGV4IHx8IDA7XG4gICAgLy8ganNoaW50ICtXMDE2XG5cbiAgICBpZiAoTWF0aC5hYnMoZnJvbUluZGV4KSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGZyb21JbmRleCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgIGZyb21JbmRleCArPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoO2Zyb21JbmRleCA8IGxlbmd0aDsgZnJvbUluZGV4KyspIHtcbiAgICAgIGlmICh0aGlzW2Zyb21JbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21JbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmRcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XG4gICAgfVxuXG4gICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgIGZUb0JpbmQgPSB0aGlzLFxuICAgICAgZk5PUCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgZkJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpc1xuICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICA6IG9UaGlzLFxuICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICB9O1xuXG4gICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcblxuICAgIHJldHVybiBmQm91bmQ7XG4gIH07XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRJbmRleFxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaW5kSW5kZXgnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmQgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIGluIGxpc3QpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vjb25kIGFyZ3VtZW50IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBhIG51bGwgW1tQcm90b3R5cGVdXScpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgICByZXR1cm4gbmV3IEYoKTtcbiAgICB9O1xuICB9KSgpO1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzXG5pZiAoIU9iamVjdC5rZXlzKSB7XG4gIE9iamVjdC5rZXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGhhc0RvbnRFbnVtQnVnID0gISh7dG9TdHJpbmc6IG51bGx9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKSxcbiAgICAgIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICAgIF0sXG4gICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSwgcHJvcCwgaTtcblxuICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSgpKTtcbn1cblxuLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL29iamVjdGdldHByb3RvdHlwZW9mL1xuaWYgKCB0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mICE9PSBcImZ1bmN0aW9uXCIgKSB7XG4gIGlmICggdHlwZW9mIFwidGVzdFwiLl9fcHJvdG9fXyA9PT0gXCJvYmplY3RcIiApIHtcbiAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbihvYmplY3Qpe1xuICAgICAgcmV0dXJuIG9iamVjdC5fX3Byb3RvX187XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbihvYmplY3Qpe1xuICAgICAgLy8gTWF5IGJyZWFrIGlmIHRoZSBjb25zdHJ1Y3RvciBoYXMgYmVlbiB0YW1wZXJlZCB3aXRoXG4gICAgICByZXR1cm4gb2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB9O1xuICB9XG59XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGFuZ3VsYXIubW9kdWxlKCdmaXJlYmFzZScpXG4gICAgLmZhY3RvcnkoJyRmaXJlYmFzZUNvbmZpZycsIFtcIiRmaXJlYmFzZUFycmF5XCIsIFwiJGZpcmViYXNlT2JqZWN0XCIsIFwiJGluamVjdG9yXCIsXG4gICAgICBmdW5jdGlvbigkZmlyZWJhc2VBcnJheSwgJGZpcmViYXNlT2JqZWN0LCAkaW5qZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbmZpZ09wdHMpIHtcbiAgICAgICAgICAvLyBtYWtlIGEgY29weSB3ZSBjYW4gbW9kaWZ5XG4gICAgICAgICAgdmFyIG9wdHMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgY29uZmlnT3B0cyk7XG4gICAgICAgICAgLy8gbG9vayB1cCBmYWN0b3JpZXMgaWYgcGFzc2VkIGFzIHN0cmluZyBuYW1lc1xuICAgICAgICAgIGlmKCB0eXBlb2Ygb3B0cy5vYmplY3RGYWN0b3J5ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIG9wdHMub2JqZWN0RmFjdG9yeSA9ICRpbmplY3Rvci5nZXQob3B0cy5vYmplY3RGYWN0b3J5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIHR5cGVvZiBvcHRzLmFycmF5RmFjdG9yeSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICBvcHRzLmFycmF5RmFjdG9yeSA9ICRpbmplY3Rvci5nZXQob3B0cy5hcnJheUZhY3RvcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBleHRlbmQgZGVmYXVsdHMgYW5kIHJldHVyblxuICAgICAgICAgIHJldHVybiBhbmd1bGFyLmV4dGVuZCh7XG4gICAgICAgICAgICBhcnJheUZhY3Rvcnk6ICRmaXJlYmFzZUFycmF5LFxuICAgICAgICAgICAgb2JqZWN0RmFjdG9yeTogJGZpcmViYXNlT2JqZWN0XG4gICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgXSlcblxuICAgIC5mYWN0b3J5KCckZmlyZWJhc2VVdGlscycsIFtcIiRxXCIsIFwiJHRpbWVvdXRcIiwgXCIkcm9vdFNjb3BlXCIsXG4gICAgICBmdW5jdGlvbigkcSwgJHRpbWVvdXQsICRyb290U2NvcGUpIHtcblxuICAgICAgICAvLyBFUzYgc3R5bGUgcHJvbWlzZXMgcG9seWZpbGwgZm9yIGFuZ3VsYXIgMS4yLnhcbiAgICAgICAgLy8gQ29waWVkIGZyb20gYW5ndWxhciAxLjMueCBpbXBsZW1lbnRhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9ibG9iL3YxLjMuNS9zcmMvbmcvcS5qcyNMNTM5XG4gICAgICAgIGZ1bmN0aW9uIFEocmVzb2x2ZXIpIHtcbiAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXNvbHZlciBmdW5jdGlvbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlRm4odmFsdWUpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdEZuKHJlYXNvbikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZXIocmVzb2x2ZUZuLCByZWplY3RGbik7XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1dGlscyA9IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIGVhY2ggdGltZSBpdCBpcyBpbnZva2VkLCB3aWxsIGdhdGhlciB1cCB0aGUgdmFsdWVzIHVudGlsXG4gICAgICAgICAgICogdGhlIG5leHQgXCJ0aWNrXCIgaW4gdGhlIEFuZ3VsYXIgY29tcGlsZXIgcHJvY2Vzcy4gVGhlbiB0aGV5IGFyZSBhbGwgcnVuIGF0IHRoZSBzYW1lXG4gICAgICAgICAgICogdGltZSB0byBhdm9pZCBtdWx0aXBsZSBjeWNsZXMgb2YgdGhlIGRpZ2VzdCBsb29wLiBJbnRlcm5hbGx5LCB0aGlzIGlzIGRvbmUgdXNpbmcgJGV2YWxBc3luYygpXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25cbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGJhdGNoOiBmdW5jdGlvbihhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgICB1dGlscy5jb21waWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIHJ1ZGltZW50YXJ5IGRlYm91bmNlIG1ldGhvZFxuICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZVxuICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4XSB0aGUgYHRoaXNgIGNvbnRleHQgdG8gc2V0IGluIGZuXG4gICAgICAgICAgICogQHBhcmFtIHtpbnR9IHdhaXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBwYXVzZSBiZWZvcmUgc2VuZGluZyBvdXQgYWZ0ZXIgZWFjaCBpbnZvY2F0aW9uXG4gICAgICAgICAgICogQHBhcmFtIHtpbnR9IFttYXhXYWl0XSBtYXggbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHNlbmRpbmcgb3V0LCBkZWZhdWx0cyB0byB3YWl0ICogMTAgb3IgMTAwXG4gICAgICAgICAgICovXG4gICAgICAgICAgZGVib3VuY2U6IGZ1bmN0aW9uKGZuLCBjdHgsIHdhaXQsIG1heFdhaXQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCwgY2FuY2VsVGltZXIsIGFyZ3MsIHJ1blNjaGVkdWxlZEZvck5leHRUaWNrO1xuICAgICAgICAgICAgaWYoIHR5cGVvZihjdHgpID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgICAgbWF4V2FpdCA9IHdhaXQ7XG4gICAgICAgICAgICAgIHdhaXQgPSBjdHg7XG4gICAgICAgICAgICAgIGN0eCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCB0eXBlb2Ygd2FpdCAhPT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgdmFsaWQgaW50ZWdlciBmb3Igd2FpdC4gVHJ5IDAgZm9yIGEgZGVmYXVsdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIHR5cGVvZihmbikgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgdmFsaWQgZnVuY3Rpb24gdG8gZGVib3VuY2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCAhbWF4V2FpdCApIHsgbWF4V2FpdCA9IHdhaXQqMTAgfHwgMTAwOyB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFycyB0aGUgY3VycmVudCB3YWl0IHRpbWVyIGFuZCBjcmVhdGVzIGEgbmV3IG9uZVxuICAgICAgICAgICAgLy8gaG93ZXZlciwgaWYgbWF4V2FpdCBpcyBleGNlZWRlZCwgY2FsbHMgcnVuTm93KCkgb24gdGhlIG5leHQgdGljay5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2V0VGltZXIoKSB7XG4gICAgICAgICAgICAgIGlmKCBjYW5jZWxUaW1lciApIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxUaW1lcigpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiggc3RhcnQgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0ID4gbWF4V2FpdCApIHtcbiAgICAgICAgICAgICAgICBpZighcnVuU2NoZWR1bGVkRm9yTmV4dFRpY2spe1xuICAgICAgICAgICAgICAgICAgcnVuU2NoZWR1bGVkRm9yTmV4dFRpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdXRpbHMuY29tcGlsZShydW5Ob3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiggIXN0YXJ0ICkgeyBzdGFydCA9IERhdGUubm93KCk7IH1cbiAgICAgICAgICAgICAgICBjYW5jZWxUaW1lciA9IHV0aWxzLndhaXQocnVuTm93LCB3YWl0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGVhcnMgdGhlIHF1ZXVlIGFuZCBpbnZva2VzIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2l0aCB0aGUgbW9zdCByZWNlbnQgYXJndW1lbnRzXG4gICAgICAgICAgICBmdW5jdGlvbiBydW5Ob3coKSB7XG4gICAgICAgICAgICAgIGNhbmNlbFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICBydW5TY2hlZHVsZWRGb3JOZXh0VGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICBmbi5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgICByZXNldFRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJvdW5jZWQucnVubmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgPiAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYXNzZXJ0VmFsaWRSZWY6IGZ1bmN0aW9uKHJlZiwgbXNnKSB7XG4gICAgICAgICAgICBpZiggIWFuZ3VsYXIuaXNPYmplY3QocmVmKSB8fFxuICAgICAgICAgICAgICB0eXBlb2YocmVmLnJlZikgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgdHlwZW9mKHJlZi5yZWYoKS50cmFuc2FjdGlvbikgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0ludmFsaWQgRmlyZWJhc2UgcmVmZXJlbmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzUwOTgzMS9hbHRlcm5hdGl2ZS1mb3ItdGhlLWRlcHJlY2F0ZWQtcHJvdG9cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG4gICAgICAgICAgaW5oZXJpdDogZnVuY3Rpb24oQ2hpbGRDbGFzcywgUGFyZW50Q2xhc3MsIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE1ldGhvZHMgPSBDaGlsZENsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgICAgIENoaWxkQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJlbnRDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgQ2hpbGRDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZENsYXNzOyAvLyByZXN0b3JpbmcgcHJvcGVyIGNvbnN0cnVjdG9yIGZvciBjaGlsZCBjbGFzc1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKE9iamVjdC5rZXlzKGNoaWxkTWV0aG9kcyksIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgQ2hpbGRDbGFzcy5wcm90b3R5cGVba10gPSBjaGlsZE1ldGhvZHNba107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKCBhbmd1bGFyLmlzT2JqZWN0KG1ldGhvZHMpICkge1xuICAgICAgICAgICAgICBhbmd1bGFyLmV4dGVuZChDaGlsZENsYXNzLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2hpbGRDbGFzcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0UHJvdG90eXBlTWV0aG9kczogZnVuY3Rpb24oaW5zdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RzID0ge307XG4gICAgICAgICAgICB2YXIgb2JqUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuICAgICAgICAgICAgdmFyIHByb3RvID0gYW5ndWxhci5pc0Z1bmN0aW9uKGluc3QpICYmIGFuZ3VsYXIuaXNPYmplY3QoaW5zdC5wcm90b3R5cGUpP1xuICAgICAgICAgICAgICBpbnN0LnByb3RvdHlwZSA6IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KTtcbiAgICAgICAgICAgIHdoaWxlKHByb3RvICYmIHByb3RvICE9PSBvYmpQcm90bykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG8pIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IGludm9rZSBlYWNoIGtleSBvbmNlOyBpZiBhIHN1cGVyIGlzIG92ZXJyaWRkZW4gaXQncyBza2lwcGVkIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhbWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBtZXRob2RzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBwcm90b1trZXldLCBrZXksIHByb3RvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXRQdWJsaWNNZXRob2RzOiBmdW5jdGlvbihpbnN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICAgICAgdXRpbHMuZ2V0UHJvdG90eXBlTWV0aG9kcyhpbnN0LCBmdW5jdGlvbihtLCBrKSB7XG4gICAgICAgICAgICAgIGlmKCB0eXBlb2YobSkgPT09ICdmdW5jdGlvbicgJiYgay5jaGFyQXQoMCkgIT09ICdfJyApIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG0sIGspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVmZXI6ICRxLmRlZmVyLFxuXG4gICAgICAgICAgcmVqZWN0OiAkcS5yZWplY3QsXG5cbiAgICAgICAgICByZXNvbHZlOiAkcS53aGVuLFxuXG4gICAgICAgICAgLy9UT0RPOiBSZW1vdmUgZmFsc2UgYnJhbmNoIGFuZCB1c2Ugb25seSBhbmd1bGFyIGltcGxlbWVudGF0aW9uIHdoZW4gd2UgZHJvcCBhbmd1bGFyIDEuMi54IHN1cHBvcnQuXG4gICAgICAgICAgcHJvbWlzZTogYW5ndWxhci5pc0Z1bmN0aW9uKCRxKSA/ICRxIDogUSxcblxuICAgICAgICAgIG1ha2VOb2RlUmVzb2x2ZXI6ZnVuY3Rpb24oZGVmZXJyZWQpe1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycixyZXN1bHQpe1xuICAgICAgICAgICAgICBpZihlcnIgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAyKXtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3YWl0OiBmdW5jdGlvbihmbiwgd2FpdCkge1xuICAgICAgICAgICAgdmFyIHRvID0gJHRpbWVvdXQoZm4sIHdhaXR8fDApO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiggdG8gKSB7XG4gICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRvKTtcbiAgICAgICAgICAgICAgICB0byA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gJHJvb3RTY29wZS4kZXZhbEFzeW5jKGZufHxmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZGVlcENvcHk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYoICFhbmd1bGFyLmlzT2JqZWN0KG9iaikgKSB7IHJldHVybiBvYmo7IH1cbiAgICAgICAgICAgIHZhciBuZXdDb3B5ID0gYW5ndWxhci5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvYmopO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld0NvcHkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NvcHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KG5ld0NvcHlba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0NvcHlba2V5XSA9IHV0aWxzLmRlZXBDb3B5KG5ld0NvcHlba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3Q29weTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgdHJpbUtleXM6IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSkge1xuICAgICAgICAgICAgdXRpbHMuZWFjaChkZXN0LCBmdW5jdGlvbih2LGspIHtcbiAgICAgICAgICAgICAgaWYoICFzb3VyY2UuaGFzT3duUHJvcGVydHkoaykgKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRlc3Rba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzY29wZURhdGE6IGZ1bmN0aW9uKGRhdGFPclJlYykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICRpZDogZGF0YU9yUmVjLiRpZCxcbiAgICAgICAgICAgICAgJHByaW9yaXR5OiBkYXRhT3JSZWMuJHByaW9yaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhhc1B1YmxpY1Byb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWxzLmVhY2goZGF0YU9yUmVjLCBmdW5jdGlvbih2LGspIHtcbiAgICAgICAgICAgICAgaGFzUHVibGljUHJvcCA9IHRydWU7XG4gICAgICAgICAgICAgIGRhdGFba10gPSB1dGlscy5kZWVwQ29weSh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYoIWhhc1B1YmxpY1Byb3AgJiYgZGF0YU9yUmVjLmhhc093blByb3BlcnR5KCckdmFsdWUnKSl7XG4gICAgICAgICAgICAgIGRhdGEuJHZhbHVlID0gZGF0YU9yUmVjLiR2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB1cGRhdGVSZWM6IGZ1bmN0aW9uKHJlYywgc25hcCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzbmFwLnZhbCgpO1xuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSBhbmd1bGFyLmV4dGVuZCh7fSwgcmVjKTtcblxuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIHByaW1pdGl2ZXNcbiAgICAgICAgICAgIGlmKCAhYW5ndWxhci5pc09iamVjdChkYXRhKSApIHtcbiAgICAgICAgICAgICAgcmVjLiR2YWx1ZSA9IGRhdGE7XG4gICAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgcmVjLiR2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwbHkgY2hhbmdlczogcmVtb3ZlIG9sZCBrZXlzLCBpbnNlcnQgbmV3IGRhdGEsIHNldCBwcmlvcml0eVxuICAgICAgICAgICAgdXRpbHMudHJpbUtleXMocmVjLCBkYXRhKTtcbiAgICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKHJlYywgZGF0YSk7XG4gICAgICAgICAgICByZWMuJHByaW9yaXR5ID0gc25hcC5nZXRQcmlvcml0eSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gIWFuZ3VsYXIuZXF1YWxzKG9sZERhdGEsIHJlYykgfHxcbiAgICAgICAgICAgICAgb2xkRGF0YS4kdmFsdWUgIT09IHJlYy4kdmFsdWUgfHxcbiAgICAgICAgICAgICAgb2xkRGF0YS4kcHJpb3JpdHkgIT09IHJlYy4kcHJpb3JpdHk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGFwcGx5RGVmYXVsdHM6IGZ1bmN0aW9uKHJlYywgZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmKCBhbmd1bGFyLmlzT2JqZWN0KGRlZmF1bHRzKSApIHtcbiAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRlZmF1bHRzLCBmdW5jdGlvbih2LGspIHtcbiAgICAgICAgICAgICAgICBpZiggIXJlYy5oYXNPd25Qcm9wZXJ0eShrKSApIHtcbiAgICAgICAgICAgICAgICAgIHJlY1trXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRhdGFLZXlzOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIHV0aWxzLmVhY2gob2JqLCBmdW5jdGlvbih2LGspIHtcbiAgICAgICAgICAgICAgb3V0LnB1c2goayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmKGFuZ3VsYXIuaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjID0gay5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgICBpZiggYyAhPT0gJ18nICYmIGMgIT09ICckJyAmJiBjICE9PSAnLicgKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihhbmd1bGFyLmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSB1dGlsaXR5IGZvciByZXRyaWV2aW5nIGEgRmlyZWJhc2UgcmVmZXJlbmNlIG9yIERhdGFTbmFwc2hvdCdzXG4gICAgICAgICAgICoga2V5IG5hbWUuIFRoaXMgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBgbmFtZSgpYCBmcm9tIEZpcmViYXNlXG4gICAgICAgICAgICogMS54LnggYW5kIGBrZXkoKWAgZnJvbSBGaXJlYmFzZSAyLjAuMCsuIE9uY2Ugc3VwcG9ydCBmb3IgRmlyZWJhc2VcbiAgICAgICAgICAgKiAxLngueCBpcyBkcm9wcGVkIGluIEFuZ3VsYXJGaXJlLCB0aGlzIGhlbHBlciBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXRLZXk6IGZ1bmN0aW9uKHJlZk9yU25hcHNob3QpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHJlZk9yU25hcHNob3Qua2V5ID09PSAnZnVuY3Rpb24nKSA/IHJlZk9yU25hcHNob3Qua2V5KCkgOiByZWZPclNuYXBzaG90Lm5hbWUoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSB1dGlsaXR5IGZvciBjb252ZXJ0aW5nIHJlY29yZHMgdG8gSlNPTiBvYmplY3RzXG4gICAgICAgICAgICogd2hpY2ggd2UgY2FuIHNhdmUgaW50byBGaXJlYmFzZS4gSXQgYXNzZXJ0cyB2YWxpZFxuICAgICAgICAgICAqIGtleXMgYW5kIHN0cmlwcyBvZmYgYW55IGl0ZW1zIHByZWZpeGVkIHdpdGggJC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIElmIHRoZSByZWMgcGFzc2VkIGludG8gdGhpcyBtZXRob2QgaGFzIGEgdG9KU09OKClcbiAgICAgICAgICAgKiBtZXRob2QsIHRoYXQgd2lsbCBiZSB1c2VkIGluIHBsYWNlIG9mIHRoZSBjdXN0b21cbiAgICAgICAgICAgKiBmdW5jdGlvbmFsaXR5IGhlcmUuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0gcmVjXG4gICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdG9KU09OOiBmdW5jdGlvbihyZWMpIHtcbiAgICAgICAgICAgIHZhciBkYXQ7XG4gICAgICAgICAgICBpZiggIWFuZ3VsYXIuaXNPYmplY3QocmVjKSApIHtcbiAgICAgICAgICAgICAgcmVjID0geyR2YWx1ZTogcmVjfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24ocmVjLnRvSlNPTikpIHtcbiAgICAgICAgICAgICAgZGF0ID0gcmVjLnRvSlNPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGRhdCA9IHt9O1xuICAgICAgICAgICAgICB1dGlscy5lYWNoKHJlYywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICBkYXRba10gPSBzdHJpcERvbGxhclByZWZpeGVkS2V5cyh2KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggYW5ndWxhci5pc0RlZmluZWQocmVjLiR2YWx1ZSkgJiYgT2JqZWN0LmtleXMoZGF0KS5sZW5ndGggPT09IDAgJiYgcmVjLiR2YWx1ZSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgZGF0WycudmFsdWUnXSA9IHJlYy4kdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggYW5ndWxhci5pc0RlZmluZWQocmVjLiRwcmlvcml0eSkgJiYgT2JqZWN0LmtleXMoZGF0KS5sZW5ndGggPiAwICYmIHJlYy4kcHJpb3JpdHkgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgIGRhdFsnLnByaW9yaXR5J10gPSByZWMuJHByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRhdCwgZnVuY3Rpb24odixrKSB7XG4gICAgICAgICAgICAgIGlmIChrLm1hdGNoKC9bLiRcXFtcXF0jXFwvXS8pICYmIGsgIT09ICcudmFsdWUnICYmIGsgIT09ICcucHJpb3JpdHknICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgJyArIGsgKyAnIChjYW5ub3QgY29udGFpbiAuJFtdIyknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmKCBhbmd1bGFyLmlzVW5kZWZpbmVkKHYpICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5ICcraysnIHdhcyB1bmRlZmluZWQuIENhbm5vdCBwYXNzIHVuZGVmaW5lZCBpbiBKU09OLiBVc2UgbnVsbCBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYXQ7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRvU2V0OiBmdW5jdGlvbihyZWYsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSB1dGlscy5kZWZlcigpO1xuICAgICAgICAgICAgaWYoIGFuZ3VsYXIuaXNGdW5jdGlvbihyZWYuc2V0KSB8fCAhYW5ndWxhci5pc09iamVjdChkYXRhKSApIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgYSBxdWVyeSwganVzdCBkbyBhIGZsYXQgc2V0XG4gICAgICAgICAgICAgIHJlZi5zZXQoZGF0YSwgdXRpbHMubWFrZU5vZGVSZXNvbHZlcihkZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGF0YUNvcHkgPSBhbmd1bGFyLmV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBxdWVyeSwgc28gd2Ugd2lsbCByZXBsYWNlIGFsbCB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgLy8gb2YgdGhpcyBxdWVyeSB3aXRoIHRoZSB2YWx1ZSBwcm92aWRlZCwgYnV0IG5vdCBibG93IGF3YXlcbiAgICAgICAgICAgICAgLy8gdGhlIGVudGlyZSBGaXJlYmFzZSBwYXRoXG4gICAgICAgICAgICAgIHJlZi5vbmNlKCd2YWx1ZScsIGZ1bmN0aW9uKHNuYXApIHtcbiAgICAgICAgICAgICAgICBzbmFwLmZvckVhY2goZnVuY3Rpb24oc3MpIHtcbiAgICAgICAgICAgICAgICAgIGlmKCAhZGF0YUNvcHkuaGFzT3duUHJvcGVydHkodXRpbHMuZ2V0S2V5KHNzKSkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFDb3B5W3V0aWxzLmdldEtleShzcyldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWYucmVmKCkudXBkYXRlKGRhdGFDb3B5LCB1dGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZikpO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBkZWYucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZi5wcm9taXNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBkb1JlbW92ZTogZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gdXRpbHMuZGVmZXIoKTtcbiAgICAgICAgICAgIGlmKCBhbmd1bGFyLmlzRnVuY3Rpb24ocmVmLnJlbW92ZSkgKSB7XG4gICAgICAgICAgICAgIC8vIHJlZiBpcyBub3QgYSBxdWVyeSwganVzdCBkbyBhIGZsYXQgcmVtb3ZlXG4gICAgICAgICAgICAgIHJlZi5yZW1vdmUodXRpbHMubWFrZU5vZGVSZXNvbHZlcihkZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZWYgaXMgYSBxdWVyeSBzbyBsZXQncyBvbmx5IHJlbW92ZSB0aGVcbiAgICAgICAgICAgICAgLy8gaXRlbXMgaW4gdGhlIHF1ZXJ5IGFuZCBub3QgdGhlIGVudGlyZSBwYXRoXG4gICAgICAgICAgICAgIHJlZi5vbmNlKCd2YWx1ZScsIGZ1bmN0aW9uKHNuYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBzbmFwLmZvckVhY2goZnVuY3Rpb24oc3MpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkID0gdXRpbHMuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZC5wcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgIHNzLnJlZigpLnJlbW92ZSh1dGlscy5tYWtlTm9kZVJlc29sdmVyKGRlZikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHV0aWxzLmFsbFByb21pc2VzKHByb21pc2VzKVxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZi5yZXNvbHZlKHJlZik7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgICAgICAgICAgICAgZGVmLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGRlZi5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmLnByb21pc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEFuZ3VsYXJGaXJlIHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIFZFUlNJT046ICcxLjEuNCcsXG5cbiAgICAgICAgICBhbGxQcm9taXNlczogJHEuYWxsLmJpbmQoJHEpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHV0aWxzO1xuICAgICAgfVxuICAgIF0pO1xuXG4gICAgZnVuY3Rpb24gc3RyaXBEb2xsYXJQcmVmaXhlZEtleXMoZGF0YSkge1xuICAgICAgaWYoICFhbmd1bGFyLmlzT2JqZWN0KGRhdGEpICkgeyByZXR1cm4gZGF0YTsgfVxuICAgICAgdmFyIG91dCA9IGFuZ3VsYXIuaXNBcnJheShkYXRhKT8gW10gOiB7fTtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbih2LGspIHtcbiAgICAgICAgaWYodHlwZW9mIGsgIT09ICdzdHJpbmcnIHx8IGsuY2hhckF0KDApICE9PSAnJCcpIHtcbiAgICAgICAgICBvdXRba10gPSBzdHJpcERvbGxhclByZWZpeGVkS2V5cyh2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn0pKCk7XG4iLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLG51bGwsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbn0gZWxzZSB7XG4gIC8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG4gIEJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG4gIEJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldFN0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgc2V0IG1ldGhvZCBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgY29tbWVudFJ4ID0gL15cXHMqXFwvKD86XFwvfFxcKilbQCNdXFxzK3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTooPzphcHBsaWNhdGlvbnx0ZXh0KVxcL2pzb247KD86Y2hhcnNldFs6PV1cXFMrOyk/YmFzZTY0LCguKikkL21nO1xudmFyIG1hcEZpbGVDb21tZW50UnggPVxuICAvL0V4YW1wbGUgKEV4dHJhIHNwYWNlIGJldHdlZW4gc2xhc2hlcyBhZGRlZCB0byBzb2x2ZSBTYWZhcmkgYnVnLiBFeGNsdWRlIHNwYWNlIGluIHByb2R1Y3Rpb24pOlxuICAvLyAgICAgLyAvIyBzb3VyY2VNYXBwaW5nVVJMPWZvby5qcy5tYXAgICAgICAgICAgIC8qIyBzb3VyY2VNYXBwaW5nVVJMPWZvby5qcy5tYXAgKi9cbiAgLyg/OlxcL1xcL1tAI11bIFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKz8pWyBcXHRdKiQpfCg/OlxcL1xcKltAI11bIFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXCpdKz8pWyBcXHRdKig/OlxcKlxcLyl7MX1bIFxcdF0qJCkvbWdcblxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGJhc2U2NCkge1xuICByZXR1cm4gbmV3IEJ1ZmZlcihiYXNlNjQsICdiYXNlNjQnKS50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBzdHJpcENvbW1lbnQoc20pIHtcbiAgcmV0dXJuIHNtLnNwbGl0KCcsJykucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGcm9tRmlsZU1hcChzbSwgZGlyKSB7XG4gIC8vIE5PVEU6IHRoaXMgd2lsbCBvbmx5IHdvcmsgb24gdGhlIHNlcnZlciBzaW5jZSBpdCBhdHRlbXB0cyB0byByZWFkIHRoZSBtYXAgZmlsZVxuXG4gIHZhciByID0gbWFwRmlsZUNvbW1lbnRSeC5leGVjKHNtKTtcbiAgbWFwRmlsZUNvbW1lbnRSeC5sYXN0SW5kZXggPSAwO1xuXG4gIC8vIGZvciBzb21lIG9kZCByZWFzb24gLy8jIC4uIGNhcHR1cmVzIGluIDEgYW5kIC8qIC4uICovIGluIDJcbiAgdmFyIGZpbGVuYW1lID0gclsxXSB8fCByWzJdO1xuICB2YXIgZmlsZXBhdGggPSBwYXRoLmpvaW4oZGlyLCBmaWxlbmFtZSk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVwYXRoLCAndXRmOCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gcmVhZCB0aGUgbWFwIGZpbGUgYXQgJyArIGZpbGVwYXRoICsgJ1xcbicgKyBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBDb252ZXJ0ZXIgKHNtLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmIChvcHRzLmlzRmlsZUNvbW1lbnQpIHNtID0gcmVhZEZyb21GaWxlTWFwKHNtLCBvcHRzLmNvbW1lbnRGaWxlRGlyKTtcbiAgaWYgKG9wdHMuaGFzQ29tbWVudCkgc20gPSBzdHJpcENvbW1lbnQoc20pO1xuICBpZiAob3B0cy5pc0VuY29kZWQpIHNtID0gZGVjb2RlQmFzZTY0KHNtKTtcbiAgaWYgKG9wdHMuaXNKU09OIHx8IG9wdHMuaXNFbmNvZGVkKSBzbSA9IEpTT04ucGFyc2Uoc20pO1xuXG4gIHRoaXMuc291cmNlbWFwID0gc207XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGcm9tTGFyZ2VTb3VyY2UoY29udGVudCl7XG4gIHZhciBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICB2YXIgbGluZTtcbiAgLy8gZmluZCBmaXJzdCBsaW5lIHdoaWNoIGNvbnRhaW5zIGEgc291cmNlIG1hcCBzdGFydGluZyBhdCBlbmQgb2YgY29udGVudFxuICBmb3IgKHZhciBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXVxuICAgIGlmICh+bGluZS5pbmRleE9mKCdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6JykpIHJldHVybiBleHBvcnRzLmZyb21Db21tZW50KGxpbmUpO1xuICB9XG59XG5cbkNvbnZlcnRlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHNwYWNlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnNvdXJjZW1hcCwgbnVsbCwgc3BhY2UpO1xufTtcblxuQ29udmVydGVyLnByb3RvdHlwZS50b0Jhc2U2NCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGpzb24gPSB0aGlzLnRvSlNPTigpO1xuICByZXR1cm4gbmV3IEJ1ZmZlcihqc29uKS50b1N0cmluZygnYmFzZTY0Jyk7XG59O1xuXG5Db252ZXJ0ZXIucHJvdG90eXBlLnRvQ29tbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBiYXNlNjQgPSB0aGlzLnRvQmFzZTY0KCk7XG4gIHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYmFzZTY0O1xuICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLm11bHRpbGluZSA/ICcvKiMgJyArIGRhdGEgKyAnICovJyA6ICcvLyMgJyArIGRhdGE7XG59O1xuXG4vLyByZXR1cm5zIGNvcHkgaW5zdGVhZCBvZiBvcmlnaW5hbFxuQ29udmVydGVyLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy50b0pTT04oKSk7XG59O1xuXG5Db252ZXJ0ZXIucHJvdG90eXBlLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKHRoaXMuc291cmNlbWFwLmhhc093blByb3BlcnR5KGtleSkpIHRocm93IG5ldyBFcnJvcigncHJvcGVydHkgJXMgYWxyZWFkeSBleGlzdHMgb24gdGhlIHNvdXJjZW1hcCwgdXNlIHNldCBwcm9wZXJ0eSBpbnN0ZWFkJyk7XG4gIHJldHVybiB0aGlzLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xufTtcblxuQ29udmVydGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRoaXMuc291cmNlbWFwW2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Db252ZXJ0ZXIucHJvdG90eXBlLmdldFByb3BlcnR5ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5zb3VyY2VtYXBba2V5XTtcbn07XG5cbmV4cG9ydHMuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG5ldyBDb252ZXJ0ZXIob2JqKTtcbn07XG5cbmV4cG9ydHMuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICByZXR1cm4gbmV3IENvbnZlcnRlcihqc29uLCB7IGlzSlNPTjogdHJ1ZSB9KTtcbn07XG5cbmV4cG9ydHMuZnJvbUJhc2U2NCA9IGZ1bmN0aW9uIChiYXNlNjQpIHtcbiAgcmV0dXJuIG5ldyBDb252ZXJ0ZXIoYmFzZTY0LCB7IGlzRW5jb2RlZDogdHJ1ZSB9KTtcbn07XG5cbmV4cG9ydHMuZnJvbUNvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCkge1xuICBjb21tZW50ID0gY29tbWVudFxuICAgIC5yZXBsYWNlKC9eXFwvXFwqL2csICcvLycpXG4gICAgLnJlcGxhY2UoL1xcKlxcLyQvZywgJycpO1xuXG4gIHJldHVybiBuZXcgQ29udmVydGVyKGNvbW1lbnQsIHsgaXNFbmNvZGVkOiB0cnVlLCBoYXNDb21tZW50OiB0cnVlIH0pO1xufTtcblxuZXhwb3J0cy5mcm9tTWFwRmlsZUNvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgZGlyKSB7XG4gIHJldHVybiBuZXcgQ29udmVydGVyKGNvbW1lbnQsIHsgY29tbWVudEZpbGVEaXI6IGRpciwgaXNGaWxlQ29tbWVudDogdHJ1ZSwgaXNKU09OOiB0cnVlIH0pO1xufTtcblxuLy8gRmluZHMgbGFzdCBzb3VyY2VtYXAgY29tbWVudCBpbiBmaWxlIG9yIHJldHVybnMgbnVsbCBpZiBub25lIHdhcyBmb3VuZFxuZXhwb3J0cy5mcm9tU291cmNlID0gZnVuY3Rpb24gKGNvbnRlbnQsIGxhcmdlU291cmNlKSB7XG4gIGlmIChsYXJnZVNvdXJjZSkge1xuICAgIHZhciByZXMgPSBjb252ZXJ0RnJvbUxhcmdlU291cmNlKGNvbnRlbnQpO1xuICAgIHJldHVybiByZXMgPyByZXMgOiBudWxsO1xuICB9XG5cbiAgdmFyIG0gPSBjb250ZW50Lm1hdGNoKGNvbW1lbnRSeCk7XG4gIGNvbW1lbnRSeC5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gbSA/IGV4cG9ydHMuZnJvbUNvbW1lbnQobS5wb3AoKSkgOiBudWxsO1xufTtcblxuLy8gRmluZHMgbGFzdCBzb3VyY2VtYXAgY29tbWVudCBpbiBmaWxlIG9yIHJldHVybnMgbnVsbCBpZiBub25lIHdhcyBmb3VuZFxuZXhwb3J0cy5mcm9tTWFwRmlsZVNvdXJjZSA9IGZ1bmN0aW9uIChjb250ZW50LCBkaXIpIHtcbiAgdmFyIG0gPSBjb250ZW50Lm1hdGNoKG1hcEZpbGVDb21tZW50UngpO1xuICBtYXBGaWxlQ29tbWVudFJ4Lmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiBtID8gZXhwb3J0cy5mcm9tTWFwRmlsZUNvbW1lbnQobS5wb3AoKSwgZGlyKSA6IG51bGw7XG59O1xuXG5leHBvcnRzLnJlbW92ZUNvbW1lbnRzID0gZnVuY3Rpb24gKHNyYykge1xuICBjb21tZW50UngubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRSeCwgJycpO1xufTtcblxuZXhwb3J0cy5yZW1vdmVNYXBGaWxlQ29tbWVudHMgPSBmdW5jdGlvbiAoc3JjKSB7XG4gIG1hcEZpbGVDb21tZW50UngubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKG1hcEZpbGVDb21tZW50UngsICcnKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY29tbWVudFJlZ2V4Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldENvbW1lbnRSZWdleCAoKSB7XG4gICAgY29tbWVudFJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGNvbW1lbnRSeDtcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbWFwRmlsZUNvbW1lbnRSZWdleCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXRNYXBGaWxlQ29tbWVudFJlZ2V4ICgpIHtcbiAgICBtYXBGaWxlQ29tbWVudFJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIG1hcEZpbGVDb21tZW50Ung7XG4gIH1cbn0pO1xuIiwiLyohIEBsaWNlbnNlIEZpcmViYXNlIHYyLjQuMVxuICAgIExpY2Vuc2U6IGh0dHBzOi8vd3d3LmZpcmViYXNlLmNvbS90ZXJtcy90ZXJtcy1vZi1zZXJ2aWNlLmh0bWwgKi9cbihmdW5jdGlvbigpIHt2YXIgaCxuPXRoaXM7ZnVuY3Rpb24gcChhKXtyZXR1cm4gdm9pZCAwIT09YX1mdW5jdGlvbiBhYSgpe31mdW5jdGlvbiBiYShhKXthLnliPWZ1bmN0aW9uKCl7cmV0dXJuIGEuemY/YS56ZjphLnpmPW5ldyBhfX1cbmZ1bmN0aW9uIGNhKGEpe3ZhciBiPXR5cGVvZiBhO2lmKFwib2JqZWN0XCI9PWIpaWYoYSl7aWYoYSBpbnN0YW5jZW9mIEFycmF5KXJldHVyblwiYXJyYXlcIjtpZihhIGluc3RhbmNlb2YgT2JqZWN0KXJldHVybiBiO3ZhciBjPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtpZihcIltvYmplY3QgV2luZG93XVwiPT1jKXJldHVyblwib2JqZWN0XCI7aWYoXCJbb2JqZWN0IEFycmF5XVwiPT1jfHxcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGgmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnNwbGljZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwic3BsaWNlXCIpKXJldHVyblwiYXJyYXlcIjtpZihcIltvYmplY3QgRnVuY3Rpb25dXCI9PWN8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLmNhbGwmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpcmV0dXJuXCJmdW5jdGlvblwifWVsc2UgcmV0dXJuXCJudWxsXCI7XG5lbHNlIGlmKFwiZnVuY3Rpb25cIj09YiYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIGEuY2FsbClyZXR1cm5cIm9iamVjdFwiO3JldHVybiBifWZ1bmN0aW9uIGRhKGEpe3JldHVyblwiYXJyYXlcIj09Y2EoYSl9ZnVuY3Rpb24gZWEoYSl7dmFyIGI9Y2EoYSk7cmV0dXJuXCJhcnJheVwiPT1ifHxcIm9iamVjdFwiPT1iJiZcIm51bWJlclwiPT10eXBlb2YgYS5sZW5ndGh9ZnVuY3Rpb24gcShhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYX1mdW5jdGlvbiBmYShhKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYX1mdW5jdGlvbiByKGEpe3JldHVyblwiZnVuY3Rpb25cIj09Y2EoYSl9ZnVuY3Rpb24gZ2EoYSl7dmFyIGI9dHlwZW9mIGE7cmV0dXJuXCJvYmplY3RcIj09YiYmbnVsbCE9YXx8XCJmdW5jdGlvblwiPT1ifWZ1bmN0aW9uIGhhKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfVxuZnVuY3Rpb24gaWEoYSxiLGMpe2lmKCFhKXRocm93IEVycm9yKCk7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLGQpO3JldHVybiBhLmFwcGx5KGIsYyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gdShhLGIsYyl7dT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCYmLTEhPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpP2hhOmlhO3JldHVybiB1LmFwcGx5KG51bGwsYXJndW1lbnRzKX12YXIgamE9RGF0ZS5ub3d8fGZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfTtcbmZ1bmN0aW9uIGthKGEsYil7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT1iLnByb3RvdHlwZTthLm9oPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBjO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWE7YS5raD1mdW5jdGlvbihhLGMsZil7Zm9yKHZhciBnPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMiksaz0yO2s8YXJndW1lbnRzLmxlbmd0aDtrKyspZ1trLTJdPWFyZ3VtZW50c1trXTtyZXR1cm4gYi5wcm90b3R5cGVbY10uYXBwbHkoYSxnKX19O2Z1bmN0aW9uIGxhKGEpe2lmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsbGEpO2Vsc2V7dmFyIGI9RXJyb3IoKS5zdGFjaztiJiYodGhpcy5zdGFjaz1iKX1hJiYodGhpcy5tZXNzYWdlPVN0cmluZyhhKSl9a2EobGEsRXJyb3IpO2xhLnByb3RvdHlwZS5uYW1lPVwiQ3VzdG9tRXJyb3JcIjtmdW5jdGlvbiB2KGEsYil7Zm9yKHZhciBjIGluIGEpYi5jYWxsKHZvaWQgMCxhW2NdLGMsYSl9ZnVuY3Rpb24gbWEoYSxiKXt2YXIgYz17fSxkO2ZvcihkIGluIGEpY1tkXT1iLmNhbGwodm9pZCAwLGFbZF0sZCxhKTtyZXR1cm4gY31mdW5jdGlvbiBuYShhLGIpe2Zvcih2YXIgYyBpbiBhKWlmKCFiLmNhbGwodm9pZCAwLGFbY10sYyxhKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBvYShhKXt2YXIgYj0wLGM7Zm9yKGMgaW4gYSliKys7cmV0dXJuIGJ9ZnVuY3Rpb24gcGEoYSl7Zm9yKHZhciBiIGluIGEpcmV0dXJuIGJ9ZnVuY3Rpb24gcWEoYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109YVtkXTtyZXR1cm4gYn1mdW5jdGlvbiByYShhKXt2YXIgYj1bXSxjPTAsZDtmb3IoZCBpbiBhKWJbYysrXT1kO3JldHVybiBifWZ1bmN0aW9uIHNhKGEsYil7Zm9yKHZhciBjIGluIGEpaWYoYVtjXT09YilyZXR1cm4hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIHRhKGEsYixjKXtmb3IodmFyIGQgaW4gYSlpZihiLmNhbGwoYyxhW2RdLGQsYSkpcmV0dXJuIGR9ZnVuY3Rpb24gdWEoYSxiKXt2YXIgYz10YShhLGIsdm9pZCAwKTtyZXR1cm4gYyYmYVtjXX1mdW5jdGlvbiB2YShhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB3YShhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYltjXT1hW2NdO3JldHVybiBifXZhciB4YT1cImNvbnN0cnVjdG9yIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGUgdG9Mb2NhbGVTdHJpbmcgdG9TdHJpbmcgdmFsdWVPZlwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIHlhKGEsYil7Zm9yKHZhciBjLGQsZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe2Q9YXJndW1lbnRzW2VdO2ZvcihjIGluIGQpYVtjXT1kW2NdO2Zvcih2YXIgZj0wO2Y8eGEubGVuZ3RoO2YrKyljPXhhW2ZdLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLGMpJiYoYVtjXT1kW2NdKX19O2Z1bmN0aW9uIHphKGEpe2E9U3RyaW5nKGEpO2lmKC9eXFxzKiQvLnRlc3QoYSk/MDovXltcXF0sOnt9XFxzXFx1MjAyOFxcdTIwMjldKiQvLnRlc3QoYS5yZXBsYWNlKC9cXFxcW1wiXFxcXFxcL2JmbnJ0dV0vZyxcIkBcIikucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XFx4MDAtXFx4MDhcXHgwYS1cXHgxZl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OltcXHNcXHUyMDI4XFx1MjAyOV0qXFxbKSsvZyxcIlwiKSkpdHJ5e3JldHVybiBldmFsKFwiKFwiK2ErXCIpXCIpfWNhdGNoKGIpe310aHJvdyBFcnJvcihcIkludmFsaWQgSlNPTiBzdHJpbmc6IFwiK2EpO31mdW5jdGlvbiBBYSgpe3RoaXMuVmQ9dm9pZCAwfVxuZnVuY3Rpb24gQmEoYSxiLGMpe3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcInN0cmluZ1wiOkNhKGIsYyk7YnJlYWs7Y2FzZSBcIm51bWJlclwiOmMucHVzaChpc0Zpbml0ZShiKSYmIWlzTmFOKGIpP2I6XCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJib29sZWFuXCI6Yy5wdXNoKGIpO2JyZWFrO2Nhc2UgXCJ1bmRlZmluZWRcIjpjLnB1c2goXCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjppZihudWxsPT1iKXtjLnB1c2goXCJudWxsXCIpO2JyZWFrfWlmKGRhKGIpKXt2YXIgZD1iLmxlbmd0aDtjLnB1c2goXCJbXCIpO2Zvcih2YXIgZT1cIlwiLGY9MDtmPGQ7ZisrKWMucHVzaChlKSxlPWJbZl0sQmEoYSxhLlZkP2EuVmQuY2FsbChiLFN0cmluZyhmKSxlKTplLGMpLGU9XCIsXCI7Yy5wdXNoKFwiXVwiKTticmVha31jLnB1c2goXCJ7XCIpO2Q9XCJcIjtmb3IoZiBpbiBiKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLGYpJiYoZT1iW2ZdLFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJihjLnB1c2goZCksQ2EoZixjKSxcbmMucHVzaChcIjpcIiksQmEoYSxhLlZkP2EuVmQuY2FsbChiLGYsZSk6ZSxjKSxkPVwiLFwiKSk7Yy5wdXNoKFwifVwiKTticmVhaztjYXNlIFwiZnVuY3Rpb25cIjpicmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0eXBlb2YgYik7fX12YXIgRGE9eydcIic6J1xcXFxcIicsXCJcXFxcXCI6XCJcXFxcXFxcXFwiLFwiL1wiOlwiXFxcXC9cIixcIlxcYlwiOlwiXFxcXGJcIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcclwiOlwiXFxcXHJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxceDBCXCI6XCJcXFxcdTAwMGJcIn0sRWE9L1xcdWZmZmYvLnRlc3QoXCJcXHVmZmZmXCIpPy9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2c6L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4ZmZdL2c7XG5mdW5jdGlvbiBDYShhLGIpe2IucHVzaCgnXCInLGEucmVwbGFjZShFYSxmdW5jdGlvbihhKXtpZihhIGluIERhKXJldHVybiBEYVthXTt2YXIgYj1hLmNoYXJDb2RlQXQoMCksZT1cIlxcXFx1XCI7MTY+Yj9lKz1cIjAwMFwiOjI1Nj5iP2UrPVwiMDBcIjo0MDk2PmImJihlKz1cIjBcIik7cmV0dXJuIERhW2FdPWUrYi50b1N0cmluZygxNil9KSwnXCInKX07ZnVuY3Rpb24gRmEoKXtyZXR1cm4gTWF0aC5mbG9vcigyMTQ3NDgzNjQ4Kk1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDM2KStNYXRoLmFicyhNYXRoLmZsb29yKDIxNDc0ODM2NDgqTWF0aC5yYW5kb20oKSleamEoKSkudG9TdHJpbmcoMzYpfTt2YXIgdzthOnt2YXIgR2E9bi5uYXZpZ2F0b3I7aWYoR2Epe3ZhciBIYT1HYS51c2VyQWdlbnQ7aWYoSGEpe3c9SGE7YnJlYWsgYX19dz1cIlwifTtmdW5jdGlvbiBJYSgpe3RoaXMuWWE9LTF9O2Z1bmN0aW9uIEphKCl7dGhpcy5ZYT0tMTt0aGlzLllhPTY0O3RoaXMuUD1bXTt0aGlzLnBlPVtdO3RoaXMuZWc9W107dGhpcy5PZD1bXTt0aGlzLk9kWzBdPTEyODtmb3IodmFyIGE9MTthPHRoaXMuWWE7KythKXRoaXMuT2RbYV09MDt0aGlzLmdlPXRoaXMuZWM9MDt0aGlzLnJlc2V0KCl9a2EoSmEsSWEpO0phLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuUFswXT0xNzMyNTg0MTkzO3RoaXMuUFsxXT00MDIzMjMzNDE3O3RoaXMuUFsyXT0yNTYyMzgzMTAyO3RoaXMuUFszXT0yNzE3MzM4Nzg7dGhpcy5QWzRdPTMyODUzNzc1MjA7dGhpcy5nZT10aGlzLmVjPTB9O1xuZnVuY3Rpb24gS2EoYSxiLGMpe2N8fChjPTApO3ZhciBkPWEuZWc7aWYocShiKSlmb3IodmFyIGU9MDsxNj5lO2UrKylkW2VdPWIuY2hhckNvZGVBdChjKTw8MjR8Yi5jaGFyQ29kZUF0KGMrMSk8PDE2fGIuY2hhckNvZGVBdChjKzIpPDw4fGIuY2hhckNvZGVBdChjKzMpLGMrPTQ7ZWxzZSBmb3IoZT0wOzE2PmU7ZSsrKWRbZV09YltjXTw8MjR8YltjKzFdPDwxNnxiW2MrMl08PDh8YltjKzNdLGMrPTQ7Zm9yKGU9MTY7ODA+ZTtlKyspe3ZhciBmPWRbZS0zXV5kW2UtOF1eZFtlLTE0XV5kW2UtMTZdO2RbZV09KGY8PDF8Zj4+PjMxKSY0Mjk0OTY3Mjk1fWI9YS5QWzBdO2M9YS5QWzFdO2Zvcih2YXIgZz1hLlBbMl0saz1hLlBbM10sbT1hLlBbNF0sbCxlPTA7ODA+ZTtlKyspNDA+ZT8yMD5lPyhmPWteYyYoZ15rKSxsPTE1MTg1MDAyNDkpOihmPWNeZ15rLGw9MTg1OTc3NTM5Myk6NjA+ZT8oZj1jJmd8ayYoY3xnKSxsPTI0MDA5NTk3MDgpOihmPWNeZ15rLGw9MzM5NTQ2OTc4MiksZj0oYjw8XG41fGI+Pj4yNykrZittK2wrZFtlXSY0Mjk0OTY3Mjk1LG09ayxrPWcsZz0oYzw8MzB8Yz4+PjIpJjQyOTQ5NjcyOTUsYz1iLGI9ZjthLlBbMF09YS5QWzBdK2ImNDI5NDk2NzI5NTthLlBbMV09YS5QWzFdK2MmNDI5NDk2NzI5NTthLlBbMl09YS5QWzJdK2cmNDI5NDk2NzI5NTthLlBbM109YS5QWzNdK2smNDI5NDk2NzI5NTthLlBbNF09YS5QWzRdK20mNDI5NDk2NzI5NX1cbkphLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKXtwKGIpfHwoYj1hLmxlbmd0aCk7Zm9yKHZhciBjPWItdGhpcy5ZYSxkPTAsZT10aGlzLnBlLGY9dGhpcy5lYztkPGI7KXtpZigwPT1mKWZvcig7ZDw9YzspS2EodGhpcyxhLGQpLGQrPXRoaXMuWWE7aWYocShhKSlmb3IoO2Q8Yjspe2lmKGVbZl09YS5jaGFyQ29kZUF0KGQpLCsrZiwrK2QsZj09dGhpcy5ZYSl7S2EodGhpcyxlKTtmPTA7YnJlYWt9fWVsc2UgZm9yKDtkPGI7KWlmKGVbZl09YVtkXSwrK2YsKytkLGY9PXRoaXMuWWEpe0thKHRoaXMsZSk7Zj0wO2JyZWFrfX10aGlzLmVjPWY7dGhpcy5nZSs9Yn19O3ZhciB4PUFycmF5LnByb3RvdHlwZSxMYT14LmluZGV4T2Y/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB4LmluZGV4T2YuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtjPW51bGw9PWM/MDowPmM/TWF0aC5tYXgoMCxhLmxlbmd0aCtjKTpjO2lmKHEoYSkpcmV0dXJuIHEoYikmJjE9PWIubGVuZ3RoP2EuaW5kZXhPZihiLGMpOi0xO2Zvcig7YzxhLmxlbmd0aDtjKyspaWYoYyBpbiBhJiZhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sTWE9eC5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXt4LmZvckVhY2guY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1xKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKX0sTmE9eC5maWx0ZXI/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB4LmZpbHRlci5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPVtdLGY9MCxnPXEoYSk/XG5hLnNwbGl0KFwiXCIpOmEsaz0wO2s8ZDtrKyspaWYoayBpbiBnKXt2YXIgbT1nW2tdO2IuY2FsbChjLG0sayxhKSYmKGVbZisrXT1tKX1yZXR1cm4gZX0sT2E9eC5tYXA/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB4Lm1hcC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPUFycmF5KGQpLGY9cShhKT9hLnNwbGl0KFwiXCIpOmEsZz0wO2c8ZDtnKyspZyBpbiBmJiYoZVtnXT1iLmNhbGwoYyxmW2ddLGcsYSkpO3JldHVybiBlfSxQYT14LnJlZHVjZT9mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGU9W10sZj0xLGc9YXJndW1lbnRzLmxlbmd0aDtmPGc7ZisrKWUucHVzaChhcmd1bWVudHNbZl0pO2QmJihlWzBdPXUoYixkKSk7cmV0dXJuIHgucmVkdWNlLmFwcGx5KGEsZSl9OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWM7TWEoYSxmdW5jdGlvbihjLGcpe2U9Yi5jYWxsKGQsZSxjLGcsYSl9KTtyZXR1cm4gZX0sUWE9eC5ldmVyeT9mdW5jdGlvbihhLGIsXG5jKXtyZXR1cm4geC5ldmVyeS5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPXEoYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWlmKGYgaW4gZSYmIWIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4hMTtyZXR1cm4hMH07ZnVuY3Rpb24gUmEoYSxiKXt2YXIgYz1TYShhLGIsdm9pZCAwKTtyZXR1cm4gMD5jP251bGw6cShhKT9hLmNoYXJBdChjKTphW2NdfWZ1bmN0aW9uIFNhKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1xKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylpZihmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4gZjtyZXR1cm4tMX1mdW5jdGlvbiBUYShhLGIpe3ZhciBjPUxhKGEsYik7MDw9YyYmeC5zcGxpY2UuY2FsbChhLGMsMSl9ZnVuY3Rpb24gVWEoYSxiLGMpe3JldHVybiAyPj1hcmd1bWVudHMubGVuZ3RoP3guc2xpY2UuY2FsbChhLGIpOnguc2xpY2UuY2FsbChhLGIsYyl9XG5mdW5jdGlvbiBWYShhLGIpe2Euc29ydChifHxXYSl9ZnVuY3Rpb24gV2EoYSxiKXtyZXR1cm4gYT5iPzE6YTxiPy0xOjB9O2Z1bmN0aW9uIFhhKGEpe24uc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGE7fSwwKX12YXIgWWE7XG5mdW5jdGlvbiBaYSgpe3ZhciBhPW4uTWVzc2FnZUNoYW5uZWw7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmd2luZG93LnBvc3RNZXNzYWdlJiZ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciYmLTE9PXcuaW5kZXhPZihcIlByZXN0b1wiKSYmKGE9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2Euc3R5bGUuZGlzcGxheT1cIm5vbmVcIjthLnNyYz1cIlwiO2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChhKTt2YXIgYj1hLmNvbnRlbnRXaW5kb3csYT1iLmRvY3VtZW50O2Eub3BlbigpO2Eud3JpdGUoXCJcIik7YS5jbG9zZSgpO3ZhciBjPVwiY2FsbEltbWVkaWF0ZVwiK01hdGgucmFuZG9tKCksZD1cImZpbGU6XCI9PWIubG9jYXRpb24ucHJvdG9jb2w/XCIqXCI6Yi5sb2NhdGlvbi5wcm90b2NvbCtcIi8vXCIrYi5sb2NhdGlvbi5ob3N0LGE9dShmdW5jdGlvbihhKXtpZigoXCIqXCI9PWR8fGEub3JpZ2luPT1cbmQpJiZhLmRhdGE9PWMpdGhpcy5wb3J0MS5vbm1lc3NhZ2UoKX0sdGhpcyk7Yi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGEsITEpO3RoaXMucG9ydDE9e307dGhpcy5wb3J0Mj17cG9zdE1lc3NhZ2U6ZnVuY3Rpb24oKXtiLnBvc3RNZXNzYWdlKGMsZCl9fX0pO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmLTE9PXcuaW5kZXhPZihcIlRyaWRlbnRcIikmJi0xPT13LmluZGV4T2YoXCJNU0lFXCIpKXt2YXIgYj1uZXcgYSxjPXt9LGQ9YztiLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKHAoYy5uZXh0KSl7Yz1jLm5leHQ7dmFyIGE9Yy5oYjtjLmhiPW51bGw7YSgpfX07cmV0dXJuIGZ1bmN0aW9uKGEpe2QubmV4dD17aGI6YX07ZD1kLm5leHQ7Yi5wb3J0Mi5wb3N0TWVzc2FnZSgwKX19cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik/ZnVuY3Rpb24oYSl7dmFyIGI9XG5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Iub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbDtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7Yj1udWxsO2EoKTthPW51bGx9O2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChiKX06ZnVuY3Rpb24oYSl7bi5zZXRUaW1lb3V0KGEsMCl9fTtmdW5jdGlvbiAkYShhLGIpe2FifHxiYigpO2NifHwoYWIoKSxjYj0hMCk7ZGIucHVzaChuZXcgZWIoYSxiKSl9dmFyIGFiO2Z1bmN0aW9uIGJiKCl7aWYobi5Qcm9taXNlJiZuLlByb21pc2UucmVzb2x2ZSl7dmFyIGE9bi5Qcm9taXNlLnJlc29sdmUoKTthYj1mdW5jdGlvbigpe2EudGhlbihmYil9fWVsc2UgYWI9ZnVuY3Rpb24oKXt2YXIgYT1mYjshcihuLnNldEltbWVkaWF0ZSl8fG4uV2luZG93JiZuLldpbmRvdy5wcm90b3R5cGUmJm4uV2luZG93LnByb3RvdHlwZS5zZXRJbW1lZGlhdGU9PW4uc2V0SW1tZWRpYXRlPyhZYXx8KFlhPVphKCkpLFlhKGEpKTpuLnNldEltbWVkaWF0ZShhKX19dmFyIGNiPSExLGRiPVtdO1tdLnB1c2goZnVuY3Rpb24oKXtjYj0hMTtkYj1bXX0pO1xuZnVuY3Rpb24gZmIoKXtmb3IoO2RiLmxlbmd0aDspe3ZhciBhPWRiO2RiPVtdO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO3RyeXtjLnlnLmNhbGwoYy5zY29wZSl9Y2F0Y2goZCl7WGEoZCl9fX1jYj0hMX1mdW5jdGlvbiBlYihhLGIpe3RoaXMueWc9YTt0aGlzLnNjb3BlPWJ9O3ZhciBnYj0tMSE9dy5pbmRleE9mKFwiT3BlcmFcIil8fC0xIT13LmluZGV4T2YoXCJPUFJcIiksaGI9LTEhPXcuaW5kZXhPZihcIlRyaWRlbnRcIil8fC0xIT13LmluZGV4T2YoXCJNU0lFXCIpLGliPS0xIT13LmluZGV4T2YoXCJHZWNrb1wiKSYmLTE9PXcudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpJiYhKC0xIT13LmluZGV4T2YoXCJUcmlkZW50XCIpfHwtMSE9dy5pbmRleE9mKFwiTVNJRVwiKSksamI9LTEhPXcudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwid2Via2l0XCIpO1xuKGZ1bmN0aW9uKCl7dmFyIGE9XCJcIixiO2lmKGdiJiZuLm9wZXJhKXJldHVybiBhPW4ub3BlcmEudmVyc2lvbixyKGEpP2EoKTphO2liP2I9L3J2XFw6KFteXFwpO10rKShcXCl8OykvOmhiP2I9L1xcYig/Ok1TSUV8cnYpWzogXShbXlxcKTtdKykoXFwpfDspLzpqYiYmKGI9L1dlYktpdFxcLyhcXFMrKS8pO2ImJihhPShhPWIuZXhlYyh3KSk/YVsxXTpcIlwiKTtyZXR1cm4gaGImJihiPShiPW4uZG9jdW1lbnQpP2IuZG9jdW1lbnRNb2RlOnZvaWQgMCxiPnBhcnNlRmxvYXQoYSkpP1N0cmluZyhiKTphfSkoKTt2YXIga2I9bnVsbCxsYj1udWxsLG1iPW51bGw7ZnVuY3Rpb24gbmIoYSxiKXtpZighZWEoYSkpdGhyb3cgRXJyb3IoXCJlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXJcIik7b2IoKTtmb3IodmFyIGM9Yj9sYjprYixkPVtdLGU9MDtlPGEubGVuZ3RoO2UrPTMpe3ZhciBmPWFbZV0sZz1lKzE8YS5sZW5ndGgsaz1nP2FbZSsxXTowLG09ZSsyPGEubGVuZ3RoLGw9bT9hW2UrMl06MCx0PWY+PjIsZj0oZiYzKTw8NHxrPj40LGs9KGsmMTUpPDwyfGw+PjYsbD1sJjYzO218fChsPTY0LGd8fChrPTY0KSk7ZC5wdXNoKGNbdF0sY1tmXSxjW2tdLGNbbF0pfXJldHVybiBkLmpvaW4oXCJcIil9XG5mdW5jdGlvbiBvYigpe2lmKCFrYil7a2I9e307bGI9e307bWI9e307Zm9yKHZhciBhPTA7NjU+YTthKyspa2JbYV09XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLmNoYXJBdChhKSxsYlthXT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8uXCIuY2hhckF0KGEpLG1iW2xiW2FdXT1hLDYyPD1hJiYobWJbXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLmNoYXJBdChhKV09YSl9fTtmdW5jdGlvbiBwYihhLGIpe3RoaXMuTj1xYjt0aGlzLlJmPXZvaWQgMDt0aGlzLkJhPXRoaXMuSGE9bnVsbDt0aGlzLnlkPXRoaXMueWU9ITE7aWYoYT09cmIpc2IodGhpcyx0YixiKTtlbHNlIHRyeXt2YXIgYz10aGlzO2EuY2FsbChiLGZ1bmN0aW9uKGEpe3NiKGMsdGIsYSl9LGZ1bmN0aW9uKGEpe2lmKCEoYSBpbnN0YW5jZW9mIHViKSl0cnl7aWYoYSBpbnN0YW5jZW9mIEVycm9yKXRocm93IGE7dGhyb3cgRXJyb3IoXCJQcm9taXNlIHJlamVjdGVkLlwiKTt9Y2F0Y2goYil7fXNiKGMsdmIsYSl9KX1jYXRjaChkKXtzYih0aGlzLHZiLGQpfX12YXIgcWI9MCx0Yj0yLHZiPTM7ZnVuY3Rpb24gcmIoKXt9cGIucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB3Yih0aGlzLHIoYSk/YTpudWxsLHIoYik/YjpudWxsLGMpfTtwYi5wcm90b3R5cGUudGhlbj1wYi5wcm90b3R5cGUudGhlbjtwYi5wcm90b3R5cGUuJGdvb2dfVGhlbmFibGU9ITA7aD1wYi5wcm90b3R5cGU7XG5oLmZoPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHdiKHRoaXMsbnVsbCxhLGIpfTtoLmNhbmNlbD1mdW5jdGlvbihhKXt0aGlzLk49PXFiJiYkYShmdW5jdGlvbigpe3ZhciBiPW5ldyB1YihhKTt4Yih0aGlzLGIpfSx0aGlzKX07ZnVuY3Rpb24geGIoYSxiKXtpZihhLk49PXFiKWlmKGEuSGEpe3ZhciBjPWEuSGE7aWYoYy5CYSl7Zm9yKHZhciBkPTAsZT0tMSxmPTAsZztnPWMuQmFbZl07ZisrKWlmKGc9Zy5vKWlmKGQrKyxnPT1hJiYoZT1mKSwwPD1lJiYxPGQpYnJlYWs7MDw9ZSYmKGMuTj09cWImJjE9PWQ/eGIoYyxiKTooZD1jLkJhLnNwbGljZShlLDEpWzBdLHliKGMsZCx2YixiKSkpfWEuSGE9bnVsbH1lbHNlIHNiKGEsdmIsYil9ZnVuY3Rpb24gemIoYSxiKXthLkJhJiZhLkJhLmxlbmd0aHx8YS5OIT10YiYmYS5OIT12Ynx8QWIoYSk7YS5CYXx8KGEuQmE9W10pO2EuQmEucHVzaChiKX1cbmZ1bmN0aW9uIHdiKGEsYixjLGQpe3ZhciBlPXtvOm51bGwsSGY6bnVsbCxKZjpudWxsfTtlLm89bmV3IHBiKGZ1bmN0aW9uKGEsZyl7ZS5IZj1iP2Z1bmN0aW9uKGMpe3RyeXt2YXIgZT1iLmNhbGwoZCxjKTthKGUpfWNhdGNoKGwpe2cobCl9fTphO2UuSmY9Yz9mdW5jdGlvbihiKXt0cnl7dmFyIGU9Yy5jYWxsKGQsYik7IXAoZSkmJmIgaW5zdGFuY2VvZiB1Yj9nKGIpOmEoZSl9Y2F0Y2gobCl7ZyhsKX19Omd9KTtlLm8uSGE9YTt6YihhLGUpO3JldHVybiBlLm99aC5ZZj1mdW5jdGlvbihhKXt0aGlzLk49cWI7c2IodGhpcyx0YixhKX07aC5aZj1mdW5jdGlvbihhKXt0aGlzLk49cWI7c2IodGhpcyx2YixhKX07XG5mdW5jdGlvbiBzYihhLGIsYyl7aWYoYS5OPT1xYil7aWYoYT09YyliPXZiLGM9bmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2Fubm90IHJlc29sdmUgdG8gaXRzZWxmXCIpO2Vsc2V7dmFyIGQ7aWYoYyl0cnl7ZD0hIWMuJGdvb2dfVGhlbmFibGV9Y2F0Y2goZSl7ZD0hMX1lbHNlIGQ9ITE7aWYoZCl7YS5OPTE7Yy50aGVuKGEuWWYsYS5aZixhKTtyZXR1cm59aWYoZ2EoYykpdHJ5e3ZhciBmPWMudGhlbjtpZihyKGYpKXtCYihhLGMsZik7cmV0dXJufX1jYXRjaChnKXtiPXZiLGM9Z319YS5SZj1jO2EuTj1iO2EuSGE9bnVsbDtBYihhKTtiIT12Ynx8YyBpbnN0YW5jZW9mIHVifHxDYihhLGMpfX1mdW5jdGlvbiBCYihhLGIsYyl7ZnVuY3Rpb24gZChiKXtmfHwoZj0hMCxhLlpmKGIpKX1mdW5jdGlvbiBlKGIpe2Z8fChmPSEwLGEuWWYoYikpfWEuTj0xO3ZhciBmPSExO3RyeXtjLmNhbGwoYixlLGQpfWNhdGNoKGcpe2QoZyl9fVxuZnVuY3Rpb24gQWIoYSl7YS55ZXx8KGEueWU9ITAsJGEoYS53ZyxhKSl9aC53Zz1mdW5jdGlvbigpe2Zvcig7dGhpcy5CYSYmdGhpcy5CYS5sZW5ndGg7KXt2YXIgYT10aGlzLkJhO3RoaXMuQmE9bnVsbDtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl5Yih0aGlzLGFbYl0sdGhpcy5OLHRoaXMuUmYpfXRoaXMueWU9ITF9O2Z1bmN0aW9uIHliKGEsYixjLGQpe2lmKGM9PXRiKWIuSGYoZCk7ZWxzZXtpZihiLm8pZm9yKDthJiZhLnlkO2E9YS5IYSlhLnlkPSExO2IuSmYoZCl9fWZ1bmN0aW9uIENiKGEsYil7YS55ZD0hMDskYShmdW5jdGlvbigpe2EueWQmJkRiLmNhbGwobnVsbCxiKX0pfXZhciBEYj1YYTtmdW5jdGlvbiB1YihhKXtsYS5jYWxsKHRoaXMsYSl9a2EodWIsbGEpO3ViLnByb3RvdHlwZS5uYW1lPVwiY2FuY2VsXCI7dmFyIEViPUVifHxcIjIuNC4xXCI7ZnVuY3Rpb24geShhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxiKX1mdW5jdGlvbiB6KGEsYil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsYikpcmV0dXJuIGFbYl19ZnVuY3Rpb24gRmIoYSxiKXtmb3IodmFyIGMgaW4gYSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjKSYmYihjLGFbY10pfWZ1bmN0aW9uIEdiKGEpe3ZhciBiPXt9O0ZiKGEsZnVuY3Rpb24oYSxkKXtiW2FdPWR9KTtyZXR1cm4gYn1mdW5jdGlvbiBIYihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hfTtmdW5jdGlvbiBJYihhKXt2YXIgYj1bXTtGYihhLGZ1bmN0aW9uKGEsZCl7ZGEoZCk/TWEoZCxmdW5jdGlvbihkKXtiLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGEpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChkKSl9KTpiLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGEpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChkKSl9KTtyZXR1cm4gYi5sZW5ndGg/XCImXCIrYi5qb2luKFwiJlwiKTpcIlwifWZ1bmN0aW9uIEpiKGEpe3ZhciBiPXt9O2E9YS5yZXBsYWNlKC9eXFw/LyxcIlwiKS5zcGxpdChcIiZcIik7TWEoYSxmdW5jdGlvbihhKXthJiYoYT1hLnNwbGl0KFwiPVwiKSxiW2FbMF1dPWFbMV0pfSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIEtiKGEsYil7aWYoIWEpdGhyb3cgTGIoYik7fWZ1bmN0aW9uIExiKGEpe3JldHVybiBFcnJvcihcIkZpcmViYXNlIChcIitFYitcIikgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogXCIrYSl9O3ZhciBNYj1uLlByb21pc2V8fHBiO3BiLnByb3RvdHlwZVtcImNhdGNoXCJdPXBiLnByb3RvdHlwZS5maDtmdW5jdGlvbiBCKCl7dmFyIGE9dGhpczt0aGlzLnJlamVjdD10aGlzLnJlc29sdmU9bnVsbDt0aGlzLkQ9bmV3IE1iKGZ1bmN0aW9uKGIsYyl7YS5yZXNvbHZlPWI7YS5yZWplY3Q9Y30pfWZ1bmN0aW9uIEMoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXtjP2EucmVqZWN0KGMpOmEucmVzb2x2ZShkKTtyKGIpJiYoTmIoYS5EKSwxPT09Yi5sZW5ndGg/YihjKTpiKGMsZCkpfX1mdW5jdGlvbiBOYihhKXthLnRoZW4odm9pZCAwLGFhKX07ZnVuY3Rpb24gT2IoYSl7Zm9yKHZhciBiPVtdLGM9MCxkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBlPWEuY2hhckNvZGVBdChkKTs1NTI5Njw9ZSYmNTYzMTk+PWUmJihlLT01NTI5NixkKyssS2IoZDxhLmxlbmd0aCxcIlN1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLlwiKSxlPTY1NTM2KyhlPDwxMCkrKGEuY2hhckNvZGVBdChkKS01NjMyMCkpOzEyOD5lP2JbYysrXT1lOigyMDQ4PmU/YltjKytdPWU+PjZ8MTkyOig2NTUzNj5lP2JbYysrXT1lPj4xMnwyMjQ6KGJbYysrXT1lPj4xOHwyNDAsYltjKytdPWU+PjEyJjYzfDEyOCksYltjKytdPWU+PjYmNjN8MTI4KSxiW2MrK109ZSY2M3wxMjgpfXJldHVybiBifWZ1bmN0aW9uIFBiKGEpe2Zvcih2YXIgYj0wLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YS5jaGFyQ29kZUF0KGMpOzEyOD5kP2IrKzoyMDQ4PmQ/Yis9Mjo1NTI5Njw9ZCYmNTYzMTk+PWQ/KGIrPTQsYysrKTpiKz0zfXJldHVybiBifTtmdW5jdGlvbiBEKGEsYixjLGQpe3ZhciBlO2Q8Yj9lPVwiYXQgbGVhc3QgXCIrYjpkPmMmJihlPTA9PT1jP1wibm9uZVwiOlwibm8gbW9yZSB0aGFuIFwiK2MpO2lmKGUpdGhyb3cgRXJyb3IoYStcIiBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCBcIitkKygxPT09ZD9cIiBhcmd1bWVudC5cIjpcIiBhcmd1bWVudHMuXCIpK1wiIEV4cGVjdHMgXCIrZStcIi5cIik7fWZ1bmN0aW9uIEUoYSxiLGMpe3ZhciBkPVwiXCI7c3dpdGNoKGIpe2Nhc2UgMTpkPWM/XCJmaXJzdFwiOlwiRmlyc3RcIjticmVhaztjYXNlIDI6ZD1jP1wic2Vjb25kXCI6XCJTZWNvbmRcIjticmVhaztjYXNlIDM6ZD1jP1widGhpcmRcIjpcIlRoaXJkXCI7YnJlYWs7Y2FzZSA0OmQ9Yz9cImZvdXJ0aFwiOlwiRm91cnRoXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImVycm9yUHJlZml4IGNhbGxlZCB3aXRoIGFyZ3VtZW50TnVtYmVyID4gNC4gIE5lZWQgdG8gdXBkYXRlIGl0P1wiKTt9cmV0dXJuIGE9YStcIiBmYWlsZWQ6IFwiKyhkK1wiIGFyZ3VtZW50IFwiKX1cbmZ1bmN0aW9uIEYoYSxiLGMsZCl7aWYoKCFkfHxwKGMpKSYmIXIoYykpdGhyb3cgRXJyb3IoRShhLGIsZCkrXCJtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uXCIpO31mdW5jdGlvbiBRYihhLGIsYyl7aWYocChjKSYmKCFnYShjKXx8bnVsbD09PWMpKXRocm93IEVycm9yKEUoYSxiLCEwKStcIm11c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC5cIik7fTtmdW5jdGlvbiBSYihhKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIEpTT04mJnAoSlNPTi5wYXJzZSk/SlNPTi5wYXJzZShhKTp6YShhKX1mdW5jdGlvbiBHKGEpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgSlNPTiYmcChKU09OLnN0cmluZ2lmeSkpYT1KU09OLnN0cmluZ2lmeShhKTtlbHNle3ZhciBiPVtdO0JhKG5ldyBBYSxhLGIpO2E9Yi5qb2luKFwiXCIpfXJldHVybiBhfTtmdW5jdGlvbiBTYigpe3RoaXMuWmQ9SH1TYi5wcm90b3R5cGUuaj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5aZC5TKGEpfTtTYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5aZC50b1N0cmluZygpfTtmdW5jdGlvbiBUYigpe31UYi5wcm90b3R5cGUudWY9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07VGIucHJvdG90eXBlLkNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3ZhciBVYj1uZXcgVGI7ZnVuY3Rpb24gVmIoYSxiLGMpe3RoaXMuYmc9YTt0aGlzLk9hPWI7dGhpcy5OZD1jfVZiLnByb3RvdHlwZS51Zj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLk9hLlE7aWYoV2IoYixhKSlyZXR1cm4gYi5qKCkuVChhKTtiPW51bGwhPXRoaXMuTmQ/bmV3IFhiKHRoaXMuTmQsITAsITEpOnRoaXMuT2EudygpO3JldHVybiB0aGlzLmJnLkJjKGEsYil9O1ZiLnByb3RvdHlwZS5DZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9bnVsbCE9dGhpcy5OZD90aGlzLk5kOlliKHRoaXMuT2EpO2E9dGhpcy5iZy5xZShkLGIsMSxjLGEpO3JldHVybiAwPT09YS5sZW5ndGg/bnVsbDphWzBdfTtmdW5jdGlvbiBaYigpe3RoaXMueGI9W119ZnVuY3Rpb24gJGIoYSxiKXtmb3IodmFyIGM9bnVsbCxkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF0sZj1lLmNjKCk7bnVsbD09PWN8fGYuZWEoYy5jYygpKXx8KGEueGIucHVzaChjKSxjPW51bGwpO251bGw9PT1jJiYoYz1uZXcgYWMoZikpO2MuYWRkKGUpfWMmJmEueGIucHVzaChjKX1mdW5jdGlvbiBiYyhhLGIsYyl7JGIoYSxjKTtjYyhhLGZ1bmN0aW9uKGEpe3JldHVybiBhLmVhKGIpfSl9ZnVuY3Rpb24gZGMoYSxiLGMpeyRiKGEsYyk7Y2MoYSxmdW5jdGlvbihhKXtyZXR1cm4gYS5jb250YWlucyhiKXx8Yi5jb250YWlucyhhKX0pfVxuZnVuY3Rpb24gY2MoYSxiKXtmb3IodmFyIGM9ITAsZD0wO2Q8YS54Yi5sZW5ndGg7ZCsrKXt2YXIgZT1hLnhiW2RdO2lmKGUpaWYoZT1lLmNjKCksYihlKSl7Zm9yKHZhciBlPWEueGJbZF0sZj0wO2Y8ZS54ZC5sZW5ndGg7ZisrKXt2YXIgZz1lLnhkW2ZdO2lmKG51bGwhPT1nKXtlLnhkW2ZdPW51bGw7dmFyIGs9Zy5aYigpO2VjJiZmYyhcImV2ZW50OiBcIitnLnRvU3RyaW5nKCkpO2djKGspfX1hLnhiW2RdPW51bGx9ZWxzZSBjPSExfWMmJihhLnhiPVtdKX1mdW5jdGlvbiBhYyhhKXt0aGlzLnRhPWE7dGhpcy54ZD1bXX1hYy5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3RoaXMueGQucHVzaChhKX07YWMucHJvdG90eXBlLmNjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGF9O2Z1bmN0aW9uIEooYSxiLGMsZCl7dGhpcy50eXBlPWE7dGhpcy5OYT1iO3RoaXMuWmE9Yzt0aGlzLk9lPWQ7dGhpcy5UZD12b2lkIDB9ZnVuY3Rpb24gaGMoYSl7cmV0dXJuIG5ldyBKKGljLGEpfXZhciBpYz1cInZhbHVlXCI7ZnVuY3Rpb24gamMoYSxiLGMsZCl7dGhpcy54ZT1iO3RoaXMuYmU9Yzt0aGlzLlRkPWQ7dGhpcy53ZD1hfWpjLnByb3RvdHlwZS5jYz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYmUuTWIoKTtyZXR1cm5cInZhbHVlXCI9PT10aGlzLndkP2EucGF0aDphLnBhcmVudCgpLnBhdGh9O2pjLnByb3RvdHlwZS5EZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLndkfTtqYy5wcm90b3R5cGUuWmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54ZS5aYih0aGlzKX07amMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2MoKS50b1N0cmluZygpK1wiOlwiK3RoaXMud2QrXCI6XCIrRyh0aGlzLmJlLnFmKCkpfTtmdW5jdGlvbiBrYyhhLGIsYyl7dGhpcy54ZT1hO3RoaXMuZXJyb3I9Yjt0aGlzLnBhdGg9Y31rYy5wcm90b3R5cGUuY2M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRofTtrYy5wcm90b3R5cGUuRGU9ZnVuY3Rpb24oKXtyZXR1cm5cImNhbmNlbFwifTtcbmtjLnByb3RvdHlwZS5aYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnhlLlpiKHRoaXMpfTtrYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkrXCI6Y2FuY2VsXCJ9O2Z1bmN0aW9uIFhiKGEsYixjKXt0aGlzLkE9YTt0aGlzLmdhPWI7dGhpcy5ZYj1jfWZ1bmN0aW9uIGxjKGEpe3JldHVybiBhLmdhfWZ1bmN0aW9uIG1jKGEpe3JldHVybiBhLllifWZ1bmN0aW9uIG5jKGEsYil7cmV0dXJuIGIuZSgpP2EuZ2EmJiFhLlliOldiKGEsSyhiKSl9ZnVuY3Rpb24gV2IoYSxiKXtyZXR1cm4gYS5nYSYmIWEuWWJ8fGEuQS5GYShiKX1YYi5wcm90b3R5cGUuaj1mdW5jdGlvbigpe3JldHVybiB0aGlzLkF9O2Z1bmN0aW9uIG9jKGEpe3RoaXMucGc9YTt0aGlzLkdkPW51bGx9b2MucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe3ZhciBhPXRoaXMucGcuZ2V0KCksYj13YShhKTtpZih0aGlzLkdkKWZvcih2YXIgYyBpbiB0aGlzLkdkKWJbY10tPXRoaXMuR2RbY107dGhpcy5HZD1hO3JldHVybiBifTtmdW5jdGlvbiBwYyhhLGIpe3RoaXMuVmY9e307dGhpcy5oZD1uZXcgb2MoYSk7dGhpcy5kYT1iO3ZhciBjPTFFNCsyRTQqTWF0aC5yYW5kb20oKTtzZXRUaW1lb3V0KHUodGhpcy5PZix0aGlzKSxNYXRoLmZsb29yKGMpKX1wYy5wcm90b3R5cGUuT2Y9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmhkLmdldCgpLGI9e30sYz0hMSxkO2ZvcihkIGluIGEpMDxhW2RdJiZ5KHRoaXMuVmYsZCkmJihiW2RdPWFbZF0sYz0hMCk7YyYmdGhpcy5kYS5ZZShiKTtzZXRUaW1lb3V0KHUodGhpcy5PZix0aGlzKSxNYXRoLmZsb29yKDZFNSpNYXRoLnJhbmRvbSgpKSl9O2Z1bmN0aW9uIHFjKCl7dGhpcy5IYz17fX1mdW5jdGlvbiByYyhhLGIsYyl7cChjKXx8KGM9MSk7eShhLkhjLGIpfHwoYS5IY1tiXT0wKTthLkhjW2JdKz1jfXFjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gd2EodGhpcy5IYyl9O3ZhciBzYz17fSx0Yz17fTtmdW5jdGlvbiB1YyhhKXthPWEudG9TdHJpbmcoKTtzY1thXXx8KHNjW2FdPW5ldyBxYyk7cmV0dXJuIHNjW2FdfWZ1bmN0aW9uIHZjKGEsYil7dmFyIGM9YS50b1N0cmluZygpO3RjW2NdfHwodGNbY109YigpKTtyZXR1cm4gdGNbY119O2Z1bmN0aW9uIEwoYSxiKXt0aGlzLm5hbWU9YTt0aGlzLlU9Yn1mdW5jdGlvbiB3YyhhLGIpe3JldHVybiBuZXcgTChhLGIpfTtmdW5jdGlvbiB4YyhhLGIpe3JldHVybiB5YyhhLm5hbWUsYi5uYW1lKX1mdW5jdGlvbiB6YyhhLGIpe3JldHVybiB5YyhhLGIpfTtmdW5jdGlvbiBBYyhhLGIsYyl7dGhpcy50eXBlPUJjO3RoaXMuc291cmNlPWE7dGhpcy5wYXRoPWI7dGhpcy5KYT1jfUFjLnByb3RvdHlwZS4kYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wYXRoLmUoKT9uZXcgQWModGhpcy5zb3VyY2UsTSx0aGlzLkphLlQoYSkpOm5ldyBBYyh0aGlzLnNvdXJjZSxOKHRoaXMucGF0aCksdGhpcy5KYSl9O0FjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBvdmVyd3JpdGU6IFwiK3RoaXMuSmEudG9TdHJpbmcoKStcIilcIn07ZnVuY3Rpb24gQ2MoYSxiKXt0aGlzLnR5cGU9RGM7dGhpcy5zb3VyY2U9YTt0aGlzLnBhdGg9Yn1DYy5wcm90b3R5cGUuJGM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXRoLmUoKT9uZXcgQ2ModGhpcy5zb3VyY2UsTSk6bmV3IENjKHRoaXMuc291cmNlLE4odGhpcy5wYXRoKSl9O0NjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiT3BlcmF0aW9uKFwiK3RoaXMucGF0aCtcIjogXCIrdGhpcy5zb3VyY2UudG9TdHJpbmcoKStcIiBsaXN0ZW5fY29tcGxldGUpXCJ9O2Z1bmN0aW9uIEVjKGEsYil7dGhpcy5QYT1hO3RoaXMueGE9Yj9iOkZjfWg9RWMucHJvdG90eXBlO2guU2E9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IEVjKHRoaXMuUGEsdGhpcy54YS5TYShhLGIsdGhpcy5QYSkuJChudWxsLG51bGwsITEsbnVsbCxudWxsKSl9O2gucmVtb3ZlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgRWModGhpcy5QYSx0aGlzLnhhLnJlbW92ZShhLHRoaXMuUGEpLiQobnVsbCxudWxsLCExLG51bGwsbnVsbCkpfTtoLmdldD1mdW5jdGlvbihhKXtmb3IodmFyIGIsYz10aGlzLnhhOyFjLmUoKTspe2I9dGhpcy5QYShhLGMua2V5KTtpZigwPT09YilyZXR1cm4gYy52YWx1ZTswPmI/Yz1jLmxlZnQ6MDxiJiYoYz1jLnJpZ2h0KX1yZXR1cm4gbnVsbH07XG5mdW5jdGlvbiBHYyhhLGIpe2Zvcih2YXIgYyxkPWEueGEsZT1udWxsOyFkLmUoKTspe2M9YS5QYShiLGQua2V5KTtpZigwPT09Yyl7aWYoZC5sZWZ0LmUoKSlyZXR1cm4gZT9lLmtleTpudWxsO2ZvcihkPWQubGVmdDshZC5yaWdodC5lKCk7KWQ9ZC5yaWdodDtyZXR1cm4gZC5rZXl9MD5jP2Q9ZC5sZWZ0OjA8YyYmKGU9ZCxkPWQucmlnaHQpfXRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGZpbmQgcHJlZGVjZXNzb3Iga2V5IGZvciBhIG5vbmV4aXN0ZW50IGtleS4gIFdoYXQgZ2l2ZXM/XCIpO31oLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54YS5lKCl9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54YS5jb3VudCgpfTtoLlZjPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueGEuVmMoKX07aC5qYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnhhLmpjKCl9O2gua2E9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMueGEua2EoYSl9O1xuaC5hYz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IEhjKHRoaXMueGEsbnVsbCx0aGlzLlBhLCExLGEpfTtoLmJjPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBIYyh0aGlzLnhhLGEsdGhpcy5QYSwhMSxiKX07aC5kYz1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgSGModGhpcy54YSxhLHRoaXMuUGEsITAsYil9O2gueGY9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBIYyh0aGlzLnhhLG51bGwsdGhpcy5QYSwhMCxhKX07ZnVuY3Rpb24gSGMoYSxiLGMsZCxlKXt0aGlzLlhkPWV8fG51bGw7dGhpcy5KZT1kO3RoaXMuVGE9W107Zm9yKGU9MTshYS5lKCk7KWlmKGU9Yj9jKGEua2V5LGIpOjEsZCYmKGUqPS0xKSwwPmUpYT10aGlzLkplP2EubGVmdDphLnJpZ2h0O2Vsc2UgaWYoMD09PWUpe3RoaXMuVGEucHVzaChhKTticmVha31lbHNlIHRoaXMuVGEucHVzaChhKSxhPXRoaXMuSmU/YS5yaWdodDphLmxlZnR9XG5mdW5jdGlvbiBJYyhhKXtpZigwPT09YS5UYS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGI9YS5UYS5wb3AoKSxjO2M9YS5YZD9hLlhkKGIua2V5LGIudmFsdWUpOntrZXk6Yi5rZXksdmFsdWU6Yi52YWx1ZX07aWYoYS5KZSlmb3IoYj1iLmxlZnQ7IWIuZSgpOylhLlRhLnB1c2goYiksYj1iLnJpZ2h0O2Vsc2UgZm9yKGI9Yi5yaWdodDshYi5lKCk7KWEuVGEucHVzaChiKSxiPWIubGVmdDtyZXR1cm4gY31mdW5jdGlvbiBKYyhhKXtpZigwPT09YS5UYS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGI7Yj1hLlRhO2I9YltiLmxlbmd0aC0xXTtyZXR1cm4gYS5YZD9hLlhkKGIua2V5LGIudmFsdWUpOntrZXk6Yi5rZXksdmFsdWU6Yi52YWx1ZX19ZnVuY3Rpb24gS2MoYSxiLGMsZCxlKXt0aGlzLmtleT1hO3RoaXMudmFsdWU9Yjt0aGlzLmNvbG9yPW51bGwhPWM/YzohMDt0aGlzLmxlZnQ9bnVsbCE9ZD9kOkZjO3RoaXMucmlnaHQ9bnVsbCE9ZT9lOkZjfWg9S2MucHJvdG90eXBlO1xuaC4kPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIG5ldyBLYyhudWxsIT1hP2E6dGhpcy5rZXksbnVsbCE9Yj9iOnRoaXMudmFsdWUsbnVsbCE9Yz9jOnRoaXMuY29sb3IsbnVsbCE9ZD9kOnRoaXMubGVmdCxudWxsIT1lP2U6dGhpcy5yaWdodCl9O2guY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZWZ0LmNvdW50KCkrMSt0aGlzLnJpZ2h0LmNvdW50KCl9O2guZT1mdW5jdGlvbigpe3JldHVybiExfTtoLmthPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmxlZnQua2EoYSl8fGEodGhpcy5rZXksdGhpcy52YWx1ZSl8fHRoaXMucmlnaHQua2EoYSl9O2Z1bmN0aW9uIExjKGEpe3JldHVybiBhLmxlZnQuZSgpP2E6TGMoYS5sZWZ0KX1oLlZjPWZ1bmN0aW9uKCl7cmV0dXJuIExjKHRoaXMpLmtleX07aC5qYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJpZ2h0LmUoKT90aGlzLmtleTp0aGlzLnJpZ2h0LmpjKCl9O1xuaC5TYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtlPXRoaXM7ZD1jKGEsZS5rZXkpO2U9MD5kP2UuJChudWxsLG51bGwsbnVsbCxlLmxlZnQuU2EoYSxiLGMpLG51bGwpOjA9PT1kP2UuJChudWxsLGIsbnVsbCxudWxsLG51bGwpOmUuJChudWxsLG51bGwsbnVsbCxudWxsLGUucmlnaHQuU2EoYSxiLGMpKTtyZXR1cm4gTWMoZSl9O2Z1bmN0aW9uIE5jKGEpe2lmKGEubGVmdC5lKCkpcmV0dXJuIEZjO2EubGVmdC5oYSgpfHxhLmxlZnQubGVmdC5oYSgpfHwoYT1PYyhhKSk7YT1hLiQobnVsbCxudWxsLG51bGwsTmMoYS5sZWZ0KSxudWxsKTtyZXR1cm4gTWMoYSl9XG5oLnJlbW92ZT1mdW5jdGlvbihhLGIpe3ZhciBjLGQ7Yz10aGlzO2lmKDA+YihhLGMua2V5KSljLmxlZnQuZSgpfHxjLmxlZnQuaGEoKXx8Yy5sZWZ0LmxlZnQuaGEoKXx8KGM9T2MoYykpLGM9Yy4kKG51bGwsbnVsbCxudWxsLGMubGVmdC5yZW1vdmUoYSxiKSxudWxsKTtlbHNle2MubGVmdC5oYSgpJiYoYz1QYyhjKSk7Yy5yaWdodC5lKCl8fGMucmlnaHQuaGEoKXx8Yy5yaWdodC5sZWZ0LmhhKCl8fChjPVFjKGMpLGMubGVmdC5sZWZ0LmhhKCkmJihjPVBjKGMpLGM9UWMoYykpKTtpZigwPT09YihhLGMua2V5KSl7aWYoYy5yaWdodC5lKCkpcmV0dXJuIEZjO2Q9TGMoYy5yaWdodCk7Yz1jLiQoZC5rZXksZC52YWx1ZSxudWxsLG51bGwsTmMoYy5yaWdodCkpfWM9Yy4kKG51bGwsbnVsbCxudWxsLG51bGwsYy5yaWdodC5yZW1vdmUoYSxiKSl9cmV0dXJuIE1jKGMpfTtoLmhhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29sb3J9O1xuZnVuY3Rpb24gTWMoYSl7YS5yaWdodC5oYSgpJiYhYS5sZWZ0LmhhKCkmJihhPVJjKGEpKTthLmxlZnQuaGEoKSYmYS5sZWZ0LmxlZnQuaGEoKSYmKGE9UGMoYSkpO2EubGVmdC5oYSgpJiZhLnJpZ2h0LmhhKCkmJihhPVFjKGEpKTtyZXR1cm4gYX1mdW5jdGlvbiBPYyhhKXthPVFjKGEpO2EucmlnaHQubGVmdC5oYSgpJiYoYT1hLiQobnVsbCxudWxsLG51bGwsbnVsbCxQYyhhLnJpZ2h0KSksYT1SYyhhKSxhPVFjKGEpKTtyZXR1cm4gYX1mdW5jdGlvbiBSYyhhKXtyZXR1cm4gYS5yaWdodC4kKG51bGwsbnVsbCxhLmNvbG9yLGEuJChudWxsLG51bGwsITAsbnVsbCxhLnJpZ2h0LmxlZnQpLG51bGwpfWZ1bmN0aW9uIFBjKGEpe3JldHVybiBhLmxlZnQuJChudWxsLG51bGwsYS5jb2xvcixudWxsLGEuJChudWxsLG51bGwsITAsYS5sZWZ0LnJpZ2h0LG51bGwpKX1cbmZ1bmN0aW9uIFFjKGEpe3JldHVybiBhLiQobnVsbCxudWxsLCFhLmNvbG9yLGEubGVmdC4kKG51bGwsbnVsbCwhYS5sZWZ0LmNvbG9yLG51bGwsbnVsbCksYS5yaWdodC4kKG51bGwsbnVsbCwhYS5yaWdodC5jb2xvcixudWxsLG51bGwpKX1mdW5jdGlvbiBTYygpe31oPVNjLnByb3RvdHlwZTtoLiQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307aC5TYT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgS2MoYSxiLG51bGwpfTtoLnJlbW92ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtoLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIDB9O2guZT1mdW5jdGlvbigpe3JldHVybiEwfTtoLmthPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guVmM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07aC5qYz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtoLmhhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O3ZhciBGYz1uZXcgU2M7ZnVuY3Rpb24gVGMoYSxiKXtyZXR1cm4gYSYmXCJvYmplY3RcIj09PXR5cGVvZiBhPyhPKFwiLnN2XCJpbiBhLFwiVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHNcIiksYlthW1wiLnN2XCJdXSk6YX1mdW5jdGlvbiBVYyhhLGIpe3ZhciBjPW5ldyBWYztXYyhhLG5ldyBQKFwiXCIpLGZ1bmN0aW9uKGEsZSl7Yy5yYyhhLFhjKGUsYikpfSk7cmV0dXJuIGN9ZnVuY3Rpb24gWGMoYSxiKXt2YXIgYz1hLkMoKS5KKCksYz1UYyhjLGIpLGQ7aWYoYS5MKCkpe3ZhciBlPVRjKGEuRWEoKSxiKTtyZXR1cm4gZSE9PWEuRWEoKXx8YyE9PWEuQygpLkooKT9uZXcgWWMoZSxRKGMpKTphfWQ9YTtjIT09YS5DKCkuSigpJiYoZD1kLmlhKG5ldyBZYyhjKSkpO2EuUihSLGZ1bmN0aW9uKGEsYyl7dmFyIGU9WGMoYyxiKTtlIT09YyYmKGQ9ZC5XKGEsZSkpfSk7cmV0dXJuIGR9O2Z1bmN0aW9uIFpjKCl7dGhpcy5BYz17fX1aYy5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7bnVsbD09Yj9kZWxldGUgdGhpcy5BY1thXTp0aGlzLkFjW2FdPWJ9O1pjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHkodGhpcy5BYyxhKT90aGlzLkFjW2FdOm51bGx9O1pjLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuQWNbYV19O1pjLnByb3RvdHlwZS5BZj0hMDtmdW5jdGlvbiAkYyhhKXt0aGlzLkljPWE7dGhpcy5TZD1cImZpcmViYXNlOlwifWg9JGMucHJvdG90eXBlO2guc2V0PWZ1bmN0aW9uKGEsYil7bnVsbD09Yj90aGlzLkljLnJlbW92ZUl0ZW0odGhpcy5TZCthKTp0aGlzLkljLnNldEl0ZW0odGhpcy5TZCthLEcoYikpfTtoLmdldD1mdW5jdGlvbihhKXthPXRoaXMuSWMuZ2V0SXRlbSh0aGlzLlNkK2EpO3JldHVybiBudWxsPT1hP251bGw6UmIoYSl9O2gucmVtb3ZlPWZ1bmN0aW9uKGEpe3RoaXMuSWMucmVtb3ZlSXRlbSh0aGlzLlNkK2EpfTtoLkFmPSExO2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5JYy50b1N0cmluZygpfTtmdW5jdGlvbiBhZChhKXt0cnl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93W2FdKXt2YXIgYj13aW5kb3dbYV07Yi5zZXRJdGVtKFwiZmlyZWJhc2U6c2VudGluZWxcIixcImNhY2hlXCIpO2IucmVtb3ZlSXRlbShcImZpcmViYXNlOnNlbnRpbmVsXCIpO3JldHVybiBuZXcgJGMoYil9fWNhdGNoKGMpe31yZXR1cm4gbmV3IFpjfXZhciBiZD1hZChcImxvY2FsU3RvcmFnZVwiKSxjZD1hZChcInNlc3Npb25TdG9yYWdlXCIpO2Z1bmN0aW9uIGRkKGEsYixjLGQsZSl7dGhpcy5ob3N0PWEudG9Mb3dlckNhc2UoKTt0aGlzLmRvbWFpbj10aGlzLmhvc3Quc3Vic3RyKHRoaXMuaG9zdC5pbmRleE9mKFwiLlwiKSsxKTt0aGlzLm9iPWI7dGhpcy5sYz1jO3RoaXMuaWg9ZDt0aGlzLlJkPWV8fFwiXCI7dGhpcy5hYj1iZC5nZXQoXCJob3N0OlwiK2EpfHx0aGlzLmhvc3R9ZnVuY3Rpb24gZWQoYSxiKXtiIT09YS5hYiYmKGEuYWI9YixcInMtXCI9PT1hLmFiLnN1YnN0cigwLDIpJiZiZC5zZXQoXCJob3N0OlwiK2EuaG9zdCxhLmFiKSl9XG5mdW5jdGlvbiBmZChhLGIsYyl7TyhcInN0cmluZ1wiPT09dHlwZW9mIGIsXCJ0eXBlb2YgdHlwZSBtdXN0ID09IHN0cmluZ1wiKTtPKFwib2JqZWN0XCI9PT10eXBlb2YgYyxcInR5cGVvZiBwYXJhbXMgbXVzdCA9PSBvYmplY3RcIik7aWYoYj09PWdkKWI9KGEub2I/XCJ3c3M6Ly9cIjpcIndzOi8vXCIpK2EuYWIrXCIvLndzP1wiO2Vsc2UgaWYoYj09PWhkKWI9KGEub2I/XCJodHRwczovL1wiOlwiaHR0cDovL1wiKSthLmFiK1wiLy5scD9cIjtlbHNlIHRocm93IEVycm9yKFwiVW5rbm93biBjb25uZWN0aW9uIHR5cGU6IFwiK2IpO2EuaG9zdCE9PWEuYWImJihjLm5zPWEubGMpO3ZhciBkPVtdO3YoYyxmdW5jdGlvbihhLGIpe2QucHVzaChiK1wiPVwiK2EpfSk7cmV0dXJuIGIrZC5qb2luKFwiJlwiKX1kZC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT0odGhpcy5vYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuaG9zdDt0aGlzLlJkJiYoYSs9XCI8XCIrdGhpcy5SZCtcIj5cIik7cmV0dXJuIGF9O3ZhciBpZD1mdW5jdGlvbigpe3ZhciBhPTE7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGErK319KCksTz1LYixqZD1MYjtcbmZ1bmN0aW9uIGtkKGEpe3RyeXt2YXIgYjtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGF0b2IpYj1hdG9iKGEpO2Vsc2V7b2IoKTtmb3IodmFyIGM9bWIsZD1bXSxlPTA7ZTxhLmxlbmd0aDspe3ZhciBmPWNbYS5jaGFyQXQoZSsrKV0sZz1lPGEubGVuZ3RoP2NbYS5jaGFyQXQoZSldOjA7KytlO3ZhciBrPWU8YS5sZW5ndGg/Y1thLmNoYXJBdChlKV06NjQ7KytlO3ZhciBtPWU8YS5sZW5ndGg/Y1thLmNoYXJBdChlKV06NjQ7KytlO2lmKG51bGw9PWZ8fG51bGw9PWd8fG51bGw9PWt8fG51bGw9PW0pdGhyb3cgRXJyb3IoKTtkLnB1c2goZjw8MnxnPj40KTs2NCE9ayYmKGQucHVzaChnPDw0JjI0MHxrPj4yKSw2NCE9bSYmZC5wdXNoKGs8PDYmMTkyfG0pKX1pZig4MTkyPmQubGVuZ3RoKWI9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGQpO2Vsc2V7YT1cIlwiO2ZvcihjPTA7YzxkLmxlbmd0aDtjKz04MTkyKWErPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxVYShkLGMsXG5jKzgxOTIpKTtiPWF9fXJldHVybiBifWNhdGNoKGwpe2ZjKFwiYmFzZTY0RGVjb2RlIGZhaWxlZDogXCIsbCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gbGQoYSl7dmFyIGI9T2IoYSk7YT1uZXcgSmE7YS51cGRhdGUoYik7dmFyIGI9W10sYz04KmEuZ2U7NTY+YS5lYz9hLnVwZGF0ZShhLk9kLDU2LWEuZWMpOmEudXBkYXRlKGEuT2QsYS5ZYS0oYS5lYy01NikpO2Zvcih2YXIgZD1hLllhLTE7NTY8PWQ7ZC0tKWEucGVbZF09YyYyNTUsYy89MjU2O0thKGEsYS5wZSk7Zm9yKGQ9Yz0wOzU+ZDtkKyspZm9yKHZhciBlPTI0OzA8PWU7ZS09OCliW2NdPWEuUFtkXT4+ZSYyNTUsKytjO3JldHVybiBuYihiKX1cbmZ1bmN0aW9uIG1kKGEpe2Zvcih2YXIgYj1cIlwiLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWI9ZWEoYXJndW1lbnRzW2NdKT9iK21kLmFwcGx5KG51bGwsYXJndW1lbnRzW2NdKTpcIm9iamVjdFwiPT09dHlwZW9mIGFyZ3VtZW50c1tjXT9iK0coYXJndW1lbnRzW2NdKTpiK2FyZ3VtZW50c1tjXSxiKz1cIiBcIjtyZXR1cm4gYn12YXIgZWM9bnVsbCxuZD0hMDtcbmZ1bmN0aW9uIG9kKGEsYil7S2IoIWJ8fCEwPT09YXx8ITE9PT1hLFwiQ2FuJ3QgdHVybiBvbiBjdXN0b20gbG9nZ2VycyBwZXJzaXN0ZW50bHkuXCIpOyEwPT09YT8oXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGNvbnNvbGUubG9nP2VjPXUoY29uc29sZS5sb2csY29uc29sZSk6XCJvYmplY3RcIj09PXR5cGVvZiBjb25zb2xlLmxvZyYmKGVjPWZ1bmN0aW9uKGEpe2NvbnNvbGUubG9nKGEpfSkpLGImJmNkLnNldChcImxvZ2dpbmdfZW5hYmxlZFwiLCEwKSk6cihhKT9lYz1hOihlYz1udWxsLGNkLnJlbW92ZShcImxvZ2dpbmdfZW5hYmxlZFwiKSl9ZnVuY3Rpb24gZmMoYSl7ITA9PT1uZCYmKG5kPSExLG51bGw9PT1lYyYmITA9PT1jZC5nZXQoXCJsb2dnaW5nX2VuYWJsZWRcIikmJm9kKCEwKSk7aWYoZWMpe3ZhciBiPW1kLmFwcGx5KG51bGwsYXJndW1lbnRzKTtlYyhiKX19XG5mdW5jdGlvbiBwZChhKXtyZXR1cm4gZnVuY3Rpb24oKXtmYyhhLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHFkKGEpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIGI9XCJGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogXCIrbWQuYXBwbHkobnVsbCxhcmd1bWVudHMpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZS5lcnJvcj9jb25zb2xlLmVycm9yKGIpOmNvbnNvbGUubG9nKGIpfX1mdW5jdGlvbiByZChhKXt2YXIgYj1tZC5hcHBseShudWxsLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoXCJGSVJFQkFTRSBGQVRBTCBFUlJPUjogXCIrYik7fWZ1bmN0aW9uIFMoYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjb25zb2xlKXt2YXIgYj1cIkZJUkVCQVNFIFdBUk5JTkc6IFwiK21kLmFwcGx5KG51bGwsYXJndW1lbnRzKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUud2Fybj9jb25zb2xlLndhcm4oYik6Y29uc29sZS5sb2coYil9fVxuZnVuY3Rpb24gc2QoYSl7dmFyIGI9XCJcIixjPVwiXCIsZD1cIlwiLGU9XCJcIixmPSEwLGc9XCJodHRwc1wiLGs9NDQzO2lmKHEoYSkpe3ZhciBtPWEuaW5kZXhPZihcIi8vXCIpOzA8PW0mJihnPWEuc3Vic3RyaW5nKDAsbS0xKSxhPWEuc3Vic3RyaW5nKG0rMikpO209YS5pbmRleE9mKFwiL1wiKTstMT09PW0mJihtPWEubGVuZ3RoKTtiPWEuc3Vic3RyaW5nKDAsbSk7ZT1cIlwiO2E9YS5zdWJzdHJpbmcobSkuc3BsaXQoXCIvXCIpO2ZvcihtPTA7bTxhLmxlbmd0aDttKyspaWYoMDxhW21dLmxlbmd0aCl7dmFyIGw9YVttXTt0cnl7bD1kZWNvZGVVUklDb21wb25lbnQobC5yZXBsYWNlKC9cXCsvZyxcIiBcIikpfWNhdGNoKHQpe31lKz1cIi9cIitsfWE9Yi5zcGxpdChcIi5cIik7Mz09PWEubGVuZ3RoPyhjPWFbMV0sZD1hWzBdLnRvTG93ZXJDYXNlKCkpOjI9PT1hLmxlbmd0aCYmKGM9YVswXSk7bT1iLmluZGV4T2YoXCI6XCIpOzA8PW0mJihmPVwiaHR0cHNcIj09PWd8fFwid3NzXCI9PT1nLGs9Yi5zdWJzdHJpbmcobSsxKSxpc0Zpbml0ZShrKSYmXG4oaz1TdHJpbmcoaykpLGs9cShrKT8vXlxccyotPzB4L2kudGVzdChrKT9wYXJzZUludChrLDE2KTpwYXJzZUludChrLDEwKTpOYU4pfXJldHVybntob3N0OmIscG9ydDprLGRvbWFpbjpjLGVoOmQsb2I6ZixzY2hlbWU6ZyxiZDplfX1mdW5jdGlvbiB0ZChhKXtyZXR1cm4gZmEoYSkmJihhIT1hfHxhPT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl8fGE9PU51bWJlci5ORUdBVElWRV9JTkZJTklUWSl9XG5mdW5jdGlvbiB1ZChhKXtpZihcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlKWEoKTtlbHNle3ZhciBiPSExLGM9ZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5P2J8fChiPSEwLGEoKSk6c2V0VGltZW91dChjLE1hdGguZmxvb3IoMTApKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcj8oZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixjLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixjLCExKSk6ZG9jdW1lbnQuYXR0YWNoRXZlbnQmJihkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmYygpfSksd2luZG93LmF0dGFjaEV2ZW50KFwib25sb2FkXCIsYykpfX1cbmZ1bmN0aW9uIHljKGEsYil7aWYoYT09PWIpcmV0dXJuIDA7aWYoXCJbTUlOX05BTUVdXCI9PT1hfHxcIltNQVhfTkFNRV1cIj09PWIpcmV0dXJuLTE7aWYoXCJbTUlOX05BTUVdXCI9PT1ifHxcIltNQVhfTkFNRV1cIj09PWEpcmV0dXJuIDE7dmFyIGM9dmQoYSksZD12ZChiKTtyZXR1cm4gbnVsbCE9PWM/bnVsbCE9PWQ/MD09Yy1kP2EubGVuZ3RoLWIubGVuZ3RoOmMtZDotMTpudWxsIT09ZD8xOmE8Yj8tMToxfWZ1bmN0aW9uIHdkKGEsYil7aWYoYiYmYSBpbiBiKXJldHVybiBiW2FdO3Rocm93IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBrZXkgKFwiK2ErXCIpIGluIG9iamVjdDogXCIrRyhiKSk7fVxuZnVuY3Rpb24geGQoYSl7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhfHxudWxsPT09YSlyZXR1cm4gRyhhKTt2YXIgYj1bXSxjO2ZvcihjIGluIGEpYi5wdXNoKGMpO2Iuc29ydCgpO2M9XCJ7XCI7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspMCE9PWQmJihjKz1cIixcIiksYys9RyhiW2RdKSxjKz1cIjpcIixjKz14ZChhW2JbZF1dKTtyZXR1cm4gYytcIn1cIn1mdW5jdGlvbiB5ZChhLGIpe2lmKGEubGVuZ3RoPD1iKXJldHVyblthXTtmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCs9YilkK2I+YT9jLnB1c2goYS5zdWJzdHJpbmcoZCxhLmxlbmd0aCkpOmMucHVzaChhLnN1YnN0cmluZyhkLGQrYikpO3JldHVybiBjfWZ1bmN0aW9uIHpkKGEsYil7aWYoZGEoYSkpZm9yKHZhciBjPTA7YzxhLmxlbmd0aDsrK2MpYihjLGFbY10pO2Vsc2UgdihhLGIpfVxuZnVuY3Rpb24gQWQoYSl7TyghdGQoYSksXCJJbnZhbGlkIEpTT04gbnVtYmVyXCIpO3ZhciBiLGMsZCxlOzA9PT1hPyhkPWM9MCxiPS1JbmZpbml0eT09PTEvYT8xOjApOihiPTA+YSxhPU1hdGguYWJzKGEpLGE+PU1hdGgucG93KDIsLTEwMjIpPyhkPU1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2coYSkvTWF0aC5MTjIpLDEwMjMpLGM9ZCsxMDIzLGQ9TWF0aC5yb3VuZChhKk1hdGgucG93KDIsNTItZCktTWF0aC5wb3coMiw1MikpKTooYz0wLGQ9TWF0aC5yb3VuZChhL01hdGgucG93KDIsLTEwNzQpKSkpO2U9W107Zm9yKGE9NTI7YTstLWEpZS5wdXNoKGQlMj8xOjApLGQ9TWF0aC5mbG9vcihkLzIpO2ZvcihhPTExO2E7LS1hKWUucHVzaChjJTI/MTowKSxjPU1hdGguZmxvb3IoYy8yKTtlLnB1c2goYj8xOjApO2UucmV2ZXJzZSgpO2I9ZS5qb2luKFwiXCIpO2M9XCJcIjtmb3IoYT0wOzY0PmE7YSs9OClkPXBhcnNlSW50KGIuc3Vic3RyKGEsOCksMikudG9TdHJpbmcoMTYpLDE9PT1kLmxlbmd0aCYmXG4oZD1cIjBcIitkKSxjKz1kO3JldHVybiBjLnRvTG93ZXJDYXNlKCl9dmFyIEJkPS9eLT9cXGR7MSwxMH0kLztmdW5jdGlvbiB2ZChhKXtyZXR1cm4gQmQudGVzdChhKSYmKGE9TnVtYmVyKGEpLC0yMTQ3NDgzNjQ4PD1hJiYyMTQ3NDgzNjQ3Pj1hKT9hOm51bGx9ZnVuY3Rpb24gZ2MoYSl7dHJ5e2EoKX1jYXRjaChiKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7UyhcIkV4Y2VwdGlvbiB3YXMgdGhyb3duIGJ5IHVzZXIgY2FsbGJhY2suXCIsYi5zdGFja3x8XCJcIik7dGhyb3cgYjt9LE1hdGguZmxvb3IoMCkpfX1mdW5jdGlvbiBUKGEsYil7aWYocihhKSl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLnNsaWNlKCk7Z2MoZnVuY3Rpb24oKXthLmFwcGx5KG51bGwsYyl9KX19O2Z1bmN0aW9uIENkKGEpe3ZhciBiPXt9LGM9e30sZD17fSxlPVwiXCI7dHJ5e3ZhciBmPWEuc3BsaXQoXCIuXCIpLGI9UmIoa2QoZlswXSl8fFwiXCIpLGM9UmIoa2QoZlsxXSl8fFwiXCIpLGU9ZlsyXSxkPWMuZHx8e307ZGVsZXRlIGMuZH1jYXRjaChnKXt9cmV0dXJue2xoOmIsRWM6YyxkYXRhOmQsYWg6ZX19ZnVuY3Rpb24gRGQoYSl7YT1DZChhKS5FYztyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJmEuaGFzT3duUHJvcGVydHkoXCJpYXRcIik/eihhLFwiaWF0XCIpOm51bGx9ZnVuY3Rpb24gRWQoYSl7YT1DZChhKTt2YXIgYj1hLkVjO3JldHVybiEhYS5haCYmISFiJiZcIm9iamVjdFwiPT09dHlwZW9mIGImJmIuaGFzT3duUHJvcGVydHkoXCJpYXRcIil9O2Z1bmN0aW9uIEZkKGEpe3RoaXMuWT1hO3RoaXMuZz1hLm4uZ31mdW5jdGlvbiBHZChhLGIsYyxkKXt2YXIgZT1bXSxmPVtdO01hKGIsZnVuY3Rpb24oYil7XCJjaGlsZF9jaGFuZ2VkXCI9PT1iLnR5cGUmJmEuZy5EZChiLk9lLGIuTmEpJiZmLnB1c2gobmV3IEooXCJjaGlsZF9tb3ZlZFwiLGIuTmEsYi5aYSkpfSk7SGQoYSxlLFwiY2hpbGRfcmVtb3ZlZFwiLGIsZCxjKTtIZChhLGUsXCJjaGlsZF9hZGRlZFwiLGIsZCxjKTtIZChhLGUsXCJjaGlsZF9tb3ZlZFwiLGYsZCxjKTtIZChhLGUsXCJjaGlsZF9jaGFuZ2VkXCIsYixkLGMpO0hkKGEsZSxpYyxiLGQsYyk7cmV0dXJuIGV9ZnVuY3Rpb24gSGQoYSxiLGMsZCxlLGYpe2Q9TmEoZCxmdW5jdGlvbihhKXtyZXR1cm4gYS50eXBlPT09Y30pO1ZhKGQsdShhLnFnLGEpKTtNYShkLGZ1bmN0aW9uKGMpe3ZhciBkPUlkKGEsYyxmKTtNYShlLGZ1bmN0aW9uKGUpe2UuUWYoYy50eXBlKSYmYi5wdXNoKGUuY3JlYXRlRXZlbnQoZCxhLlkpKX0pfSl9XG5mdW5jdGlvbiBJZChhLGIsYyl7XCJ2YWx1ZVwiIT09Yi50eXBlJiZcImNoaWxkX3JlbW92ZWRcIiE9PWIudHlwZSYmKGIuVGQ9Yy53ZihiLlphLGIuTmEsYS5nKSk7cmV0dXJuIGJ9RmQucHJvdG90eXBlLnFnPWZ1bmN0aW9uKGEsYil7aWYobnVsbD09YS5aYXx8bnVsbD09Yi5aYSl0aHJvdyBqZChcIlNob3VsZCBvbmx5IGNvbXBhcmUgY2hpbGRfIGV2ZW50cy5cIik7cmV0dXJuIHRoaXMuZy5jb21wYXJlKG5ldyBMKGEuWmEsYS5OYSksbmV3IEwoYi5aYSxiLk5hKSl9O2Z1bmN0aW9uIEpkKCl7dGhpcy5pYj17fX1cbmZ1bmN0aW9uIEtkKGEsYil7dmFyIGM9Yi50eXBlLGQ9Yi5aYTtPKFwiY2hpbGRfYWRkZWRcIj09Y3x8XCJjaGlsZF9jaGFuZ2VkXCI9PWN8fFwiY2hpbGRfcmVtb3ZlZFwiPT1jLFwiT25seSBjaGlsZCBjaGFuZ2VzIHN1cHBvcnRlZCBmb3IgdHJhY2tpbmdcIik7TyhcIi5wcmlvcml0eVwiIT09ZCxcIk9ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuXCIpO3ZhciBlPXooYS5pYixkKTtpZihlKXt2YXIgZj1lLnR5cGU7aWYoXCJjaGlsZF9hZGRlZFwiPT1jJiZcImNoaWxkX3JlbW92ZWRcIj09ZilhLmliW2RdPW5ldyBKKFwiY2hpbGRfY2hhbmdlZFwiLGIuTmEsZCxlLk5hKTtlbHNlIGlmKFwiY2hpbGRfcmVtb3ZlZFwiPT1jJiZcImNoaWxkX2FkZGVkXCI9PWYpZGVsZXRlIGEuaWJbZF07ZWxzZSBpZihcImNoaWxkX3JlbW92ZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5pYltkXT1uZXcgSihcImNoaWxkX3JlbW92ZWRcIixlLk9lLGQpO2Vsc2UgaWYoXCJjaGlsZF9jaGFuZ2VkXCI9PWMmJlxuXCJjaGlsZF9hZGRlZFwiPT1mKWEuaWJbZF09bmV3IEooXCJjaGlsZF9hZGRlZFwiLGIuTmEsZCk7ZWxzZSBpZihcImNoaWxkX2NoYW5nZWRcIj09YyYmXCJjaGlsZF9jaGFuZ2VkXCI9PWYpYS5pYltkXT1uZXcgSihcImNoaWxkX2NoYW5nZWRcIixiLk5hLGQsZS5PZSk7ZWxzZSB0aHJvdyBqZChcIklsbGVnYWwgY29tYmluYXRpb24gb2YgY2hhbmdlczogXCIrYitcIiBvY2N1cnJlZCBhZnRlciBcIitlKTt9ZWxzZSBhLmliW2RdPWJ9O2Z1bmN0aW9uIExkKGEpe3RoaXMuZz1hfWg9TGQucHJvdG90eXBlO2guSD1mdW5jdGlvbihhLGIsYyxkLGUsZil7TyhhLk1jKHRoaXMuZyksXCJBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkXCIpO2U9YS5UKGIpO2lmKGUuUyhkKS5lYShjLlMoZCkpJiZlLmUoKT09Yy5lKCkpcmV0dXJuIGE7bnVsbCE9ZiYmKGMuZSgpP2EuRmEoYik/S2QoZixuZXcgSihcImNoaWxkX3JlbW92ZWRcIixlLGIpKTpPKGEuTCgpLFwiQSBjaGlsZCByZW1vdmUgd2l0aG91dCBhbiBvbGQgY2hpbGQgb25seSBtYWtlcyBzZW5zZSBvbiBhIGxlYWYgbm9kZVwiKTplLmUoKT9LZChmLG5ldyBKKFwiY2hpbGRfYWRkZWRcIixjLGIpKTpLZChmLG5ldyBKKFwiY2hpbGRfY2hhbmdlZFwiLGMsYixlKSkpO3JldHVybiBhLkwoKSYmYy5lKCk/YTphLlcoYixjKS5wYih0aGlzLmcpfTtcbmgueWE9ZnVuY3Rpb24oYSxiLGMpe251bGwhPWMmJihhLkwoKXx8YS5SKFIsZnVuY3Rpb24oYSxlKXtiLkZhKGEpfHxLZChjLG5ldyBKKFwiY2hpbGRfcmVtb3ZlZFwiLGUsYSkpfSksYi5MKCl8fGIuUihSLGZ1bmN0aW9uKGIsZSl7aWYoYS5GYShiKSl7dmFyIGY9YS5UKGIpO2YuZWEoZSl8fEtkKGMsbmV3IEooXCJjaGlsZF9jaGFuZ2VkXCIsZSxiLGYpKX1lbHNlIEtkKGMsbmV3IEooXCJjaGlsZF9hZGRlZFwiLGUsYikpfSkpO3JldHVybiBiLnBiKHRoaXMuZyl9O2guaWE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5lKCk/SDphLmlhKGIpfTtoLlJhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guJGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307ZnVuY3Rpb24gTWQoYSl7dGhpcy5GZT1uZXcgTGQoYS5nKTt0aGlzLmc9YS5nO3ZhciBiO2Eub2E/KGI9TmQoYSksYj1hLmcuU2MoT2QoYSksYikpOmI9YS5nLldjKCk7dGhpcy5nZD1iO2EucmE/KGI9UGQoYSksYT1hLmcuU2MoUmQoYSksYikpOmE9YS5nLlRjKCk7dGhpcy5KYz1hfWg9TWQucHJvdG90eXBlO2gubWF0Y2hlcz1mdW5jdGlvbihhKXtyZXR1cm4gMD49dGhpcy5nLmNvbXBhcmUodGhpcy5nZCxhKSYmMD49dGhpcy5nLmNvbXBhcmUoYSx0aGlzLkpjKX07aC5IPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLm1hdGNoZXMobmV3IEwoYixjKSl8fChjPUgpO3JldHVybiB0aGlzLkZlLkgoYSxiLGMsZCxlLGYpfTtcbmgueWE9ZnVuY3Rpb24oYSxiLGMpe2IuTCgpJiYoYj1IKTt2YXIgZD1iLnBiKHRoaXMuZyksZD1kLmlhKEgpLGU9dGhpcztiLlIoUixmdW5jdGlvbihhLGIpe2UubWF0Y2hlcyhuZXcgTChhLGIpKXx8KGQ9ZC5XKGEsSCkpfSk7cmV0dXJuIHRoaXMuRmUueWEoYSxkLGMpfTtoLmlhPWZ1bmN0aW9uKGEpe3JldHVybiBhfTtoLlJhPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guJGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5GZX07ZnVuY3Rpb24gU2QoYSl7dGhpcy51YT1uZXcgTWQoYSk7dGhpcy5nPWEuZztPKGEubGEsXCJPbmx5IHZhbGlkIGlmIGxpbWl0IGhhcyBiZWVuIHNldFwiKTt0aGlzLm1hPWEubWE7dGhpcy5OYj0hVGQoYSl9aD1TZC5wcm90b3R5cGU7aC5IPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLnVhLm1hdGNoZXMobmV3IEwoYixjKSl8fChjPUgpO3JldHVybiBhLlQoYikuZWEoYyk/YTphLkhiKCk8dGhpcy5tYT90aGlzLnVhLiRiKCkuSChhLGIsYyxkLGUsZik6VWQodGhpcyxhLGIsYyxlLGYpfTtcbmgueWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2lmKGIuTCgpfHxiLmUoKSlkPUgucGIodGhpcy5nKTtlbHNlIGlmKDIqdGhpcy5tYTxiLkhiKCkmJmIuTWModGhpcy5nKSl7ZD1ILnBiKHRoaXMuZyk7Yj10aGlzLk5iP2IuZGModGhpcy51YS5KYyx0aGlzLmcpOmIuYmModGhpcy51YS5nZCx0aGlzLmcpO2Zvcih2YXIgZT0wOzA8Yi5UYS5sZW5ndGgmJmU8dGhpcy5tYTspe3ZhciBmPUljKGIpLGc7aWYoZz10aGlzLk5iPzA+PXRoaXMuZy5jb21wYXJlKHRoaXMudWEuZ2QsZik6MD49dGhpcy5nLmNvbXBhcmUoZix0aGlzLnVhLkpjKSlkPWQuVyhmLm5hbWUsZi5VKSxlKys7ZWxzZSBicmVha319ZWxzZXtkPWIucGIodGhpcy5nKTtkPWQuaWEoSCk7dmFyIGssbSxsO2lmKHRoaXMuTmIpe2I9ZC54Zih0aGlzLmcpO2s9dGhpcy51YS5KYzttPXRoaXMudWEuZ2Q7dmFyIHQ9VmQodGhpcy5nKTtsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHQoYixhKX19ZWxzZSBiPWQuYWModGhpcy5nKSxrPXRoaXMudWEuZ2QsXG5tPXRoaXMudWEuSmMsbD1WZCh0aGlzLmcpO2Zvcih2YXIgZT0wLEE9ITE7MDxiLlRhLmxlbmd0aDspZj1JYyhiKSwhQSYmMD49bChrLGYpJiYoQT0hMCksKGc9QSYmZTx0aGlzLm1hJiYwPj1sKGYsbSkpP2UrKzpkPWQuVyhmLm5hbWUsSCl9cmV0dXJuIHRoaXMudWEuJGIoKS55YShhLGQsYyl9O2guaWE9ZnVuY3Rpb24oYSl7cmV0dXJuIGF9O2guUmE9ZnVuY3Rpb24oKXtyZXR1cm4hMH07aC4kYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVhLiRiKCl9O1xuZnVuY3Rpb24gVWQoYSxiLGMsZCxlLGYpe3ZhciBnO2lmKGEuTmIpe3ZhciBrPVZkKGEuZyk7Zz1mdW5jdGlvbihhLGIpe3JldHVybiBrKGIsYSl9fWVsc2UgZz1WZChhLmcpO08oYi5IYigpPT1hLm1hLFwiXCIpO3ZhciBtPW5ldyBMKGMsZCksbD1hLk5iP1dkKGIsYS5nKTpYZChiLGEuZyksdD1hLnVhLm1hdGNoZXMobSk7aWYoYi5GYShjKSl7Zm9yKHZhciBBPWIuVChjKSxsPWUuQ2UoYS5nLGwsYS5OYik7bnVsbCE9bCYmKGwubmFtZT09Y3x8Yi5GYShsLm5hbWUpKTspbD1lLkNlKGEuZyxsLGEuTmIpO2U9bnVsbD09bD8xOmcobCxtKTtpZih0JiYhZC5lKCkmJjA8PWUpcmV0dXJuIG51bGwhPWYmJktkKGYsbmV3IEooXCJjaGlsZF9jaGFuZ2VkXCIsZCxjLEEpKSxiLlcoYyxkKTtudWxsIT1mJiZLZChmLG5ldyBKKFwiY2hpbGRfcmVtb3ZlZFwiLEEsYykpO2I9Yi5XKGMsSCk7cmV0dXJuIG51bGwhPWwmJmEudWEubWF0Y2hlcyhsKT8obnVsbCE9ZiYmS2QoZixuZXcgSihcImNoaWxkX2FkZGVkXCIsXG5sLlUsbC5uYW1lKSksYi5XKGwubmFtZSxsLlUpKTpifXJldHVybiBkLmUoKT9iOnQmJjA8PWcobCxtKT8obnVsbCE9ZiYmKEtkKGYsbmV3IEooXCJjaGlsZF9yZW1vdmVkXCIsbC5VLGwubmFtZSkpLEtkKGYsbmV3IEooXCJjaGlsZF9hZGRlZFwiLGQsYykpKSxiLlcoYyxkKS5XKGwubmFtZSxIKSk6Yn07ZnVuY3Rpb24gWWQoYSxiKXt0aGlzLm1lPWE7dGhpcy5vZz1ifWZ1bmN0aW9uIFpkKGEpe3RoaXMuWD1hfVxuWmQucHJvdG90eXBlLmdiPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBKZCxmO2lmKGIudHlwZT09PUJjKWIuc291cmNlLkFlP2M9JGQodGhpcyxhLGIucGF0aCxiLkphLGMsZCxlKTooTyhiLnNvdXJjZS50ZixcIlVua25vd24gc291cmNlLlwiKSxmPWIuc291cmNlLmVmfHxtYyhhLncoKSkmJiFiLnBhdGguZSgpLGM9YWUodGhpcyxhLGIucGF0aCxiLkphLGMsZCxmLGUpKTtlbHNlIGlmKGIudHlwZT09PWJlKWIuc291cmNlLkFlP2M9Y2UodGhpcyxhLGIucGF0aCxiLmNoaWxkcmVuLGMsZCxlKTooTyhiLnNvdXJjZS50ZixcIlVua25vd24gc291cmNlLlwiKSxmPWIuc291cmNlLmVmfHxtYyhhLncoKSksYz1kZSh0aGlzLGEsYi5wYXRoLGIuY2hpbGRyZW4sYyxkLGYsZSkpO2Vsc2UgaWYoYi50eXBlPT09ZWUpaWYoYi5ZZClpZihiPWIucGF0aCxudWxsIT1jLnhjKGIpKWM9YTtlbHNle2Y9bmV3IFZiKGMsYSxkKTtkPWEuUS5qKCk7aWYoYi5lKCl8fFwiLnByaW9yaXR5XCI9PT1LKGIpKWxjKGEudygpKT9cbmI9Yy5BYShZYihhKSk6KGI9YS53KCkuaigpLE8oYiBpbnN0YW5jZW9mIGZlLFwic2VydmVyQ2hpbGRyZW4gd291bGQgYmUgY29tcGxldGUgaWYgbGVhZiBub2RlXCIpLGI9Yy5DYyhiKSksYj10aGlzLlgueWEoZCxiLGUpO2Vsc2V7dmFyIGc9SyhiKSxrPWMuQmMoZyxhLncoKSk7bnVsbD09ayYmV2IoYS53KCksZykmJihrPWQuVChnKSk7Yj1udWxsIT1rP3RoaXMuWC5IKGQsZyxrLE4oYiksZixlKTphLlEuaigpLkZhKGcpP3RoaXMuWC5IKGQsZyxILE4oYiksZixlKTpkO2IuZSgpJiZsYyhhLncoKSkmJihkPWMuQWEoWWIoYSkpLGQuTCgpJiYoYj10aGlzLlgueWEoYixkLGUpKSl9ZD1sYyhhLncoKSl8fG51bGwhPWMueGMoTSk7Yz1nZShhLGIsZCx0aGlzLlguUmEoKSl9ZWxzZSBjPWhlKHRoaXMsYSxiLnBhdGgsYi5VYixjLGQsZSk7ZWxzZSBpZihiLnR5cGU9PT1EYylkPWIucGF0aCxiPWEudygpLGY9Yi5qKCksZz1iLmdhfHxkLmUoKSxjPWllKHRoaXMsbmV3IGplKGEuUSxuZXcgWGIoZixcbmcsYi5ZYikpLGQsYyxVYixlKTtlbHNlIHRocm93IGpkKFwiVW5rbm93biBvcGVyYXRpb24gdHlwZTogXCIrYi50eXBlKTtlPXFhKGUuaWIpO2Q9YztiPWQuUTtiLmdhJiYoZj1iLmooKS5MKCl8fGIuaigpLmUoKSxnPWtlKGEpLCgwPGUubGVuZ3RofHwhYS5RLmdhfHxmJiYhYi5qKCkuZWEoZyl8fCFiLmooKS5DKCkuZWEoZy5DKCkpKSYmZS5wdXNoKGhjKGtlKGQpKSkpO3JldHVybiBuZXcgWWQoYyxlKX07XG5mdW5jdGlvbiBpZShhLGIsYyxkLGUsZil7dmFyIGc9Yi5RO2lmKG51bGwhPWQueGMoYykpcmV0dXJuIGI7dmFyIGs7aWYoYy5lKCkpTyhsYyhiLncoKSksXCJJZiBjaGFuZ2UgcGF0aCBpcyBlbXB0eSwgd2UgbXVzdCBoYXZlIGNvbXBsZXRlIHNlcnZlciBkYXRhXCIpLG1jKGIudygpKT8oZT1ZYihiKSxkPWQuQ2MoZSBpbnN0YW5jZW9mIGZlP2U6SCkpOmQ9ZC5BYShZYihiKSksZj1hLlgueWEoYi5RLmooKSxkLGYpO2Vsc2V7dmFyIG09SyhjKTtpZihcIi5wcmlvcml0eVwiPT1tKU8oMT09bGUoYyksXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKSxmPWcuaigpLGs9Yi53KCkuaigpLGQ9ZC5uZChjLGYsayksZj1udWxsIT1kP2EuWC5pYShmLGQpOmcuaigpO2Vsc2V7dmFyIGw9TihjKTtXYihnLG0pPyhrPWIudygpLmooKSxkPWQubmQoYyxnLmooKSxrKSxkPW51bGwhPWQ/Zy5qKCkuVChtKS5IKGwsZCk6Zy5qKCkuVChtKSk6ZD1kLkJjKG0sXG5iLncoKSk7Zj1udWxsIT1kP2EuWC5IKGcuaigpLG0sZCxsLGUsZik6Zy5qKCl9fXJldHVybiBnZShiLGYsZy5nYXx8Yy5lKCksYS5YLlJhKCkpfWZ1bmN0aW9uIGFlKGEsYixjLGQsZSxmLGcsayl7dmFyIG09Yi53KCk7Zz1nP2EuWDphLlguJGIoKTtpZihjLmUoKSlkPWcueWEobS5qKCksZCxudWxsKTtlbHNlIGlmKGcuUmEoKSYmIW0uWWIpZD1tLmooKS5IKGMsZCksZD1nLnlhKG0uaigpLGQsbnVsbCk7ZWxzZXt2YXIgbD1LKGMpO2lmKCFuYyhtLGMpJiYxPGxlKGMpKXJldHVybiBiO3ZhciB0PU4oYyk7ZD1tLmooKS5UKGwpLkgodCxkKTtkPVwiLnByaW9yaXR5XCI9PWw/Zy5pYShtLmooKSxkKTpnLkgobS5qKCksbCxkLHQsVWIsbnVsbCl9bT1tLmdhfHxjLmUoKTtiPW5ldyBqZShiLlEsbmV3IFhiKGQsbSxnLlJhKCkpKTtyZXR1cm4gaWUoYSxiLGMsZSxuZXcgVmIoZSxiLGYpLGspfVxuZnVuY3Rpb24gJGQoYSxiLGMsZCxlLGYsZyl7dmFyIGs9Yi5RO2U9bmV3IFZiKGUsYixmKTtpZihjLmUoKSlnPWEuWC55YShiLlEuaigpLGQsZyksYT1nZShiLGcsITAsYS5YLlJhKCkpO2Vsc2UgaWYoZj1LKGMpLFwiLnByaW9yaXR5XCI9PT1mKWc9YS5YLmlhKGIuUS5qKCksZCksYT1nZShiLGcsay5nYSxrLlliKTtlbHNle2M9TihjKTt2YXIgbT1rLmooKS5UKGYpO2lmKCFjLmUoKSl7dmFyIGw9ZS51ZihmKTtkPW51bGwhPWw/XCIucHJpb3JpdHlcIj09PW1lKGMpJiZsLlMoYy5wYXJlbnQoKSkuZSgpP2w6bC5IKGMsZCk6SH1tLmVhKGQpP2E9YjooZz1hLlguSChrLmooKSxmLGQsYyxlLGcpLGE9Z2UoYixnLGsuZ2EsYS5YLlJhKCkpKX1yZXR1cm4gYX1cbmZ1bmN0aW9uIGNlKGEsYixjLGQsZSxmLGcpe3ZhciBrPWI7bmUoZCxmdW5jdGlvbihkLGwpe3ZhciB0PWMubyhkKTtXYihiLlEsSyh0KSkmJihrPSRkKGEsayx0LGwsZSxmLGcpKX0pO25lKGQsZnVuY3Rpb24oZCxsKXt2YXIgdD1jLm8oZCk7V2IoYi5RLEsodCkpfHwoaz0kZChhLGssdCxsLGUsZixnKSl9KTtyZXR1cm4ga31mdW5jdGlvbiBvZShhLGIpe25lKGIsZnVuY3Rpb24oYixkKXthPWEuSChiLGQpfSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBkZShhLGIsYyxkLGUsZixnLGspe2lmKGIudygpLmooKS5lKCkmJiFsYyhiLncoKSkpcmV0dXJuIGI7dmFyIG09YjtjPWMuZSgpP2Q6cGUocWUsYyxkKTt2YXIgbD1iLncoKS5qKCk7Yy5jaGlsZHJlbi5rYShmdW5jdGlvbihjLGQpe2lmKGwuRmEoYykpe3ZhciBJPWIudygpLmooKS5UKGMpLEk9b2UoSSxkKTttPWFlKGEsbSxuZXcgUChjKSxJLGUsZixnLGspfX0pO2MuY2hpbGRyZW4ua2EoZnVuY3Rpb24oYyxkKXt2YXIgST0hV2IoYi53KCksYykmJm51bGw9PWQudmFsdWU7bC5GYShjKXx8SXx8KEk9Yi53KCkuaigpLlQoYyksST1vZShJLGQpLG09YWUoYSxtLG5ldyBQKGMpLEksZSxmLGcsaykpfSk7cmV0dXJuIG19XG5mdW5jdGlvbiBoZShhLGIsYyxkLGUsZixnKXtpZihudWxsIT1lLnhjKGMpKXJldHVybiBiO3ZhciBrPW1jKGIudygpKSxtPWIudygpO2lmKG51bGwhPWQudmFsdWUpe2lmKGMuZSgpJiZtLmdhfHxuYyhtLGMpKXJldHVybiBhZShhLGIsYyxtLmooKS5TKGMpLGUsZixrLGcpO2lmKGMuZSgpKXt2YXIgbD1xZTttLmooKS5SKHJlLGZ1bmN0aW9uKGEsYil7bD1sLnNldChuZXcgUChhKSxiKX0pO3JldHVybiBkZShhLGIsYyxsLGUsZixrLGcpfXJldHVybiBifWw9cWU7bmUoZCxmdW5jdGlvbihhKXt2YXIgYj1jLm8oYSk7bmMobSxiKSYmKGw9bC5zZXQoYSxtLmooKS5TKGIpKSl9KTtyZXR1cm4gZGUoYSxiLGMsbCxlLGYsayxnKX07ZnVuY3Rpb24gc2UoKXt9dmFyIHRlPXt9O2Z1bmN0aW9uIFZkKGEpe3JldHVybiB1KGEuY29tcGFyZSxhKX1zZS5wcm90b3R5cGUuRGQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMCE9PXRoaXMuY29tcGFyZShuZXcgTChcIltNSU5fTkFNRV1cIixhKSxuZXcgTChcIltNSU5fTkFNRV1cIixiKSl9O3NlLnByb3RvdHlwZS5XYz1mdW5jdGlvbigpe3JldHVybiB1ZX07ZnVuY3Rpb24gdmUoYSl7TyghYS5lKCkmJlwiLnByaW9yaXR5XCIhPT1LKGEpLFwiQ2FuJ3QgY3JlYXRlIFBhdGhJbmRleCB3aXRoIGVtcHR5IHBhdGggb3IgLnByaW9yaXR5IGtleVwiKTt0aGlzLmdjPWF9a2EodmUsc2UpO2g9dmUucHJvdG90eXBlO2guTGM9ZnVuY3Rpb24oYSl7cmV0dXJuIWEuUyh0aGlzLmdjKS5lKCl9O2guY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuVS5TKHRoaXMuZ2MpLGQ9Yi5VLlModGhpcy5nYyksYz1jLkdjKGQpO3JldHVybiAwPT09Yz95YyhhLm5hbWUsYi5uYW1lKTpjfTtcbmguU2M9ZnVuY3Rpb24oYSxiKXt2YXIgYz1RKGEpLGM9SC5IKHRoaXMuZ2MsYyk7cmV0dXJuIG5ldyBMKGIsYyl9O2guVGM9ZnVuY3Rpb24oKXt2YXIgYT1ILkgodGhpcy5nYyx3ZSk7cmV0dXJuIG5ldyBMKFwiW01BWF9OQU1FXVwiLGEpfTtoLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2Muc2xpY2UoKS5qb2luKFwiL1wiKX07ZnVuY3Rpb24geGUoKXt9a2EoeGUsc2UpO2g9eGUucHJvdG90eXBlO2guY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuVS5DKCksZD1iLlUuQygpLGM9Yy5HYyhkKTtyZXR1cm4gMD09PWM/eWMoYS5uYW1lLGIubmFtZSk6Y307aC5MYz1mdW5jdGlvbihhKXtyZXR1cm4hYS5DKCkuZSgpfTtoLkRkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIWEuQygpLmVhKGIuQygpKX07aC5XYz1mdW5jdGlvbigpe3JldHVybiB1ZX07aC5UYz1mdW5jdGlvbigpe3JldHVybiBuZXcgTChcIltNQVhfTkFNRV1cIixuZXcgWWMoXCJbUFJJT1JJVFktUE9TVF1cIix3ZSkpfTtcbmguU2M9ZnVuY3Rpb24oYSxiKXt2YXIgYz1RKGEpO3JldHVybiBuZXcgTChiLG5ldyBZYyhcIltQUklPUklUWS1QT1NUXVwiLGMpKX07aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLnByaW9yaXR5XCJ9O3ZhciBSPW5ldyB4ZTtmdW5jdGlvbiB5ZSgpe31rYSh5ZSxzZSk7aD15ZS5wcm90b3R5cGU7aC5jb21wYXJlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHljKGEubmFtZSxiLm5hbWUpfTtoLkxjPWZ1bmN0aW9uKCl7dGhyb3cgamQoXCJLZXlJbmRleC5pc0RlZmluZWRPbiBub3QgZXhwZWN0ZWQgdG8gYmUgY2FsbGVkLlwiKTt9O2guRGQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5XYz1mdW5jdGlvbigpe3JldHVybiB1ZX07aC5UYz1mdW5jdGlvbigpe3JldHVybiBuZXcgTChcIltNQVhfTkFNRV1cIixIKX07aC5TYz1mdW5jdGlvbihhKXtPKHEoYSksXCJLZXlJbmRleCBpbmRleFZhbHVlIG11c3QgYWx3YXlzIGJlIGEgc3RyaW5nLlwiKTtyZXR1cm4gbmV3IEwoYSxIKX07aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLmtleVwifTtcbnZhciByZT1uZXcgeWU7ZnVuY3Rpb24gemUoKXt9a2EoemUsc2UpO2g9emUucHJvdG90eXBlO2guY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuVS5HYyhiLlUpO3JldHVybiAwPT09Yz95YyhhLm5hbWUsYi5uYW1lKTpjfTtoLkxjPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guRGQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hYS5lYShiKX07aC5XYz1mdW5jdGlvbigpe3JldHVybiB1ZX07aC5UYz1mdW5jdGlvbigpe3JldHVybiBBZX07aC5TYz1mdW5jdGlvbihhLGIpe3ZhciBjPVEoYSk7cmV0dXJuIG5ldyBMKGIsYyl9O2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIi52YWx1ZVwifTt2YXIgQmU9bmV3IHplO2Z1bmN0aW9uIENlKCl7dGhpcy5YYj10aGlzLnJhPXRoaXMuUGI9dGhpcy5vYT10aGlzLmxhPSExO3RoaXMubWE9MDt0aGlzLlJiPVwiXCI7dGhpcy5pYz1udWxsO3RoaXMuQmI9XCJcIjt0aGlzLmZjPW51bGw7dGhpcy56Yj1cIlwiO3RoaXMuZz1SfXZhciBEZT1uZXcgQ2U7ZnVuY3Rpb24gVGQoYSl7cmV0dXJuXCJcIj09PWEuUmI/YS5vYTpcImxcIj09PWEuUmJ9ZnVuY3Rpb24gT2QoYSl7TyhhLm9hLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuaWN9ZnVuY3Rpb24gTmQoYSl7TyhhLm9hLFwiT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuUGI/YS5CYjpcIltNSU5fTkFNRV1cIn1mdW5jdGlvbiBSZChhKXtPKGEucmEsXCJPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuZmN9XG5mdW5jdGlvbiBQZChhKXtPKGEucmEsXCJPbmx5IHZhbGlkIGlmIGVuZCBoYXMgYmVlbiBzZXRcIik7cmV0dXJuIGEuWGI/YS56YjpcIltNQVhfTkFNRV1cIn1mdW5jdGlvbiBFZShhKXt2YXIgYj1uZXcgQ2U7Yi5sYT1hLmxhO2IubWE9YS5tYTtiLm9hPWEub2E7Yi5pYz1hLmljO2IuUGI9YS5QYjtiLkJiPWEuQmI7Yi5yYT1hLnJhO2IuZmM9YS5mYztiLlhiPWEuWGI7Yi56Yj1hLnpiO2IuZz1hLmc7cmV0dXJuIGJ9aD1DZS5wcm90b3R5cGU7aC5MZT1mdW5jdGlvbihhKXt2YXIgYj1FZSh0aGlzKTtiLmxhPSEwO2IubWE9YTtiLlJiPVwiXCI7cmV0dXJuIGJ9O2guTWU9ZnVuY3Rpb24oYSl7dmFyIGI9RWUodGhpcyk7Yi5sYT0hMDtiLm1hPWE7Yi5SYj1cImxcIjtyZXR1cm4gYn07aC5OZT1mdW5jdGlvbihhKXt2YXIgYj1FZSh0aGlzKTtiLmxhPSEwO2IubWE9YTtiLlJiPVwiclwiO3JldHVybiBifTtcbmguY2U9ZnVuY3Rpb24oYSxiKXt2YXIgYz1FZSh0aGlzKTtjLm9hPSEwO3AoYSl8fChhPW51bGwpO2MuaWM9YTtudWxsIT1iPyhjLlBiPSEwLGMuQmI9Yik6KGMuUGI9ITEsYy5CYj1cIlwiKTtyZXR1cm4gY307aC52ZD1mdW5jdGlvbihhLGIpe3ZhciBjPUVlKHRoaXMpO2MucmE9ITA7cChhKXx8KGE9bnVsbCk7Yy5mYz1hO3AoYik/KGMuWGI9ITAsYy56Yj1iKTooYy5uaD0hMSxjLnpiPVwiXCIpO3JldHVybiBjfTtmdW5jdGlvbiBGZShhLGIpe3ZhciBjPUVlKGEpO2MuZz1iO3JldHVybiBjfWZ1bmN0aW9uIEdlKGEpe3ZhciBiPXt9O2Eub2EmJihiLnNwPWEuaWMsYS5QYiYmKGIuc249YS5CYikpO2EucmEmJihiLmVwPWEuZmMsYS5YYiYmKGIuZW49YS56YikpO2lmKGEubGEpe2IubD1hLm1hO3ZhciBjPWEuUmI7XCJcIj09PWMmJihjPVRkKGEpP1wibFwiOlwiclwiKTtiLnZmPWN9YS5nIT09UiYmKGIuaT1hLmcudG9TdHJpbmcoKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBIZShhKXtyZXR1cm4hKGEub2F8fGEucmF8fGEubGEpfWZ1bmN0aW9uIEllKGEpe3JldHVybiBIZShhKSYmYS5nPT1SfWZ1bmN0aW9uIEplKGEpe3ZhciBiPXt9O2lmKEllKGEpKXJldHVybiBiO3ZhciBjO2EuZz09PVI/Yz1cIiRwcmlvcml0eVwiOmEuZz09PUJlP2M9XCIkdmFsdWVcIjphLmc9PT1yZT9jPVwiJGtleVwiOihPKGEuZyBpbnN0YW5jZW9mIHZlLFwiVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhXCIpLGM9YS5nLnRvU3RyaW5nKCkpO2Iub3JkZXJCeT1HKGMpO2Eub2EmJihiLnN0YXJ0QXQ9RyhhLmljKSxhLlBiJiYoYi5zdGFydEF0Kz1cIixcIitHKGEuQmIpKSk7YS5yYSYmKGIuZW5kQXQ9RyhhLmZjKSxhLlhiJiYoYi5lbmRBdCs9XCIsXCIrRyhhLnpiKSkpO2EubGEmJihUZChhKT9iLmxpbWl0VG9GaXJzdD1hLm1hOmIubGltaXRUb0xhc3Q9YS5tYSk7cmV0dXJuIGJ9aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBHKEdlKHRoaXMpKX07ZnVuY3Rpb24gS2UoYSxiKXt0aGlzLkVkPWE7dGhpcy5oYz1ifUtlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9eih0aGlzLkVkLGEpO2lmKCFiKXRocm93IEVycm9yKFwiTm8gaW5kZXggZGVmaW5lZCBmb3IgXCIrYSk7cmV0dXJuIGI9PT10ZT9udWxsOmJ9O2Z1bmN0aW9uIExlKGEsYixjKXt2YXIgZD1tYShhLkVkLGZ1bmN0aW9uKGQsZil7dmFyIGc9eihhLmhjLGYpO08oZyxcIk1pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yIFwiK2YpO2lmKGQ9PT10ZSl7aWYoZy5MYyhiLlUpKXtmb3IodmFyIGs9W10sbT1jLmFjKHdjKSxsPUljKG0pO2w7KWwubmFtZSE9Yi5uYW1lJiZrLnB1c2gobCksbD1JYyhtKTtrLnB1c2goYik7cmV0dXJuIE1lKGssVmQoZykpfXJldHVybiB0ZX1nPWMuZ2V0KGIubmFtZSk7az1kO2cmJihrPWsucmVtb3ZlKG5ldyBMKGIubmFtZSxnKSkpO3JldHVybiBrLlNhKGIsYi5VKX0pO3JldHVybiBuZXcgS2UoZCxhLmhjKX1cbmZ1bmN0aW9uIE5lKGEsYixjKXt2YXIgZD1tYShhLkVkLGZ1bmN0aW9uKGEpe2lmKGE9PT10ZSlyZXR1cm4gYTt2YXIgZD1jLmdldChiLm5hbWUpO3JldHVybiBkP2EucmVtb3ZlKG5ldyBMKGIubmFtZSxkKSk6YX0pO3JldHVybiBuZXcgS2UoZCxhLmhjKX12YXIgT2U9bmV3IEtlKHtcIi5wcmlvcml0eVwiOnRlfSx7XCIucHJpb3JpdHlcIjpSfSk7ZnVuY3Rpb24gWWMoYSxiKXt0aGlzLkI9YTtPKHAodGhpcy5CKSYmbnVsbCE9PXRoaXMuQixcIkxlYWZOb2RlIHNob3VsZG4ndCBiZSBjcmVhdGVkIHdpdGggbnVsbC91bmRlZmluZWQgdmFsdWUuXCIpO3RoaXMuY2E9Ynx8SDtQZSh0aGlzLmNhKTt0aGlzLkdiPW51bGx9dmFyIFFlPVtcIm9iamVjdFwiLFwiYm9vbGVhblwiLFwibnVtYmVyXCIsXCJzdHJpbmdcIl07aD1ZYy5wcm90b3R5cGU7aC5MPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2guQz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhfTtoLmlhPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgWWModGhpcy5CLGEpfTtoLlQ9ZnVuY3Rpb24oYSl7cmV0dXJuXCIucHJpb3JpdHlcIj09PWE/dGhpcy5jYTpIfTtoLlM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZSgpP3RoaXM6XCIucHJpb3JpdHlcIj09PUsoYSk/dGhpcy5jYTpIfTtoLkZhPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2gud2Y9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XG5oLlc9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cIi5wcmlvcml0eVwiPT09YT90aGlzLmlhKGIpOmIuZSgpJiZcIi5wcmlvcml0eVwiIT09YT90aGlzOkguVyhhLGIpLmlhKHRoaXMuY2EpfTtoLkg9ZnVuY3Rpb24oYSxiKXt2YXIgYz1LKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGIuZSgpJiZcIi5wcmlvcml0eVwiIT09YylyZXR1cm4gdGhpcztPKFwiLnByaW9yaXR5XCIhPT1jfHwxPT09bGUoYSksXCIucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGhcIik7cmV0dXJuIHRoaXMuVyhjLEguSChOKGEpLGIpKX07aC5lPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guSGI9ZnVuY3Rpb24oKXtyZXR1cm4gMH07aC5SPWZ1bmN0aW9uKCl7cmV0dXJuITF9O2guSj1mdW5jdGlvbihhKXtyZXR1cm4gYSYmIXRoaXMuQygpLmUoKT97XCIudmFsdWVcIjp0aGlzLkVhKCksXCIucHJpb3JpdHlcIjp0aGlzLkMoKS5KKCl9OnRoaXMuRWEoKX07XG5oLmhhc2g9ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5HYil7dmFyIGE9XCJcIjt0aGlzLmNhLmUoKXx8KGErPVwicHJpb3JpdHk6XCIrUmUodGhpcy5jYS5KKCkpK1wiOlwiKTt2YXIgYj10eXBlb2YgdGhpcy5CLGE9YSsoYitcIjpcIiksYT1cIm51bWJlclwiPT09Yj9hK0FkKHRoaXMuQik6YSt0aGlzLkI7dGhpcy5HYj1sZChhKX1yZXR1cm4gdGhpcy5HYn07aC5FYT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkJ9O2guR2M9ZnVuY3Rpb24oYSl7aWYoYT09PUgpcmV0dXJuIDE7aWYoYSBpbnN0YW5jZW9mIGZlKXJldHVybi0xO08oYS5MKCksXCJVbmtub3duIG5vZGUgdHlwZVwiKTt2YXIgYj10eXBlb2YgYS5CLGM9dHlwZW9mIHRoaXMuQixkPUxhKFFlLGIpLGU9TGEoUWUsYyk7TygwPD1kLFwiVW5rbm93biBsZWFmIHR5cGU6IFwiK2IpO08oMDw9ZSxcIlVua25vd24gbGVhZiB0eXBlOiBcIitjKTtyZXR1cm4gZD09PWU/XCJvYmplY3RcIj09PWM/MDp0aGlzLkI8YS5CPy0xOnRoaXMuQj09PWEuQj8wOjE6ZS1kfTtcbmgucGI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307aC5NYz1mdW5jdGlvbigpe3JldHVybiEwfTtoLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpcz8hMDphLkwoKT90aGlzLkI9PT1hLkImJnRoaXMuY2EuZWEoYS5jYSk6ITF9O2gudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gRyh0aGlzLkooITApKX07ZnVuY3Rpb24gZmUoYSxiLGMpe3RoaXMubT1hOyh0aGlzLmNhPWIpJiZQZSh0aGlzLmNhKTthLmUoKSYmTyghdGhpcy5jYXx8dGhpcy5jYS5lKCksXCJBbiBlbXB0eSBub2RlIGNhbm5vdCBoYXZlIGEgcHJpb3JpdHlcIik7dGhpcy5BYj1jO3RoaXMuR2I9bnVsbH1oPWZlLnByb3RvdHlwZTtoLkw9ZnVuY3Rpb24oKXtyZXR1cm4hMX07aC5DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2F8fEh9O2guaWE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubS5lKCk/dGhpczpuZXcgZmUodGhpcy5tLGEsdGhpcy5BYil9O2guVD1mdW5jdGlvbihhKXtpZihcIi5wcmlvcml0eVwiPT09YSlyZXR1cm4gdGhpcy5DKCk7YT10aGlzLm0uZ2V0KGEpO3JldHVybiBudWxsPT09YT9IOmF9O2guUz1mdW5jdGlvbihhKXt2YXIgYj1LKGEpO3JldHVybiBudWxsPT09Yj90aGlzOnRoaXMuVChiKS5TKE4oYSkpfTtoLkZhPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09dGhpcy5tLmdldChhKX07XG5oLlc9ZnVuY3Rpb24oYSxiKXtPKGIsXCJXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXNcIik7aWYoXCIucHJpb3JpdHlcIj09PWEpcmV0dXJuIHRoaXMuaWEoYik7dmFyIGM9bmV3IEwoYSxiKSxkLGU7Yi5lKCk/KGQ9dGhpcy5tLnJlbW92ZShhKSxjPU5lKHRoaXMuQWIsYyx0aGlzLm0pKTooZD10aGlzLm0uU2EoYSxiKSxjPUxlKHRoaXMuQWIsYyx0aGlzLm0pKTtlPWQuZSgpP0g6dGhpcy5jYTtyZXR1cm4gbmV3IGZlKGQsZSxjKX07aC5IPWZ1bmN0aW9uKGEsYil7dmFyIGM9SyhhKTtpZihudWxsPT09YylyZXR1cm4gYjtPKFwiLnByaW9yaXR5XCIhPT1LKGEpfHwxPT09bGUoYSksXCIucHJpb3JpdHkgbXVzdCBiZSB0aGUgbGFzdCB0b2tlbiBpbiBhIHBhdGhcIik7dmFyIGQ9dGhpcy5UKGMpLkgoTihhKSxiKTtyZXR1cm4gdGhpcy5XKGMsZCl9O2guZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm0uZSgpfTtoLkhiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubS5jb3VudCgpfTtcbnZhciBTZT0vXigwfFsxLTldXFxkKikkLztoPWZlLnByb3RvdHlwZTtoLko9ZnVuY3Rpb24oYSl7aWYodGhpcy5lKCkpcmV0dXJuIG51bGw7dmFyIGI9e30sYz0wLGQ9MCxlPSEwO3RoaXMuUihSLGZ1bmN0aW9uKGYsZyl7YltmXT1nLkooYSk7YysrO2UmJlNlLnRlc3QoZik/ZD1NYXRoLm1heChkLE51bWJlcihmKSk6ZT0hMX0pO2lmKCFhJiZlJiZkPDIqYyl7dmFyIGY9W10sZztmb3IoZyBpbiBiKWZbZ109YltnXTtyZXR1cm4gZn1hJiYhdGhpcy5DKCkuZSgpJiYoYltcIi5wcmlvcml0eVwiXT10aGlzLkMoKS5KKCkpO3JldHVybiBifTtoLmhhc2g9ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5HYil7dmFyIGE9XCJcIjt0aGlzLkMoKS5lKCl8fChhKz1cInByaW9yaXR5OlwiK1JlKHRoaXMuQygpLkooKSkrXCI6XCIpO3RoaXMuUihSLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yy5oYXNoKCk7XCJcIiE9PWQmJihhKz1cIjpcIitiK1wiOlwiK2QpfSk7dGhpcy5HYj1cIlwiPT09YT9cIlwiOmxkKGEpfXJldHVybiB0aGlzLkdifTtcbmgud2Y9ZnVuY3Rpb24oYSxiLGMpe3JldHVybihjPVRlKHRoaXMsYykpPyhhPUdjKGMsbmV3IEwoYSxiKSkpP2EubmFtZTpudWxsOkdjKHRoaXMubSxhKX07ZnVuY3Rpb24gV2QoYSxiKXt2YXIgYztjPShjPVRlKGEsYikpPyhjPWMuVmMoKSkmJmMubmFtZTphLm0uVmMoKTtyZXR1cm4gYz9uZXcgTChjLGEubS5nZXQoYykpOm51bGx9ZnVuY3Rpb24gWGQoYSxiKXt2YXIgYztjPShjPVRlKGEsYikpPyhjPWMuamMoKSkmJmMubmFtZTphLm0uamMoKTtyZXR1cm4gYz9uZXcgTChjLGEubS5nZXQoYykpOm51bGx9aC5SPWZ1bmN0aW9uKGEsYil7dmFyIGM9VGUodGhpcyxhKTtyZXR1cm4gYz9jLmthKGZ1bmN0aW9uKGEpe3JldHVybiBiKGEubmFtZSxhLlUpfSk6dGhpcy5tLmthKGIpfTtoLmFjPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmJjKGEuV2MoKSxhKX07XG5oLmJjPWZ1bmN0aW9uKGEsYil7dmFyIGM9VGUodGhpcyxiKTtpZihjKXJldHVybiBjLmJjKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmb3IodmFyIGM9dGhpcy5tLmJjKGEubmFtZSx3YyksZD1KYyhjKTtudWxsIT1kJiYwPmIuY29tcGFyZShkLGEpOylJYyhjKSxkPUpjKGMpO3JldHVybiBjfTtoLnhmPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmRjKGEuVGMoKSxhKX07aC5kYz1mdW5jdGlvbihhLGIpe3ZhciBjPVRlKHRoaXMsYik7aWYoYylyZXR1cm4gYy5kYyhhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSk7Zm9yKHZhciBjPXRoaXMubS5kYyhhLm5hbWUsd2MpLGQ9SmMoYyk7bnVsbCE9ZCYmMDxiLmNvbXBhcmUoZCxhKTspSWMoYyksZD1KYyhjKTtyZXR1cm4gY307aC5HYz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lKCk/YS5lKCk/MDotMTphLkwoKXx8YS5lKCk/MTphPT09d2U/LTE6MH07XG5oLnBiPWZ1bmN0aW9uKGEpe2lmKGE9PT1yZXx8c2EodGhpcy5BYi5oYyxhLnRvU3RyaW5nKCkpKXJldHVybiB0aGlzO3ZhciBiPXRoaXMuQWIsYz10aGlzLm07TyhhIT09cmUsXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO2Zvcih2YXIgZD1bXSxlPSExLGM9Yy5hYyh3YyksZj1JYyhjKTtmOyllPWV8fGEuTGMoZi5VKSxkLnB1c2goZiksZj1JYyhjKTtkPWU/TWUoZCxWZChhKSk6dGU7ZT1hLnRvU3RyaW5nKCk7Yz13YShiLmhjKTtjW2VdPWE7YT13YShiLkVkKTthW2VdPWQ7cmV0dXJuIG5ldyBmZSh0aGlzLm0sdGhpcy5jYSxuZXcgS2UoYSxjKSl9O2guTWM9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1yZXx8c2EodGhpcy5BYi5oYyxhLnRvU3RyaW5nKCkpfTtcbmguZWE9ZnVuY3Rpb24oYSl7aWYoYT09PXRoaXMpcmV0dXJuITA7aWYoYS5MKCkpcmV0dXJuITE7aWYodGhpcy5DKCkuZWEoYS5DKCkpJiZ0aGlzLm0uY291bnQoKT09PWEubS5jb3VudCgpKXt2YXIgYj10aGlzLmFjKFIpO2E9YS5hYyhSKTtmb3IodmFyIGM9SWMoYiksZD1JYyhhKTtjJiZkOyl7aWYoYy5uYW1lIT09ZC5uYW1lfHwhYy5VLmVhKGQuVSkpcmV0dXJuITE7Yz1JYyhiKTtkPUljKGEpfXJldHVybiBudWxsPT09YyYmbnVsbD09PWR9cmV0dXJuITF9O2Z1bmN0aW9uIFRlKGEsYil7cmV0dXJuIGI9PT1yZT9udWxsOmEuQWIuZ2V0KGIudG9TdHJpbmcoKSl9aC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBHKHRoaXMuSighMCkpfTtmdW5jdGlvbiBRKGEsYil7aWYobnVsbD09PWEpcmV0dXJuIEg7dmFyIGM9bnVsbDtcIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiLnByaW9yaXR5XCJpbiBhP2M9YVtcIi5wcmlvcml0eVwiXTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGImJihjPWIpO08obnVsbD09PWN8fFwic3RyaW5nXCI9PT10eXBlb2YgY3x8XCJudW1iZXJcIj09PXR5cGVvZiBjfHxcIm9iamVjdFwiPT09dHlwZW9mIGMmJlwiLnN2XCJpbiBjLFwiSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiBcIit0eXBlb2YgYyk7XCJvYmplY3RcIj09PXR5cGVvZiBhJiZcIi52YWx1ZVwiaW4gYSYmbnVsbCE9PWFbXCIudmFsdWVcIl0mJihhPWFbXCIudmFsdWVcIl0pO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8XCIuc3ZcImluIGEpcmV0dXJuIG5ldyBZYyhhLFEoYykpO2lmKGEgaW5zdGFuY2VvZiBBcnJheSl7dmFyIGQ9SCxlPWE7dihlLGZ1bmN0aW9uKGEsYil7aWYoeShlLGIpJiZcIi5cIiE9PWIuc3Vic3RyaW5nKDAsMSkpe3ZhciBjPVEoYSk7aWYoYy5MKCl8fCFjLmUoKSlkPVxuZC5XKGIsYyl9fSk7cmV0dXJuIGQuaWEoUShjKSl9dmFyIGY9W10sZz0hMSxrPWE7RmIoayxmdW5jdGlvbihhKXtpZihcInN0cmluZ1wiIT09dHlwZW9mIGF8fFwiLlwiIT09YS5zdWJzdHJpbmcoMCwxKSl7dmFyIGI9UShrW2FdKTtiLmUoKXx8KGc9Z3x8IWIuQygpLmUoKSxmLnB1c2gobmV3IEwoYSxiKSkpfX0pO2lmKDA9PWYubGVuZ3RoKXJldHVybiBIO3ZhciBtPU1lKGYseGMsZnVuY3Rpb24oYSl7cmV0dXJuIGEubmFtZX0semMpO2lmKGcpe3ZhciBsPU1lKGYsVmQoUikpO3JldHVybiBuZXcgZmUobSxRKGMpLG5ldyBLZSh7XCIucHJpb3JpdHlcIjpsfSx7XCIucHJpb3JpdHlcIjpSfSkpfXJldHVybiBuZXcgZmUobSxRKGMpLE9lKX12YXIgVWU9TWF0aC5sb2coMik7XG5mdW5jdGlvbiBWZShhKXt0aGlzLmNvdW50PXBhcnNlSW50KE1hdGgubG9nKGErMSkvVWUsMTApO3RoaXMubmY9dGhpcy5jb3VudC0xO3RoaXMubmc9YSsxJnBhcnNlSW50KEFycmF5KHRoaXMuY291bnQrMSkuam9pbihcIjFcIiksMil9ZnVuY3Rpb24gV2UoYSl7dmFyIGI9IShhLm5nJjE8PGEubmYpO2EubmYtLTtyZXR1cm4gYn1cbmZ1bmN0aW9uIE1lKGEsYixjLGQpe2Z1bmN0aW9uIGUoYixkKXt2YXIgZj1kLWI7aWYoMD09ZilyZXR1cm4gbnVsbDtpZigxPT1mKXt2YXIgbD1hW2JdLHQ9Yz9jKGwpOmw7cmV0dXJuIG5ldyBLYyh0LGwuVSwhMSxudWxsLG51bGwpfXZhciBsPXBhcnNlSW50KGYvMiwxMCkrYixmPWUoYixsKSxBPWUobCsxLGQpLGw9YVtsXSx0PWM/YyhsKTpsO3JldHVybiBuZXcgS2ModCxsLlUsITEsZixBKX1hLnNvcnQoYik7dmFyIGY9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZChiLGcpe3ZhciBrPXQtYixBPXQ7dC09Yjt2YXIgQT1lKGsrMSxBKSxrPWFba10sST1jP2Moayk6ayxBPW5ldyBLYyhJLGsuVSxnLG51bGwsQSk7Zj9mLmxlZnQ9QTpsPUE7Zj1BfWZvcih2YXIgZj1udWxsLGw9bnVsbCx0PWEubGVuZ3RoLEE9MDtBPGIuY291bnQ7KytBKXt2YXIgST1XZShiKSxRZD1NYXRoLnBvdygyLGIuY291bnQtKEErMSkpO0k/ZChRZCwhMSk6KGQoUWQsITEpLGQoUWQsITApKX1yZXR1cm4gbH0obmV3IFZlKGEubGVuZ3RoKSk7XG5yZXR1cm4gbnVsbCE9PWY/bmV3IEVjKGR8fGIsZik6bmV3IEVjKGR8fGIpfWZ1bmN0aW9uIFJlKGEpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYT9cIm51bWJlcjpcIitBZChhKTpcInN0cmluZzpcIithfWZ1bmN0aW9uIFBlKGEpe2lmKGEuTCgpKXt2YXIgYj1hLkooKTtPKFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBifHxcIm9iamVjdFwiPT09dHlwZW9mIGImJnkoYixcIi5zdlwiKSxcIlByaW9yaXR5IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyLlwiKX1lbHNlIE8oYT09PXdlfHxhLmUoKSxcInByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS5cIik7TyhhPT09d2V8fGEuQygpLmUoKSxcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpfXZhciBIPW5ldyBmZShuZXcgRWMoemMpLG51bGwsT2UpO2Z1bmN0aW9uIFhlKCl7ZmUuY2FsbCh0aGlzLG5ldyBFYyh6YyksSCxPZSl9a2EoWGUsZmUpO2g9WGUucHJvdG90eXBlO1xuaC5HYz1mdW5jdGlvbihhKXtyZXR1cm4gYT09PXRoaXM/MDoxfTtoLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhPT09dGhpc307aC5DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O2guVD1mdW5jdGlvbigpe3JldHVybiBIfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4hMX07dmFyIHdlPW5ldyBYZSx1ZT1uZXcgTChcIltNSU5fTkFNRV1cIixIKSxBZT1uZXcgTChcIltNQVhfTkFNRV1cIix3ZSk7ZnVuY3Rpb24gamUoYSxiKXt0aGlzLlE9YTt0aGlzLmFlPWJ9ZnVuY3Rpb24gZ2UoYSxiLGMsZCl7cmV0dXJuIG5ldyBqZShuZXcgWGIoYixjLGQpLGEuYWUpfWZ1bmN0aW9uIGtlKGEpe3JldHVybiBhLlEuZ2E/YS5RLmooKTpudWxsfWplLnByb3RvdHlwZS53PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWV9O2Z1bmN0aW9uIFliKGEpe3JldHVybiBhLmFlLmdhP2EuYWUuaigpOm51bGx9O2Z1bmN0aW9uIFllKGEsYil7dGhpcy5ZPWE7dmFyIGM9YS5uLGQ9bmV3IExkKGMuZyksYz1IZShjKT9uZXcgTGQoYy5nKTpjLmxhP25ldyBTZChjKTpuZXcgTWQoYyk7dGhpcy5OZj1uZXcgWmQoYyk7dmFyIGU9Yi53KCksZj1iLlEsZz1kLnlhKEgsZS5qKCksbnVsbCksaz1jLnlhKEgsZi5qKCksbnVsbCk7dGhpcy5PYT1uZXcgamUobmV3IFhiKGssZi5nYSxjLlJhKCkpLG5ldyBYYihnLGUuZ2EsZC5SYSgpKSk7dGhpcy4kYT1bXTt0aGlzLnVnPW5ldyBGZChhKX1mdW5jdGlvbiBaZShhKXtyZXR1cm4gYS5ZfWg9WWUucHJvdG90eXBlO2gudz1mdW5jdGlvbigpe3JldHVybiB0aGlzLk9hLncoKS5qKCl9O2gua2I9ZnVuY3Rpb24oYSl7dmFyIGI9WWIodGhpcy5PYSk7cmV0dXJuIGImJihIZSh0aGlzLlkubil8fCFhLmUoKSYmIWIuVChLKGEpKS5lKCkpP2IuUyhhKTpudWxsfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuJGEubGVuZ3RofTtoLlRiPWZ1bmN0aW9uKGEpe3RoaXMuJGEucHVzaChhKX07XG5oLm5iPWZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYoYil7TyhudWxsPT1hLFwiQSBjYW5jZWwgc2hvdWxkIGNhbmNlbCBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucy5cIik7dmFyIGQ9dGhpcy5ZLnBhdGg7TWEodGhpcy4kYSxmdW5jdGlvbihhKXsoYT1hLmxmKGIsZCkpJiZjLnB1c2goYSl9KX1pZihhKXtmb3IodmFyIGU9W10sZj0wO2Y8dGhpcy4kYS5sZW5ndGg7KytmKXt2YXIgZz10aGlzLiRhW2ZdO2lmKCFnLm1hdGNoZXMoYSkpZS5wdXNoKGcpO2Vsc2UgaWYoYS55ZigpKXtlPWUuY29uY2F0KHRoaXMuJGEuc2xpY2UoZisxKSk7YnJlYWt9fXRoaXMuJGE9ZX1lbHNlIHRoaXMuJGE9W107cmV0dXJuIGN9O1xuaC5nYj1mdW5jdGlvbihhLGIsYyl7YS50eXBlPT09YmUmJm51bGwhPT1hLnNvdXJjZS5MYiYmKE8oWWIodGhpcy5PYSksXCJXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBmdWxsIGNhY2hlIGJlZm9yZSBoYW5kbGluZyBtZXJnZXNcIiksTyhrZSh0aGlzLk9hKSxcIk1pc3NpbmcgZXZlbnQgY2FjaGUsIGV2ZW4gdGhvdWdoIHdlIGhhdmUgYSBzZXJ2ZXIgY2FjaGVcIikpO3ZhciBkPXRoaXMuT2E7YT10aGlzLk5mLmdiKGQsYSxiLGMpO2I9dGhpcy5OZjtjPWEubWU7TyhjLlEuaigpLk1jKGIuWC5nKSxcIkV2ZW50IHNuYXAgbm90IGluZGV4ZWRcIik7TyhjLncoKS5qKCkuTWMoYi5YLmcpLFwiU2VydmVyIHNuYXAgbm90IGluZGV4ZWRcIik7TyhsYyhhLm1lLncoKSl8fCFsYyhkLncoKSksXCJPbmNlIGEgc2VydmVyIHNuYXAgaXMgY29tcGxldGUsIGl0IHNob3VsZCBuZXZlciBnbyBiYWNrXCIpO3RoaXMuT2E9YS5tZTtyZXR1cm4gJGUodGhpcyxhLm9nLGEubWUuUS5qKCksbnVsbCl9O1xuZnVuY3Rpb24gYWYoYSxiKXt2YXIgYz1hLk9hLlEsZD1bXTtjLmooKS5MKCl8fGMuaigpLlIoUixmdW5jdGlvbihhLGIpe2QucHVzaChuZXcgSihcImNoaWxkX2FkZGVkXCIsYixhKSl9KTtjLmdhJiZkLnB1c2goaGMoYy5qKCkpKTtyZXR1cm4gJGUoYSxkLGMuaigpLGIpfWZ1bmN0aW9uICRlKGEsYixjLGQpe3JldHVybiBHZChhLnVnLGIsYyxkP1tkXTphLiRhKX07ZnVuY3Rpb24gYmYoYSxiLGMpe3RoaXMudHlwZT1iZTt0aGlzLnNvdXJjZT1hO3RoaXMucGF0aD1iO3RoaXMuY2hpbGRyZW49Y31iZi5wcm90b3R5cGUuJGM9ZnVuY3Rpb24oYSl7aWYodGhpcy5wYXRoLmUoKSlyZXR1cm4gYT10aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFAoYSkpLGEuZSgpP251bGw6YS52YWx1ZT9uZXcgQWModGhpcy5zb3VyY2UsTSxhLnZhbHVlKTpuZXcgYmYodGhpcy5zb3VyY2UsTSxhKTtPKEsodGhpcy5wYXRoKT09PWEsXCJDYW4ndCBnZXQgYSBtZXJnZSBmb3IgYSBjaGlsZCBub3Qgb24gdGhlIHBhdGggb2YgdGhlIG9wZXJhdGlvblwiKTtyZXR1cm4gbmV3IGJmKHRoaXMuc291cmNlLE4odGhpcy5wYXRoKSx0aGlzLmNoaWxkcmVuKX07YmYucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJPcGVyYXRpb24oXCIrdGhpcy5wYXRoK1wiOiBcIit0aGlzLnNvdXJjZS50b1N0cmluZygpK1wiIG1lcmdlOiBcIit0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkrXCIpXCJ9O2Z1bmN0aW9uIGNmKGEsYil7dGhpcy5mPXBkKFwicDpyZXN0OlwiKTt0aGlzLkc9YTt0aGlzLktiPWI7dGhpcy5DYT1udWxsO3RoaXMuYmE9e319ZnVuY3Rpb24gZGYoYSxiKXtpZihwKGIpKXJldHVyblwidGFnJFwiK2I7TyhJZShhLm4pLFwic2hvdWxkIGhhdmUgYSB0YWcgaWYgaXQncyBub3QgYSBkZWZhdWx0IHF1ZXJ5LlwiKTtyZXR1cm4gYS5wYXRoLnRvU3RyaW5nKCl9aD1jZi5wcm90b3R5cGU7XG5oLkNmPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEucGF0aC50b1N0cmluZygpO3RoaXMuZihcIkxpc3RlbiBjYWxsZWQgZm9yIFwiK2UrXCIgXCIrYS53YSgpKTt2YXIgZj1kZihhLGMpLGc9e307dGhpcy5iYVtmXT1nO2E9SmUoYS5uKTt2YXIgaz10aGlzO2VmKHRoaXMsZStcIi5qc29uXCIsYSxmdW5jdGlvbihhLGIpe3ZhciB0PWI7NDA0PT09YSYmKGE9dD1udWxsKTtudWxsPT09YSYmay5LYihlLHQsITEsYyk7eihrLmJhLGYpPT09ZyYmZChhPzQwMT09YT9cInBlcm1pc3Npb25fZGVuaWVkXCI6XCJyZXN0X2Vycm9yOlwiK2E6XCJva1wiLG51bGwpfSl9O2guJGY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1kZihhLGIpO2RlbGV0ZSB0aGlzLmJhW2NdfTtoLk89ZnVuY3Rpb24oYSxiKXt0aGlzLkNhPWE7dmFyIGM9Q2QoYSksZD1jLmRhdGEsYz1jLkVjJiZjLkVjLmV4cDtiJiZiKFwib2tcIix7YXV0aDpkLGV4cGlyZXM6Y30pfTtoLmplPWZ1bmN0aW9uKGEpe3RoaXMuQ2E9bnVsbDthKFwib2tcIixudWxsKX07XG5oLlFlPWZ1bmN0aW9uKCl7fTtoLkdmPWZ1bmN0aW9uKCl7fTtoLk1kPWZ1bmN0aW9uKCl7fTtoLnB1dD1mdW5jdGlvbigpe307aC5EZj1mdW5jdGlvbigpe307aC5ZZT1mdW5jdGlvbigpe307XG5mdW5jdGlvbiBlZihhLGIsYyxkKXtjPWN8fHt9O2MuZm9ybWF0PVwiZXhwb3J0XCI7YS5DYSYmKGMuYXV0aD1hLkNhKTt2YXIgZT0oYS5HLm9iP1wiaHR0cHM6Ly9cIjpcImh0dHA6Ly9cIikrYS5HLmhvc3QrYitcIj9cIitJYihjKTthLmYoXCJTZW5kaW5nIFJFU1QgcmVxdWVzdCBmb3IgXCIrZSk7dmFyIGY9bmV3IFhNTEh0dHBSZXF1ZXN0O2Yub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZCYmND09PWYucmVhZHlTdGF0ZSl7YS5mKFwiUkVTVCBSZXNwb25zZSBmb3IgXCIrZStcIiByZWNlaXZlZC4gc3RhdHVzOlwiLGYuc3RhdHVzLFwicmVzcG9uc2U6XCIsZi5yZXNwb25zZVRleHQpO3ZhciBiPW51bGw7aWYoMjAwPD1mLnN0YXR1cyYmMzAwPmYuc3RhdHVzKXt0cnl7Yj1SYihmLnJlc3BvbnNlVGV4dCl9Y2F0Y2goYyl7UyhcIkZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlIGZvciBcIitlK1wiOiBcIitmLnJlc3BvbnNlVGV4dCl9ZChudWxsLGIpfWVsc2UgNDAxIT09Zi5zdGF0dXMmJjQwNCE9PVxuZi5zdGF0dXMmJlMoXCJHb3QgdW5zdWNjZXNzZnVsIFJFU1QgcmVzcG9uc2UgZm9yIFwiK2UrXCIgU3RhdHVzOiBcIitmLnN0YXR1cyksZChmLnN0YXR1cyk7ZD1udWxsfX07Zi5vcGVuKFwiR0VUXCIsZSwhMCk7Zi5zZW5kKCl9O2Z1bmN0aW9uIGZmKGEpe08oZGEoYSkmJjA8YS5sZW5ndGgsXCJSZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheVwiKTt0aGlzLmZnPWE7dGhpcy5SYz17fX1mZi5wcm90b3R5cGUuaWU9ZnVuY3Rpb24oYSxiKXt2YXIgYztjPXRoaXMuUmNbYV18fFtdO3ZhciBkPWMubGVuZ3RoO2lmKDA8ZCl7Zm9yKHZhciBlPUFycmF5KGQpLGY9MDtmPGQ7ZisrKWVbZl09Y1tmXTtjPWV9ZWxzZSBjPVtdO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5EYy5hcHBseShjW2RdLlFhLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9O2ZmLnByb3RvdHlwZS5JYj1mdW5jdGlvbihhLGIsYyl7Z2YodGhpcyxhKTt0aGlzLlJjW2FdPXRoaXMuUmNbYV18fFtdO3RoaXMuUmNbYV0ucHVzaCh7RGM6YixRYTpjfSk7KGE9dGhpcy5FZShhKSkmJmIuYXBwbHkoYyxhKX07XG5mZi5wcm90b3R5cGUubWM9ZnVuY3Rpb24oYSxiLGMpe2dmKHRoaXMsYSk7YT10aGlzLlJjW2FdfHxbXTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLkRjPT09YiYmKCFjfHxjPT09YVtkXS5RYSkpe2Euc3BsaWNlKGQsMSk7YnJlYWt9fTtmdW5jdGlvbiBnZihhLGIpe08oUmEoYS5mZyxmdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9KSxcIlVua25vd24gZXZlbnQ6IFwiK2IpfTt2YXIgaGY9ZnVuY3Rpb24oKXt2YXIgYT0wLGI9W107cmV0dXJuIGZ1bmN0aW9uKGMpe3ZhciBkPWM9PT1hO2E9Yztmb3IodmFyIGU9QXJyYXkoOCksZj03OzA8PWY7Zi0tKWVbZl09XCItMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuY2hhckF0KGMlNjQpLGM9TWF0aC5mbG9vcihjLzY0KTtPKDA9PT1jLFwiQ2Fubm90IHB1c2ggYXQgdGltZSA9PSAwXCIpO2M9ZS5qb2luKFwiXCIpO2lmKGQpe2ZvcihmPTExOzA8PWYmJjYzPT09YltmXTtmLS0pYltmXT0wO2JbZl0rK31lbHNlIGZvcihmPTA7MTI+ZjtmKyspYltmXT1NYXRoLmZsb29yKDY0Kk1hdGgucmFuZG9tKCkpO2ZvcihmPTA7MTI+ZjtmKyspYys9XCItMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuY2hhckF0KGJbZl0pO08oMjA9PT1jLmxlbmd0aCxcIm5leHRQdXNoSWQ6IExlbmd0aCBzaG91bGQgYmUgMjAuXCIpO1xucmV0dXJuIGN9fSgpO2Z1bmN0aW9uIGpmKCl7ZmYuY2FsbCh0aGlzLFtcIm9ubGluZVwiXSk7dGhpcy5vYz0hMDtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7dmFyIGE9dGhpczt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLGZ1bmN0aW9uKCl7YS5vY3x8KGEub2M9ITAsYS5pZShcIm9ubGluZVwiLCEwKSl9LCExKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIixmdW5jdGlvbigpe2Eub2MmJihhLm9jPSExLGEuaWUoXCJvbmxpbmVcIiwhMSkpfSwhMSl9fWthKGpmLGZmKTtqZi5wcm90b3R5cGUuRWU9ZnVuY3Rpb24oYSl7TyhcIm9ubGluZVwiPT09YSxcIlVua25vd24gZXZlbnQgdHlwZTogXCIrYSk7cmV0dXJuW3RoaXMub2NdfTtiYShqZik7ZnVuY3Rpb24ga2YoKXtmZi5jYWxsKHRoaXMsW1widmlzaWJsZVwiXSk7dmFyIGEsYjtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXImJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LmhpZGRlbj8oYj1cInZpc2liaWxpdHljaGFuZ2VcIixhPVwiaGlkZGVuXCIpOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuPyhiPVwibW96dmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtb3pIaWRkZW5cIik6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbj8oYj1cIm1zdmlzaWJpbGl0eWNoYW5nZVwiLGE9XCJtc0hpZGRlblwiKTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiYmKGI9XCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCIsYT1cIndlYmtpdEhpZGRlblwiKSk7dGhpcy5TYj0hMDtpZihiKXt2YXIgYz10aGlzO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYixcbmZ1bmN0aW9uKCl7dmFyIGI9IWRvY3VtZW50W2FdO2IhPT1jLlNiJiYoYy5TYj1iLGMuaWUoXCJ2aXNpYmxlXCIsYikpfSwhMSl9fWthKGtmLGZmKTtrZi5wcm90b3R5cGUuRWU9ZnVuY3Rpb24oYSl7TyhcInZpc2libGVcIj09PWEsXCJVbmtub3duIGV2ZW50IHR5cGU6IFwiK2EpO3JldHVyblt0aGlzLlNiXX07YmEoa2YpO2Z1bmN0aW9uIFAoYSxiKXtpZigxPT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLnU9YS5zcGxpdChcIi9cIik7Zm9yKHZhciBjPTAsZD0wO2Q8dGhpcy51Lmxlbmd0aDtkKyspMDx0aGlzLnVbZF0ubGVuZ3RoJiYodGhpcy51W2NdPXRoaXMudVtkXSxjKyspO3RoaXMudS5sZW5ndGg9Yzt0aGlzLmFhPTB9ZWxzZSB0aGlzLnU9YSx0aGlzLmFhPWJ9ZnVuY3Rpb24gbGYoYSxiKXt2YXIgYz1LKGEpO2lmKG51bGw9PT1jKXJldHVybiBiO2lmKGM9PT1LKGIpKXJldHVybiBsZihOKGEpLE4oYikpO3Rocm93IEVycm9yKFwiSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoXCIrYitcIikgaXMgbm90IHdpdGhpbiBvdXRlclBhdGggKFwiK2ErXCIpXCIpO31cbmZ1bmN0aW9uIG1mKGEsYil7Zm9yKHZhciBjPWEuc2xpY2UoKSxkPWIuc2xpY2UoKSxlPTA7ZTxjLmxlbmd0aCYmZTxkLmxlbmd0aDtlKyspe3ZhciBmPXljKGNbZV0sZFtlXSk7aWYoMCE9PWYpcmV0dXJuIGZ9cmV0dXJuIGMubGVuZ3RoPT09ZC5sZW5ndGg/MDpjLmxlbmd0aDxkLmxlbmd0aD8tMToxfWZ1bmN0aW9uIEsoYSl7cmV0dXJuIGEuYWE+PWEudS5sZW5ndGg/bnVsbDphLnVbYS5hYV19ZnVuY3Rpb24gbGUoYSl7cmV0dXJuIGEudS5sZW5ndGgtYS5hYX1mdW5jdGlvbiBOKGEpe3ZhciBiPWEuYWE7YjxhLnUubGVuZ3RoJiZiKys7cmV0dXJuIG5ldyBQKGEudSxiKX1mdW5jdGlvbiBtZShhKXtyZXR1cm4gYS5hYTxhLnUubGVuZ3RoP2EudVthLnUubGVuZ3RoLTFdOm51bGx9aD1QLnByb3RvdHlwZTtcbmgudG9TdHJpbmc9ZnVuY3Rpb24oKXtmb3IodmFyIGE9XCJcIixiPXRoaXMuYWE7Yjx0aGlzLnUubGVuZ3RoO2IrKylcIlwiIT09dGhpcy51W2JdJiYoYSs9XCIvXCIrdGhpcy51W2JdKTtyZXR1cm4gYXx8XCIvXCJ9O2guc2xpY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudS5zbGljZSh0aGlzLmFhKyhhfHwwKSl9O2gucGFyZW50PWZ1bmN0aW9uKCl7aWYodGhpcy5hYT49dGhpcy51Lmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIGE9W10sYj10aGlzLmFhO2I8dGhpcy51Lmxlbmd0aC0xO2IrKylhLnB1c2godGhpcy51W2JdKTtyZXR1cm4gbmV3IFAoYSwwKX07XG5oLm89ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9dGhpcy5hYTtjPHRoaXMudS5sZW5ndGg7YysrKWIucHVzaCh0aGlzLnVbY10pO2lmKGEgaW5zdGFuY2VvZiBQKWZvcihjPWEuYWE7YzxhLnUubGVuZ3RoO2MrKyliLnB1c2goYS51W2NdKTtlbHNlIGZvcihhPWEuc3BsaXQoXCIvXCIpLGM9MDtjPGEubGVuZ3RoO2MrKykwPGFbY10ubGVuZ3RoJiZiLnB1c2goYVtjXSk7cmV0dXJuIG5ldyBQKGIsMCl9O2guZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFhPj10aGlzLnUubGVuZ3RofTtoLmVhPWZ1bmN0aW9uKGEpe2lmKGxlKHRoaXMpIT09bGUoYSkpcmV0dXJuITE7Zm9yKHZhciBiPXRoaXMuYWEsYz1hLmFhO2I8PXRoaXMudS5sZW5ndGg7YisrLGMrKylpZih0aGlzLnVbYl0hPT1hLnVbY10pcmV0dXJuITE7cmV0dXJuITB9O1xuaC5jb250YWlucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmFhLGM9YS5hYTtpZihsZSh0aGlzKT5sZShhKSlyZXR1cm4hMTtmb3IoO2I8dGhpcy51Lmxlbmd0aDspe2lmKHRoaXMudVtiXSE9PWEudVtjXSlyZXR1cm4hMTsrK2I7KytjfXJldHVybiEwfTt2YXIgTT1uZXcgUChcIlwiKTtmdW5jdGlvbiBuZihhLGIpe3RoaXMuVWE9YS5zbGljZSgpO3RoaXMuS2E9TWF0aC5tYXgoMSx0aGlzLlVhLmxlbmd0aCk7dGhpcy5wZj1iO2Zvcih2YXIgYz0wO2M8dGhpcy5VYS5sZW5ndGg7YysrKXRoaXMuS2ErPVBiKHRoaXMuVWFbY10pO29mKHRoaXMpfW5mLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEpezA8dGhpcy5VYS5sZW5ndGgmJih0aGlzLkthKz0xKTt0aGlzLlVhLnB1c2goYSk7dGhpcy5LYSs9UGIoYSk7b2YodGhpcyl9O25mLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLlVhLnBvcCgpO3RoaXMuS2EtPVBiKGEpOzA8dGhpcy5VYS5sZW5ndGgmJi0tdGhpcy5LYX07XG5mdW5jdGlvbiBvZihhKXtpZig3Njg8YS5LYSl0aHJvdyBFcnJvcihhLnBmK1wiaGFzIGEga2V5IHBhdGggbG9uZ2VyIHRoYW4gNzY4IGJ5dGVzIChcIithLkthK1wiKS5cIik7aWYoMzI8YS5VYS5sZW5ndGgpdGhyb3cgRXJyb3IoYS5wZitcInBhdGggc3BlY2lmaWVkIGV4Y2VlZHMgdGhlIG1heGltdW0gZGVwdGggdGhhdCBjYW4gYmUgd3JpdHRlbiAoMzIpIG9yIG9iamVjdCBjb250YWlucyBhIGN5Y2xlIFwiK3BmKGEpKTt9ZnVuY3Rpb24gcGYoYSl7cmV0dXJuIDA9PWEuVWEubGVuZ3RoP1wiXCI6XCJpbiBwcm9wZXJ0eSAnXCIrYS5VYS5qb2luKFwiLlwiKStcIidcIn07ZnVuY3Rpb24gcWYoYSxiKXt0aGlzLnZhbHVlPWE7dGhpcy5jaGlsZHJlbj1ifHxyZn12YXIgcmY9bmV3IEVjKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9PT1iPzA6YTxiPy0xOjF9KTtmdW5jdGlvbiBzZihhKXt2YXIgYj1xZTt2KGEsZnVuY3Rpb24oYSxkKXtiPWIuc2V0KG5ldyBQKGQpLGEpfSk7cmV0dXJuIGJ9aD1xZi5wcm90b3R5cGU7aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlJiZ0aGlzLmNoaWxkcmVuLmUoKX07ZnVuY3Rpb24gdGYoYSxiLGMpe2lmKG51bGwhPWEudmFsdWUmJmMoYS52YWx1ZSkpcmV0dXJue3BhdGg6TSx2YWx1ZTphLnZhbHVlfTtpZihiLmUoKSlyZXR1cm4gbnVsbDt2YXIgZD1LKGIpO2E9YS5jaGlsZHJlbi5nZXQoZCk7cmV0dXJuIG51bGwhPT1hPyhiPXRmKGEsTihiKSxjKSxudWxsIT1iP3twYXRoOihuZXcgUChkKSkubyhiLnBhdGgpLHZhbHVlOmIudmFsdWV9Om51bGwpOm51bGx9XG5mdW5jdGlvbiB1ZihhLGIpe3JldHVybiB0ZihhLGIsZnVuY3Rpb24oKXtyZXR1cm4hMH0pfWguc3VidHJlZT1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpczt2YXIgYj10aGlzLmNoaWxkcmVuLmdldChLKGEpKTtyZXR1cm4gbnVsbCE9PWI/Yi5zdWJ0cmVlKE4oYSkpOnFlfTtoLnNldD1mdW5jdGlvbihhLGIpe2lmKGEuZSgpKXJldHVybiBuZXcgcWYoYix0aGlzLmNoaWxkcmVuKTt2YXIgYz1LKGEpLGQ9KHRoaXMuY2hpbGRyZW4uZ2V0KGMpfHxxZSkuc2V0KE4oYSksYiksYz10aGlzLmNoaWxkcmVuLlNhKGMsZCk7cmV0dXJuIG5ldyBxZih0aGlzLnZhbHVlLGMpfTtcbmgucmVtb3ZlPWZ1bmN0aW9uKGEpe2lmKGEuZSgpKXJldHVybiB0aGlzLmNoaWxkcmVuLmUoKT9xZTpuZXcgcWYobnVsbCx0aGlzLmNoaWxkcmVuKTt2YXIgYj1LKGEpLGM9dGhpcy5jaGlsZHJlbi5nZXQoYik7cmV0dXJuIGM/KGE9Yy5yZW1vdmUoTihhKSksYj1hLmUoKT90aGlzLmNoaWxkcmVuLnJlbW92ZShiKTp0aGlzLmNoaWxkcmVuLlNhKGIsYSksbnVsbD09PXRoaXMudmFsdWUmJmIuZSgpP3FlOm5ldyBxZih0aGlzLnZhbHVlLGIpKTp0aGlzfTtoLmdldD1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gdGhpcy52YWx1ZTt2YXIgYj10aGlzLmNoaWxkcmVuLmdldChLKGEpKTtyZXR1cm4gYj9iLmdldChOKGEpKTpudWxsfTtcbmZ1bmN0aW9uIHBlKGEsYixjKXtpZihiLmUoKSlyZXR1cm4gYzt2YXIgZD1LKGIpO2I9cGUoYS5jaGlsZHJlbi5nZXQoZCl8fHFlLE4oYiksYyk7ZD1iLmUoKT9hLmNoaWxkcmVuLnJlbW92ZShkKTphLmNoaWxkcmVuLlNhKGQsYik7cmV0dXJuIG5ldyBxZihhLnZhbHVlLGQpfWZ1bmN0aW9uIHZmKGEsYil7cmV0dXJuIHdmKGEsTSxiKX1mdW5jdGlvbiB3ZihhLGIsYyl7dmFyIGQ9e307YS5jaGlsZHJlbi5rYShmdW5jdGlvbihhLGYpe2RbYV09d2YoZixiLm8oYSksYyl9KTtyZXR1cm4gYyhiLGEudmFsdWUsZCl9ZnVuY3Rpb24geGYoYSxiLGMpe3JldHVybiB5ZihhLGIsTSxjKX1mdW5jdGlvbiB5ZihhLGIsYyxkKXt2YXIgZT1hLnZhbHVlP2QoYyxhLnZhbHVlKTohMTtpZihlKXJldHVybiBlO2lmKGIuZSgpKXJldHVybiBudWxsO2U9SyhiKTtyZXR1cm4oYT1hLmNoaWxkcmVuLmdldChlKSk/eWYoYSxOKGIpLGMubyhlKSxkKTpudWxsfVxuZnVuY3Rpb24gemYoYSxiLGMpe0FmKGEsYixNLGMpfWZ1bmN0aW9uIEFmKGEsYixjLGQpe2lmKGIuZSgpKXJldHVybiBhO2EudmFsdWUmJmQoYyxhLnZhbHVlKTt2YXIgZT1LKGIpO3JldHVybihhPWEuY2hpbGRyZW4uZ2V0KGUpKT9BZihhLE4oYiksYy5vKGUpLGQpOnFlfWZ1bmN0aW9uIG5lKGEsYil7QmYoYSxNLGIpfWZ1bmN0aW9uIEJmKGEsYixjKXthLmNoaWxkcmVuLmthKGZ1bmN0aW9uKGEsZSl7QmYoZSxiLm8oYSksYyl9KTthLnZhbHVlJiZjKGIsYS52YWx1ZSl9ZnVuY3Rpb24gQ2YoYSxiKXthLmNoaWxkcmVuLmthKGZ1bmN0aW9uKGEsZCl7ZC52YWx1ZSYmYihhLGQudmFsdWUpfSl9dmFyIHFlPW5ldyBxZihudWxsKTtxZi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT17fTtuZSh0aGlzLGZ1bmN0aW9uKGIsYyl7YVtiLnRvU3RyaW5nKCldPWMudG9TdHJpbmcoKX0pO3JldHVybiBHKGEpfTtmdW5jdGlvbiBEZihhLGIsYyl7dGhpcy50eXBlPWVlO3RoaXMuc291cmNlPUVmO3RoaXMucGF0aD1hO3RoaXMuVWI9Yjt0aGlzLllkPWN9RGYucHJvdG90eXBlLiRjPWZ1bmN0aW9uKGEpe2lmKHRoaXMucGF0aC5lKCkpe2lmKG51bGwhPXRoaXMuVWIudmFsdWUpcmV0dXJuIE8odGhpcy5VYi5jaGlsZHJlbi5lKCksXCJhZmZlY3RlZFRyZWUgc2hvdWxkIG5vdCBoYXZlIG92ZXJsYXBwaW5nIGFmZmVjdGVkIHBhdGhzLlwiKSx0aGlzO2E9dGhpcy5VYi5zdWJ0cmVlKG5ldyBQKGEpKTtyZXR1cm4gbmV3IERmKE0sYSx0aGlzLllkKX1PKEsodGhpcy5wYXRoKT09PWEsXCJvcGVyYXRpb25Gb3JDaGlsZCBjYWxsZWQgZm9yIHVucmVsYXRlZCBjaGlsZC5cIik7cmV0dXJuIG5ldyBEZihOKHRoaXMucGF0aCksdGhpcy5VYix0aGlzLllkKX07XG5EZi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk9wZXJhdGlvbihcIit0aGlzLnBhdGgrXCI6IFwiK3RoaXMuc291cmNlLnRvU3RyaW5nKCkrXCIgYWNrIHdyaXRlIHJldmVydD1cIit0aGlzLllkK1wiIGFmZmVjdGVkVHJlZT1cIit0aGlzLlViK1wiKVwifTt2YXIgQmM9MCxiZT0xLGVlPTIsRGM9MztmdW5jdGlvbiBGZihhLGIsYyxkKXt0aGlzLkFlPWE7dGhpcy50Zj1iO3RoaXMuTGI9Yzt0aGlzLmVmPWQ7TyghZHx8YixcIlRhZ2dlZCBxdWVyaWVzIG11c3QgYmUgZnJvbSBzZXJ2ZXIuXCIpfXZhciBFZj1uZXcgRmYoITAsITEsbnVsbCwhMSksR2Y9bmV3IEZmKCExLCEwLG51bGwsITEpO0ZmLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLkFlP1widXNlclwiOnRoaXMuZWY/XCJzZXJ2ZXIocXVlcnlJRD1cIit0aGlzLkxiK1wiKVwiOlwic2VydmVyXCJ9O2Z1bmN0aW9uIEhmKGEpe3RoaXMuWj1hfXZhciBJZj1uZXcgSGYobmV3IHFmKG51bGwpKTtmdW5jdGlvbiBKZihhLGIsYyl7aWYoYi5lKCkpcmV0dXJuIG5ldyBIZihuZXcgcWYoYykpO3ZhciBkPXVmKGEuWixiKTtpZihudWxsIT1kKXt2YXIgZT1kLnBhdGgsZD1kLnZhbHVlO2I9bGYoZSxiKTtkPWQuSChiLGMpO3JldHVybiBuZXcgSGYoYS5aLnNldChlLGQpKX1hPXBlKGEuWixiLG5ldyBxZihjKSk7cmV0dXJuIG5ldyBIZihhKX1mdW5jdGlvbiBLZihhLGIsYyl7dmFyIGQ9YTtGYihjLGZ1bmN0aW9uKGEsYyl7ZD1KZihkLGIubyhhKSxjKX0pO3JldHVybiBkfUhmLnByb3RvdHlwZS5VZD1mdW5jdGlvbihhKXtpZihhLmUoKSlyZXR1cm4gSWY7YT1wZSh0aGlzLlosYSxxZSk7cmV0dXJuIG5ldyBIZihhKX07ZnVuY3Rpb24gTGYoYSxiKXt2YXIgYz11ZihhLlosYik7cmV0dXJuIG51bGwhPWM/YS5aLmdldChjLnBhdGgpLlMobGYoYy5wYXRoLGIpKTpudWxsfVxuZnVuY3Rpb24gTWYoYSl7dmFyIGI9W10sYz1hLloudmFsdWU7bnVsbCE9Yz9jLkwoKXx8Yy5SKFIsZnVuY3Rpb24oYSxjKXtiLnB1c2gobmV3IEwoYSxjKSl9KTphLlouY2hpbGRyZW4ua2EoZnVuY3Rpb24oYSxjKXtudWxsIT1jLnZhbHVlJiZiLnB1c2gobmV3IEwoYSxjLnZhbHVlKSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBOZihhLGIpe2lmKGIuZSgpKXJldHVybiBhO3ZhciBjPUxmKGEsYik7cmV0dXJuIG51bGwhPWM/bmV3IEhmKG5ldyBxZihjKSk6bmV3IEhmKGEuWi5zdWJ0cmVlKGIpKX1IZi5wcm90b3R5cGUuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLlouZSgpfTtIZi5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oYSl7cmV0dXJuIE9mKE0sdGhpcy5aLGEpfTtcbmZ1bmN0aW9uIE9mKGEsYixjKXtpZihudWxsIT1iLnZhbHVlKXJldHVybiBjLkgoYSxiLnZhbHVlKTt2YXIgZD1udWxsO2IuY2hpbGRyZW4ua2EoZnVuY3Rpb24oYixmKXtcIi5wcmlvcml0eVwiPT09Yj8oTyhudWxsIT09Zi52YWx1ZSxcIlByaW9yaXR5IHdyaXRlcyBtdXN0IGFsd2F5cyBiZSBsZWFmIG5vZGVzXCIpLGQ9Zi52YWx1ZSk6Yz1PZihhLm8oYiksZixjKX0pO2MuUyhhKS5lKCl8fG51bGw9PT1kfHwoYz1jLkgoYS5vKFwiLnByaW9yaXR5XCIpLGQpKTtyZXR1cm4gY307ZnVuY3Rpb24gUGYoKXt0aGlzLlY9SWY7dGhpcy5wYT1bXTt0aGlzLlBjPS0xfWZ1bmN0aW9uIFFmKGEsYil7Zm9yKHZhciBjPTA7YzxhLnBhLmxlbmd0aDtjKyspe3ZhciBkPWEucGFbY107aWYoZC5tZD09PWIpcmV0dXJuIGR9cmV0dXJuIG51bGx9aD1QZi5wcm90b3R5cGU7XG5oLlVkPWZ1bmN0aW9uKGEpe3ZhciBiPVNhKHRoaXMucGEsZnVuY3Rpb24oYil7cmV0dXJuIGIubWQ9PT1hfSk7TygwPD1iLFwicmVtb3ZlV3JpdGUgY2FsbGVkIHdpdGggbm9uZXhpc3RlbnQgd3JpdGVJZC5cIik7dmFyIGM9dGhpcy5wYVtiXTt0aGlzLnBhLnNwbGljZShiLDEpO2Zvcih2YXIgZD1jLnZpc2libGUsZT0hMSxmPXRoaXMucGEubGVuZ3RoLTE7ZCYmMDw9Zjspe3ZhciBnPXRoaXMucGFbZl07Zy52aXNpYmxlJiYoZj49YiYmUmYoZyxjLnBhdGgpP2Q9ITE6Yy5wYXRoLmNvbnRhaW5zKGcucGF0aCkmJihlPSEwKSk7Zi0tfWlmKGQpe2lmKGUpdGhpcy5WPVNmKHRoaXMucGEsVGYsTSksdGhpcy5QYz0wPHRoaXMucGEubGVuZ3RoP3RoaXMucGFbdGhpcy5wYS5sZW5ndGgtMV0ubWQ6LTE7ZWxzZSBpZihjLkphKXRoaXMuVj10aGlzLlYuVWQoYy5wYXRoKTtlbHNle3ZhciBrPXRoaXM7dihjLmNoaWxkcmVuLGZ1bmN0aW9uKGEsYil7ay5WPWsuVi5VZChjLnBhdGgubyhiKSl9KX1yZXR1cm4hMH1yZXR1cm4hMX07XG5oLkFhPWZ1bmN0aW9uKGEsYixjLGQpe2lmKGN8fGQpe3ZhciBlPU5mKHRoaXMuVixhKTtyZXR1cm4hZCYmZS5lKCk/YjpkfHxudWxsIT1ifHxudWxsIT1MZihlLE0pPyhlPVNmKHRoaXMucGEsZnVuY3Rpb24oYil7cmV0dXJuKGIudmlzaWJsZXx8ZCkmJighY3x8ISgwPD1MYShjLGIubWQpKSkmJihiLnBhdGguY29udGFpbnMoYSl8fGEuY29udGFpbnMoYi5wYXRoKSl9LGEpLGI9Ynx8SCxlLmFwcGx5KGIpKTpudWxsfWU9TGYodGhpcy5WLGEpO2lmKG51bGwhPWUpcmV0dXJuIGU7ZT1OZih0aGlzLlYsYSk7cmV0dXJuIGUuZSgpP2I6bnVsbCE9Ynx8bnVsbCE9TGYoZSxNKT8oYj1ifHxILGUuYXBwbHkoYikpOm51bGx9O1xuaC5DYz1mdW5jdGlvbihhLGIpe3ZhciBjPUgsZD1MZih0aGlzLlYsYSk7aWYoZClkLkwoKXx8ZC5SKFIsZnVuY3Rpb24oYSxiKXtjPWMuVyhhLGIpfSk7ZWxzZSBpZihiKXt2YXIgZT1OZih0aGlzLlYsYSk7Yi5SKFIsZnVuY3Rpb24oYSxiKXt2YXIgZD1OZihlLG5ldyBQKGEpKS5hcHBseShiKTtjPWMuVyhhLGQpfSk7TWEoTWYoZSksZnVuY3Rpb24oYSl7Yz1jLlcoYS5uYW1lLGEuVSl9KX1lbHNlIGU9TmYodGhpcy5WLGEpLE1hKE1mKGUpLGZ1bmN0aW9uKGEpe2M9Yy5XKGEubmFtZSxhLlUpfSk7cmV0dXJuIGN9O2gubmQ9ZnVuY3Rpb24oYSxiLGMsZCl7TyhjfHxkLFwiRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0XCIpO2E9YS5vKGIpO2lmKG51bGwhPUxmKHRoaXMuVixhKSlyZXR1cm4gbnVsbDthPU5mKHRoaXMuVixhKTtyZXR1cm4gYS5lKCk/ZC5TKGIpOmEuYXBwbHkoZC5TKGIpKX07XG5oLkJjPWZ1bmN0aW9uKGEsYixjKXthPWEubyhiKTt2YXIgZD1MZih0aGlzLlYsYSk7cmV0dXJuIG51bGwhPWQ/ZDpXYihjLGIpP05mKHRoaXMuVixhKS5hcHBseShjLmooKS5UKGIpKTpudWxsfTtoLnhjPWZ1bmN0aW9uKGEpe3JldHVybiBMZih0aGlzLlYsYSl9O2gucWU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnO2E9TmYodGhpcy5WLGEpO2c9TGYoYSxNKTtpZihudWxsPT1nKWlmKG51bGwhPWIpZz1hLmFwcGx5KGIpO2Vsc2UgcmV0dXJuW107Zz1nLnBiKGYpO2lmKGcuZSgpfHxnLkwoKSlyZXR1cm5bXTtiPVtdO2E9VmQoZik7ZT1lP2cuZGMoYyxmKTpnLmJjKGMsZik7Zm9yKGY9SWMoZSk7ZiYmYi5sZW5ndGg8ZDspMCE9PWEoZixjKSYmYi5wdXNoKGYpLGY9SWMoZSk7cmV0dXJuIGJ9O1xuZnVuY3Rpb24gUmYoYSxiKXtyZXR1cm4gYS5KYT9hLnBhdGguY29udGFpbnMoYik6ISF0YShhLmNoaWxkcmVuLGZ1bmN0aW9uKGMsZCl7cmV0dXJuIGEucGF0aC5vKGQpLmNvbnRhaW5zKGIpfSl9ZnVuY3Rpb24gVGYoYSl7cmV0dXJuIGEudmlzaWJsZX1cbmZ1bmN0aW9uIFNmKGEsYixjKXtmb3IodmFyIGQ9SWYsZT0wO2U8YS5sZW5ndGg7KytlKXt2YXIgZj1hW2VdO2lmKGIoZikpe3ZhciBnPWYucGF0aDtpZihmLkphKWMuY29udGFpbnMoZyk/KGc9bGYoYyxnKSxkPUpmKGQsZyxmLkphKSk6Zy5jb250YWlucyhjKSYmKGc9bGYoZyxjKSxkPUpmKGQsTSxmLkphLlMoZykpKTtlbHNlIGlmKGYuY2hpbGRyZW4paWYoYy5jb250YWlucyhnKSlnPWxmKGMsZyksZD1LZihkLGcsZi5jaGlsZHJlbik7ZWxzZXtpZihnLmNvbnRhaW5zKGMpKWlmKGc9bGYoZyxjKSxnLmUoKSlkPUtmKGQsTSxmLmNoaWxkcmVuKTtlbHNlIGlmKGY9eihmLmNoaWxkcmVuLEsoZykpKWY9Zi5TKE4oZykpLGQ9SmYoZCxNLGYpfWVsc2UgdGhyb3cgamQoXCJXcml0ZVJlY29yZCBzaG91bGQgaGF2ZSAuc25hcCBvciAuY2hpbGRyZW5cIik7fX1yZXR1cm4gZH1mdW5jdGlvbiBVZihhLGIpe3RoaXMuUWI9YTt0aGlzLlo9Yn1oPVVmLnByb3RvdHlwZTtcbmguQWE9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLlouQWEodGhpcy5RYixhLGIsYyl9O2guQ2M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWi5DYyh0aGlzLlFiLGEpfTtoLm5kPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5aLm5kKHRoaXMuUWIsYSxiLGMpfTtoLnhjPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLloueGModGhpcy5RYi5vKGEpKX07aC5xZT1mdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiB0aGlzLloucWUodGhpcy5RYixhLGIsYyxkLGUpfTtoLkJjPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuWi5CYyh0aGlzLlFiLGEsYil9O2gubz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFVmKHRoaXMuUWIubyhhKSx0aGlzLlopfTtmdW5jdGlvbiBWZigpe3RoaXMuY2hpbGRyZW49e307dGhpcy5wZD0wO3RoaXMudmFsdWU9bnVsbH1mdW5jdGlvbiBXZihhLGIsYyl7dGhpcy5KZD1hP2E6XCJcIjt0aGlzLkhhPWI/YjpudWxsO3RoaXMuQT1jP2M6bmV3IFZmfWZ1bmN0aW9uIFhmKGEsYil7Zm9yKHZhciBjPWIgaW5zdGFuY2VvZiBQP2I6bmV3IFAoYiksZD1hLGU7bnVsbCE9PShlPUsoYykpOylkPW5ldyBXZihlLGQseihkLkEuY2hpbGRyZW4sZSl8fG5ldyBWZiksYz1OKGMpO3JldHVybiBkfWg9V2YucHJvdG90eXBlO2guRWE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5BLnZhbHVlfTtmdW5jdGlvbiBZZihhLGIpe08oXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiLFwiQ2Fubm90IHNldCB2YWx1ZSB0byB1bmRlZmluZWRcIik7YS5BLnZhbHVlPWI7WmYoYSl9aC5jbGVhcj1mdW5jdGlvbigpe3RoaXMuQS52YWx1ZT1udWxsO3RoaXMuQS5jaGlsZHJlbj17fTt0aGlzLkEucGQ9MDtaZih0aGlzKX07XG5oLnpkPWZ1bmN0aW9uKCl7cmV0dXJuIDA8dGhpcy5BLnBkfTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuRWEoKSYmIXRoaXMuemQoKX07aC5SPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dih0aGlzLkEuY2hpbGRyZW4sZnVuY3Rpb24oYyxkKXthKG5ldyBXZihkLGIsYykpfSl9O2Z1bmN0aW9uICRmKGEsYixjLGQpe2MmJiFkJiZiKGEpO2EuUihmdW5jdGlvbihhKXskZihhLGIsITAsZCl9KTtjJiZkJiZiKGEpfWZ1bmN0aW9uIGFnKGEsYil7Zm9yKHZhciBjPWEucGFyZW50KCk7bnVsbCE9PWMmJiFiKGMpOyljPWMucGFyZW50KCl9aC5wYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBQKG51bGw9PT10aGlzLkhhP3RoaXMuSmQ6dGhpcy5IYS5wYXRoKCkrXCIvXCIrdGhpcy5KZCl9O2gubmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLkpkfTtoLnBhcmVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLkhhfTtcbmZ1bmN0aW9uIFpmKGEpe2lmKG51bGwhPT1hLkhhKXt2YXIgYj1hLkhhLGM9YS5KZCxkPWEuZSgpLGU9eShiLkEuY2hpbGRyZW4sYyk7ZCYmZT8oZGVsZXRlIGIuQS5jaGlsZHJlbltjXSxiLkEucGQtLSxaZihiKSk6ZHx8ZXx8KGIuQS5jaGlsZHJlbltjXT1hLkEsYi5BLnBkKyssWmYoYikpfX07dmFyIGJnPS9bXFxbXFxdLiMkXFwvXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vLGNnPS9bXFxbXFxdLiMkXFx1MDAwMC1cXHUwMDFGXFx1MDA3Rl0vLGRnPS9eW2EtekEtWl1bYS16QS1aLl9cXC0rXSskLztmdW5jdGlvbiBlZyhhKXtyZXR1cm4gcShhKSYmMCE9PWEubGVuZ3RoJiYhYmcudGVzdChhKX1mdW5jdGlvbiBmZyhhKXtyZXR1cm4gbnVsbD09PWF8fHEoYSl8fGZhKGEpJiYhdGQoYSl8fGdhKGEpJiZ5KGEsXCIuc3ZcIil9ZnVuY3Rpb24gZ2coYSxiLGMsZCl7ZCYmIXAoYil8fGhnKEUoYSwxLGQpLGIsYyl9XG5mdW5jdGlvbiBoZyhhLGIsYyl7YyBpbnN0YW5jZW9mIFAmJihjPW5ldyBuZihjLGEpKTtpZighcChiKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgdW5kZWZpbmVkIFwiK3BmKGMpKTtpZihyKGIpKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIGZ1bmN0aW9uIFwiK3BmKGMpK1wiIHdpdGggY29udGVudHM6IFwiK2IudG9TdHJpbmcoKSk7aWYodGQoYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIFwiK2IudG9TdHJpbmcoKStcIiBcIitwZihjKSk7aWYocShiKSYmYi5sZW5ndGg+MTA0ODU3NjAvMyYmMTA0ODU3NjA8UGIoYikpdGhyb3cgRXJyb3IoYStcImNvbnRhaW5zIGEgc3RyaW5nIGdyZWF0ZXIgdGhhbiAxMDQ4NTc2MCB1dGY4IGJ5dGVzIFwiK3BmKGMpK1wiICgnXCIrYi5zdWJzdHJpbmcoMCw1MCkrXCIuLi4nKVwiKTtpZihnYShiKSl7dmFyIGQ9ITEsZT0hMTtGYihiLGZ1bmN0aW9uKGIsZyl7aWYoXCIudmFsdWVcIj09PWIpZD0hMDtlbHNlIGlmKFwiLnByaW9yaXR5XCIhPT1iJiZcIi5zdlwiIT09YiYmKGU9XG4hMCwhZWcoYikpKXRocm93IEVycm9yKGErXCIgY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKFwiK2IrXCIpIFwiK3BmKGMpKycuICBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7Yy5wdXNoKGIpO2hnKGEsZyxjKTtjLnBvcCgpfSk7aWYoZCYmZSl0aHJvdyBFcnJvcihhKycgY29udGFpbnMgXCIudmFsdWVcIiBjaGlsZCAnK3BmKGMpK1wiIGluIGFkZGl0aW9uIHRvIGFjdHVhbCBjaGlsZHJlbi5cIik7fX1cbmZ1bmN0aW9uIGlnKGEsYil7dmFyIGMsZDtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKXtkPWJbY107Zm9yKHZhciBlPWQuc2xpY2UoKSxmPTA7ZjxlLmxlbmd0aDtmKyspaWYoKFwiLnByaW9yaXR5XCIhPT1lW2ZdfHxmIT09ZS5sZW5ndGgtMSkmJiFlZyhlW2ZdKSl0aHJvdyBFcnJvcihhK1wiY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKFwiK2VbZl0rXCIpIGluIHBhdGggXCIrZC50b1N0cmluZygpKycuIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCInKTt9Yi5zb3J0KG1mKTtlPW51bGw7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKyl7ZD1iW2NdO2lmKG51bGwhPT1lJiZlLmNvbnRhaW5zKGQpKXRocm93IEVycm9yKGErXCJjb250YWlucyBhIHBhdGggXCIrZS50b1N0cmluZygpK1wiIHRoYXQgaXMgYW5jZXN0b3Igb2YgYW5vdGhlciBwYXRoIFwiK2QudG9TdHJpbmcoKSk7ZT1kfX1cbmZ1bmN0aW9uIGpnKGEsYixjKXt2YXIgZD1FKGEsMSwhMSk7aWYoIWdhKGIpfHxkYShiKSl0aHJvdyBFcnJvcihkK1wiIG11c3QgYmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuIHRvIHJlcGxhY2UuXCIpO3ZhciBlPVtdO0ZiKGIsZnVuY3Rpb24oYSxiKXt2YXIgaz1uZXcgUChhKTtoZyhkLGIsYy5vKGspKTtpZihcIi5wcmlvcml0eVwiPT09bWUoaykmJiFmZyhiKSl0aHJvdyBFcnJvcihkK1wiY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgJ1wiK2sudG9TdHJpbmcoKStcIicsIHdoaWNoIG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO2UucHVzaChrKX0pO2lnKGQsZSl9XG5mdW5jdGlvbiBrZyhhLGIsYyl7aWYodGQoYykpdGhyb3cgRXJyb3IoRShhLGIsITEpK1wiaXMgXCIrYy50b1N0cmluZygpK1wiLCBidXQgbXVzdCBiZSBhIHZhbGlkIEZpcmViYXNlIHByaW9yaXR5IChhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS5cIik7aWYoIWZnKGMpKXRocm93IEVycm9yKEUoYSxiLCExKStcIm11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuXCIpO31cbmZ1bmN0aW9uIGxnKGEsYixjKXtpZighY3x8cChiKSlzd2l0Y2goYil7Y2FzZSBcInZhbHVlXCI6Y2FzZSBcImNoaWxkX2FkZGVkXCI6Y2FzZSBcImNoaWxkX3JlbW92ZWRcIjpjYXNlIFwiY2hpbGRfY2hhbmdlZFwiOmNhc2UgXCJjaGlsZF9tb3ZlZFwiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoRShhLDEsYykrJ211c3QgYmUgYSB2YWxpZCBldmVudCB0eXBlOiBcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsIFwiY2hpbGRfY2hhbmdlZFwiLCBvciBcImNoaWxkX21vdmVkXCIuJyk7fX1mdW5jdGlvbiBtZyhhLGIpe2lmKHAoYikmJiFlZyhiKSl0aHJvdyBFcnJvcihFKGEsMiwhMCkrJ3dhcyBhbiBpbnZhbGlkIGtleTogXCInK2IrJ1wiLiAgRmlyZWJhc2Uga2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCIvXCIsIFwiW1wiLCBvciBcIl1cIikuJyk7fVxuZnVuY3Rpb24gbmcoYSxiKXtpZighcShiKXx8MD09PWIubGVuZ3RofHxjZy50ZXN0KGIpKXRocm93IEVycm9yKEUoYSwxLCExKSsnd2FzIGFuIGludmFsaWQgcGF0aDogXCInK2IrJ1wiLiBQYXRocyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzIGFuZCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiJyk7fWZ1bmN0aW9uIG9nKGEsYil7aWYoXCIuaW5mb1wiPT09SyhiKSl0aHJvdyBFcnJvcihhK1wiIGZhaWxlZDogQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTt9ZnVuY3Rpb24gcGcoYSxiKXtpZighcShiKSl0aHJvdyBFcnJvcihFKGEsMSwhMSkrXCJtdXN0IGJlIGEgdmFsaWQgY3JlZGVudGlhbCAoYSBzdHJpbmcpLlwiKTt9ZnVuY3Rpb24gcWcoYSxiLGMpe2lmKCFxKGMpKXRocm93IEVycm9yKEUoYSxiLCExKStcIm11c3QgYmUgYSB2YWxpZCBzdHJpbmcuXCIpO31cbmZ1bmN0aW9uIHJnKGEsYil7cWcoYSwxLGIpO2lmKCFkZy50ZXN0KGIpKXRocm93IEVycm9yKEUoYSwxLCExKStcIidcIitiK1wiJyBpcyBub3QgYSB2YWxpZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlci5cIik7fWZ1bmN0aW9uIHNnKGEsYixjLGQpe2lmKCFkfHxwKGMpKWlmKCFnYShjKXx8bnVsbD09PWMpdGhyb3cgRXJyb3IoRShhLGIsZCkrXCJtdXN0IGJlIGEgdmFsaWQgb2JqZWN0LlwiKTt9ZnVuY3Rpb24gdGcoYSxiLGMpe2lmKCFnYShiKXx8IXkoYixjKSl0aHJvdyBFcnJvcihFKGEsMSwhMSkrJ211c3QgY29udGFpbiB0aGUga2V5IFwiJytjKydcIicpO2lmKCFxKHooYixjKSkpdGhyb3cgRXJyb3IoRShhLDEsITEpKydtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicrYysnXCIgd2l0aCB0eXBlIFwic3RyaW5nXCInKTt9O2Z1bmN0aW9uIHVnKCl7dGhpcy5zZXQ9e319aD11Zy5wcm90b3R5cGU7aC5hZGQ9ZnVuY3Rpb24oYSxiKXt0aGlzLnNldFthXT1udWxsIT09Yj9iOiEwfTtoLmNvbnRhaW5zPWZ1bmN0aW9uKGEpe3JldHVybiB5KHRoaXMuc2V0LGEpfTtoLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jb250YWlucyhhKT90aGlzLnNldFthXTp2b2lkIDB9O2gucmVtb3ZlPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLnNldFthXX07aC5jbGVhcj1mdW5jdGlvbigpe3RoaXMuc2V0PXt9fTtoLmU9ZnVuY3Rpb24oKXtyZXR1cm4gdmEodGhpcy5zZXQpfTtoLmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIG9hKHRoaXMuc2V0KX07ZnVuY3Rpb24gdmcoYSxiKXt2KGEuc2V0LGZ1bmN0aW9uKGEsZCl7YihkLGEpfSl9aC5rZXlzPWZ1bmN0aW9uKCl7dmFyIGE9W107dih0aGlzLnNldCxmdW5jdGlvbihiLGMpe2EucHVzaChjKX0pO3JldHVybiBhfTtmdW5jdGlvbiBWYygpe3RoaXMubT10aGlzLkI9bnVsbH1WYy5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihhKXtpZihudWxsIT10aGlzLkIpcmV0dXJuIHRoaXMuQi5TKGEpO2lmKGEuZSgpfHxudWxsPT10aGlzLm0pcmV0dXJuIG51bGw7dmFyIGI9SyhhKTthPU4oYSk7cmV0dXJuIHRoaXMubS5jb250YWlucyhiKT90aGlzLm0uZ2V0KGIpLmZpbmQoYSk6bnVsbH07VmMucHJvdG90eXBlLnJjPWZ1bmN0aW9uKGEsYil7aWYoYS5lKCkpdGhpcy5CPWIsdGhpcy5tPW51bGw7ZWxzZSBpZihudWxsIT09dGhpcy5CKXRoaXMuQj10aGlzLkIuSChhLGIpO2Vsc2V7bnVsbD09dGhpcy5tJiYodGhpcy5tPW5ldyB1Zyk7dmFyIGM9SyhhKTt0aGlzLm0uY29udGFpbnMoYyl8fHRoaXMubS5hZGQoYyxuZXcgVmMpO2M9dGhpcy5tLmdldChjKTthPU4oYSk7Yy5yYyhhLGIpfX07XG5mdW5jdGlvbiB3ZyhhLGIpe2lmKGIuZSgpKXJldHVybiBhLkI9bnVsbCxhLm09bnVsbCwhMDtpZihudWxsIT09YS5CKXtpZihhLkIuTCgpKXJldHVybiExO3ZhciBjPWEuQjthLkI9bnVsbDtjLlIoUixmdW5jdGlvbihiLGMpe2EucmMobmV3IFAoYiksYyl9KTtyZXR1cm4gd2coYSxiKX1yZXR1cm4gbnVsbCE9PWEubT8oYz1LKGIpLGI9TihiKSxhLm0uY29udGFpbnMoYykmJndnKGEubS5nZXQoYyksYikmJmEubS5yZW1vdmUoYyksYS5tLmUoKT8oYS5tPW51bGwsITApOiExKTohMH1mdW5jdGlvbiBXYyhhLGIsYyl7bnVsbCE9PWEuQj9jKGIsYS5CKTphLlIoZnVuY3Rpb24oYSxlKXt2YXIgZj1uZXcgUChiLnRvU3RyaW5nKCkrXCIvXCIrYSk7V2MoZSxmLGMpfSl9VmMucHJvdG90eXBlLlI9ZnVuY3Rpb24oYSl7bnVsbCE9PXRoaXMubSYmdmcodGhpcy5tLGZ1bmN0aW9uKGIsYyl7YShiLGMpfSl9O3ZhciB4Zz1cImF1dGguZmlyZWJhc2UuY29tXCI7ZnVuY3Rpb24geWcoYSxiLGMpe3RoaXMucWQ9YXx8e307dGhpcy5oZT1ifHx7fTt0aGlzLmZiPWN8fHt9O3RoaXMucWQucmVtZW1iZXJ8fCh0aGlzLnFkLnJlbWVtYmVyPVwiZGVmYXVsdFwiKX12YXIgemc9W1wicmVtZW1iZXJcIixcInJlZGlyZWN0VG9cIl07ZnVuY3Rpb24gQWcoYSl7dmFyIGI9e30sYz17fTtGYihhfHx7fSxmdW5jdGlvbihhLGUpezA8PUxhKHpnLGEpP2JbYV09ZTpjW2FdPWV9KTtyZXR1cm4gbmV3IHlnKGIse30sYyl9O2Z1bmN0aW9uIEJnKGEsYil7dGhpcy5VZT1bXCJzZXNzaW9uXCIsYS5SZCxhLmxjXS5qb2luKFwiOlwiKTt0aGlzLmVlPWJ9QmcucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe2lmKCFiKWlmKHRoaXMuZWUubGVuZ3RoKWI9dGhpcy5lZVswXTtlbHNlIHRocm93IEVycm9yKFwiZmIubG9naW4uU2Vzc2lvbk1hbmFnZXIgOiBObyBzdG9yYWdlIG9wdGlvbnMgYXZhaWxhYmxlIVwiKTtiLnNldCh0aGlzLlVlLGEpfTtCZy5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7dmFyIGE9T2EodGhpcy5lZSx1KHRoaXMuQmcsdGhpcykpLGE9TmEoYSxmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9PWF9KTtWYShhLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIERkKGMudG9rZW4pLURkKGEudG9rZW4pfSk7cmV0dXJuIDA8YS5sZW5ndGg/YS5zaGlmdCgpOm51bGx9O0JnLnByb3RvdHlwZS5CZz1mdW5jdGlvbihhKXt0cnl7dmFyIGI9YS5nZXQodGhpcy5VZSk7aWYoYiYmYi50b2tlbilyZXR1cm4gYn1jYXRjaChjKXt9cmV0dXJuIG51bGx9O1xuQmcucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztNYSh0aGlzLmVlLGZ1bmN0aW9uKGIpe2IucmVtb3ZlKGEuVWUpfSl9O2Z1bmN0aW9uIENnKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuYXZpZ2F0b3ImJlwic3RyaW5nXCI9PT10eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudD9uYXZpZ2F0b3IudXNlckFnZW50OlwiXCJ9ZnVuY3Rpb24gRGcoKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmISEod2luZG93LmNvcmRvdmF8fHdpbmRvdy5waG9uZWdhcHx8d2luZG93LlBob25lR2FwKSYmL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoQ2coKSl9ZnVuY3Rpb24gRWcoKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGxvY2F0aW9uJiYvXmZpbGU6XFwvLy50ZXN0KGxvY2F0aW9uLmhyZWYpfVxuZnVuY3Rpb24gRmcoYSl7dmFyIGI9Q2coKTtpZihcIlwiPT09YilyZXR1cm4hMTtpZihcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiPT09bmF2aWdhdG9yLmFwcE5hbWUpe2lmKChiPWIubWF0Y2goL01TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSkvKSkmJjE8Yi5sZW5ndGgpcmV0dXJuIHBhcnNlRmxvYXQoYlsxXSk+PWF9ZWxzZSBpZigtMTxiLmluZGV4T2YoXCJUcmlkZW50XCIpJiYoYj1iLm1hdGNoKC9ydjooWzAtOV17MiwyfVtcXC4wLTldezAsfSkvKSkmJjE8Yi5sZW5ndGgpcmV0dXJuIHBhcnNlRmxvYXQoYlsxXSk+PWE7cmV0dXJuITF9O2Z1bmN0aW9uIEdnKCl7dmFyIGE9d2luZG93Lm9wZW5lci5mcmFtZXMsYjtmb3IoYj1hLmxlbmd0aC0xOzA8PWI7Yi0tKXRyeXtpZihhW2JdLmxvY2F0aW9uLnByb3RvY29sPT09d2luZG93LmxvY2F0aW9uLnByb3RvY29sJiZhW2JdLmxvY2F0aW9uLmhvc3Q9PT13aW5kb3cubG9jYXRpb24uaG9zdCYmXCJfX3dpbmNoYW5fcmVsYXlfZnJhbWVcIj09PWFbYl0ubmFtZSlyZXR1cm4gYVtiXX1jYXRjaChjKXt9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSGcoYSxiLGMpe2EuYXR0YWNoRXZlbnQ/YS5hdHRhY2hFdmVudChcIm9uXCIrYixjKTphLmFkZEV2ZW50TGlzdGVuZXImJmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITEpfWZ1bmN0aW9uIElnKGEsYixjKXthLmRldGFjaEV2ZW50P2EuZGV0YWNoRXZlbnQoXCJvblwiK2IsYyk6YS5yZW1vdmVFdmVudExpc3RlbmVyJiZhLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKX1cbmZ1bmN0aW9uIEpnKGEpey9eaHR0cHM/OlxcL1xcLy8udGVzdChhKXx8KGE9d2luZG93LmxvY2F0aW9uLmhyZWYpO3ZhciBiPS9eKGh0dHBzPzpcXC9cXC9bXFwtX2EtekEtWlxcLjAtOTpdKykvLmV4ZWMoYSk7cmV0dXJuIGI/YlsxXTphfWZ1bmN0aW9uIEtnKGEpe3ZhciBiPVwiXCI7dHJ5e2E9YS5yZXBsYWNlKC8uKlxcPy8sXCJcIik7dmFyIGM9SmIoYSk7YyYmeShjLFwiX19maXJlYmFzZV9yZXF1ZXN0X2tleVwiKSYmKGI9eihjLFwiX19maXJlYmFzZV9yZXF1ZXN0X2tleVwiKSl9Y2F0Y2goZCl7fXJldHVybiBifWZ1bmN0aW9uIExnKCl7dHJ5e3ZhciBhPWRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgvJl9fZmlyZWJhc2VfcmVxdWVzdF9rZXk9KFthLXpBLXowLTldKikvLFwiXCIpLGE9YS5yZXBsYWNlKC9cXD8kLyxcIlwiKSxhPWEucmVwbGFjZSgvXiMrJC8sXCJcIik7ZG9jdW1lbnQubG9jYXRpb24uaGFzaD1hfWNhdGNoKGIpe319XG5mdW5jdGlvbiBNZygpe3ZhciBhPXNkKHhnKTtyZXR1cm4gYS5zY2hlbWUrXCI6Ly9cIithLmhvc3QrXCIvdjJcIn1mdW5jdGlvbiBOZyhhKXtyZXR1cm4gTWcoKStcIi9cIithK1wiL2F1dGgvY2hhbm5lbFwifTtmdW5jdGlvbiBPZyhhKXt2YXIgYj10aGlzO3RoaXMuaGI9YTt0aGlzLmZlPVwiKlwiO0ZnKDgpP3RoaXMuVWM9dGhpcy5DZD1HZygpOih0aGlzLlVjPXdpbmRvdy5vcGVuZXIsdGhpcy5DZD13aW5kb3cpO2lmKCFiLlVjKXRocm93XCJVbmFibGUgdG8gZmluZCByZWxheSBmcmFtZVwiO0hnKHRoaXMuQ2QsXCJtZXNzYWdlXCIsdSh0aGlzLm5jLHRoaXMpKTtIZyh0aGlzLkNkLFwibWVzc2FnZVwiLHUodGhpcy5GZix0aGlzKSk7dHJ5e1BnKHRoaXMse2E6XCJyZWFkeVwifSl9Y2F0Y2goYyl7SGcodGhpcy5VYyxcImxvYWRcIixmdW5jdGlvbigpe1BnKGIse2E6XCJyZWFkeVwifSl9KX1IZyh3aW5kb3csXCJ1bmxvYWRcIix1KHRoaXMuTWcsdGhpcykpfWZ1bmN0aW9uIFBnKGEsYil7Yj1HKGIpO0ZnKDgpP2EuVWMuZG9Qb3N0KGIsYS5mZSk6YS5VYy5wb3N0TWVzc2FnZShiLGEuZmUpfVxuT2cucHJvdG90eXBlLm5jPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYzt0cnl7Yz1SYihhLmRhdGEpfWNhdGNoKGQpe31jJiZcInJlcXVlc3RcIj09PWMuYSYmKElnKHdpbmRvdyxcIm1lc3NhZ2VcIix0aGlzLm5jKSx0aGlzLmZlPWEub3JpZ2luLHRoaXMuaGImJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLmhiKGIuZmUsYy5kLGZ1bmN0aW9uKGEsYyl7Yi5tZz0hYztiLmhiPXZvaWQgMDtQZyhiLHthOlwicmVzcG9uc2VcIixkOmEsZm9yY2VLZWVwV2luZG93T3BlbjpjfSl9KX0sMCkpfTtPZy5wcm90b3R5cGUuTWc9ZnVuY3Rpb24oKXt0cnl7SWcodGhpcy5DZCxcIm1lc3NhZ2VcIix0aGlzLkZmKX1jYXRjaChhKXt9dGhpcy5oYiYmKFBnKHRoaXMse2E6XCJlcnJvclwiLGQ6XCJ1bmtub3duIGNsb3NlZCB3aW5kb3dcIn0pLHRoaXMuaGI9dm9pZCAwKTt0cnl7d2luZG93LmNsb3NlKCl9Y2F0Y2goYil7fX07T2cucHJvdG90eXBlLkZmPWZ1bmN0aW9uKGEpe2lmKHRoaXMubWcmJlwiZGllXCI9PT1hLmRhdGEpdHJ5e3dpbmRvdy5jbG9zZSgpfWNhdGNoKGIpe319O2Z1bmN0aW9uIFFnKGEpe3RoaXMudGM9RmEoKStGYSgpK0ZhKCk7dGhpcy5LZj1hfVFnLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYil7Y2Quc2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiLHRoaXMudGMpO2NkLnNldChcInJlZGlyZWN0X3JlcXVlc3RfaWRcIix0aGlzLnRjKTtiLnJlcXVlc3RJZD10aGlzLnRjO2IucmVkaXJlY3RUbz1iLnJlZGlyZWN0VG98fHdpbmRvdy5sb2NhdGlvbi5ocmVmO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK0liKGIpO3dpbmRvdy5sb2NhdGlvbj1hfTtRZy5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVybiFFZygpJiYhRGcoKX07UWcucHJvdG90eXBlLkZjPWZ1bmN0aW9uKCl7cmV0dXJuXCJyZWRpcmVjdFwifTt2YXIgUmc9e05FVFdPUktfRVJST1I6XCJVbmFibGUgdG8gY29udGFjdCB0aGUgRmlyZWJhc2Ugc2VydmVyLlwiLFNFUlZFUl9FUlJPUjpcIkFuIHVua25vd24gc2VydmVyIGVycm9yIG9jY3VycmVkLlwiLFRSQU5TUE9SVF9VTkFWQUlMQUJMRTpcIlRoZXJlIGFyZSBubyBsb2dpbiB0cmFuc3BvcnRzIGF2YWlsYWJsZSBmb3IgdGhlIHJlcXVlc3RlZCBtZXRob2QuXCIsUkVRVUVTVF9JTlRFUlJVUFRFRDpcIlRoZSBicm93c2VyIHJlZGlyZWN0ZWQgdGhlIHBhZ2UgYmVmb3JlIHRoZSBsb2dpbiByZXF1ZXN0IGNvdWxkIGNvbXBsZXRlLlwiLFVTRVJfQ0FOQ0VMTEVEOlwiVGhlIHVzZXIgY2FuY2VsbGVkIGF1dGhlbnRpY2F0aW9uLlwifTtmdW5jdGlvbiBTZyhhKXt2YXIgYj1FcnJvcih6KFJnLGEpLGEpO2IuY29kZT1hO3JldHVybiBifTtmdW5jdGlvbiBUZyhhKXt2YXIgYjsoYj0hYS53aW5kb3dfZmVhdHVyZXMpfHwoYj1DZygpLGI9LTEhPT1iLmluZGV4T2YoXCJGZW5uZWMvXCIpfHwtMSE9PWIuaW5kZXhPZihcIkZpcmVmb3gvXCIpJiYtMSE9PWIuaW5kZXhPZihcIkFuZHJvaWRcIikpO2ImJihhLndpbmRvd19mZWF0dXJlcz12b2lkIDApO2Eud2luZG93X25hbWV8fChhLndpbmRvd19uYW1lPVwiX2JsYW5rXCIpO3RoaXMub3B0aW9ucz1hfVxuVGcucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7ZyYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZyksZz12b2lkIDApO3QmJih0PWNsZWFySW50ZXJ2YWwodCkpO0lnKHdpbmRvdyxcIm1lc3NhZ2VcIixlKTtJZyh3aW5kb3csXCJ1bmxvYWRcIixkKTtpZihsJiYhYSl0cnl7bC5jbG9zZSgpfWNhdGNoKGIpe2sucG9zdE1lc3NhZ2UoXCJkaWVcIixtKX1sPWs9dm9pZCAwfWZ1bmN0aW9uIGUoYSl7aWYoYS5vcmlnaW49PT1tKXRyeXt2YXIgYj1SYihhLmRhdGEpO1wicmVhZHlcIj09PWIuYT9rLnBvc3RNZXNzYWdlKEEsbSk6XCJlcnJvclwiPT09Yi5hPyhkKCExKSxjJiYoYyhiLmQpLGM9bnVsbCkpOlwicmVzcG9uc2VcIj09PWIuYSYmKGQoYi5mb3JjZUtlZXBXaW5kb3dPcGVuKSxjJiYoYyhudWxsLGIuZCksYz1udWxsKSl9Y2F0Y2goZSl7fX12YXIgZj1GZyg4KSxnLGs7aWYoIXRoaXMub3B0aW9ucy5yZWxheV91cmwpcmV0dXJuIGMoRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50czogb3JpZ2luIG9mIHVybCBhbmQgcmVsYXlfdXJsIG11c3QgbWF0Y2hcIikpO1xudmFyIG09SmcoYSk7aWYobSE9PUpnKHRoaXMub3B0aW9ucy5yZWxheV91cmwpKWMmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKEVycm9yKFwiaW52YWxpZCBhcmd1bWVudHM6IG9yaWdpbiBvZiB1cmwgYW5kIHJlbGF5X3VybCBtdXN0IG1hdGNoXCIpKX0sMCk7ZWxzZXtmJiYoZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpLGcuc2V0QXR0cmlidXRlKFwic3JjXCIsdGhpcy5vcHRpb25zLnJlbGF5X3VybCksZy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGcuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwiX193aW5jaGFuX3JlbGF5X2ZyYW1lXCIpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZyksaz1nLmNvbnRlbnRXaW5kb3cpO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK0liKGIpO3ZhciBsPXdpbmRvdy5vcGVuKGEsdGhpcy5vcHRpb25zLndpbmRvd19uYW1lLHRoaXMub3B0aW9ucy53aW5kb3dfZmVhdHVyZXMpO2t8fChrPWwpO3ZhciB0PXNldEludGVydmFsKGZ1bmN0aW9uKCl7bCYmbC5jbG9zZWQmJlxuKGQoITEpLGMmJihjKFNnKFwiVVNFUl9DQU5DRUxMRURcIikpLGM9bnVsbCkpfSw1MDApLEE9Ryh7YTpcInJlcXVlc3RcIixkOmJ9KTtIZyh3aW5kb3csXCJ1bmxvYWRcIixkKTtIZyh3aW5kb3csXCJtZXNzYWdlXCIsZSl9fTtcblRnLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7dmFyIGE7aWYoYT1cInBvc3RNZXNzYWdlXCJpbiB3aW5kb3cmJiFFZygpKShhPURnKCl8fFwidW5kZWZpbmVkXCIhPT10eXBlb2YgbmF2aWdhdG9yJiYoISFDZygpLm1hdGNoKC9XaW5kb3dzIFBob25lLyl8fCEhd2luZG93LldpbmRvd3MmJi9ebXMtYXBweDovLnRlc3QobG9jYXRpb24uaHJlZikpKXx8KGE9Q2coKSxhPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgbmF2aWdhdG9yJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmISEoYS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pKXx8YS5tYXRjaCgvQ3JpT1MvKXx8YS5tYXRjaCgvVHdpdHRlciBmb3IgaVBob25lLyl8fGEubWF0Y2goL0ZCQU5cXC9GQklPUy8pfHx3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSxhPSFhO3JldHVybiBhJiYhQ2coKS5tYXRjaCgvUGhhbnRvbUpTLyl9O1RnLnByb3RvdHlwZS5GYz1mdW5jdGlvbigpe3JldHVyblwicG9wdXBcIn07ZnVuY3Rpb24gVWcoYSl7YS5tZXRob2R8fChhLm1ldGhvZD1cIkdFVFwiKTthLmhlYWRlcnN8fChhLmhlYWRlcnM9e30pO2EuaGVhZGVycy5jb250ZW50X3R5cGV8fChhLmhlYWRlcnMuY29udGVudF90eXBlPVwiYXBwbGljYXRpb24vanNvblwiKTthLmhlYWRlcnMuY29udGVudF90eXBlPWEuaGVhZGVycy5jb250ZW50X3R5cGUudG9Mb3dlckNhc2UoKTt0aGlzLm9wdGlvbnM9YX1cblVnLnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKCl7YyYmKGMoU2coXCJSRVFVRVNUX0lOVEVSUlVQVEVEXCIpKSxjPW51bGwpfXZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdCxmPXRoaXMub3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSxnO0hnKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpO2Uub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoYyYmND09PWUucmVhZHlTdGF0ZSl7dmFyIGE7aWYoMjAwPD1lLnN0YXR1cyYmMzAwPmUuc3RhdHVzKXt0cnl7YT1SYihlLnJlc3BvbnNlVGV4dCl9Y2F0Y2goYil7fWMobnVsbCxhKX1lbHNlIDUwMDw9ZS5zdGF0dXMmJjYwMD5lLnN0YXR1cz9jKFNnKFwiU0VSVkVSX0VSUk9SXCIpKTpjKFNnKFwiTkVUV09SS19FUlJPUlwiKSk7Yz1udWxsO0lnKHdpbmRvdyxcImJlZm9yZXVubG9hZFwiLGQpfX07aWYoXCJHRVRcIj09PWYpYSs9KC9cXD8vLnRlc3QoYSk/XCJcIjpcIj9cIikrSWIoYiksZz1udWxsO2Vsc2V7dmFyIGs9dGhpcy5vcHRpb25zLmhlYWRlcnMuY29udGVudF90eXBlO1xuXCJhcHBsaWNhdGlvbi9qc29uXCI9PT1rJiYoZz1HKGIpKTtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiPT09ayYmKGc9SWIoYikpfWUub3BlbihmLGEsITApO2E9e1wiWC1SZXF1ZXN0ZWQtV2l0aFwiOlwiWE1MSHR0cFJlcXVlc3RcIixBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uO3RleHQvcGxhaW5cIn07eWEoYSx0aGlzLm9wdGlvbnMuaGVhZGVycyk7Zm9yKHZhciBtIGluIGEpZS5zZXRSZXF1ZXN0SGVhZGVyKG0sYVttXSk7ZS5zZW5kKGcpfTtVZy5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3ZhciBhO2lmKGE9ISF3aW5kb3cuWE1MSHR0cFJlcXVlc3QpYT1DZygpLGE9IShhLm1hdGNoKC9NU0lFLyl8fGEubWF0Y2goL1RyaWRlbnQvKSl8fEZnKDEwKTtyZXR1cm4gYX07VWcucHJvdG90eXBlLkZjPWZ1bmN0aW9uKCl7cmV0dXJuXCJqc29uXCJ9O2Z1bmN0aW9uIFZnKGEpe3RoaXMudGM9RmEoKStGYSgpK0ZhKCk7dGhpcy5LZj1hfVxuVmcucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoKXtjJiYoYyhTZyhcIlVTRVJfQ0FOQ0VMTEVEXCIpKSxjPW51bGwpfXZhciBlPXRoaXMsZj1zZCh4ZyksZztiLnJlcXVlc3RJZD10aGlzLnRjO2IucmVkaXJlY3RUbz1mLnNjaGVtZStcIjovL1wiK2YuaG9zdCtcIi9ibGFuay9wYWdlLmh0bWxcIjthKz0vXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCI7YSs9SWIoYik7KGc9d2luZG93Lm9wZW4oYSxcIl9ibGFua1wiLFwibG9jYXRpb249bm9cIikpJiZyKGcuYWRkRXZlbnRMaXN0ZW5lcik/KGcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLGZ1bmN0aW9uKGEpe3ZhciBiO2lmKGI9YSYmYS51cmwpYTp7dHJ5e3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2wuaHJlZj1hLnVybDtiPWwuaG9zdD09PWYuaG9zdCYmXCIvYmxhbmsvcGFnZS5odG1sXCI9PT1sLnBhdGhuYW1lO2JyZWFrIGF9Y2F0Y2godCl7fWI9ITF9YiYmKGE9S2coYS51cmwpLGcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImV4aXRcIixcbmQpLGcuY2xvc2UoKSxhPW5ldyB5ZyhudWxsLG51bGwse3JlcXVlc3RJZDplLnRjLHJlcXVlc3RLZXk6YX0pLGUuS2YucmVxdWVzdFdpdGhDcmVkZW50aWFsKFwiL2F1dGgvc2Vzc2lvblwiLGEsYyksYz1udWxsKX0pLGcuYWRkRXZlbnRMaXN0ZW5lcihcImV4aXRcIixkKSk6YyhTZyhcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9O1ZnLmlzQXZhaWxhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIERnKCl9O1ZnLnByb3RvdHlwZS5GYz1mdW5jdGlvbigpe3JldHVyblwicmVkaXJlY3RcIn07ZnVuY3Rpb24gV2coYSl7YS5jYWxsYmFja19wYXJhbWV0ZXJ8fChhLmNhbGxiYWNrX3BhcmFtZXRlcj1cImNhbGxiYWNrXCIpO3RoaXMub3B0aW9ucz1hO3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnA9d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucHx8e319XG5XZy5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZCgpe2MmJihjKFNnKFwiUkVRVUVTVF9JTlRFUlJVUFRFRFwiKSksYz1udWxsKX1mdW5jdGlvbiBlKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3dpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnBbZl09dm9pZCAwO3ZhKHdpbmRvdy5fX2ZpcmViYXNlX2F1dGhfanNvbnApJiYod2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucD12b2lkIDApO3RyeXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChmKTthJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9Y2F0Y2goYil7fX0sMSk7SWcod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCl9dmFyIGY9XCJmblwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpK01hdGguZmxvb3IoOTk5OTkqTWF0aC5yYW5kb20oKSk7Ylt0aGlzLm9wdGlvbnMuY2FsbGJhY2tfcGFyYW1ldGVyXT1cIl9fZmlyZWJhc2VfYXV0aF9qc29ucC5cIitmO2ErPSgvXFw/Ly50ZXN0KGEpP1wiXCI6XCI/XCIpK0liKGIpO1xuSGcod2luZG93LFwiYmVmb3JldW5sb2FkXCIsZCk7d2luZG93Ll9fZmlyZWJhc2VfYXV0aF9qc29ucFtmXT1mdW5jdGlvbihhKXtjJiYoYyhudWxsLGEpLGM9bnVsbCk7ZSgpfTtYZyhmLGEsYyl9O1xuZnVuY3Rpb24gWGcoYSxiLGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0cnl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtkLnR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIjtkLmlkPWE7ZC5hc3luYz0hMDtkLnNyYz1iO2Qub25lcnJvcj1mdW5jdGlvbigpe3ZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO251bGwhPT1iJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7YyYmYyhTZyhcIk5FVFdPUktfRVJST1JcIikpfTt2YXIgZT1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIik7KGUmJjAhPWUubGVuZ3RoP2VbMF06ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChkKX1jYXRjaChmKXtjJiZjKFNnKFwiTkVUV09SS19FUlJPUlwiKSl9fSwwKX1XZy5pc0F2YWlsYWJsZT1mdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQmJm51bGwhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnR9O1xuV2cucHJvdG90eXBlLkZjPWZ1bmN0aW9uKCl7cmV0dXJuXCJqc29uXCJ9O2Z1bmN0aW9uIFlnKGEsYixjLGQpe2ZmLmNhbGwodGhpcyxbXCJhdXRoX3N0YXR1c1wiXSk7dGhpcy5HPWE7dGhpcy5oZj1iO3RoaXMuaGg9Yzt0aGlzLlBlPWQ7dGhpcy53Yz1uZXcgQmcoYSxbYmQsY2RdKTt0aGlzLnFiPW51bGw7dGhpcy5XZT0hMTtaZyh0aGlzKX1rYShZZyxmZik7aD1ZZy5wcm90b3R5cGU7aC5CZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnFifHxudWxsfTtmdW5jdGlvbiBaZyhhKXtjZC5nZXQoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpJiYkZyhhKTt2YXIgYj1hLndjLmdldCgpO2ImJmIudG9rZW4/KGFoKGEsYiksYS5oZihiLnRva2VuLGZ1bmN0aW9uKGMsZCl7YmgoYSxjLGQsITEsYi50b2tlbixiKX0sZnVuY3Rpb24oYixkKXtjaChhLFwicmVzdW1lU2Vzc2lvbigpXCIsYixkKX0pKTphaChhLG51bGwpfVxuZnVuY3Rpb24gZGgoYSxiLGMsZCxlLGYpe1wiZmlyZWJhc2Vpby1kZW1vLmNvbVwiPT09YS5HLmRvbWFpbiYmUyhcIkZpcmViYXNlIGF1dGhlbnRpY2F0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgb24gZGVtbyBGaXJlYmFzZXMgKCouZmlyZWJhc2Vpby1kZW1vLmNvbSkuIFRvIHNlY3VyZSB5b3VyIEZpcmViYXNlLCBjcmVhdGUgYSBwcm9kdWN0aW9uIEZpcmViYXNlIGF0IGh0dHBzOi8vd3d3LmZpcmViYXNlLmNvbS5cIik7YS5oZihiLGZ1bmN0aW9uKGYsayl7YmgoYSxmLGssITAsYixjLGR8fHt9LGUpfSxmdW5jdGlvbihiLGMpe2NoKGEsXCJhdXRoKClcIixiLGMsZil9KX1mdW5jdGlvbiBlaChhLGIpe2Eud2MuY2xlYXIoKTthaChhLG51bGwpO2EuaGgoZnVuY3Rpb24oYSxkKXtpZihcIm9rXCI9PT1hKVQoYixudWxsKTtlbHNle3ZhciBlPShhfHxcImVycm9yXCIpLnRvVXBwZXJDYXNlKCksZj1lO2QmJihmKz1cIjogXCIrZCk7Zj1FcnJvcihmKTtmLmNvZGU9ZTtUKGIsZil9fSl9XG5mdW5jdGlvbiBiaChhLGIsYyxkLGUsZixnLGspe1wib2tcIj09PWI/KGQmJihiPWMuYXV0aCxmLmF1dGg9YixmLmV4cGlyZXM9Yy5leHBpcmVzLGYudG9rZW49RWQoZSk/ZTpcIlwiLGM9bnVsbCxiJiZ5KGIsXCJ1aWRcIik/Yz16KGIsXCJ1aWRcIik6eShmLFwidWlkXCIpJiYoYz16KGYsXCJ1aWRcIikpLGYudWlkPWMsYz1cImN1c3RvbVwiLGImJnkoYixcInByb3ZpZGVyXCIpP2M9eihiLFwicHJvdmlkZXJcIik6eShmLFwicHJvdmlkZXJcIikmJihjPXooZixcInByb3ZpZGVyXCIpKSxmLnByb3ZpZGVyPWMsYS53Yy5jbGVhcigpLEVkKGUpJiYoZz1nfHx7fSxjPWJkLFwic2Vzc2lvbk9ubHlcIj09PWcucmVtZW1iZXImJihjPWNkKSxcIm5vbmVcIiE9PWcucmVtZW1iZXImJmEud2Muc2V0KGYsYykpLGFoKGEsZikpLFQoayxudWxsLGYpKTooYS53Yy5jbGVhcigpLGFoKGEsbnVsbCksZj1hPShifHxcImVycm9yXCIpLnRvVXBwZXJDYXNlKCksYyYmKGYrPVwiOiBcIitjKSxmPUVycm9yKGYpLGYuY29kZT1hLFQoayxmKSl9XG5mdW5jdGlvbiBjaChhLGIsYyxkLGUpe1MoYitcIiB3YXMgY2FuY2VsZWQ6IFwiK2QpO2Eud2MuY2xlYXIoKTthaChhLG51bGwpO2E9RXJyb3IoZCk7YS5jb2RlPWMudG9VcHBlckNhc2UoKTtUKGUsYSl9ZnVuY3Rpb24gZmgoYSxiLGMsZCxlKXtnaChhKTtjPW5ldyB5ZyhkfHx7fSx7fSxjfHx7fSk7aGgoYSxbVWcsV2ddLFwiL2F1dGgvXCIrYixjLGUpfVxuZnVuY3Rpb24gaWgoYSxiLGMsZCl7Z2goYSk7dmFyIGU9W1RnLFZnXTtjPUFnKGMpO1wiYW5vbnltb3VzXCI9PT1ifHxcInBhc3N3b3JkXCI9PT1iP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtUKGQsU2coXCJUUkFOU1BPUlRfVU5BVkFJTEFCTEVcIikpfSwwKTooYy5oZS53aW5kb3dfZmVhdHVyZXM9XCJtZW51YmFyPXllcyxtb2RhbD15ZXMsYWx3YXlzUmFpc2VkPXllc2xvY2F0aW9uPXllcyxyZXNpemFibGU9eWVzLHNjcm9sbGJhcnM9eWVzLHN0YXR1cz15ZXMsaGVpZ2h0PTYyNSx3aWR0aD02MjUsdG9wPVwiKyhcIm9iamVjdFwiPT09dHlwZW9mIHNjcmVlbj8uNSooc2NyZWVuLmhlaWdodC02MjUpOjApK1wiLGxlZnQ9XCIrKFwib2JqZWN0XCI9PT10eXBlb2Ygc2NyZWVuPy41KihzY3JlZW4ud2lkdGgtNjI1KTowKSxjLmhlLnJlbGF5X3VybD1OZyhhLkcubGMpLGMuaGUucmVxdWVzdFdpdGhDcmVkZW50aWFsPXUoYS51YyxhKSxoaChhLGUsXCIvYXV0aC9cIitiLGMsZCkpfVxuZnVuY3Rpb24gJGcoYSl7dmFyIGI9Y2QuZ2V0KFwicmVkaXJlY3RfcmVxdWVzdF9pZFwiKTtpZihiKXt2YXIgYz1jZC5nZXQoXCJyZWRpcmVjdF9jbGllbnRfb3B0aW9uc1wiKTtjZC5yZW1vdmUoXCJyZWRpcmVjdF9yZXF1ZXN0X2lkXCIpO2NkLnJlbW92ZShcInJlZGlyZWN0X2NsaWVudF9vcHRpb25zXCIpO3ZhciBkPVtVZyxXZ10sYj17cmVxdWVzdElkOmIscmVxdWVzdEtleTpLZyhkb2N1bWVudC5sb2NhdGlvbi5oYXNoKX0sYz1uZXcgeWcoYyx7fSxiKTthLldlPSEwO0xnKCk7aGgoYSxkLFwiL2F1dGgvc2Vzc2lvblwiLGMsZnVuY3Rpb24oKXt0aGlzLldlPSExfS5iaW5kKGEpKX19aC52ZT1mdW5jdGlvbihhLGIpe2doKHRoaXMpO3ZhciBjPUFnKGEpO2MuZmIuX21ldGhvZD1cIlBPU1RcIjt0aGlzLnVjKFwiL3VzZXJzXCIsYyxmdW5jdGlvbihhLGMpe2E/VChiLGEpOlQoYixhLGMpfSl9O1xuaC5YZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7Z2godGhpcyk7dmFyIGQ9XCIvdXNlcnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuZW1haWwpLGU9QWcoYSk7ZS5mYi5fbWV0aG9kPVwiREVMRVRFXCI7dGhpcy51YyhkLGUsZnVuY3Rpb24oYSxkKXshYSYmZCYmZC51aWQmJmMucWImJmMucWIudWlkJiZjLnFiLnVpZD09PWQudWlkJiZlaChjKTtUKGIsYSl9KX07aC5zZT1mdW5jdGlvbihhLGIpe2doKHRoaXMpO3ZhciBjPVwiL3VzZXJzL1wiK2VuY29kZVVSSUNvbXBvbmVudChhLmVtYWlsKStcIi9wYXNzd29yZFwiLGQ9QWcoYSk7ZC5mYi5fbWV0aG9kPVwiUFVUXCI7ZC5mYi5wYXNzd29yZD1hLm5ld1Bhc3N3b3JkO3RoaXMudWMoYyxkLGZ1bmN0aW9uKGEpe1QoYixhKX0pfTtcbmgucmU9ZnVuY3Rpb24oYSxiKXtnaCh0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5vbGRFbWFpbCkrXCIvZW1haWxcIixkPUFnKGEpO2QuZmIuX21ldGhvZD1cIlBVVFwiO2QuZmIuZW1haWw9YS5uZXdFbWFpbDtkLmZiLnBhc3N3b3JkPWEucGFzc3dvcmQ7dGhpcy51YyhjLGQsZnVuY3Rpb24oYSl7VChiLGEpfSl9O2guWmU9ZnVuY3Rpb24oYSxiKXtnaCh0aGlzKTt2YXIgYz1cIi91c2Vycy9cIitlbmNvZGVVUklDb21wb25lbnQoYS5lbWFpbCkrXCIvcGFzc3dvcmRcIixkPUFnKGEpO2QuZmIuX21ldGhvZD1cIlBPU1RcIjt0aGlzLnVjKGMsZCxmdW5jdGlvbihhKXtUKGIsYSl9KX07aC51Yz1mdW5jdGlvbihhLGIsYyl7amgodGhpcyxbVWcsV2ddLGEsYixjKX07XG5mdW5jdGlvbiBoaChhLGIsYyxkLGUpe2poKGEsYixjLGQsZnVuY3Rpb24oYixjKXshYiYmYyYmYy50b2tlbiYmYy51aWQ/ZGgoYSxjLnRva2VuLGMsZC5xZCxmdW5jdGlvbihhLGIpe2E/VChlLGEpOlQoZSxudWxsLGIpfSk6VChlLGJ8fFNnKFwiVU5LTk9XTl9FUlJPUlwiKSl9KX1cbmZ1bmN0aW9uIGpoKGEsYixjLGQsZSl7Yj1OYShiLGZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLmlzQXZhaWxhYmxlJiZhLmlzQXZhaWxhYmxlKCl9KTswPT09Yi5sZW5ndGg/c2V0VGltZW91dChmdW5jdGlvbigpe1QoZSxTZyhcIlRSQU5TUE9SVF9VTkFWQUlMQUJMRVwiKSl9LDApOihiPW5ldyAoYi5zaGlmdCgpKShkLmhlKSxkPUdiKGQuZmIpLGQudj1cImpzLVwiK0ViLGQudHJhbnNwb3J0PWIuRmMoKSxkLnN1cHByZXNzX3N0YXR1c19jb2Rlcz0hMCxhPU1nKCkrXCIvXCIrYS5HLmxjK2MsYi5vcGVuKGEsZCxmdW5jdGlvbihhLGIpe2lmKGEpVChlLGEpO2Vsc2UgaWYoYiYmYi5lcnJvcil7dmFyIGM9RXJyb3IoYi5lcnJvci5tZXNzYWdlKTtjLmNvZGU9Yi5lcnJvci5jb2RlO2MuZGV0YWlscz1iLmVycm9yLmRldGFpbHM7VChlLGMpfWVsc2UgVChlLG51bGwsYil9KSl9XG5mdW5jdGlvbiBhaChhLGIpe3ZhciBjPW51bGwhPT1hLnFifHxudWxsIT09YjthLnFiPWI7YyYmYS5pZShcImF1dGhfc3RhdHVzXCIsYik7YS5QZShudWxsIT09Yil9aC5FZT1mdW5jdGlvbihhKXtPKFwiYXV0aF9zdGF0dXNcIj09PWEsJ2luaXRpYWwgZXZlbnQgbXVzdCBiZSBvZiB0eXBlIFwiYXV0aF9zdGF0dXNcIicpO3JldHVybiB0aGlzLldlP251bGw6W3RoaXMucWJdfTtmdW5jdGlvbiBnaChhKXt2YXIgYj1hLkc7aWYoXCJmaXJlYmFzZWlvLmNvbVwiIT09Yi5kb21haW4mJlwiZmlyZWJhc2Vpby1kZW1vLmNvbVwiIT09Yi5kb21haW4mJlwiYXV0aC5maXJlYmFzZS5jb21cIj09PXhnKXRocm93IEVycm9yKFwiVGhpcyBjdXN0b20gRmlyZWJhc2Ugc2VydmVyICgnXCIrYS5HLmRvbWFpbitcIicpIGRvZXMgbm90IHN1cHBvcnQgZGVsZWdhdGVkIGxvZ2luLlwiKTt9O3ZhciBnZD1cIndlYnNvY2tldFwiLGhkPVwibG9uZ19wb2xsaW5nXCI7ZnVuY3Rpb24ga2goYSl7dGhpcy5uYz1hO3RoaXMuUWQ9W107dGhpcy5XYj0wO3RoaXMudGU9LTE7dGhpcy5KYj1udWxsfWZ1bmN0aW9uIGxoKGEsYixjKXthLnRlPWI7YS5KYj1jO2EudGU8YS5XYiYmKGEuSmIoKSxhLkpiPW51bGwpfWZ1bmN0aW9uIG1oKGEsYixjKXtmb3IoYS5RZFtiXT1jO2EuUWRbYS5XYl07KXt2YXIgZD1hLlFkW2EuV2JdO2RlbGV0ZSBhLlFkW2EuV2JdO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7KytlKWlmKGRbZV0pe3ZhciBmPWE7Z2MoZnVuY3Rpb24oKXtmLm5jKGRbZV0pfSl9aWYoYS5XYj09PWEudGUpe2EuSmImJihjbGVhclRpbWVvdXQoYS5KYiksYS5KYigpLGEuSmI9bnVsbCk7YnJlYWt9YS5XYisrfX07ZnVuY3Rpb24gbmgoYSxiLGMsZCl7dGhpcy51ZT1hO3RoaXMuZj1wZChhKTt0aGlzLnJiPXRoaXMuc2I9MDt0aGlzLlhhPXVjKGIpO3RoaXMuWGY9Yzt0aGlzLktjPSExO3RoaXMuRmI9ZDt0aGlzLmxkPWZ1bmN0aW9uKGEpe3JldHVybiBmZChiLGhkLGEpfX12YXIgb2gscGg7XG5uaC5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihhLGIpe3RoaXMubWY9MDt0aGlzLm5hPWI7dGhpcy5FZj1uZXcga2goYSk7dGhpcy5EYj0hMTt2YXIgYz10aGlzO3RoaXMudWI9c2V0VGltZW91dChmdW5jdGlvbigpe2MuZihcIlRpbWVkIG91dCB0cnlpbmcgdG8gY29ubmVjdC5cIik7Yy5iYigpO2MudWI9bnVsbH0sTWF0aC5mbG9vcigzRTQpKTt1ZChmdW5jdGlvbigpe2lmKCFjLkRiKXtjLldhPW5ldyBxaChmdW5jdGlvbihhLGIsZCxrLG0pe3JoKGMsYXJndW1lbnRzKTtpZihjLldhKWlmKGMudWImJihjbGVhclRpbWVvdXQoYy51YiksYy51Yj1udWxsKSxjLktjPSEwLFwic3RhcnRcIj09YSljLmlkPWIsYy5NZj1kO2Vsc2UgaWYoXCJjbG9zZVwiPT09YSliPyhjLldhLiRkPSExLGxoKGMuRWYsYixmdW5jdGlvbigpe2MuYmIoKX0pKTpjLmJiKCk7ZWxzZSB0aHJvdyBFcnJvcihcIlVucmVjb2duaXplZCBjb21tYW5kIHJlY2VpdmVkOiBcIithKTt9LGZ1bmN0aW9uKGEsYil7cmgoYyxhcmd1bWVudHMpO1xubWgoYy5FZixhLGIpfSxmdW5jdGlvbigpe2MuYmIoKX0sYy5sZCk7dmFyIGE9e3N0YXJ0OlwidFwifTthLnNlcj1NYXRoLmZsb29yKDFFOCpNYXRoLnJhbmRvbSgpKTtjLldhLmtlJiYoYS5jYj1jLldhLmtlKTthLnY9XCI1XCI7Yy5YZiYmKGEucz1jLlhmKTtjLkZiJiYoYS5scz1jLkZiKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGxvY2F0aW9uJiZsb2NhdGlvbi5ocmVmJiYtMSE9PWxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImZpcmViYXNlaW8uY29tXCIpJiYoYS5yPVwiZlwiKTthPWMubGQoYSk7Yy5mKFwiQ29ubmVjdGluZyB2aWEgbG9uZy1wb2xsIHRvIFwiK2EpO3NoKGMuV2EsYSxmdW5jdGlvbigpe30pfX0pfTtcbm5oLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuV2EsYj10aGlzLk1mO2EuRmc9dGhpcy5pZDthLkdnPWI7Zm9yKGEub2U9ITA7dGgoYSk7KTthPXRoaXMuaWQ7Yj10aGlzLk1mO3RoaXMua2M9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTt2YXIgYz17ZGZyYW1lOlwidFwifTtjLmlkPWE7Yy5wdz1iO3RoaXMua2Muc3JjPXRoaXMubGQoYyk7dGhpcy5rYy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5rYyl9O1xubmguaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gb2h8fCFwaCYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmbnVsbCE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCYmIShcIm9iamVjdFwiPT09dHlwZW9mIHdpbmRvdyYmd2luZG93LmNocm9tZSYmd2luZG93LmNocm9tZS5leHRlbnNpb24mJiEvXmNocm9tZS8udGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZikpJiYhKFwib2JqZWN0XCI9PT10eXBlb2YgV2luZG93cyYmXCJvYmplY3RcIj09PXR5cGVvZiBXaW5kb3dzLmpoKSYmITB9O2g9bmgucHJvdG90eXBlO2guSGQ9ZnVuY3Rpb24oKXt9O2guZmQ9ZnVuY3Rpb24oKXt0aGlzLkRiPSEwO3RoaXMuV2EmJih0aGlzLldhLmNsb3NlKCksdGhpcy5XYT1udWxsKTt0aGlzLmtjJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmtjKSx0aGlzLmtjPW51bGwpO3RoaXMudWImJihjbGVhclRpbWVvdXQodGhpcy51YiksdGhpcy51Yj1udWxsKX07XG5oLmJiPWZ1bmN0aW9uKCl7dGhpcy5EYnx8KHRoaXMuZihcIkxvbmdwb2xsIGlzIGNsb3NpbmcgaXRzZWxmXCIpLHRoaXMuZmQoKSx0aGlzLm5hJiYodGhpcy5uYSh0aGlzLktjKSx0aGlzLm5hPW51bGwpKX07aC5jbG9zZT1mdW5jdGlvbigpe3RoaXMuRGJ8fCh0aGlzLmYoXCJMb25ncG9sbCBpcyBiZWluZyBjbG9zZWQuXCIpLHRoaXMuZmQoKSl9O2guc2VuZD1mdW5jdGlvbihhKXthPUcoYSk7dGhpcy5zYis9YS5sZW5ndGg7cmModGhpcy5YYSxcImJ5dGVzX3NlbnRcIixhLmxlbmd0aCk7YT1PYihhKTthPW5iKGEsITApO2E9eWQoYSwxODQwKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5XYTtjLmNkLnB1c2goe1hnOnRoaXMubWYsZ2g6YS5sZW5ndGgsb2Y6YVtiXX0pO2Mub2UmJnRoKGMpO3RoaXMubWYrK319O2Z1bmN0aW9uIHJoKGEsYil7dmFyIGM9RyhiKS5sZW5ndGg7YS5yYis9YztyYyhhLlhhLFwiYnl0ZXNfcmVjZWl2ZWRcIixjKX1cbmZ1bmN0aW9uIHFoKGEsYixjLGQpe3RoaXMubGQ9ZDt0aGlzLmxiPWM7dGhpcy5UZT1uZXcgdWc7dGhpcy5jZD1bXTt0aGlzLndlPU1hdGguZmxvb3IoMUU4Kk1hdGgucmFuZG9tKCkpO3RoaXMuJGQ9ITA7dGhpcy5rZT1pZCgpO3dpbmRvd1tcInBMUENvbW1hbmRcIit0aGlzLmtlXT1hO3dpbmRvd1tcInBSVExQQ0JcIit0aGlzLmtlXT1iO2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTthLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7aWYoZG9jdW1lbnQuYm9keSl7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTt0cnl7YS5jb250ZW50V2luZG93LmRvY3VtZW50fHxmYyhcIk5vIElFIGRvbWFpbiBzZXR0aW5nIHJlcXVpcmVkXCIpfWNhdGNoKGUpe2Euc3JjPVwiamF2YXNjcmlwdDp2b2lkKChmdW5jdGlvbigpe2RvY3VtZW50Lm9wZW4oKTtkb2N1bWVudC5kb21haW49J1wiK2RvY3VtZW50LmRvbWFpbitcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwifX1lbHNlIHRocm93XCJEb2N1bWVudCBib2R5IGhhcyBub3QgaW5pdGlhbGl6ZWQuIFdhaXQgdG8gaW5pdGlhbGl6ZSBGaXJlYmFzZSB1bnRpbCBhZnRlciB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuXCI7XG5hLmNvbnRlbnREb2N1bWVudD9hLmpiPWEuY29udGVudERvY3VtZW50OmEuY29udGVudFdpbmRvdz9hLmpiPWEuY29udGVudFdpbmRvdy5kb2N1bWVudDphLmRvY3VtZW50JiYoYS5qYj1hLmRvY3VtZW50KTt0aGlzLkdhPWE7YT1cIlwiO3RoaXMuR2Euc3JjJiZcImphdmFzY3JpcHQ6XCI9PT10aGlzLkdhLnNyYy5zdWJzdHIoMCwxMSkmJihhPSc8c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cIicrZG9jdW1lbnQuZG9tYWluKydcIjtcXHgzYy9zY3JpcHQ+Jyk7YT1cIjxodG1sPjxib2R5PlwiK2ErXCI8L2JvZHk+PC9odG1sPlwiO3RyeXt0aGlzLkdhLmpiLm9wZW4oKSx0aGlzLkdhLmpiLndyaXRlKGEpLHRoaXMuR2EuamIuY2xvc2UoKX1jYXRjaChmKXtmYyhcImZyYW1lIHdyaXRpbmcgZXhjZXB0aW9uXCIpLGYuc3RhY2smJmZjKGYuc3RhY2spLGZjKGYpfX1cbnFoLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe3RoaXMub2U9ITE7aWYodGhpcy5HYSl7dGhpcy5HYS5qYi5ib2R5LmlubmVySFRNTD1cIlwiO3ZhciBhPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe251bGwhPT1hLkdhJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhLkdhKSxhLkdhPW51bGwpfSxNYXRoLmZsb29yKDApKX12YXIgYj10aGlzLmxiO2ImJih0aGlzLmxiPW51bGwsYigpKX07XG5mdW5jdGlvbiB0aChhKXtpZihhLm9lJiZhLiRkJiZhLlRlLmNvdW50KCk8KDA8YS5jZC5sZW5ndGg/MjoxKSl7YS53ZSsrO3ZhciBiPXt9O2IuaWQ9YS5GZztiLnB3PWEuR2c7Yi5zZXI9YS53ZTtmb3IodmFyIGI9YS5sZChiKSxjPVwiXCIsZD0wOzA8YS5jZC5sZW5ndGg7KWlmKDE4NzA+PWEuY2RbMF0ub2YubGVuZ3RoKzMwK2MubGVuZ3RoKXt2YXIgZT1hLmNkLnNoaWZ0KCksYz1jK1wiJnNlZ1wiK2QrXCI9XCIrZS5YZytcIiZ0c1wiK2QrXCI9XCIrZS5naCtcIiZkXCIrZCtcIj1cIitlLm9mO2QrK31lbHNlIGJyZWFrO3VoKGEsYitjLGEud2UpO3JldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHVoKGEsYixjKXtmdW5jdGlvbiBkKCl7YS5UZS5yZW1vdmUoYyk7dGgoYSl9YS5UZS5hZGQoYywxKTt2YXIgZT1zZXRUaW1lb3V0KGQsTWF0aC5mbG9vcigyNUUzKSk7c2goYSxiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUpO2QoKX0pfVxuZnVuY3Rpb24gc2goYSxiLGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0cnl7aWYoYS4kZCl7dmFyIGQ9YS5HYS5qYi5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2QudHlwZT1cInRleHQvamF2YXNjcmlwdFwiO2QuYXN5bmM9ITA7ZC5zcmM9YjtkLm9ubG9hZD1kLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe3ZhciBhPWQucmVhZHlTdGF0ZTthJiZcImxvYWRlZFwiIT09YSYmXCJjb21wbGV0ZVwiIT09YXx8KGQub25sb2FkPWQub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsZC5wYXJlbnROb2RlJiZkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksYygpKX07ZC5vbmVycm9yPWZ1bmN0aW9uKCl7ZmMoXCJMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiBcIitiKTthLiRkPSExO2EuY2xvc2UoKX07YS5HYS5qYi5ib2R5LmFwcGVuZENoaWxkKGQpfX1jYXRjaChlKXt9fSxNYXRoLmZsb29yKDEpKX07dmFyIHZoPW51bGw7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNb3pXZWJTb2NrZXQ/dmg9TW96V2ViU29ja2V0OlwidW5kZWZpbmVkXCIhPT10eXBlb2YgV2ViU29ja2V0JiYodmg9V2ViU29ja2V0KTtmdW5jdGlvbiB3aChhLGIsYyxkKXt0aGlzLnVlPWE7dGhpcy5mPXBkKHRoaXMudWUpO3RoaXMuZnJhbWVzPXRoaXMuTmM9bnVsbDt0aGlzLnJiPXRoaXMuc2I9dGhpcy5mZj0wO3RoaXMuWGE9dWMoYik7YT17djpcIjVcIn07XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsb2NhdGlvbiYmbG9jYXRpb24uaHJlZiYmLTEhPT1sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJmaXJlYmFzZWlvLmNvbVwiKSYmKGEucj1cImZcIik7YyYmKGEucz1jKTtkJiYoYS5scz1kKTt0aGlzLmpmPWZkKGIsZ2QsYSl9dmFyIHhoO1xud2gucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oYSxiKXt0aGlzLmxiPWI7dGhpcy5LZz1hO3RoaXMuZihcIldlYnNvY2tldCBjb25uZWN0aW5nIHRvIFwiK3RoaXMuamYpO3RoaXMuS2M9ITE7YmQuc2V0KFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIiwhMCk7dHJ5e3RoaXMuTGE9bmV3IHZoKHRoaXMuamYpfWNhdGNoKGMpe3RoaXMuZihcIkVycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LlwiKTt2YXIgZD1jLm1lc3NhZ2V8fGMuZGF0YTtkJiZ0aGlzLmYoZCk7dGhpcy5iYigpO3JldHVybn12YXIgZT10aGlzO3RoaXMuTGEub25vcGVuPWZ1bmN0aW9uKCl7ZS5mKFwiV2Vic29ja2V0IGNvbm5lY3RlZC5cIik7ZS5LYz0hMH07dGhpcy5MYS5vbmNsb3NlPWZ1bmN0aW9uKCl7ZS5mKFwiV2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRpc2Nvbm5lY3RlZC5cIik7ZS5MYT1udWxsO2UuYmIoKX07dGhpcy5MYS5vbm1lc3NhZ2U9ZnVuY3Rpb24oYSl7aWYobnVsbCE9PWUuTGEpaWYoYT1hLmRhdGEsZS5yYis9XG5hLmxlbmd0aCxyYyhlLlhhLFwiYnl0ZXNfcmVjZWl2ZWRcIixhLmxlbmd0aCkseWgoZSksbnVsbCE9PWUuZnJhbWVzKXpoKGUsYSk7ZWxzZXthOntPKG51bGw9PT1lLmZyYW1lcyxcIldlIGFscmVhZHkgaGF2ZSBhIGZyYW1lIGJ1ZmZlclwiKTtpZig2Pj1hLmxlbmd0aCl7dmFyIGI9TnVtYmVyKGEpO2lmKCFpc05hTihiKSl7ZS5mZj1iO2UuZnJhbWVzPVtdO2E9bnVsbDticmVhayBhfX1lLmZmPTE7ZS5mcmFtZXM9W119bnVsbCE9PWEmJnpoKGUsYSl9fTt0aGlzLkxhLm9uZXJyb3I9ZnVuY3Rpb24oYSl7ZS5mKFwiV2ViU29ja2V0IGVycm9yLiAgQ2xvc2luZyBjb25uZWN0aW9uLlwiKTsoYT1hLm1lc3NhZ2V8fGEuZGF0YSkmJmUuZihhKTtlLmJiKCl9fTt3aC5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt9O1xud2guaXNBdmFpbGFibGU9ZnVuY3Rpb24oKXt2YXIgYT0hMTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudCl7dmFyIGI9bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZCAoWzAtOV17MCx9XFwuWzAtOV17MCx9KS8pO2ImJjE8Yi5sZW5ndGgmJjQuND5wYXJzZUZsb2F0KGJbMV0pJiYoYT0hMCl9cmV0dXJuIWEmJm51bGwhPT12aCYmIXhofTt3aC5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5PTI7d2guaGVhbHRoeVRpbWVvdXQ9M0U0O2g9d2gucHJvdG90eXBlO2guSGQ9ZnVuY3Rpb24oKXtiZC5yZW1vdmUoXCJwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZVwiKX07ZnVuY3Rpb24gemgoYSxiKXthLmZyYW1lcy5wdXNoKGIpO2lmKGEuZnJhbWVzLmxlbmd0aD09YS5mZil7dmFyIGM9YS5mcmFtZXMuam9pbihcIlwiKTthLmZyYW1lcz1udWxsO2M9UmIoYyk7YS5LZyhjKX19XG5oLnNlbmQ9ZnVuY3Rpb24oYSl7eWgodGhpcyk7YT1HKGEpO3RoaXMuc2IrPWEubGVuZ3RoO3JjKHRoaXMuWGEsXCJieXRlc19zZW50XCIsYS5sZW5ndGgpO2E9eWQoYSwxNjM4NCk7MTxhLmxlbmd0aCYmQWgodGhpcyxTdHJpbmcoYS5sZW5ndGgpKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKylBaCh0aGlzLGFbYl0pfTtoLmZkPWZ1bmN0aW9uKCl7dGhpcy5EYj0hMDt0aGlzLk5jJiYoY2xlYXJJbnRlcnZhbCh0aGlzLk5jKSx0aGlzLk5jPW51bGwpO3RoaXMuTGEmJih0aGlzLkxhLmNsb3NlKCksdGhpcy5MYT1udWxsKX07aC5iYj1mdW5jdGlvbigpe3RoaXMuRGJ8fCh0aGlzLmYoXCJXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGZcIiksdGhpcy5mZCgpLHRoaXMubGImJih0aGlzLmxiKHRoaXMuS2MpLHRoaXMubGI9bnVsbCkpfTtoLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5EYnx8KHRoaXMuZihcIldlYlNvY2tldCBpcyBiZWluZyBjbG9zZWRcIiksdGhpcy5mZCgpKX07XG5mdW5jdGlvbiB5aChhKXtjbGVhckludGVydmFsKGEuTmMpO2EuTmM9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXthLkxhJiZBaChhLFwiMFwiKTt5aChhKX0sTWF0aC5mbG9vcig0NUUzKSl9ZnVuY3Rpb24gQWgoYSxiKXt0cnl7YS5MYS5zZW5kKGIpfWNhdGNoKGMpe2EuZihcIkV4Y2VwdGlvbiB0aHJvd24gZnJvbSBXZWJTb2NrZXQuc2VuZCgpOlwiLGMubWVzc2FnZXx8Yy5kYXRhLFwiQ2xvc2luZyBjb25uZWN0aW9uLlwiKSxzZXRUaW1lb3V0KHUoYS5iYixhKSwwKX19O2Z1bmN0aW9uIEJoKGEpe0NoKHRoaXMsYSl9dmFyIERoPVtuaCx3aF07ZnVuY3Rpb24gQ2goYSxiKXt2YXIgYz13aCYmd2guaXNBdmFpbGFibGUoKSxkPWMmJiEoYmQuQWZ8fCEwPT09YmQuZ2V0KFwicHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmVcIikpO2IuaWgmJihjfHxTKFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKSxkPSEwKTtpZihkKWEuamQ9W3doXTtlbHNle3ZhciBlPWEuamQ9W107emQoRGgsZnVuY3Rpb24oYSxiKXtiJiZiLmlzQXZhaWxhYmxlKCkmJmUucHVzaChiKX0pfX1mdW5jdGlvbiBFaChhKXtpZigwPGEuamQubGVuZ3RoKXJldHVybiBhLmpkWzBdO3Rocm93IEVycm9yKFwiTm8gdHJhbnNwb3J0cyBhdmFpbGFibGVcIik7fTtmdW5jdGlvbiBGaChhLGIsYyxkLGUsZixnKXt0aGlzLmlkPWE7dGhpcy5mPXBkKFwiYzpcIit0aGlzLmlkK1wiOlwiKTt0aGlzLm5jPWM7dGhpcy5aYz1kO3RoaXMubmE9ZTt0aGlzLlJlPWY7dGhpcy5HPWI7dGhpcy5QZD1bXTt0aGlzLmtmPTA7dGhpcy5XZj1uZXcgQmgoYik7dGhpcy5OPTA7dGhpcy5GYj1nO3RoaXMuZihcIkNvbm5lY3Rpb24gY3JlYXRlZFwiKTtHaCh0aGlzKX1cbmZ1bmN0aW9uIEdoKGEpe3ZhciBiPUVoKGEuV2YpO2EuSz1uZXcgYihcImM6XCIrYS5pZCtcIjpcIithLmtmKyssYS5HLHZvaWQgMCxhLkZiKTthLlZlPWIucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeXx8MDt2YXIgYz1IaChhLGEuSyksZD1JaChhLGEuSyk7YS5rZD1hLks7YS5lZD1hLks7YS5GPW51bGw7YS5FYj0hMTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5LJiZhLksub3BlbihjLGQpfSxNYXRoLmZsb29yKDApKTtiPWIuaGVhbHRoeVRpbWVvdXR8fDA7MDxiJiYoYS5CZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5CZD1udWxsO2EuRWJ8fChhLksmJjEwMjQwMDxhLksucmI/KGEuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgcmVjZWl2ZWQgXCIrYS5LLnJiK1wiIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuXCIpLGEuRWI9ITAsYS5LLkhkKCkpOmEuSyYmMTAyNDA8YS5LLnNiP2EuZihcIkNvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCBcIitcbmEuSy5zYitcIiBieXRlcy4gIExlYXZpbmcgY29ubmVjdGlvbiBhbGl2ZS5cIik6KGEuZihcIkNsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC5cIiksYS5jbG9zZSgpKSl9LE1hdGguZmxvb3IoYikpKX1mdW5jdGlvbiBJaChhLGIpe3JldHVybiBmdW5jdGlvbihjKXtiPT09YS5LPyhhLks9bnVsbCxjfHwwIT09YS5OPzE9PT1hLk4mJmEuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gbG9zdC5cIik6KGEuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gZmFpbGVkLlwiKSxcInMtXCI9PT1hLkcuYWIuc3Vic3RyKDAsMikmJihiZC5yZW1vdmUoXCJob3N0OlwiK2EuRy5ob3N0KSxhLkcuYWI9YS5HLmhvc3QpKSxhLmNsb3NlKCkpOmI9PT1hLkY/KGEuZihcIlNlY29uZGFyeSBjb25uZWN0aW9uIGxvc3QuXCIpLGM9YS5GLGEuRj1udWxsLGEua2QhPT1jJiZhLmVkIT09Y3x8YS5jbG9zZSgpKTphLmYoXCJjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uXCIpfX1cbmZ1bmN0aW9uIEhoKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKDIhPWEuTilpZihiPT09YS5lZCl7dmFyIGQ9d2QoXCJ0XCIsYyk7Yz13ZChcImRcIixjKTtpZihcImNcIj09ZCl7aWYoZD13ZChcInRcIixjKSxcImRcImluIGMpaWYoYz1jLmQsXCJoXCI9PT1kKXt2YXIgZD1jLnRzLGU9Yy52LGY9Yy5oO2EuVWY9Yy5zO2VkKGEuRyxmKTswPT1hLk4mJihhLksuc3RhcnQoKSxKaChhLGEuSyxkKSxcIjVcIiE9PWUmJlMoXCJQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkXCIpLGM9YS5XZiwoYz0xPGMuamQubGVuZ3RoP2MuamRbMV06bnVsbCkmJktoKGEsYykpfWVsc2UgaWYoXCJuXCI9PT1kKXthLmYoXCJyZWN2ZCBlbmQgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnlcIik7YS5lZD1hLkY7Zm9yKGM9MDtjPGEuUGQubGVuZ3RoOysrYylhLkxkKGEuUGRbY10pO2EuUGQ9W107TGgoYSl9ZWxzZVwic1wiPT09ZD8oYS5mKFwiQ29ubmVjdGlvbiBzaHV0ZG93biBjb21tYW5kIHJlY2VpdmVkLiBTaHV0dGluZyBkb3duLi4uXCIpLFxuYS5SZSYmKGEuUmUoYyksYS5SZT1udWxsKSxhLm5hPW51bGwsYS5jbG9zZSgpKTpcInJcIj09PWQ/KGEuZihcIlJlc2V0IHBhY2tldCByZWNlaXZlZC4gIE5ldyBob3N0OiBcIitjKSxlZChhLkcsYyksMT09PWEuTj9hLmNsb3NlKCk6KE1oKGEpLEdoKGEpKSk6XCJlXCI9PT1kP3FkKFwiU2VydmVyIEVycm9yOiBcIitjKTpcIm9cIj09PWQ/KGEuZihcImdvdCBwb25nIG9uIHByaW1hcnkuXCIpLE5oKGEpLE9oKGEpKTpxZChcIlVua25vd24gY29udHJvbCBwYWNrZXQgY29tbWFuZDogXCIrZCl9ZWxzZVwiZFwiPT1kJiZhLkxkKGMpfWVsc2UgaWYoYj09PWEuRilpZihkPXdkKFwidFwiLGMpLGM9d2QoXCJkXCIsYyksXCJjXCI9PWQpXCJ0XCJpbiBjJiYoYz1jLnQsXCJhXCI9PT1jP1BoKGEpOlwiclwiPT09Yz8oYS5mKFwiR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0XCIpLGEuRi5jbG9zZSgpLGEua2QhPT1hLkYmJmEuZWQhPT1hLkZ8fGEuY2xvc2UoKSk6XCJvXCI9PT1jJiYoYS5mKFwiZ290IHBvbmcgb24gc2Vjb25kYXJ5LlwiKSxcbmEuVGYtLSxQaChhKSkpO2Vsc2UgaWYoXCJkXCI9PWQpYS5QZC5wdXNoKGMpO2Vsc2UgdGhyb3cgRXJyb3IoXCJVbmtub3duIHByb3RvY29sIGxheWVyOiBcIitkKTtlbHNlIGEuZihcIm1lc3NhZ2Ugb24gb2xkIGNvbm5lY3Rpb25cIil9fUZoLnByb3RvdHlwZS5JYT1mdW5jdGlvbihhKXtRaCh0aGlzLHt0OlwiZFwiLGQ6YX0pfTtmdW5jdGlvbiBMaChhKXthLmtkPT09YS5GJiZhLmVkPT09YS5GJiYoYS5mKFwiY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246IFwiK2EuRi51ZSksYS5LPWEuRixhLkY9bnVsbCl9XG5mdW5jdGlvbiBQaChhKXswPj1hLlRmPyhhLmYoXCJTZWNvbmRhcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LlwiKSxhLkViPSEwLGEuRi5IZCgpLGEuRi5zdGFydCgpLGEuZihcInNlbmRpbmcgY2xpZW50IGFjayBvbiBzZWNvbmRhcnlcIiksYS5GLnNlbmQoe3Q6XCJjXCIsZDp7dDpcImFcIixkOnt9fX0pLGEuZihcIkVuZGluZyB0cmFuc21pc3Npb24gb24gcHJpbWFyeVwiKSxhLksuc2VuZCh7dDpcImNcIixkOnt0OlwiblwiLGQ6e319fSksYS5rZD1hLkYsTGgoYSkpOihhLmYoXCJzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LlwiKSxhLkYuc2VuZCh7dDpcImNcIixkOnt0OlwicFwiLGQ6e319fSkpfUZoLnByb3RvdHlwZS5MZD1mdW5jdGlvbihhKXtOaCh0aGlzKTt0aGlzLm5jKGEpfTtmdW5jdGlvbiBOaChhKXthLkVifHwoYS5WZS0tLDA+PWEuVmUmJihhLmYoXCJQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cIiksYS5FYj0hMCxhLksuSGQoKSkpfVxuZnVuY3Rpb24gS2goYSxiKXthLkY9bmV3IGIoXCJjOlwiK2EuaWQrXCI6XCIrYS5rZisrLGEuRyxhLlVmKTthLlRmPWIucmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeXx8MDthLkYub3BlbihIaChhLGEuRiksSWgoYSxhLkYpKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5GJiYoYS5mKFwiVGltZWQgb3V0IHRyeWluZyB0byB1cGdyYWRlLlwiKSxhLkYuY2xvc2UoKSl9LE1hdGguZmxvb3IoNkU0KSl9ZnVuY3Rpb24gSmgoYSxiLGMpe2EuZihcIlJlYWx0aW1lIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuXCIpO2EuSz1iO2EuTj0xO2EuWmMmJihhLlpjKGMsYS5VZiksYS5aYz1udWxsKTswPT09YS5WZT8oYS5mKFwiUHJpbWFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXCIpLGEuRWI9ITApOnNldFRpbWVvdXQoZnVuY3Rpb24oKXtPaChhKX0sTWF0aC5mbG9vcig1RTMpKX1cbmZ1bmN0aW9uIE9oKGEpe2EuRWJ8fDEhPT1hLk58fChhLmYoXCJzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS5cIiksUWgoYSx7dDpcImNcIixkOnt0OlwicFwiLGQ6e319fSkpfWZ1bmN0aW9uIFFoKGEsYil7aWYoMSE9PWEuTil0aHJvd1wiQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkXCI7YS5rZC5zZW5kKGIpfUZoLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpezIhPT10aGlzLk4mJih0aGlzLmYoXCJDbG9zaW5nIHJlYWx0aW1lIGNvbm5lY3Rpb24uXCIpLHRoaXMuTj0yLE1oKHRoaXMpLHRoaXMubmEmJih0aGlzLm5hKCksdGhpcy5uYT1udWxsKSl9O2Z1bmN0aW9uIE1oKGEpe2EuZihcIlNodXR0aW5nIGRvd24gYWxsIGNvbm5lY3Rpb25zXCIpO2EuSyYmKGEuSy5jbG9zZSgpLGEuSz1udWxsKTthLkYmJihhLkYuY2xvc2UoKSxhLkY9bnVsbCk7YS5CZCYmKGNsZWFyVGltZW91dChhLkJkKSxhLkJkPW51bGwpfTtmdW5jdGlvbiBSaChhLGIsYyxkKXt0aGlzLmlkPVNoKys7dGhpcy5mPXBkKFwicDpcIit0aGlzLmlkK1wiOlwiKTt0aGlzLkJmPXRoaXMuSWU9ITE7dGhpcy5iYT17fTt0aGlzLnNhPVtdO3RoaXMuYWQ9MDt0aGlzLlljPVtdO3RoaXMucWE9ITE7dGhpcy5lYj0xRTM7dGhpcy5JZD0zRTU7dGhpcy5LYj1iO3RoaXMuWGM9Yzt0aGlzLlNlPWQ7dGhpcy5HPWE7dGhpcy53Yj10aGlzLkNhPXRoaXMuTWE9dGhpcy5GYj10aGlzLiRlPW51bGw7dGhpcy5TYj0hMTt0aGlzLldkPXt9O3RoaXMuV2c9MDt0aGlzLnJmPSEwO3RoaXMuT2M9dGhpcy5LZT1udWxsO1RoKHRoaXMsMCk7a2YueWIoKS5JYihcInZpc2libGVcIix0aGlzLk5nLHRoaXMpOy0xPT09YS5ob3N0LmluZGV4T2YoXCJmYmxvY2FsXCIpJiZqZi55YigpLkliKFwib25saW5lXCIsdGhpcy5MZyx0aGlzKX12YXIgU2g9MCxVaD0wO2g9UmgucHJvdG90eXBlO1xuaC5JYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Kyt0aGlzLldnO2E9e3I6ZCxhOmEsYjpifTt0aGlzLmYoRyhhKSk7Tyh0aGlzLnFhLFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO3RoaXMuTWEuSWEoYSk7YyYmKHRoaXMuV2RbZF09Yyl9O2guQ2Y9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS53YSgpLGY9YS5wYXRoLnRvU3RyaW5nKCk7dGhpcy5mKFwiTGlzdGVuIGNhbGxlZCBmb3IgXCIrZitcIiBcIitlKTt0aGlzLmJhW2ZdPXRoaXMuYmFbZl18fHt9O08oSWUoYS5uKXx8IUhlKGEubiksXCJsaXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeVwiKTtPKCF0aGlzLmJhW2ZdW2VdLFwibGlzdGVuKCkgY2FsbGVkIHR3aWNlIGZvciBzYW1lIHBhdGgvcXVlcnlJZC5cIik7YT17STpkLEFkOmIsVGc6YSx0YWc6Y307dGhpcy5iYVtmXVtlXT1hO3RoaXMucWEmJlZoKHRoaXMsYSl9O1xuZnVuY3Rpb24gVmgoYSxiKXt2YXIgYz1iLlRnLGQ9Yy5wYXRoLnRvU3RyaW5nKCksZT1jLndhKCk7YS5mKFwiTGlzdGVuIG9uIFwiK2QrXCIgZm9yIFwiK2UpO3ZhciBmPXtwOmR9O2IudGFnJiYoZi5xPUdlKGMubiksZi50PWIudGFnKTtmLmg9Yi5BZCgpO2EuSWEoXCJxXCIsZixmdW5jdGlvbihmKXt2YXIgaz1mLmQsbT1mLnM7aWYoayYmXCJvYmplY3RcIj09PXR5cGVvZiBrJiZ5KGssXCJ3XCIpKXt2YXIgbD16KGssXCJ3XCIpO2RhKGwpJiYwPD1MYShsLFwibm9faW5kZXhcIikmJlMoXCJVc2luZyBhbiB1bnNwZWNpZmllZCBpbmRleC4gQ29uc2lkZXIgYWRkaW5nIFwiKygnXCIuaW5kZXhPblwiOiBcIicrYy5uLmcudG9TdHJpbmcoKSsnXCInKStcIiBhdCBcIitjLnBhdGgudG9TdHJpbmcoKStcIiB0byB5b3VyIHNlY3VyaXR5IHJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcIil9KGEuYmFbZF0mJmEuYmFbZF1bZV0pPT09YiYmKGEuZihcImxpc3RlbiByZXNwb25zZVwiLGYpLFwib2tcIiE9PW0mJldoKGEsZCxlKSxiLkkmJlxuYi5JKG0saykpfSl9aC5PPWZ1bmN0aW9uKGEsYixjKXt0aGlzLkNhPXtyZzphLHNmOiExLERjOmIsb2Q6Y307dGhpcy5mKFwiQXV0aGVudGljYXRpbmcgdXNpbmcgY3JlZGVudGlhbDogXCIrYSk7WGgodGhpcyk7KGI9NDA9PWEubGVuZ3RoKXx8KGE9Q2QoYSkuRWMsYj1cIm9iamVjdFwiPT09dHlwZW9mIGEmJiEwPT09eihhLFwiYWRtaW5cIikpO2ImJih0aGlzLmYoXCJBZG1pbiBhdXRoIGNyZWRlbnRpYWwgZGV0ZWN0ZWQuICBSZWR1Y2luZyBtYXggcmVjb25uZWN0IHRpbWUuXCIpLHRoaXMuSWQ9M0U0KX07aC5qZT1mdW5jdGlvbihhKXt0aGlzLkNhPW51bGw7dGhpcy5xYSYmdGhpcy5JYShcInVuYXV0aFwiLHt9LGZ1bmN0aW9uKGIpe2EoYi5zLGIuZCl9KX07XG5mdW5jdGlvbiBYaChhKXt2YXIgYj1hLkNhO2EucWEmJmImJmEuSWEoXCJhdXRoXCIse2NyZWQ6Yi5yZ30sZnVuY3Rpb24oYyl7dmFyIGQ9Yy5zO2M9Yy5kfHxcImVycm9yXCI7XCJva1wiIT09ZCYmYS5DYT09PWImJihhLkNhPW51bGwpO2Iuc2Y/XCJva1wiIT09ZCYmYi5vZCYmYi5vZChkLGMpOihiLnNmPSEwLGIuRGMmJmIuRGMoZCxjKSl9KX1oLiRmPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wYXRoLnRvU3RyaW5nKCksZD1hLndhKCk7dGhpcy5mKFwiVW5saXN0ZW4gY2FsbGVkIGZvciBcIitjK1wiIFwiK2QpO08oSWUoYS5uKXx8IUhlKGEubiksXCJ1bmxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5XCIpO2lmKFdoKHRoaXMsYyxkKSYmdGhpcy5xYSl7dmFyIGU9R2UoYS5uKTt0aGlzLmYoXCJVbmxpc3RlbiBvbiBcIitjK1wiIGZvciBcIitkKTtjPXtwOmN9O2ImJihjLnE9ZSxjLnQ9Yik7dGhpcy5JYShcIm5cIixjKX19O1xuaC5RZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5xYT9ZaCh0aGlzLFwib1wiLGEsYixjKTp0aGlzLlljLnB1c2goe2JkOmEsYWN0aW9uOlwib1wiLGRhdGE6YixJOmN9KX07aC5HZj1mdW5jdGlvbihhLGIsYyl7dGhpcy5xYT9ZaCh0aGlzLFwib21cIixhLGIsYyk6dGhpcy5ZYy5wdXNoKHtiZDphLGFjdGlvbjpcIm9tXCIsZGF0YTpiLEk6Y30pfTtoLk1kPWZ1bmN0aW9uKGEsYil7dGhpcy5xYT9ZaCh0aGlzLFwib2NcIixhLG51bGwsYik6dGhpcy5ZYy5wdXNoKHtiZDphLGFjdGlvbjpcIm9jXCIsZGF0YTpudWxsLEk6Yn0pfTtmdW5jdGlvbiBZaChhLGIsYyxkLGUpe2M9e3A6YyxkOmR9O2EuZihcIm9uRGlzY29ubmVjdCBcIitiLGMpO2EuSWEoYixjLGZ1bmN0aW9uKGEpe2UmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGEucyxhLmQpfSxNYXRoLmZsb29yKDApKX0pfWgucHV0PWZ1bmN0aW9uKGEsYixjLGQpe1poKHRoaXMsXCJwXCIsYSxiLGMsZCl9O1xuaC5EZj1mdW5jdGlvbihhLGIsYyxkKXtaaCh0aGlzLFwibVwiLGEsYixjLGQpfTtmdW5jdGlvbiBaaChhLGIsYyxkLGUsZil7ZD17cDpjLGQ6ZH07cChmKSYmKGQuaD1mKTthLnNhLnB1c2goe2FjdGlvbjpiLFBmOmQsSTplfSk7YS5hZCsrO2I9YS5zYS5sZW5ndGgtMTthLnFhPyRoKGEsYik6YS5mKFwiQnVmZmVyaW5nIHB1dDogXCIrYyl9ZnVuY3Rpb24gJGgoYSxiKXt2YXIgYz1hLnNhW2JdLmFjdGlvbixkPWEuc2FbYl0uUGYsZT1hLnNhW2JdLkk7YS5zYVtiXS5VZz1hLnFhO2EuSWEoYyxkLGZ1bmN0aW9uKGQpe2EuZihjK1wiIHJlc3BvbnNlXCIsZCk7ZGVsZXRlIGEuc2FbYl07YS5hZC0tOzA9PT1hLmFkJiYoYS5zYT1bXSk7ZSYmZShkLnMsZC5kKX0pfVxuaC5ZZT1mdW5jdGlvbihhKXt0aGlzLnFhJiYoYT17YzphfSx0aGlzLmYoXCJyZXBvcnRTdGF0c1wiLGEpLHRoaXMuSWEoXCJzXCIsYSxmdW5jdGlvbihhKXtcIm9rXCIhPT1hLnMmJnRoaXMuZihcInJlcG9ydFN0YXRzXCIsXCJFcnJvciBzZW5kaW5nIHN0YXRzOiBcIithLmQpfSkpfTtcbmguTGQ9ZnVuY3Rpb24oYSl7aWYoXCJyXCJpbiBhKXt0aGlzLmYoXCJmcm9tIHNlcnZlcjogXCIrRyhhKSk7dmFyIGI9YS5yLGM9dGhpcy5XZFtiXTtjJiYoZGVsZXRlIHRoaXMuV2RbYl0sYyhhLmIpKX1lbHNle2lmKFwiZXJyb3JcImluIGEpdGhyb3dcIkEgc2VydmVyLXNpZGUgZXJyb3IgaGFzIG9jY3VycmVkOiBcIithLmVycm9yO1wiYVwiaW4gYSYmKGI9YS5hLGM9YS5iLHRoaXMuZihcImhhbmRsZVNlcnZlck1lc3NhZ2VcIixiLGMpLFwiZFwiPT09Yj90aGlzLktiKGMucCxjLmQsITEsYy50KTpcIm1cIj09PWI/dGhpcy5LYihjLnAsYy5kLCEwLGMudCk6XCJjXCI9PT1iP2FpKHRoaXMsYy5wLGMucSk6XCJhY1wiPT09Yj8oYT1jLnMsYj1jLmQsYz10aGlzLkNhLHRoaXMuQ2E9bnVsbCxjJiZjLm9kJiZjLm9kKGEsYikpOlwic2RcIj09PWI/dGhpcy4kZT90aGlzLiRlKGMpOlwibXNnXCJpbiBjJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUubG9nKFwiRklSRUJBU0U6IFwiK2MubXNnLnJlcGxhY2UoXCJcXG5cIixcblwiXFxuRklSRUJBU0U6IFwiKSk6cWQoXCJVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiBcIitHKGIpK1wiXFxuQXJlIHlvdSB1c2luZyB0aGUgbGF0ZXN0IGNsaWVudD9cIikpfX07aC5aYz1mdW5jdGlvbihhLGIpe3RoaXMuZihcImNvbm5lY3Rpb24gcmVhZHlcIik7dGhpcy5xYT0hMDt0aGlzLk9jPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMuU2Uoe3NlcnZlclRpbWVPZmZzZXQ6YS0obmV3IERhdGUpLmdldFRpbWUoKX0pO3RoaXMuRmI9YjtpZih0aGlzLnJmKXt2YXIgYz17fTtjW1wic2RrLmpzLlwiK0ViLnJlcGxhY2UoL1xcLi9nLFwiLVwiKV09MTtEZygpP2NbXCJmcmFtZXdvcmsuY29yZG92YVwiXT0xOlwib2JqZWN0XCI9PT10eXBlb2YgbmF2aWdhdG9yJiZcIlJlYWN0TmF0aXZlXCI9PT1uYXZpZ2F0b3IucHJvZHVjdCYmKGNbXCJmcmFtZXdvcmsucmVhY3RuYXRpdmVcIl09MSk7dGhpcy5ZZShjKX1iaSh0aGlzKTt0aGlzLnJmPSExO3RoaXMuWGMoITApfTtcbmZ1bmN0aW9uIFRoKGEsYil7TyghYS5NYSxcIlNjaGVkdWxpbmcgYSBjb25uZWN0IHdoZW4gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQvaW5nP1wiKTthLndiJiZjbGVhclRpbWVvdXQoYS53Yik7YS53Yj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS53Yj1udWxsO2NpKGEpfSxNYXRoLmZsb29yKGIpKX1oLk5nPWZ1bmN0aW9uKGEpe2EmJiF0aGlzLlNiJiZ0aGlzLmViPT09dGhpcy5JZCYmKHRoaXMuZihcIldpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LlwiKSx0aGlzLmViPTFFMyx0aGlzLk1hfHxUaCh0aGlzLDApKTt0aGlzLlNiPWF9O2guTGc9ZnVuY3Rpb24oYSl7YT8odGhpcy5mKFwiQnJvd3NlciB3ZW50IG9ubGluZS5cIiksdGhpcy5lYj0xRTMsdGhpcy5NYXx8VGgodGhpcywwKSk6KHRoaXMuZihcIkJyb3dzZXIgd2VudCBvZmZsaW5lLiAgS2lsbGluZyBjb25uZWN0aW9uLlwiKSx0aGlzLk1hJiZ0aGlzLk1hLmNsb3NlKCkpfTtcbmguSWY9ZnVuY3Rpb24oKXt0aGlzLmYoXCJkYXRhIGNsaWVudCBkaXNjb25uZWN0ZWRcIik7dGhpcy5xYT0hMTt0aGlzLk1hPW51bGw7Zm9yKHZhciBhPTA7YTx0aGlzLnNhLmxlbmd0aDthKyspe3ZhciBiPXRoaXMuc2FbYV07YiYmXCJoXCJpbiBiLlBmJiZiLlVnJiYoYi5JJiZiLkkoXCJkaXNjb25uZWN0XCIpLGRlbGV0ZSB0aGlzLnNhW2FdLHRoaXMuYWQtLSl9MD09PXRoaXMuYWQmJih0aGlzLnNhPVtdKTt0aGlzLldkPXt9O2RpKHRoaXMpJiYodGhpcy5TYj90aGlzLk9jJiYoM0U0PChuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMuT2MmJih0aGlzLmViPTFFMyksdGhpcy5PYz1udWxsKToodGhpcy5mKFwiV2luZG93IGlzbid0IHZpc2libGUuICBEZWxheWluZyByZWNvbm5lY3QuXCIpLHRoaXMuZWI9dGhpcy5JZCx0aGlzLktlPShuZXcgRGF0ZSkuZ2V0VGltZSgpKSxhPU1hdGgubWF4KDAsdGhpcy5lYi0oKG5ldyBEYXRlKS5nZXRUaW1lKCktdGhpcy5LZSkpLGEqPU1hdGgucmFuZG9tKCksdGhpcy5mKFwiVHJ5aW5nIHRvIHJlY29ubmVjdCBpbiBcIitcbmErXCJtc1wiKSxUaCh0aGlzLGEpLHRoaXMuZWI9TWF0aC5taW4odGhpcy5JZCwxLjMqdGhpcy5lYikpO3RoaXMuWGMoITEpfTtmdW5jdGlvbiBjaShhKXtpZihkaShhKSl7YS5mKFwiTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0XCIpO2EuS2U9KG5ldyBEYXRlKS5nZXRUaW1lKCk7YS5PYz1udWxsO3ZhciBiPXUoYS5MZCxhKSxjPXUoYS5aYyxhKSxkPXUoYS5JZixhKSxlPWEuaWQrXCI6XCIrVWgrKzthLk1hPW5ldyBGaChlLGEuRyxiLGMsZCxmdW5jdGlvbihiKXtTKGIrXCIgKFwiK2EuRy50b1N0cmluZygpK1wiKVwiKTthLkJmPSEwfSxhLkZiKX19aC5DYj1mdW5jdGlvbigpe3RoaXMuSWU9ITA7dGhpcy5NYT90aGlzLk1hLmNsb3NlKCk6KHRoaXMud2ImJihjbGVhclRpbWVvdXQodGhpcy53YiksdGhpcy53Yj1udWxsKSx0aGlzLnFhJiZ0aGlzLklmKCkpfTtoLnZjPWZ1bmN0aW9uKCl7dGhpcy5JZT0hMTt0aGlzLmViPTFFMzt0aGlzLk1hfHxUaCh0aGlzLDApfTtcbmZ1bmN0aW9uIGFpKGEsYixjKXtjPWM/T2EoYyxmdW5jdGlvbihhKXtyZXR1cm4geGQoYSl9KS5qb2luKFwiJFwiKTpcImRlZmF1bHRcIjsoYT1XaChhLGIsYykpJiZhLkkmJmEuSShcInBlcm1pc3Npb25fZGVuaWVkXCIpfWZ1bmN0aW9uIFdoKGEsYixjKXtiPShuZXcgUChiKSkudG9TdHJpbmcoKTt2YXIgZDtwKGEuYmFbYl0pPyhkPWEuYmFbYl1bY10sZGVsZXRlIGEuYmFbYl1bY10sMD09PW9hKGEuYmFbYl0pJiZkZWxldGUgYS5iYVtiXSk6ZD12b2lkIDA7cmV0dXJuIGR9ZnVuY3Rpb24gYmkoYSl7WGgoYSk7dihhLmJhLGZ1bmN0aW9uKGIpe3YoYixmdW5jdGlvbihiKXtWaChhLGIpfSl9KTtmb3IodmFyIGI9MDtiPGEuc2EubGVuZ3RoO2IrKylhLnNhW2JdJiYkaChhLGIpO2Zvcig7YS5ZYy5sZW5ndGg7KWI9YS5ZYy5zaGlmdCgpLFloKGEsYi5hY3Rpb24sYi5iZCxiLmRhdGEsYi5JKX1mdW5jdGlvbiBkaShhKXt2YXIgYjtiPWpmLnliKCkub2M7cmV0dXJuIWEuQmYmJiFhLkllJiZifTt2YXIgVT17emc6ZnVuY3Rpb24oKXtvaD14aD0hMH19O1UuZm9yY2VMb25nUG9sbGluZz1VLnpnO1UuQWc9ZnVuY3Rpb24oKXtwaD0hMH07VS5mb3JjZVdlYlNvY2tldHM9VS5BZztVLiRnPWZ1bmN0aW9uKGEsYil7YS5rLlZhLiRlPWJ9O1Uuc2V0U2VjdXJpdHlEZWJ1Z0NhbGxiYWNrPVUuJGc7VS5iZj1mdW5jdGlvbihhLGIpe2Euay5iZihiKX07VS5zdGF0cz1VLmJmO1UuY2Y9ZnVuY3Rpb24oYSxiKXthLmsuY2YoYil9O1Uuc3RhdHNJbmNyZW1lbnRDb3VudGVyPVUuY2Y7VS51ZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5rLnVkfTtVLmRhdGFVcGRhdGVDb3VudD1VLnVkO1UuRGc9ZnVuY3Rpb24oYSxiKXthLmsuSGU9Yn07VS5pbnRlcmNlcHRTZXJ2ZXJEYXRhPVUuRGc7VS5KZz1mdW5jdGlvbihhKXtuZXcgT2coYSl9O1Uub25Qb3B1cE9wZW49VS5KZztVLllnPWZ1bmN0aW9uKGEpe3hnPWF9O1Uuc2V0QXV0aGVudGljYXRpb25TZXJ2ZXI9VS5ZZztmdW5jdGlvbiBlaShhLGIpe3RoaXMuY29tbWl0dGVkPWE7dGhpcy5zbmFwc2hvdD1ifTtmdW5jdGlvbiBWKGEsYil7dGhpcy5kZD1hO3RoaXMudGE9Yn1WLnByb3RvdHlwZS5jYW5jZWw9ZnVuY3Rpb24oYSl7RChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLmNhbmNlbFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtGKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuY2FuY2VsXCIsMSxhLCEwKTt2YXIgYj1uZXcgQjt0aGlzLmRkLk1kKHRoaXMudGEsQyhiLGEpKTtyZXR1cm4gYi5EfTtWLnByb3RvdHlwZS5jYW5jZWw9Vi5wcm90b3R5cGUuY2FuY2VsO1YucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXtEKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsMCwxLGFyZ3VtZW50cy5sZW5ndGgpO29nKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkucmVtb3ZlXCIsdGhpcy50YSk7RihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnJlbW92ZVwiLDEsYSwhMCk7dmFyIGI9bmV3IEI7ZmkodGhpcy5kZCx0aGlzLnRhLG51bGwsQyhiLGEpKTtyZXR1cm4gYi5EfTtcblYucHJvdG90eXBlLnJlbW92ZT1WLnByb3RvdHlwZS5yZW1vdmU7Vi5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtvZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFwiLHRoaXMudGEpO2dnKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0XCIsYSx0aGlzLnRhLCExKTtGKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0XCIsMixiLCEwKTt2YXIgYz1uZXcgQjtmaSh0aGlzLmRkLHRoaXMudGEsYSxDKGMsYikpO3JldHVybiBjLkR9O1YucHJvdG90eXBlLnNldD1WLnByb3RvdHlwZS5zZXQ7XG5WLnByb3RvdHlwZS5PYj1mdW5jdGlvbihhLGIsYyl7RChcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtvZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLHRoaXMudGEpO2dnKFwiRmlyZWJhc2Uub25EaXNjb25uZWN0KCkuc2V0V2l0aFByaW9yaXR5XCIsYSx0aGlzLnRhLCExKTtrZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLDIsYik7RihcIkZpcmViYXNlLm9uRGlzY29ubmVjdCgpLnNldFdpdGhQcmlvcml0eVwiLDMsYywhMCk7dmFyIGQ9bmV3IEI7Z2kodGhpcy5kZCx0aGlzLnRhLGEsYixDKGQsYykpO3JldHVybiBkLkR9O1YucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eT1WLnByb3RvdHlwZS5PYjtcblYucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGIpe0QoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7b2coXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIix0aGlzLnRhKTtpZihkYShhKSl7Zm9yKHZhciBjPXt9LGQ9MDtkPGEubGVuZ3RoOysrZCljW1wiXCIrZF09YVtkXTthPWM7UyhcIlBhc3NpbmcgYW4gQXJyYXkgdG8gRmlyZWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YSwgb3IgYW4gT2JqZWN0IHdpdGggaW50ZWdlciBrZXlzIGlmIHlvdSByZWFsbHkgZG8gd2FudCB0byBvbmx5IHVwZGF0ZSBzb21lIG9mIHRoZSBjaGlsZHJlbi5cIil9amcoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIixhLHRoaXMudGEpO0YoXCJGaXJlYmFzZS5vbkRpc2Nvbm5lY3QoKS51cGRhdGVcIiwyLGIsITApO1xuYz1uZXcgQjtoaSh0aGlzLmRkLHRoaXMudGEsYSxDKGMsYikpO3JldHVybiBjLkR9O1YucHJvdG90eXBlLnVwZGF0ZT1WLnByb3RvdHlwZS51cGRhdGU7ZnVuY3Rpb24gVyhhLGIsYyl7dGhpcy5BPWE7dGhpcy5ZPWI7dGhpcy5nPWN9Vy5wcm90b3R5cGUuSj1mdW5jdGlvbigpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QudmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSigpfTtXLnByb3RvdHlwZS52YWw9Vy5wcm90b3R5cGUuSjtXLnByb3RvdHlwZS5xZj1mdW5jdGlvbigpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhwb3J0VmFsXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuSighMCl9O1cucHJvdG90eXBlLmV4cG9ydFZhbD1XLnByb3RvdHlwZS5xZjtXLnByb3RvdHlwZS54Zz1mdW5jdGlvbigpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZXhpc3RzXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiF0aGlzLkEuZSgpfTtXLnByb3RvdHlwZS5leGlzdHM9Vy5wcm90b3R5cGUueGc7XG5XLnByb3RvdHlwZS5vPWZ1bmN0aW9uKGEpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIiwwLDEsYXJndW1lbnRzLmxlbmd0aCk7ZmEoYSkmJihhPVN0cmluZyhhKSk7bmcoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuY2hpbGRcIixhKTt2YXIgYj1uZXcgUChhKSxjPXRoaXMuWS5vKGIpO3JldHVybiBuZXcgVyh0aGlzLkEuUyhiKSxjLFIpfTtXLnByb3RvdHlwZS5jaGlsZD1XLnByb3RvdHlwZS5vO1cucHJvdG90eXBlLkZhPWZ1bmN0aW9uKGEpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuaGFzQ2hpbGRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7bmcoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuaGFzQ2hpbGRcIixhKTt2YXIgYj1uZXcgUChhKTtyZXR1cm4hdGhpcy5BLlMoYikuZSgpfTtXLnByb3RvdHlwZS5oYXNDaGlsZD1XLnByb3RvdHlwZS5GYTtcblcucHJvdG90eXBlLkM9ZnVuY3Rpb24oKXtEKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmdldFByaW9yaXR5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLkEuQygpLkooKX07Vy5wcm90b3R5cGUuZ2V0UHJpb3JpdHk9Vy5wcm90b3R5cGUuQztXLnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGEpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QuZm9yRWFjaFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtGKFwiRmlyZWJhc2UuRGF0YVNuYXBzaG90LmZvckVhY2hcIiwxLGEsITEpO2lmKHRoaXMuQS5MKCkpcmV0dXJuITE7dmFyIGI9dGhpcztyZXR1cm4hIXRoaXMuQS5SKHRoaXMuZyxmdW5jdGlvbihjLGQpe3JldHVybiBhKG5ldyBXKGQsYi5ZLm8oYyksUikpfSl9O1cucHJvdG90eXBlLmZvckVhY2g9Vy5wcm90b3R5cGUuZm9yRWFjaDtcblcucHJvdG90eXBlLnpkPWZ1bmN0aW9uKCl7RChcIkZpcmViYXNlLkRhdGFTbmFwc2hvdC5oYXNDaGlsZHJlblwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5BLkwoKT8hMTohdGhpcy5BLmUoKX07Vy5wcm90b3R5cGUuaGFzQ2hpbGRyZW49Vy5wcm90b3R5cGUuemQ7Vy5wcm90b3R5cGUubmFtZT1mdW5jdGlvbigpe1MoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubmFtZSgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2UuRGF0YVNuYXBzaG90LmtleSgpIGluc3RlYWQuXCIpO0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubmFtZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5rZXkoKX07Vy5wcm90b3R5cGUubmFtZT1XLnByb3RvdHlwZS5uYW1lO1cucHJvdG90eXBlLmtleT1mdW5jdGlvbigpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3Qua2V5XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLlkua2V5KCl9O1xuVy5wcm90b3R5cGUua2V5PVcucHJvdG90eXBlLmtleTtXLnByb3RvdHlwZS5IYj1mdW5jdGlvbigpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QubnVtQ2hpbGRyZW5cIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuQS5IYigpfTtXLnByb3RvdHlwZS5udW1DaGlsZHJlbj1XLnByb3RvdHlwZS5IYjtXLnByb3RvdHlwZS5NYj1mdW5jdGlvbigpe0QoXCJGaXJlYmFzZS5EYXRhU25hcHNob3QucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLll9O1cucHJvdG90eXBlLnJlZj1XLnByb3RvdHlwZS5NYjtmdW5jdGlvbiBpaShhLGIsYyl7dGhpcy5WYj1hO3RoaXMudGI9Yjt0aGlzLnZiPWN8fG51bGx9aD1paS5wcm90b3R5cGU7aC5RZj1mdW5jdGlvbihhKXtyZXR1cm5cInZhbHVlXCI9PT1hfTtoLmNyZWF0ZUV2ZW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5uLmc7cmV0dXJuIG5ldyBqYyhcInZhbHVlXCIsdGhpcyxuZXcgVyhhLk5hLGIuTWIoKSxjKSl9O2guWmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy52YjtpZihcImNhbmNlbFwiPT09YS5EZSgpKXtPKHRoaXMudGIsXCJSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2tcIik7dmFyIGM9dGhpcy50YjtyZXR1cm4gZnVuY3Rpb24oKXtjLmNhbGwoYixhLmVycm9yKX19dmFyIGQ9dGhpcy5WYjtyZXR1cm4gZnVuY3Rpb24oKXtkLmNhbGwoYixhLmJlKX19O2gubGY9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy50Yj9uZXcga2ModGhpcyxhLGIpOm51bGx9O1xuaC5tYXRjaGVzPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgaWk/YS5WYiYmdGhpcy5WYj9hLlZiPT09dGhpcy5WYiYmYS52Yj09PXRoaXMudmI6ITA6ITF9O2gueWY9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuVmJ9O2Z1bmN0aW9uIGppKGEsYixjKXt0aGlzLmphPWE7dGhpcy50Yj1iO3RoaXMudmI9Y31oPWppLnByb3RvdHlwZTtoLlFmPWZ1bmN0aW9uKGEpe2E9XCJjaGlsZHJlbl9hZGRlZFwiPT09YT9cImNoaWxkX2FkZGVkXCI6YTtyZXR1cm4oXCJjaGlsZHJlbl9yZW1vdmVkXCI9PT1hP1wiY2hpbGRfcmVtb3ZlZFwiOmEpaW4gdGhpcy5qYX07aC5sZj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnRiP25ldyBrYyh0aGlzLGEsYik6bnVsbH07XG5oLmNyZWF0ZUV2ZW50PWZ1bmN0aW9uKGEsYil7TyhudWxsIT1hLlphLFwiQ2hpbGQgZXZlbnRzIHNob3VsZCBoYXZlIGEgY2hpbGROYW1lLlwiKTt2YXIgYz1iLk1iKCkubyhhLlphKTtyZXR1cm4gbmV3IGpjKGEudHlwZSx0aGlzLG5ldyBXKGEuTmEsYyxiLm4uZyksYS5UZCl9O2guWmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy52YjtpZihcImNhbmNlbFwiPT09YS5EZSgpKXtPKHRoaXMudGIsXCJSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2tcIik7dmFyIGM9dGhpcy50YjtyZXR1cm4gZnVuY3Rpb24oKXtjLmNhbGwoYixhLmVycm9yKX19dmFyIGQ9dGhpcy5qYVthLndkXTtyZXR1cm4gZnVuY3Rpb24oKXtkLmNhbGwoYixhLmJlLGEuVGQpfX07XG5oLm1hdGNoZXM9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIGppKXtpZighdGhpcy5qYXx8IWEuamEpcmV0dXJuITA7aWYodGhpcy52Yj09PWEudmIpe3ZhciBiPW9hKGEuamEpO2lmKGI9PT1vYSh0aGlzLmphKSl7aWYoMT09PWIpe3ZhciBiPXBhKGEuamEpLGM9cGEodGhpcy5qYSk7cmV0dXJuIGM9PT1iJiYoIWEuamFbYl18fCF0aGlzLmphW2NdfHxhLmphW2JdPT09dGhpcy5qYVtjXSl9cmV0dXJuIG5hKHRoaXMuamEsZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5qYVtjXT09PWJ9KX19fXJldHVybiExfTtoLnlmPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmphfTtmdW5jdGlvbiBraSgpe3RoaXMuemE9e319aD1raS5wcm90b3R5cGU7aC5lPWZ1bmN0aW9uKCl7cmV0dXJuIHZhKHRoaXMuemEpfTtoLmdiPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLnNvdXJjZS5MYjtpZihudWxsIT09ZClyZXR1cm4gZD16KHRoaXMuemEsZCksTyhudWxsIT1kLFwiU3luY1RyZWUgZ2F2ZSB1cyBhbiBvcCBmb3IgYW4gaW52YWxpZCBxdWVyeS5cIiksZC5nYihhLGIsYyk7dmFyIGU9W107dih0aGlzLnphLGZ1bmN0aW9uKGQpe2U9ZS5jb25jYXQoZC5nYihhLGIsYykpfSk7cmV0dXJuIGV9O2guVGI9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1hLndhKCksZz16KHRoaXMuemEsZik7aWYoIWcpe3ZhciBnPWMuQWEoZT9kOm51bGwpLGs9ITE7Zz9rPSEwOihnPWQgaW5zdGFuY2VvZiBmZT9jLkNjKGQpOkgsaz0hMSk7Zz1uZXcgWWUoYSxuZXcgamUobmV3IFhiKGcsaywhMSksbmV3IFhiKGQsZSwhMSkpKTt0aGlzLnphW2ZdPWd9Zy5UYihiKTtyZXR1cm4gYWYoZyxiKX07XG5oLm5iPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLndhKCksZT1bXSxmPVtdLGc9bnVsbCE9bGkodGhpcyk7aWYoXCJkZWZhdWx0XCI9PT1kKXt2YXIgaz10aGlzO3YodGhpcy56YSxmdW5jdGlvbihhLGQpe2Y9Zi5jb25jYXQoYS5uYihiLGMpKTthLmUoKSYmKGRlbGV0ZSBrLnphW2RdLEhlKGEuWS5uKXx8ZS5wdXNoKGEuWSkpfSl9ZWxzZXt2YXIgbT16KHRoaXMuemEsZCk7bSYmKGY9Zi5jb25jYXQobS5uYihiLGMpKSxtLmUoKSYmKGRlbGV0ZSB0aGlzLnphW2RdLEhlKG0uWS5uKXx8ZS5wdXNoKG0uWSkpKX1nJiZudWxsPT1saSh0aGlzKSYmZS5wdXNoKG5ldyBYKGEuayxhLnBhdGgpKTtyZXR1cm57Vmc6ZSx2ZzpmfX07ZnVuY3Rpb24gbWkoYSl7cmV0dXJuIE5hKHFhKGEuemEpLGZ1bmN0aW9uKGEpe3JldHVybiFIZShhLlkubil9KX1oLmtiPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGw7dih0aGlzLnphLGZ1bmN0aW9uKGMpe2I9Ynx8Yy5rYihhKX0pO3JldHVybiBifTtcbmZ1bmN0aW9uIG5pKGEsYil7aWYoSGUoYi5uKSlyZXR1cm4gbGkoYSk7dmFyIGM9Yi53YSgpO3JldHVybiB6KGEuemEsYyl9ZnVuY3Rpb24gbGkoYSl7cmV0dXJuIHVhKGEuemEsZnVuY3Rpb24oYSl7cmV0dXJuIEhlKGEuWS5uKX0pfHxudWxsfTtmdW5jdGlvbiBvaShhKXt0aGlzLnZhPXFlO3RoaXMubWI9bmV3IFBmO3RoaXMuZGY9e307dGhpcy5xYz17fTt0aGlzLlFjPWF9ZnVuY3Rpb24gcGkoYSxiLGMsZCxlKXt2YXIgZj1hLm1iLGc9ZTtPKGQ+Zi5QYyxcIlN0YWNraW5nIGFuIG9sZGVyIHdyaXRlIG9uIHRvcCBvZiBuZXdlciBvbmVzXCIpO3AoZyl8fChnPSEwKTtmLnBhLnB1c2goe3BhdGg6YixKYTpjLG1kOmQsdmlzaWJsZTpnfSk7ZyYmKGYuVj1KZihmLlYsYixjKSk7Zi5QYz1kO3JldHVybiBlP3FpKGEsbmV3IEFjKEVmLGIsYykpOltdfWZ1bmN0aW9uIHJpKGEsYixjLGQpe3ZhciBlPWEubWI7TyhkPmUuUGMsXCJTdGFja2luZyBhbiBvbGRlciBtZXJnZSBvbiB0b3Agb2YgbmV3ZXIgb25lc1wiKTtlLnBhLnB1c2goe3BhdGg6YixjaGlsZHJlbjpjLG1kOmQsdmlzaWJsZTohMH0pO2UuVj1LZihlLlYsYixjKTtlLlBjPWQ7Yz1zZihjKTtyZXR1cm4gcWkoYSxuZXcgYmYoRWYsYixjKSl9XG5mdW5jdGlvbiBzaShhLGIsYyl7Yz1jfHwhMTt2YXIgZD1RZihhLm1iLGIpO2lmKGEubWIuVWQoYikpe3ZhciBlPXFlO251bGwhPWQuSmE/ZT1lLnNldChNLCEwKTpGYihkLmNoaWxkcmVuLGZ1bmN0aW9uKGEsYil7ZT1lLnNldChuZXcgUChhKSxiKX0pO3JldHVybiBxaShhLG5ldyBEZihkLnBhdGgsZSxjKSl9cmV0dXJuW119ZnVuY3Rpb24gdGkoYSxiLGMpe2M9c2YoYyk7cmV0dXJuIHFpKGEsbmV3IGJmKEdmLGIsYykpfWZ1bmN0aW9uIHVpKGEsYixjLGQpe2Q9dmkoYSxkKTtpZihudWxsIT1kKXt2YXIgZT13aShkKTtkPWUucGF0aDtlPWUuTGI7Yj1sZihkLGIpO2M9bmV3IEFjKG5ldyBGZighMSwhMCxlLCEwKSxiLGMpO3JldHVybiB4aShhLGQsYyl9cmV0dXJuW119XG5mdW5jdGlvbiB5aShhLGIsYyxkKXtpZihkPXZpKGEsZCkpe3ZhciBlPXdpKGQpO2Q9ZS5wYXRoO2U9ZS5MYjtiPWxmKGQsYik7Yz1zZihjKTtjPW5ldyBiZihuZXcgRmYoITEsITAsZSwhMCksYixjKTtyZXR1cm4geGkoYSxkLGMpfXJldHVybltdfVxub2kucHJvdG90eXBlLlRiPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wYXRoLGQ9bnVsbCxlPSExO3pmKHRoaXMudmEsYyxmdW5jdGlvbihhLGIpe3ZhciBmPWxmKGEsYyk7ZD1kfHxiLmtiKGYpO2U9ZXx8bnVsbCE9bGkoYil9KTt2YXIgZj10aGlzLnZhLmdldChjKTtmPyhlPWV8fG51bGwhPWxpKGYpLGQ9ZHx8Zi5rYihNKSk6KGY9bmV3IGtpLHRoaXMudmE9dGhpcy52YS5zZXQoYyxmKSk7dmFyIGc7bnVsbCE9ZD9nPSEwOihnPSExLGQ9SCxDZih0aGlzLnZhLnN1YnRyZWUoYyksZnVuY3Rpb24oYSxiKXt2YXIgYz1iLmtiKE0pO2MmJihkPWQuVyhhLGMpKX0pKTt2YXIgaz1udWxsIT1uaShmLGEpO2lmKCFrJiYhSGUoYS5uKSl7dmFyIG09emkoYSk7TyghKG0gaW4gdGhpcy5xYyksXCJWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZ1wiKTt2YXIgbD1BaSsrO3RoaXMucWNbbV09bDt0aGlzLmRmW1wiX1wiK2xdPW19Zz1mLlRiKGEsYixuZXcgVWYoYyx0aGlzLm1iKSxkLGcpO1xua3x8ZXx8KGY9bmkoZixhKSxnPWcuY29uY2F0KEJpKHRoaXMsYSxmKSkpO3JldHVybiBnfTtcbm9pLnByb3RvdHlwZS5uYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5wYXRoLGU9dGhpcy52YS5nZXQoZCksZj1bXTtpZihlJiYoXCJkZWZhdWx0XCI9PT1hLndhKCl8fG51bGwhPW5pKGUsYSkpKXtmPWUubmIoYSxiLGMpO2UuZSgpJiYodGhpcy52YT10aGlzLnZhLnJlbW92ZShkKSk7ZT1mLlZnO2Y9Zi52ZztiPS0xIT09U2EoZSxmdW5jdGlvbihhKXtyZXR1cm4gSGUoYS5uKX0pO3ZhciBnPXhmKHRoaXMudmEsZCxmdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1saShiKX0pO2lmKGImJiFnJiYoZD10aGlzLnZhLnN1YnRyZWUoZCksIWQuZSgpKSlmb3IodmFyIGQ9Q2koZCksaz0wO2s8ZC5sZW5ndGg7KytrKXt2YXIgbT1kW2tdLGw9bS5ZLG09RGkodGhpcyxtKTt0aGlzLlFjLmFmKEVpKGwpLEZpKHRoaXMsbCksbS5BZCxtLkkpfWlmKCFnJiYwPGUubGVuZ3RoJiYhYylpZihiKXRoaXMuUWMuZGUoRWkoYSksbnVsbCk7ZWxzZXt2YXIgdD10aGlzO01hKGUsZnVuY3Rpb24oYSl7YS53YSgpO1xudmFyIGI9dC5xY1t6aShhKV07dC5RYy5kZShFaShhKSxiKX0pfUdpKHRoaXMsZSl9cmV0dXJuIGZ9O29pLnByb3RvdHlwZS5BYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMubWIsZD14Zih0aGlzLnZhLGEsZnVuY3Rpb24oYixjKXt2YXIgZD1sZihiLGEpO2lmKGQ9Yy5rYihkKSlyZXR1cm4gZH0pO3JldHVybiBjLkFhKGEsZCxiLCEwKX07ZnVuY3Rpb24gQ2koYSl7cmV0dXJuIHZmKGEsZnVuY3Rpb24oYSxjLGQpe2lmKGMmJm51bGwhPWxpKGMpKXJldHVybltsaShjKV07dmFyIGU9W107YyYmKGU9bWkoYykpO3YoZCxmdW5jdGlvbihhKXtlPWUuY29uY2F0KGEpfSk7cmV0dXJuIGV9KX1mdW5jdGlvbiBHaShhLGIpe2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7KytjKXt2YXIgZD1iW2NdO2lmKCFIZShkLm4pKXt2YXIgZD16aShkKSxlPWEucWNbZF07ZGVsZXRlIGEucWNbZF07ZGVsZXRlIGEuZGZbXCJfXCIrZV19fX1cbmZ1bmN0aW9uIEVpKGEpe3JldHVybiBIZShhLm4pJiYhSWUoYS5uKT9hLk1iKCk6YX1mdW5jdGlvbiBCaShhLGIsYyl7dmFyIGQ9Yi5wYXRoLGU9RmkoYSxiKTtjPURpKGEsYyk7Yj1hLlFjLmFmKEVpKGIpLGUsYy5BZCxjLkkpO2Q9YS52YS5zdWJ0cmVlKGQpO2lmKGUpTyhudWxsPT1saShkLnZhbHVlKSxcIklmIHdlJ3JlIGFkZGluZyBhIHF1ZXJ5LCBpdCBzaG91bGRuJ3QgYmUgc2hhZG93ZWRcIik7ZWxzZSBmb3IoZT12ZihkLGZ1bmN0aW9uKGEsYixjKXtpZighYS5lKCkmJmImJm51bGwhPWxpKGIpKXJldHVybltaZShsaShiKSldO3ZhciBkPVtdO2ImJihkPWQuY29uY2F0KE9hKG1pKGIpLGZ1bmN0aW9uKGEpe3JldHVybiBhLll9KSkpO3YoYyxmdW5jdGlvbihhKXtkPWQuY29uY2F0KGEpfSk7cmV0dXJuIGR9KSxkPTA7ZDxlLmxlbmd0aDsrK2QpYz1lW2RdLGEuUWMuZGUoRWkoYyksRmkoYSxjKSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiBEaShhLGIpe3ZhciBjPWIuWSxkPUZpKGEsYyk7cmV0dXJue0FkOmZ1bmN0aW9uKCl7cmV0dXJuKGIudygpfHxIKS5oYXNoKCl9LEk6ZnVuY3Rpb24oYil7aWYoXCJva1wiPT09Yil7aWYoZCl7dmFyIGY9Yy5wYXRoO2lmKGI9dmkoYSxkKSl7dmFyIGc9d2koYik7Yj1nLnBhdGg7Zz1nLkxiO2Y9bGYoYixmKTtmPW5ldyBDYyhuZXcgRmYoITEsITAsZywhMCksZik7Yj14aShhLGIsZil9ZWxzZSBiPVtdfWVsc2UgYj1xaShhLG5ldyBDYyhHZixjLnBhdGgpKTtyZXR1cm4gYn1mPVwiVW5rbm93biBFcnJvclwiO1widG9vX2JpZ1wiPT09Yj9mPVwiVGhlIGRhdGEgcmVxdWVzdGVkIGV4Y2VlZHMgdGhlIG1heGltdW0gc2l6ZSB0aGF0IGNhbiBiZSBhY2Nlc3NlZCB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuXCI6XCJwZXJtaXNzaW9uX2RlbmllZFwiPT1iP2Y9XCJDbGllbnQgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBkZXNpcmVkIGRhdGEuXCI6XCJ1bmF2YWlsYWJsZVwiPT1iJiZcbihmPVwiVGhlIHNlcnZpY2UgaXMgdW5hdmFpbGFibGVcIik7Zj1FcnJvcihiK1wiIGF0IFwiK2MucGF0aC50b1N0cmluZygpK1wiOiBcIitmKTtmLmNvZGU9Yi50b1VwcGVyQ2FzZSgpO3JldHVybiBhLm5iKGMsbnVsbCxmKX19fWZ1bmN0aW9uIHppKGEpe3JldHVybiBhLnBhdGgudG9TdHJpbmcoKStcIiRcIithLndhKCl9ZnVuY3Rpb24gd2koYSl7dmFyIGI9YS5pbmRleE9mKFwiJFwiKTtPKC0xIT09YiYmYjxhLmxlbmd0aC0xLFwiQmFkIHF1ZXJ5S2V5LlwiKTtyZXR1cm57TGI6YS5zdWJzdHIoYisxKSxwYXRoOm5ldyBQKGEuc3Vic3RyKDAsYikpfX1mdW5jdGlvbiB2aShhLGIpe3ZhciBjPWEuZGYsZD1cIl9cIitiO3JldHVybiBkIGluIGM/Y1tkXTp2b2lkIDB9ZnVuY3Rpb24gRmkoYSxiKXt2YXIgYz16aShiKTtyZXR1cm4geihhLnFjLGMpfXZhciBBaT0xO1xuZnVuY3Rpb24geGkoYSxiLGMpe3ZhciBkPWEudmEuZ2V0KGIpO08oZCxcIk1pc3Npbmcgc3luYyBwb2ludCBmb3IgcXVlcnkgdGFnIHRoYXQgd2UncmUgdHJhY2tpbmdcIik7cmV0dXJuIGQuZ2IoYyxuZXcgVWYoYixhLm1iKSxudWxsKX1mdW5jdGlvbiBxaShhLGIpe3JldHVybiBIaShhLGIsYS52YSxudWxsLG5ldyBVZihNLGEubWIpKX1mdW5jdGlvbiBIaShhLGIsYyxkLGUpe2lmKGIucGF0aC5lKCkpcmV0dXJuIElpKGEsYixjLGQsZSk7dmFyIGY9Yy5nZXQoTSk7bnVsbD09ZCYmbnVsbCE9ZiYmKGQ9Zi5rYihNKSk7dmFyIGc9W10saz1LKGIucGF0aCksbT1iLiRjKGspO2lmKChjPWMuY2hpbGRyZW4uZ2V0KGspKSYmbSl2YXIgbD1kP2QuVChrKTpudWxsLGs9ZS5vKGspLGc9Zy5jb25jYXQoSGkoYSxtLGMsbCxrKSk7ZiYmKGc9Zy5jb25jYXQoZi5nYihiLGUsZCkpKTtyZXR1cm4gZ31cbmZ1bmN0aW9uIElpKGEsYixjLGQsZSl7dmFyIGY9Yy5nZXQoTSk7bnVsbD09ZCYmbnVsbCE9ZiYmKGQ9Zi5rYihNKSk7dmFyIGc9W107Yy5jaGlsZHJlbi5rYShmdW5jdGlvbihjLGYpe3ZhciBsPWQ/ZC5UKGMpOm51bGwsdD1lLm8oYyksQT1iLiRjKGMpO0EmJihnPWcuY29uY2F0KElpKGEsQSxmLGwsdCkpKX0pO2YmJihnPWcuY29uY2F0KGYuZ2IoYixlLGQpKSk7cmV0dXJuIGd9O2Z1bmN0aW9uIEppKGEsYil7dGhpcy5HPWE7dGhpcy5YYT11YyhhKTt0aGlzLmhkPW51bGw7dGhpcy5mYT1uZXcgWmI7dGhpcy5LZD0xO3RoaXMuVmE9bnVsbDtifHwwPD0oXCJvYmplY3RcIj09PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5uYXZpZ2F0b3ImJndpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50fHxcIlwiKS5zZWFyY2goL2dvb2dsZWJvdHxnb29nbGUgd2VibWFzdGVyIHRvb2xzfGJpbmdib3R8eWFob28hIHNsdXJwfGJhaWR1c3BpZGVyfHlhbmRleGJvdHxkdWNrZHVja2JvdC9pKT8odGhpcy5kYT1uZXcgY2YodGhpcy5HLHUodGhpcy5LYix0aGlzKSksc2V0VGltZW91dCh1KHRoaXMuWGMsdGhpcywhMCksMCkpOnRoaXMuZGE9dGhpcy5WYT1uZXcgUmgodGhpcy5HLHUodGhpcy5LYix0aGlzKSx1KHRoaXMuWGMsdGhpcyksdSh0aGlzLlNlLHRoaXMpKTt0aGlzLmRoPXZjKGEsdShmdW5jdGlvbigpe3JldHVybiBuZXcgcGModGhpcy5YYSx0aGlzLmRhKX0sdGhpcykpO3RoaXMueWM9bmV3IFdmO1xudGhpcy5HZT1uZXcgU2I7dmFyIGM9dGhpczt0aGlzLkZkPW5ldyBvaSh7YWY6ZnVuY3Rpb24oYSxiLGYsZyl7Yj1bXTtmPWMuR2UuaihhLnBhdGgpO2YuZSgpfHwoYj1xaShjLkZkLG5ldyBBYyhHZixhLnBhdGgsZikpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtnKFwib2tcIil9LDApKTtyZXR1cm4gYn0sZGU6YWF9KTtLaSh0aGlzLFwiY29ubmVjdGVkXCIsITEpO3RoaXMubmE9bmV3IFZjO3RoaXMuTz1uZXcgWWcoYSx1KHRoaXMuZGEuTyx0aGlzLmRhKSx1KHRoaXMuZGEuamUsdGhpcy5kYSksdSh0aGlzLlBlLHRoaXMpKTt0aGlzLnVkPTA7dGhpcy5IZT1udWxsO3RoaXMuTT1uZXcgb2koe2FmOmZ1bmN0aW9uKGEsYixmLGcpe2MuZGEuQ2YoYSxmLGIsZnVuY3Rpb24oYixlKXt2YXIgZj1nKGIsZSk7ZGMoYy5mYSxhLnBhdGgsZil9KTtyZXR1cm5bXX0sZGU6ZnVuY3Rpb24oYSxiKXtjLmRhLiRmKGEsYil9fSl9aD1KaS5wcm90b3R5cGU7XG5oLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuRy5vYj9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuRy5ob3N0fTtoLm5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5HLmxjfTtmdW5jdGlvbiBMaShhKXthPWEuR2UuaihuZXcgUChcIi5pbmZvL3NlcnZlclRpbWVPZmZzZXRcIikpLkooKXx8MDtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKSthfWZ1bmN0aW9uIE1pKGEpe2E9YT17dGltZXN0YW1wOkxpKGEpfTthLnRpbWVzdGFtcD1hLnRpbWVzdGFtcHx8KG5ldyBEYXRlKS5nZXRUaW1lKCk7cmV0dXJuIGF9XG5oLktiPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMudWQrKzt2YXIgZT1uZXcgUChhKTtiPXRoaXMuSGU/dGhpcy5IZShhLGIpOmI7YT1bXTtkP2M/KGI9bWEoYixmdW5jdGlvbihhKXtyZXR1cm4gUShhKX0pLGE9eWkodGhpcy5NLGUsYixkKSk6KGI9UShiKSxhPXVpKHRoaXMuTSxlLGIsZCkpOmM/KGQ9bWEoYixmdW5jdGlvbihhKXtyZXR1cm4gUShhKX0pLGE9dGkodGhpcy5NLGUsZCkpOihkPVEoYiksYT1xaSh0aGlzLk0sbmV3IEFjKEdmLGUsZCkpKTtkPWU7MDxhLmxlbmd0aCYmKGQ9TmkodGhpcyxlKSk7ZGModGhpcy5mYSxkLGEpfTtoLlhjPWZ1bmN0aW9uKGEpe0tpKHRoaXMsXCJjb25uZWN0ZWRcIixhKTshMT09PWEmJk9pKHRoaXMpfTtoLlNlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7emQoYSxmdW5jdGlvbihhLGQpe0tpKGIsZCxhKX0pfTtoLlBlPWZ1bmN0aW9uKGEpe0tpKHRoaXMsXCJhdXRoZW50aWNhdGVkXCIsYSl9O1xuZnVuY3Rpb24gS2koYSxiLGMpe2I9bmV3IFAoXCIvLmluZm8vXCIrYik7Yz1RKGMpO3ZhciBkPWEuR2U7ZC5aZD1kLlpkLkgoYixjKTtjPXFpKGEuRmQsbmV3IEFjKEdmLGIsYykpO2RjKGEuZmEsYixjKX1oLk9iPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuZihcInNldFwiLHtwYXRoOmEudG9TdHJpbmcoKSx2YWx1ZTpiLG1oOmN9KTt2YXIgZT1NaSh0aGlzKTtiPVEoYixjKTt2YXIgZT1YYyhiLGUpLGY9dGhpcy5LZCsrLGU9cGkodGhpcy5NLGEsZSxmLCEwKTskYih0aGlzLmZhLGUpO3ZhciBnPXRoaXM7dGhpcy5kYS5wdXQoYS50b1N0cmluZygpLGIuSighMCksZnVuY3Rpb24oYixjKXt2YXIgZT1cIm9rXCI9PT1iO2V8fFMoXCJzZXQgYXQgXCIrYStcIiBmYWlsZWQ6IFwiK2IpO2U9c2koZy5NLGYsIWUpO2RjKGcuZmEsYSxlKTtQaShkLGIsYyl9KTtlPVFpKHRoaXMsYSk7TmkodGhpcyxlKTtkYyh0aGlzLmZhLGUsW10pfTtcbmgudXBkYXRlPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmYoXCJ1cGRhdGVcIix7cGF0aDphLnRvU3RyaW5nKCksdmFsdWU6Yn0pO3ZhciBkPSEwLGU9TWkodGhpcyksZj17fTt2KGIsZnVuY3Rpb24oYSxiKXtkPSExO3ZhciBjPVEoYSk7ZltiXT1YYyhjLGUpfSk7aWYoZClmYyhcInVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIiksUGkoYyxcIm9rXCIpO2Vsc2V7dmFyIGc9dGhpcy5LZCsrLGs9cmkodGhpcy5NLGEsZixnKTskYih0aGlzLmZhLGspO3ZhciBtPXRoaXM7dGhpcy5kYS5EZihhLnRvU3RyaW5nKCksYixmdW5jdGlvbihiLGQpe3ZhciBlPVwib2tcIj09PWI7ZXx8UyhcInVwZGF0ZSBhdCBcIithK1wiIGZhaWxlZDogXCIrYik7dmFyIGU9c2kobS5NLGcsIWUpLGY9YTswPGUubGVuZ3RoJiYoZj1OaShtLGEpKTtkYyhtLmZhLGYsZSk7UGkoYyxiLGQpfSk7Yj1RaSh0aGlzLGEpO05pKHRoaXMsYik7ZGModGhpcy5mYSxhLFtdKX19O1xuZnVuY3Rpb24gT2koYSl7YS5mKFwib25EaXNjb25uZWN0RXZlbnRzXCIpO3ZhciBiPU1pKGEpLGM9W107V2MoVWMoYS5uYSxiKSxNLGZ1bmN0aW9uKGIsZSl7Yz1jLmNvbmNhdChxaShhLk0sbmV3IEFjKEdmLGIsZSkpKTt2YXIgZj1RaShhLGIpO05pKGEsZil9KTthLm5hPW5ldyBWYztkYyhhLmZhLE0sYyl9aC5NZD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5kYS5NZChhLnRvU3RyaW5nKCksZnVuY3Rpb24oZCxlKXtcIm9rXCI9PT1kJiZ3ZyhjLm5hLGEpO1BpKGIsZCxlKX0pfTtmdW5jdGlvbiBmaShhLGIsYyxkKXt2YXIgZT1RKGMpO2EuZGEuUWUoYi50b1N0cmluZygpLGUuSighMCksZnVuY3Rpb24oYyxnKXtcIm9rXCI9PT1jJiZhLm5hLnJjKGIsZSk7UGkoZCxjLGcpfSl9ZnVuY3Rpb24gZ2koYSxiLGMsZCxlKXt2YXIgZj1RKGMsZCk7YS5kYS5RZShiLnRvU3RyaW5nKCksZi5KKCEwKSxmdW5jdGlvbihjLGQpe1wib2tcIj09PWMmJmEubmEucmMoYixmKTtQaShlLGMsZCl9KX1cbmZ1bmN0aW9uIGhpKGEsYixjLGQpe3ZhciBlPSEwLGY7Zm9yKGYgaW4gYyllPSExO2U/KGZjKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKSxQaShkLFwib2tcIikpOmEuZGEuR2YoYi50b1N0cmluZygpLGMsZnVuY3Rpb24oZSxmKXtpZihcIm9rXCI9PT1lKWZvcih2YXIgbSBpbiBjKXt2YXIgbD1RKGNbbV0pO2EubmEucmMoYi5vKG0pLGwpfVBpKGQsZSxmKX0pfWZ1bmN0aW9uIFJpKGEsYixjKXtjPVwiLmluZm9cIj09PUsoYi5wYXRoKT9hLkZkLlRiKGIsYyk6YS5NLlRiKGIsYyk7YmMoYS5mYSxiLnBhdGgsYyl9aC5DYj1mdW5jdGlvbigpe3RoaXMuVmEmJnRoaXMuVmEuQ2IoKX07aC52Yz1mdW5jdGlvbigpe3RoaXMuVmEmJnRoaXMuVmEudmMoKX07XG5oLmJmPWZ1bmN0aW9uKGEpe2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7YT8odGhpcy5oZHx8KHRoaXMuaGQ9bmV3IG9jKHRoaXMuWGEpKSxhPXRoaXMuaGQuZ2V0KCkpOmE9dGhpcy5YYS5nZXQoKTt2YXIgYj1QYShyYShhKSxmdW5jdGlvbihhLGIpe3JldHVybiBNYXRoLm1heChiLmxlbmd0aCxhKX0sMCksYztmb3IoYyBpbiBhKXtmb3IodmFyIGQ9YVtjXSxlPWMubGVuZ3RoO2U8YisyO2UrKyljKz1cIiBcIjtjb25zb2xlLmxvZyhjK2QpfX19O2guY2Y9ZnVuY3Rpb24oYSl7cmModGhpcy5YYSxhKTt0aGlzLmRoLlZmW2FdPSEwfTtoLmY9ZnVuY3Rpb24oYSl7dmFyIGI9XCJcIjt0aGlzLlZhJiYoYj10aGlzLlZhLmlkK1wiOlwiKTtmYyhiLGFyZ3VtZW50cyl9O1xuZnVuY3Rpb24gUGkoYSxiLGMpe2EmJmdjKGZ1bmN0aW9uKCl7aWYoXCJva1wiPT1iKWEobnVsbCk7ZWxzZXt2YXIgZD0oYnx8XCJlcnJvclwiKS50b1VwcGVyQ2FzZSgpLGU9ZDtjJiYoZSs9XCI6IFwiK2MpO2U9RXJyb3IoZSk7ZS5jb2RlPWQ7YShlKX19KX07ZnVuY3Rpb24gU2koYSxiLGMsZCxlKXtmdW5jdGlvbiBmKCl7fWEuZihcInRyYW5zYWN0aW9uIG9uIFwiK2IpO3ZhciBnPW5ldyBYKGEsYik7Zy5JYihcInZhbHVlXCIsZik7Yz17cGF0aDpiLHVwZGF0ZTpjLEk6ZCxzdGF0dXM6bnVsbCxMZjppZCgpLGdmOmUsU2Y6MCxsZTpmdW5jdGlvbigpe2cubWMoXCJ2YWx1ZVwiLGYpfSxuZTpudWxsLERhOm51bGwscmQ6bnVsbCxzZDpudWxsLHRkOm51bGx9O2Q9YS5NLkFhKGIsdm9pZCAwKXx8SDtjLnJkPWQ7ZD1jLnVwZGF0ZShkLkooKSk7aWYocChkKSl7aGcoXCJ0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgXCIsZCxjLnBhdGgpO2Muc3RhdHVzPTE7ZT1YZihhLnljLGIpO3ZhciBrPWUuRWEoKXx8W107ay5wdXNoKGMpO1lmKGUsayk7XCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCYmeShkLFwiLnByaW9yaXR5XCIpPyhrPXooZCxcIi5wcmlvcml0eVwiKSxPKGZnKGspLFwiSW52YWxpZCBwcmlvcml0eSByZXR1cm5lZCBieSB0cmFuc2FjdGlvbi4gUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLlwiKSk6XG5rPShhLk0uQWEoYil8fEgpLkMoKS5KKCk7ZT1NaShhKTtkPVEoZCxrKTtlPVhjKGQsZSk7Yy5zZD1kO2MudGQ9ZTtjLkRhPWEuS2QrKztjPXBpKGEuTSxiLGUsYy5EYSxjLmdmKTtkYyhhLmZhLGIsYyk7VGkoYSl9ZWxzZSBjLmxlKCksYy5zZD1udWxsLGMudGQ9bnVsbCxjLkkmJihhPW5ldyBXKGMucmQsbmV3IFgoYSxjLnBhdGgpLFIpLGMuSShudWxsLCExLGEpKX1mdW5jdGlvbiBUaShhLGIpe3ZhciBjPWJ8fGEueWM7Ynx8VWkoYSxjKTtpZihudWxsIT09Yy5FYSgpKXt2YXIgZD1WaShhLGMpO08oMDxkLmxlbmd0aCxcIlNlbmRpbmcgemVybyBsZW5ndGggdHJhbnNhY3Rpb24gcXVldWVcIik7UWEoZCxmdW5jdGlvbihhKXtyZXR1cm4gMT09PWEuc3RhdHVzfSkmJldpKGEsYy5wYXRoKCksZCl9ZWxzZSBjLnpkKCkmJmMuUihmdW5jdGlvbihiKXtUaShhLGIpfSl9XG5mdW5jdGlvbiBXaShhLGIsYyl7Zm9yKHZhciBkPU9hKGMsZnVuY3Rpb24oYSl7cmV0dXJuIGEuRGF9KSxlPWEuTS5BYShiLGQpfHxILGQ9ZSxlPWUuaGFzaCgpLGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGc9Y1tmXTtPKDE9PT1nLnN0YXR1cyxcInRyeVRvU2VuZFRyYW5zYWN0aW9uUXVldWVfOiBpdGVtcyBpbiBxdWV1ZSBzaG91bGQgYWxsIGJlIHJ1bi5cIik7Zy5zdGF0dXM9MjtnLlNmKys7dmFyIGs9bGYoYixnLnBhdGgpLGQ9ZC5IKGssZy5zZCl9ZD1kLkooITApO2EuZGEucHV0KGIudG9TdHJpbmcoKSxkLGZ1bmN0aW9uKGQpe2EuZihcInRyYW5zYWN0aW9uIHB1dCByZXNwb25zZVwiLHtwYXRoOmIudG9TdHJpbmcoKSxzdGF0dXM6ZH0pO3ZhciBlPVtdO2lmKFwib2tcIj09PWQpe2Q9W107Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKyl7Y1tmXS5zdGF0dXM9MztlPWUuY29uY2F0KHNpKGEuTSxjW2ZdLkRhKSk7aWYoY1tmXS5JKXt2YXIgZz1jW2ZdLnRkLGs9bmV3IFgoYSxjW2ZdLnBhdGgpO2QucHVzaCh1KGNbZl0uSSxcbm51bGwsbnVsbCwhMCxuZXcgVyhnLGssUikpKX1jW2ZdLmxlKCl9VWkoYSxYZihhLnljLGIpKTtUaShhKTtkYyhhLmZhLGIsZSk7Zm9yKGY9MDtmPGQubGVuZ3RoO2YrKylnYyhkW2ZdKX1lbHNle2lmKFwiZGF0YXN0YWxlXCI9PT1kKWZvcihmPTA7ZjxjLmxlbmd0aDtmKyspY1tmXS5zdGF0dXM9ND09PWNbZl0uc3RhdHVzPzU6MTtlbHNlIGZvcihTKFwidHJhbnNhY3Rpb24gYXQgXCIrYi50b1N0cmluZygpK1wiIGZhaWxlZDogXCIrZCksZj0wO2Y8Yy5sZW5ndGg7ZisrKWNbZl0uc3RhdHVzPTUsY1tmXS5uZT1kO05pKGEsYil9fSxlKX1mdW5jdGlvbiBOaShhLGIpe3ZhciBjPVhpKGEsYiksZD1jLnBhdGgoKSxjPVZpKGEsYyk7WWkoYSxjLGQpO3JldHVybiBkfVxuZnVuY3Rpb24gWWkoYSxiLGMpe2lmKDAhPT1iLmxlbmd0aCl7Zm9yKHZhciBkPVtdLGU9W10sZj1PYShiLGZ1bmN0aW9uKGEpe3JldHVybiBhLkRhfSksZz0wO2c8Yi5sZW5ndGg7ZysrKXt2YXIgaz1iW2ddLG09bGYoYyxrLnBhdGgpLGw9ITEsdDtPKG51bGwhPT1tLFwicmVydW5UcmFuc2FjdGlvbnNVbmRlck5vZGVfOiByZWxhdGl2ZVBhdGggc2hvdWxkIG5vdCBiZSBudWxsLlwiKTtpZig1PT09ay5zdGF0dXMpbD0hMCx0PWsubmUsZT1lLmNvbmNhdChzaShhLk0say5EYSwhMCkpO2Vsc2UgaWYoMT09PWsuc3RhdHVzKWlmKDI1PD1rLlNmKWw9ITAsdD1cIm1heHJldHJ5XCIsZT1lLmNvbmNhdChzaShhLk0say5EYSwhMCkpO2Vsc2V7dmFyIEE9YS5NLkFhKGsucGF0aCxmKXx8SDtrLnJkPUE7dmFyIEk9YltnXS51cGRhdGUoQS5KKCkpO3AoSSk/KGhnKFwidHJhbnNhY3Rpb24gZmFpbGVkOiBEYXRhIHJldHVybmVkIFwiLEksay5wYXRoKSxtPVEoSSksXCJvYmplY3RcIj09PXR5cGVvZiBJJiZudWxsIT1cbkkmJnkoSSxcIi5wcmlvcml0eVwiKXx8KG09bS5pYShBLkMoKSkpLEE9ay5EYSxJPU1pKGEpLEk9WGMobSxJKSxrLnNkPW0say50ZD1JLGsuRGE9YS5LZCsrLFRhKGYsQSksZT1lLmNvbmNhdChwaShhLk0say5wYXRoLEksay5EYSxrLmdmKSksZT1lLmNvbmNhdChzaShhLk0sQSwhMCkpKToobD0hMCx0PVwibm9kYXRhXCIsZT1lLmNvbmNhdChzaShhLk0say5EYSwhMCkpKX1kYyhhLmZhLGMsZSk7ZT1bXTtsJiYoYltnXS5zdGF0dXM9MyxzZXRUaW1lb3V0KGJbZ10ubGUsTWF0aC5mbG9vcigwKSksYltnXS5JJiYoXCJub2RhdGFcIj09PXQ/KGs9bmV3IFgoYSxiW2ddLnBhdGgpLGQucHVzaCh1KGJbZ10uSSxudWxsLG51bGwsITEsbmV3IFcoYltnXS5yZCxrLFIpKSkpOmQucHVzaCh1KGJbZ10uSSxudWxsLEVycm9yKHQpLCExLG51bGwpKSkpfVVpKGEsYS55Yyk7Zm9yKGc9MDtnPGQubGVuZ3RoO2crKylnYyhkW2ddKTtUaShhKX19XG5mdW5jdGlvbiBYaShhLGIpe2Zvcih2YXIgYyxkPWEueWM7bnVsbCE9PShjPUsoYikpJiZudWxsPT09ZC5FYSgpOylkPVhmKGQsYyksYj1OKGIpO3JldHVybiBkfWZ1bmN0aW9uIFZpKGEsYil7dmFyIGM9W107WmkoYSxiLGMpO2Muc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLkxmLWIuTGZ9KTtyZXR1cm4gY31mdW5jdGlvbiBaaShhLGIsYyl7dmFyIGQ9Yi5FYSgpO2lmKG51bGwhPT1kKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWMucHVzaChkW2VdKTtiLlIoZnVuY3Rpb24oYil7WmkoYSxiLGMpfSl9ZnVuY3Rpb24gVWkoYSxiKXt2YXIgYz1iLkVhKCk7aWYoYyl7Zm9yKHZhciBkPTAsZT0wO2U8Yy5sZW5ndGg7ZSsrKTMhPT1jW2VdLnN0YXR1cyYmKGNbZF09Y1tlXSxkKyspO2MubGVuZ3RoPWQ7WWYoYiwwPGMubGVuZ3RoP2M6bnVsbCl9Yi5SKGZ1bmN0aW9uKGIpe1VpKGEsYil9KX1cbmZ1bmN0aW9uIFFpKGEsYil7dmFyIGM9WGkoYSxiKS5wYXRoKCksZD1YZihhLnljLGIpO2FnKGQsZnVuY3Rpb24oYil7JGkoYSxiKX0pOyRpKGEsZCk7JGYoZCxmdW5jdGlvbihiKXskaShhLGIpfSk7cmV0dXJuIGN9XG5mdW5jdGlvbiAkaShhLGIpe3ZhciBjPWIuRWEoKTtpZihudWxsIT09Yyl7Zm9yKHZhciBkPVtdLGU9W10sZj0tMSxnPTA7ZzxjLmxlbmd0aDtnKyspNCE9PWNbZ10uc3RhdHVzJiYoMj09PWNbZ10uc3RhdHVzPyhPKGY9PT1nLTEsXCJBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLlwiKSxmPWcsY1tnXS5zdGF0dXM9NCxjW2ddLm5lPVwic2V0XCIpOihPKDE9PT1jW2ddLnN0YXR1cyxcIlVuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0XCIpLGNbZ10ubGUoKSxlPWUuY29uY2F0KHNpKGEuTSxjW2ddLkRhLCEwKSksY1tnXS5JJiZkLnB1c2godShjW2ddLkksbnVsbCxFcnJvcihcInNldFwiKSwhMSxudWxsKSkpKTstMT09PWY/WWYoYixudWxsKTpjLmxlbmd0aD1mKzE7ZGMoYS5mYSxiLnBhdGgoKSxlKTtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKWdjKGRbZ10pfX07ZnVuY3Rpb24gYWooKXt0aGlzLnNjPXt9O3RoaXMuYWc9ITF9YWoucHJvdG90eXBlLkNiPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMuc2MpdGhpcy5zY1thXS5DYigpfTthai5wcm90b3R5cGUudmM9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5zYyl0aGlzLnNjW2FdLnZjKCl9O2FqLnByb3RvdHlwZS56ZT1mdW5jdGlvbigpe3RoaXMuYWc9ITB9O2JhKGFqKTthai5wcm90b3R5cGUuaW50ZXJydXB0PWFqLnByb3RvdHlwZS5DYjthai5wcm90b3R5cGUucmVzdW1lPWFqLnByb3RvdHlwZS52YztmdW5jdGlvbiBZKGEsYixjLGQpe3RoaXMuaz1hO3RoaXMucGF0aD1iO3RoaXMubj1jO3RoaXMucGM9ZH1cbmZ1bmN0aW9uIGJqKGEpe3ZhciBiPW51bGwsYz1udWxsO2Eub2EmJihiPU9kKGEpKTthLnJhJiYoYz1SZChhKSk7aWYoYS5nPT09cmUpe2lmKGEub2Epe2lmKFwiW01JTl9OQU1FXVwiIT1OZChhKSl0aHJvdyBFcnJvcihcIlF1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgeW91IG1heSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50IHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpLlwiKTtpZihcInN0cmluZ1wiIT09dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgc3RyaW5nLlwiKTt9aWYoYS5yYSl7aWYoXCJbTUFYX05BTUVdXCIhPVBkKGEpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuXCIpO2lmKFwic3RyaW5nXCIhPT1cbnR5cGVvZiBjKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSxvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy5cIik7fX1lbHNlIGlmKGEuZz09PVIpe2lmKG51bGwhPWImJiFmZyhiKXx8bnVsbCE9YyYmIWZnKGMpKXRocm93IEVycm9yKFwiUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkgcHJpb3JpdHksIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlIChudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLlwiKTt9ZWxzZSBpZihPKGEuZyBpbnN0YW5jZW9mIHZlfHxhLmc9PT1CZSxcInVua25vd24gaW5kZXggdHlwZS5cIiksbnVsbCE9YiYmXCJvYmplY3RcIj09PXR5cGVvZiBifHxudWxsIT1jJiZcIm9iamVjdFwiPT09dHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJRdWVyeTogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpIGNhbm5vdCBiZSBhbiBvYmplY3QuXCIpO1xufWZ1bmN0aW9uIGNqKGEpe2lmKGEub2EmJmEucmEmJmEubGEmJighYS5sYXx8XCJcIj09PWEuUmIpKXRocm93IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBlbmRBdCgpLCBhbmQgbGltaXQoKS4gVXNlIGxpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC5cIik7fWZ1bmN0aW9uIGRqKGEsYil7aWYoITA9PT1hLnBjKXRocm93IEVycm9yKGIrXCI6IFlvdSBjYW4ndCBjb21iaW5lIG11bHRpcGxlIG9yZGVyQnkgY2FsbHMuXCIpO31oPVkucHJvdG90eXBlO2guTWI9ZnVuY3Rpb24oKXtEKFwiUXVlcnkucmVmXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiBuZXcgWCh0aGlzLmssdGhpcy5wYXRoKX07XG5oLkliPWZ1bmN0aW9uKGEsYixjLGQpe0QoXCJRdWVyeS5vblwiLDIsNCxhcmd1bWVudHMubGVuZ3RoKTtsZyhcIlF1ZXJ5Lm9uXCIsYSwhMSk7RihcIlF1ZXJ5Lm9uXCIsMixiLCExKTt2YXIgZT1laihcIlF1ZXJ5Lm9uXCIsYyxkKTtpZihcInZhbHVlXCI9PT1hKVJpKHRoaXMuayx0aGlzLG5ldyBpaShiLGUuY2FuY2VsfHxudWxsLGUuUWF8fG51bGwpKTtlbHNle3ZhciBmPXt9O2ZbYV09YjtSaSh0aGlzLmssdGhpcyxuZXcgamkoZixlLmNhbmNlbCxlLlFhKSl9cmV0dXJuIGJ9O1xuaC5tYz1mdW5jdGlvbihhLGIsYyl7RChcIlF1ZXJ5Lm9mZlwiLDAsMyxhcmd1bWVudHMubGVuZ3RoKTtsZyhcIlF1ZXJ5Lm9mZlwiLGEsITApO0YoXCJRdWVyeS5vZmZcIiwyLGIsITApO1FiKFwiUXVlcnkub2ZmXCIsMyxjKTt2YXIgZD1udWxsLGU9bnVsbDtcInZhbHVlXCI9PT1hP2Q9bmV3IGlpKGJ8fG51bGwsbnVsbCxjfHxudWxsKTphJiYoYiYmKGU9e30sZVthXT1iKSxkPW5ldyBqaShlLG51bGwsY3x8bnVsbCkpO2U9dGhpcy5rO2Q9XCIuaW5mb1wiPT09Syh0aGlzLnBhdGgpP2UuRmQubmIodGhpcyxkKTplLk0ubmIodGhpcyxkKTtiYyhlLmZhLHRoaXMucGF0aCxkKX07XG5oLk9nPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhrKXtmJiYoZj0hMSxlLm1jKGEsYyksYiYmYi5jYWxsKGQuUWEsayksZy5yZXNvbHZlKGspKX1EKFwiUXVlcnkub25jZVwiLDEsNCxhcmd1bWVudHMubGVuZ3RoKTtsZyhcIlF1ZXJ5Lm9uY2VcIixhLCExKTtGKFwiUXVlcnkub25jZVwiLDIsYiwhMCk7dmFyIGQ9ZWooXCJRdWVyeS5vbmNlXCIsYXJndW1lbnRzWzJdLGFyZ3VtZW50c1szXSksZT10aGlzLGY9ITAsZz1uZXcgQjtOYihnLkQpO3RoaXMuSWIoYSxjLGZ1bmN0aW9uKGIpe2UubWMoYSxjKTtkLmNhbmNlbCYmZC5jYW5jZWwuY2FsbChkLlFhLGIpO2cucmVqZWN0KGIpfSk7cmV0dXJuIGcuRH07XG5oLkxlPWZ1bmN0aW9uKGEpe1MoXCJRdWVyeS5saW1pdCgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgUXVlcnkubGltaXRUb0ZpcnN0KCkgb3IgUXVlcnkubGltaXRUb0xhc3QoKSBpbnN0ZWFkLlwiKTtEKFwiUXVlcnkubGltaXRcIiwxLDEsYXJndW1lbnRzLmxlbmd0aCk7aWYoIWZhKGEpfHxNYXRoLmZsb29yKGEpIT09YXx8MD49YSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmxpbWl0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmxhKXRocm93IEVycm9yKFwiUXVlcnkubGltaXQ6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0LCBsaW1pdFRvRmlyc3QsIG9ybGltaXRUb0xhc3QuXCIpO3ZhciBiPXRoaXMubi5MZShhKTtjaihiKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCxiLHRoaXMucGMpfTtcbmguTWU9ZnVuY3Rpb24oYSl7RChcIlF1ZXJ5LmxpbWl0VG9GaXJzdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZmEoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci5cIik7aWYodGhpcy5uLmxhKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdCwgbGltaXRUb0ZpcnN0LCBvciBsaW1pdFRvTGFzdCkuXCIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLHRoaXMubi5NZShhKSx0aGlzLnBjKX07XG5oLk5lPWZ1bmN0aW9uKGEpe0QoXCJRdWVyeS5saW1pdFRvTGFzdFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZighZmEoYSl8fE1hdGguZmxvb3IoYSkhPT1hfHwwPj1hKXRocm93IEVycm9yKFwiUXVlcnkubGltaXRUb0xhc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtpZih0aGlzLm4ubGEpdGhyb3cgRXJyb3IoXCJRdWVyeS5saW1pdFRvTGFzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsIGxpbWl0VG9GaXJzdCwgb3IgbGltaXRUb0xhc3QpLlwiKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCx0aGlzLm4uTmUoYSksdGhpcy5wYyl9O1xuaC5QZz1mdW5jdGlvbihhKXtEKFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsMSwxLGFyZ3VtZW50cy5sZW5ndGgpO2lmKFwiJGtleVwiPT09YSl0aHJvdyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBcIiRrZXlcIiBpcyBpbnZhbGlkLiAgVXNlIFF1ZXJ5Lm9yZGVyQnlLZXkoKSBpbnN0ZWFkLicpO2lmKFwiJHByaW9yaXR5XCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHByaW9yaXR5XCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5UHJpb3JpdHkoKSBpbnN0ZWFkLicpO2lmKFwiJHZhbHVlXCI9PT1hKXRocm93IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO25nKFwiUXVlcnkub3JkZXJCeUNoaWxkXCIsYSk7ZGoodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlDaGlsZFwiKTt2YXIgYj1uZXcgUChhKTtpZihiLmUoKSl0aHJvdyBFcnJvcihcIlF1ZXJ5Lm9yZGVyQnlDaGlsZDogY2Fubm90IHBhc3MgaW4gZW1wdHkgcGF0aC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLlwiKTtcbmI9bmV3IHZlKGIpO2I9RmUodGhpcy5uLGIpO2JqKGIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGIsITApfTtoLlFnPWZ1bmN0aW9uKCl7RChcIlF1ZXJ5Lm9yZGVyQnlLZXlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7ZGoodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlLZXlcIik7dmFyIGE9RmUodGhpcy5uLHJlKTtiaihhKTtyZXR1cm4gbmV3IFkodGhpcy5rLHRoaXMucGF0aCxhLCEwKX07aC5SZz1mdW5jdGlvbigpe0QoXCJRdWVyeS5vcmRlckJ5UHJpb3JpdHlcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7ZGoodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlQcmlvcml0eVwiKTt2YXIgYT1GZSh0aGlzLm4sUik7YmooYSk7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsYSwhMCl9O1xuaC5TZz1mdW5jdGlvbigpe0QoXCJRdWVyeS5vcmRlckJ5VmFsdWVcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7ZGoodGhpcyxcIlF1ZXJ5Lm9yZGVyQnlWYWx1ZVwiKTt2YXIgYT1GZSh0aGlzLm4sQmUpO2JqKGEpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGEsITApfTtoLmNlPWZ1bmN0aW9uKGEsYil7RChcIlF1ZXJ5LnN0YXJ0QXRcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7Z2coXCJRdWVyeS5zdGFydEF0XCIsYSx0aGlzLnBhdGgsITApO21nKFwiUXVlcnkuc3RhcnRBdFwiLGIpO3ZhciBjPXRoaXMubi5jZShhLGIpO2NqKGMpO2JqKGMpO2lmKHRoaXMubi5vYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LnN0YXJ0QXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQgb3IgZXF1YWxUbykuXCIpO3AoYSl8fChiPWE9bnVsbCk7cmV0dXJuIG5ldyBZKHRoaXMuayx0aGlzLnBhdGgsYyx0aGlzLnBjKX07XG5oLnZkPWZ1bmN0aW9uKGEsYil7RChcIlF1ZXJ5LmVuZEF0XCIsMCwyLGFyZ3VtZW50cy5sZW5ndGgpO2dnKFwiUXVlcnkuZW5kQXRcIixhLHRoaXMucGF0aCwhMCk7bWcoXCJRdWVyeS5lbmRBdFwiLGIpO3ZhciBjPXRoaXMubi52ZChhLGIpO2NqKGMpO2JqKGMpO2lmKHRoaXMubi5yYSl0aHJvdyBFcnJvcihcIlF1ZXJ5LmVuZEF0OiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQgb3IgZXF1YWxUbykuXCIpO3JldHVybiBuZXcgWSh0aGlzLmssdGhpcy5wYXRoLGMsdGhpcy5wYyl9O1xuaC50Zz1mdW5jdGlvbihhLGIpe0QoXCJRdWVyeS5lcXVhbFRvXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO2dnKFwiUXVlcnkuZXF1YWxUb1wiLGEsdGhpcy5wYXRoLCExKTttZyhcIlF1ZXJ5LmVxdWFsVG9cIixiKTtpZih0aGlzLm4ub2EpdGhyb3cgRXJyb3IoXCJRdWVyeS5lcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciBlcXVhbFRvKS5cIik7aWYodGhpcy5uLnJhKXRocm93IEVycm9yKFwiUXVlcnkuZXF1YWxUbzogRW5kaW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yIGVxdWFsVG8pLlwiKTtyZXR1cm4gdGhpcy5jZShhLGIpLnZkKGEsYil9O1xuaC50b1N0cmluZz1mdW5jdGlvbigpe0QoXCJRdWVyeS50b1N0cmluZ1wiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGE9dGhpcy5wYXRoLGI9XCJcIixjPWEuYWE7YzxhLnUubGVuZ3RoO2MrKylcIlwiIT09YS51W2NdJiYoYis9XCIvXCIrZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhLnVbY10pKSk7cmV0dXJuIHRoaXMuay50b1N0cmluZygpKyhifHxcIi9cIil9O2gud2E9ZnVuY3Rpb24oKXt2YXIgYT14ZChHZSh0aGlzLm4pKTtyZXR1cm5cInt9XCI9PT1hP1wiZGVmYXVsdFwiOmF9O1xuZnVuY3Rpb24gZWooYSxiLGMpe3ZhciBkPXtjYW5jZWw6bnVsbCxRYTpudWxsfTtpZihiJiZjKWQuY2FuY2VsPWIsRihhLDMsZC5jYW5jZWwsITApLGQuUWE9YyxRYihhLDQsZC5RYSk7ZWxzZSBpZihiKWlmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpZC5RYT1iO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGIpZC5jYW5jZWw9YjtlbHNlIHRocm93IEVycm9yKEUoYSwzLCEwKStcIiBtdXN0IGVpdGhlciBiZSBhIGNhbmNlbCBjYWxsYmFjayBvciBhIGNvbnRleHQgb2JqZWN0LlwiKTtyZXR1cm4gZH1ZLnByb3RvdHlwZS5yZWY9WS5wcm90b3R5cGUuTWI7WS5wcm90b3R5cGUub249WS5wcm90b3R5cGUuSWI7WS5wcm90b3R5cGUub2ZmPVkucHJvdG90eXBlLm1jO1kucHJvdG90eXBlLm9uY2U9WS5wcm90b3R5cGUuT2c7WS5wcm90b3R5cGUubGltaXQ9WS5wcm90b3R5cGUuTGU7WS5wcm90b3R5cGUubGltaXRUb0ZpcnN0PVkucHJvdG90eXBlLk1lO1xuWS5wcm90b3R5cGUubGltaXRUb0xhc3Q9WS5wcm90b3R5cGUuTmU7WS5wcm90b3R5cGUub3JkZXJCeUNoaWxkPVkucHJvdG90eXBlLlBnO1kucHJvdG90eXBlLm9yZGVyQnlLZXk9WS5wcm90b3R5cGUuUWc7WS5wcm90b3R5cGUub3JkZXJCeVByaW9yaXR5PVkucHJvdG90eXBlLlJnO1kucHJvdG90eXBlLm9yZGVyQnlWYWx1ZT1ZLnByb3RvdHlwZS5TZztZLnByb3RvdHlwZS5zdGFydEF0PVkucHJvdG90eXBlLmNlO1kucHJvdG90eXBlLmVuZEF0PVkucHJvdG90eXBlLnZkO1kucHJvdG90eXBlLmVxdWFsVG89WS5wcm90b3R5cGUudGc7WS5wcm90b3R5cGUudG9TdHJpbmc9WS5wcm90b3R5cGUudG9TdHJpbmc7dmFyIFo9e307Wi56Yz1SaDtaLkRhdGFDb25uZWN0aW9uPVouemM7UmgucHJvdG90eXBlLmJoPWZ1bmN0aW9uKGEsYil7dGhpcy5JYShcInFcIix7cDphfSxiKX07Wi56Yy5wcm90b3R5cGUuc2ltcGxlTGlzdGVuPVouemMucHJvdG90eXBlLmJoO1JoLnByb3RvdHlwZS5zZz1mdW5jdGlvbihhLGIpe3RoaXMuSWEoXCJlY2hvXCIse2Q6YX0sYil9O1ouemMucHJvdG90eXBlLmVjaG89Wi56Yy5wcm90b3R5cGUuc2c7UmgucHJvdG90eXBlLmludGVycnVwdD1SaC5wcm90b3R5cGUuQ2I7Wi5kZz1GaDtaLlJlYWxUaW1lQ29ubmVjdGlvbj1aLmRnO0ZoLnByb3RvdHlwZS5zZW5kUmVxdWVzdD1GaC5wcm90b3R5cGUuSWE7RmgucHJvdG90eXBlLmNsb3NlPUZoLnByb3RvdHlwZS5jbG9zZTtcblouQ2c9ZnVuY3Rpb24oYSl7dmFyIGI9UmgucHJvdG90eXBlLnB1dDtSaC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKGMsZCxlLGYpe3AoZikmJihmPWEoKSk7Yi5jYWxsKHRoaXMsYyxkLGUsZil9O3JldHVybiBmdW5jdGlvbigpe1JoLnByb3RvdHlwZS5wdXQ9Yn19O1ouaGlqYWNrSGFzaD1aLkNnO1ouY2c9ZGQ7Wi5Db25uZWN0aW9uVGFyZ2V0PVouY2c7Wi53YT1mdW5jdGlvbihhKXtyZXR1cm4gYS53YSgpfTtaLnF1ZXJ5SWRlbnRpZmllcj1aLndhO1ouRWc9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuay5WYS5iYX07Wi5saXN0ZW5zPVouRWc7Wi56ZT1mdW5jdGlvbihhKXthLnplKCl9O1ouZm9yY2VSZXN0Q2xpZW50PVouemU7ZnVuY3Rpb24gWChhLGIpe3ZhciBjLGQsZTtpZihhIGluc3RhbmNlb2YgSmkpYz1hLGQ9YjtlbHNle0QoXCJuZXcgRmlyZWJhc2VcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7ZD1zZChhcmd1bWVudHNbMF0pO2M9ZC5laDtcImZpcmViYXNlXCI9PT1kLmRvbWFpbiYmcmQoZC5ob3N0K1wiIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tIGluc3RlYWRcIik7YyYmXCJ1bmRlZmluZWRcIiE9Y3x8cmQoXCJDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tXCIpO2Qub2J8fFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24mJndpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmLTEhPT13aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSYmUyhcIkluc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuIFBsZWFzZSB1c2UgaHR0cHMgaW4gY2FsbHMgdG8gbmV3IEZpcmViYXNlKCkuXCIpO1xuYz1uZXcgZGQoZC5ob3N0LGQub2IsYyxcIndzXCI9PT1kLnNjaGVtZXx8XCJ3c3NcIj09PWQuc2NoZW1lKTtkPW5ldyBQKGQuYmQpO2U9ZC50b1N0cmluZygpO3ZhciBmOyEoZj0hcShjLmhvc3QpfHwwPT09Yy5ob3N0Lmxlbmd0aHx8IWVnKGMubGMpKSYmKGY9MCE9PWUubGVuZ3RoKSYmKGUmJihlPWUucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sXCIvXCIpKSxmPSEocShlKSYmMCE9PWUubGVuZ3RoJiYhY2cudGVzdChlKSkpO2lmKGYpdGhyb3cgRXJyb3IoRShcIm5ldyBGaXJlYmFzZVwiLDEsITEpKydtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCB0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO2lmKGIpaWYoYiBpbnN0YW5jZW9mIGFqKWU9YjtlbHNlIGlmKHEoYikpZT1hai55YigpLGMuUmQ9YjtlbHNlIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgYSB2YWxpZCBGaXJlYmFzZS5Db250ZXh0IGZvciBzZWNvbmQgYXJndW1lbnQgdG8gbmV3IEZpcmViYXNlKClcIik7XG5lbHNlIGU9YWoueWIoKTtmPWMudG9TdHJpbmcoKTt2YXIgZz16KGUuc2MsZik7Z3x8KGc9bmV3IEppKGMsZS5hZyksZS5zY1tmXT1nKTtjPWd9WS5jYWxsKHRoaXMsYyxkLERlLCExKTt0aGlzLnRoZW49dm9pZCAwO3RoaXNbXCJjYXRjaFwiXT12b2lkIDB9a2EoWCxZKTt2YXIgZmo9WCxnaj1bXCJGaXJlYmFzZVwiXSxoaj1uO2dqWzBdaW4gaGp8fCFoai5leGVjU2NyaXB0fHxoai5leGVjU2NyaXB0KFwidmFyIFwiK2dqWzBdKTtmb3IodmFyIGlqO2dqLmxlbmd0aCYmKGlqPWdqLnNoaWZ0KCkpOykhZ2oubGVuZ3RoJiZwKGZqKT9oaltpal09Zmo6aGo9aGpbaWpdP2hqW2lqXTpoaltpal09e307WC5nb09mZmxpbmU9ZnVuY3Rpb24oKXtEKFwiRmlyZWJhc2UuZ29PZmZsaW5lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO2FqLnliKCkuQ2IoKX07WC5nb09ubGluZT1mdW5jdGlvbigpe0QoXCJGaXJlYmFzZS5nb09ubGluZVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTthai55YigpLnZjKCl9O1xuWC5lbmFibGVMb2dnaW5nPW9kO1guU2VydmVyVmFsdWU9e1RJTUVTVEFNUDp7XCIuc3ZcIjpcInRpbWVzdGFtcFwifX07WC5TREtfVkVSU0lPTj1FYjtYLklOVEVSTkFMPVU7WC5Db250ZXh0PWFqO1guVEVTVF9BQ0NFU1M9WjtYLnByb3RvdHlwZS5uYW1lPWZ1bmN0aW9uKCl7UyhcIkZpcmViYXNlLm5hbWUoKSBiZWluZyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZpcmViYXNlLmtleSgpIGluc3RlYWQuXCIpO0QoXCJGaXJlYmFzZS5uYW1lXCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3JldHVybiB0aGlzLmtleSgpfTtYLnByb3RvdHlwZS5uYW1lPVgucHJvdG90eXBlLm5hbWU7WC5wcm90b3R5cGUua2V5PWZ1bmN0aW9uKCl7RChcIkZpcmViYXNlLmtleVwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtyZXR1cm4gdGhpcy5wYXRoLmUoKT9udWxsOm1lKHRoaXMucGF0aCl9O1gucHJvdG90eXBlLmtleT1YLnByb3RvdHlwZS5rZXk7XG5YLnByb3RvdHlwZS5vPWZ1bmN0aW9uKGEpe0QoXCJGaXJlYmFzZS5jaGlsZFwiLDEsMSxhcmd1bWVudHMubGVuZ3RoKTtpZihmYShhKSlhPVN0cmluZyhhKTtlbHNlIGlmKCEoYSBpbnN0YW5jZW9mIFApKWlmKG51bGw9PT1LKHRoaXMucGF0aCkpe3ZhciBiPWE7YiYmKGI9Yi5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLyxcIi9cIikpO25nKFwiRmlyZWJhc2UuY2hpbGRcIixiKX1lbHNlIG5nKFwiRmlyZWJhc2UuY2hpbGRcIixhKTtyZXR1cm4gbmV3IFgodGhpcy5rLHRoaXMucGF0aC5vKGEpKX07WC5wcm90b3R5cGUuY2hpbGQ9WC5wcm90b3R5cGUubztYLnByb3RvdHlwZS5wYXJlbnQ9ZnVuY3Rpb24oKXtEKFwiRmlyZWJhc2UucGFyZW50XCIsMCwwLGFyZ3VtZW50cy5sZW5ndGgpO3ZhciBhPXRoaXMucGF0aC5wYXJlbnQoKTtyZXR1cm4gbnVsbD09PWE/bnVsbDpuZXcgWCh0aGlzLmssYSl9O1gucHJvdG90eXBlLnBhcmVudD1YLnByb3RvdHlwZS5wYXJlbnQ7XG5YLnByb3RvdHlwZS5yb290PWZ1bmN0aW9uKCl7RChcIkZpcmViYXNlLnJlZlwiLDAsMCxhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGE9dGhpcztudWxsIT09YS5wYXJlbnQoKTspYT1hLnBhcmVudCgpO3JldHVybiBhfTtYLnByb3RvdHlwZS5yb290PVgucHJvdG90eXBlLnJvb3Q7WC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLnNldFwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtvZyhcIkZpcmViYXNlLnNldFwiLHRoaXMucGF0aCk7Z2coXCJGaXJlYmFzZS5zZXRcIixhLHRoaXMucGF0aCwhMSk7RihcIkZpcmViYXNlLnNldFwiLDIsYiwhMCk7dmFyIGM9bmV3IEI7dGhpcy5rLk9iKHRoaXMucGF0aCxhLG51bGwsQyhjLGIpKTtyZXR1cm4gYy5EfTtYLnByb3RvdHlwZS5zZXQ9WC5wcm90b3R5cGUuc2V0O1xuWC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLnVwZGF0ZVwiLDEsMixhcmd1bWVudHMubGVuZ3RoKTtvZyhcIkZpcmViYXNlLnVwZGF0ZVwiLHRoaXMucGF0aCk7aWYoZGEoYSkpe2Zvcih2YXIgYz17fSxkPTA7ZDxhLmxlbmd0aDsrK2QpY1tcIlwiK2RdPWFbZF07YT1jO1MoXCJQYXNzaW5nIGFuIEFycmF5IHRvIEZpcmViYXNlLnVwZGF0ZSgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBzZXQoKSBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uXCIpfWpnKFwiRmlyZWJhc2UudXBkYXRlXCIsYSx0aGlzLnBhdGgpO0YoXCJGaXJlYmFzZS51cGRhdGVcIiwyLGIsITApO2M9bmV3IEI7dGhpcy5rLnVwZGF0ZSh0aGlzLnBhdGgsYSxDKGMsYikpO3JldHVybiBjLkR9O1xuWC5wcm90b3R5cGUudXBkYXRlPVgucHJvdG90eXBlLnVwZGF0ZTtYLnByb3RvdHlwZS5PYj1mdW5jdGlvbihhLGIsYyl7RChcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLDIsMyxhcmd1bWVudHMubGVuZ3RoKTtvZyhcIkZpcmViYXNlLnNldFdpdGhQcmlvcml0eVwiLHRoaXMucGF0aCk7Z2coXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIixhLHRoaXMucGF0aCwhMSk7a2coXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwyLGIpO0YoXCJGaXJlYmFzZS5zZXRXaXRoUHJpb3JpdHlcIiwzLGMsITApO2lmKFwiLmxlbmd0aFwiPT09dGhpcy5rZXkoKXx8XCIua2V5c1wiPT09dGhpcy5rZXkoKSl0aHJvd1wiRmlyZWJhc2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogXCIrdGhpcy5rZXkoKStcIiBpcyBhIHJlYWQtb25seSBvYmplY3QuXCI7dmFyIGQ9bmV3IEI7dGhpcy5rLk9iKHRoaXMucGF0aCxhLGIsQyhkLGMpKTtyZXR1cm4gZC5EfTtYLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHk9WC5wcm90b3R5cGUuT2I7XG5YLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7RChcIkZpcmViYXNlLnJlbW92ZVwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtvZyhcIkZpcmViYXNlLnJlbW92ZVwiLHRoaXMucGF0aCk7RihcIkZpcmViYXNlLnJlbW92ZVwiLDEsYSwhMCk7cmV0dXJuIHRoaXMuc2V0KG51bGwsYSl9O1gucHJvdG90eXBlLnJlbW92ZT1YLnByb3RvdHlwZS5yZW1vdmU7XG5YLnByb3RvdHlwZS50cmFuc2FjdGlvbj1mdW5jdGlvbihhLGIsYyl7RChcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMSwzLGFyZ3VtZW50cy5sZW5ndGgpO29nKFwiRmlyZWJhc2UudHJhbnNhY3Rpb25cIix0aGlzLnBhdGgpO0YoXCJGaXJlYmFzZS50cmFuc2FjdGlvblwiLDEsYSwhMSk7RihcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMixiLCEwKTtpZihwKGMpJiZcImJvb2xlYW5cIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoRShcIkZpcmViYXNlLnRyYW5zYWN0aW9uXCIsMywhMCkrXCJtdXN0IGJlIGEgYm9vbGVhbi5cIik7aWYoXCIubGVuZ3RoXCI9PT10aGlzLmtleSgpfHxcIi5rZXlzXCI9PT10aGlzLmtleSgpKXRocm93XCJGaXJlYmFzZS50cmFuc2FjdGlvbiBmYWlsZWQ6IFwiK3RoaXMua2V5KCkrXCIgaXMgYSByZWFkLW9ubHkgb2JqZWN0LlwiO1widW5kZWZpbmVkXCI9PT10eXBlb2YgYyYmKGM9ITApO3ZhciBkPW5ldyBCO3IoYikmJk5iKGQuRCk7U2kodGhpcy5rLHRoaXMucGF0aCxhLGZ1bmN0aW9uKGEsYyxnKXthP1xuZC5yZWplY3QoYSk6ZC5yZXNvbHZlKG5ldyBlaShjLGcpKTtyKGIpJiZiKGEsYyxnKX0sYyk7cmV0dXJuIGQuRH07WC5wcm90b3R5cGUudHJhbnNhY3Rpb249WC5wcm90b3R5cGUudHJhbnNhY3Rpb247WC5wcm90b3R5cGUuWmc9ZnVuY3Rpb24oYSxiKXtEKFwiRmlyZWJhc2Uuc2V0UHJpb3JpdHlcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7b2coXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLHRoaXMucGF0aCk7a2coXCJGaXJlYmFzZS5zZXRQcmlvcml0eVwiLDEsYSk7RihcIkZpcmViYXNlLnNldFByaW9yaXR5XCIsMixiLCEwKTt2YXIgYz1uZXcgQjt0aGlzLmsuT2IodGhpcy5wYXRoLm8oXCIucHJpb3JpdHlcIiksYSxudWxsLEMoYyxiKSk7cmV0dXJuIGMuRH07WC5wcm90b3R5cGUuc2V0UHJpb3JpdHk9WC5wcm90b3R5cGUuWmc7XG5YLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLnB1c2hcIiwwLDIsYXJndW1lbnRzLmxlbmd0aCk7b2coXCJGaXJlYmFzZS5wdXNoXCIsdGhpcy5wYXRoKTtnZyhcIkZpcmViYXNlLnB1c2hcIixhLHRoaXMucGF0aCwhMCk7RihcIkZpcmViYXNlLnB1c2hcIiwyLGIsITApO3ZhciBjPUxpKHRoaXMuayksZD1oZihjKSxjPXRoaXMubyhkKTtpZihudWxsIT1hKXt2YXIgZT10aGlzLGY9Yy5zZXQoYSxiKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGUubyhkKX0pO2MudGhlbj11KGYudGhlbixmKTtjW1wiY2F0Y2hcIl09dShmLnRoZW4sZix2b2lkIDApO3IoYikmJk5iKGYpfXJldHVybiBjfTtYLnByb3RvdHlwZS5wdXNoPVgucHJvdG90eXBlLnB1c2g7WC5wcm90b3R5cGUubGI9ZnVuY3Rpb24oKXtvZyhcIkZpcmViYXNlLm9uRGlzY29ubmVjdFwiLHRoaXMucGF0aCk7cmV0dXJuIG5ldyBWKHRoaXMuayx0aGlzLnBhdGgpfTtYLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3Q9WC5wcm90b3R5cGUubGI7XG5YLnByb3RvdHlwZS5PPWZ1bmN0aW9uKGEsYixjKXtTKFwiRmlyZWJhc2VSZWYuYXV0aCgpIGJlaW5nIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRmlyZWJhc2VSZWYuYXV0aFdpdGhDdXN0b21Ub2tlbigpIGluc3RlYWQuXCIpO0QoXCJGaXJlYmFzZS5hdXRoXCIsMSwzLGFyZ3VtZW50cy5sZW5ndGgpO3BnKFwiRmlyZWJhc2UuYXV0aFwiLGEpO0YoXCJGaXJlYmFzZS5hdXRoXCIsMixiLCEwKTtGKFwiRmlyZWJhc2UuYXV0aFwiLDMsYiwhMCk7dmFyIGQ9bmV3IEI7ZGgodGhpcy5rLk8sYSx7fSx7cmVtZW1iZXI6XCJub25lXCJ9LEMoZCxiKSxjKTtyZXR1cm4gZC5EfTtYLnByb3RvdHlwZS5hdXRoPVgucHJvdG90eXBlLk87WC5wcm90b3R5cGUuamU9ZnVuY3Rpb24oYSl7RChcIkZpcmViYXNlLnVuYXV0aFwiLDAsMSxhcmd1bWVudHMubGVuZ3RoKTtGKFwiRmlyZWJhc2UudW5hdXRoXCIsMSxhLCEwKTt2YXIgYj1uZXcgQjtlaCh0aGlzLmsuTyxDKGIsYSkpO3JldHVybiBiLkR9O1gucHJvdG90eXBlLnVuYXV0aD1YLnByb3RvdHlwZS5qZTtcblgucHJvdG90eXBlLkJlPWZ1bmN0aW9uKCl7RChcIkZpcmViYXNlLmdldEF1dGhcIiwwLDAsYXJndW1lbnRzLmxlbmd0aCk7cmV0dXJuIHRoaXMuay5PLkJlKCl9O1gucHJvdG90eXBlLmdldEF1dGg9WC5wcm90b3R5cGUuQmU7WC5wcm90b3R5cGUuSWc9ZnVuY3Rpb24oYSxiKXtEKFwiRmlyZWJhc2Uub25BdXRoXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO0YoXCJGaXJlYmFzZS5vbkF1dGhcIiwxLGEsITEpO1FiKFwiRmlyZWJhc2Uub25BdXRoXCIsMixiKTt0aGlzLmsuTy5JYihcImF1dGhfc3RhdHVzXCIsYSxiKX07WC5wcm90b3R5cGUub25BdXRoPVgucHJvdG90eXBlLklnO1gucHJvdG90eXBlLkhnPWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLm9mZkF1dGhcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7RihcIkZpcmViYXNlLm9mZkF1dGhcIiwxLGEsITEpO1FiKFwiRmlyZWJhc2Uub2ZmQXV0aFwiLDIsYik7dGhpcy5rLk8ubWMoXCJhdXRoX3N0YXR1c1wiLGEsYil9O1gucHJvdG90eXBlLm9mZkF1dGg9WC5wcm90b3R5cGUuSGc7XG5YLnByb3RvdHlwZS5oZz1mdW5jdGlvbihhLGIsYyl7RChcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIiwxLDMsYXJndW1lbnRzLmxlbmd0aCk7Mj09PWFyZ3VtZW50cy5sZW5ndGgmJkhiKGIpJiYoYz1iLGI9dm9pZCAwKTtwZyhcIkZpcmViYXNlLmF1dGhXaXRoQ3VzdG9tVG9rZW5cIixhKTtGKFwiRmlyZWJhc2UuYXV0aFdpdGhDdXN0b21Ub2tlblwiLDIsYiwhMCk7c2coXCJGaXJlYmFzZS5hdXRoV2l0aEN1c3RvbVRva2VuXCIsMyxjLCEwKTt2YXIgZD1uZXcgQjtkaCh0aGlzLmsuTyxhLHt9LGN8fHt9LEMoZCxiKSk7cmV0dXJuIGQuRH07WC5wcm90b3R5cGUuYXV0aFdpdGhDdXN0b21Ub2tlbj1YLnByb3RvdHlwZS5oZztcblgucHJvdG90eXBlLmlnPWZ1bmN0aW9uKGEsYixjKXtEKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFBvcHVwXCIsMSwzLGFyZ3VtZW50cy5sZW5ndGgpOzI9PT1hcmd1bWVudHMubGVuZ3RoJiZIYihiKSYmKGM9YixiPXZvaWQgMCk7cmcoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUG9wdXBcIixhKTtGKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFBvcHVwXCIsMixiLCEwKTtzZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhQb3B1cFwiLDMsYywhMCk7dmFyIGQ9bmV3IEI7aWgodGhpcy5rLk8sYSxjLEMoZCxiKSk7cmV0dXJuIGQuRH07WC5wcm90b3R5cGUuYXV0aFdpdGhPQXV0aFBvcHVwPVgucHJvdG90eXBlLmlnO1xuWC5wcm90b3R5cGUuamc9ZnVuY3Rpb24oYSxiLGMpe0QoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwxLDMsYXJndW1lbnRzLmxlbmd0aCk7Mj09PWFyZ3VtZW50cy5sZW5ndGgmJkhiKGIpJiYoYz1iLGI9dm9pZCAwKTtyZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdFwiLGEpO0YoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoUmVkaXJlY3RcIiwyLGIsITEpO3NnKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFJlZGlyZWN0XCIsMyxjLCEwKTt2YXIgZD1uZXcgQixlPXRoaXMuay5PLGY9YyxnPUMoZCxiKTtnaChlKTt2YXIgaz1bUWddLGY9QWcoZik7XCJhbm9ueW1vdXNcIj09PWF8fFwiZmlyZWJhc2VcIj09PWE/VChnLFNnKFwiVFJBTlNQT1JUX1VOQVZBSUxBQkxFXCIpKTooY2Quc2V0KFwicmVkaXJlY3RfY2xpZW50X29wdGlvbnNcIixmLnFkKSxoaChlLGssXCIvYXV0aC9cIithLGYsZykpO3JldHVybiBkLkR9O1gucHJvdG90eXBlLmF1dGhXaXRoT0F1dGhSZWRpcmVjdD1YLnByb3RvdHlwZS5qZztcblgucHJvdG90eXBlLmtnPWZ1bmN0aW9uKGEsYixjLGQpe0QoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwyLDQsYXJndW1lbnRzLmxlbmd0aCk7Mz09PWFyZ3VtZW50cy5sZW5ndGgmJkhiKGMpJiYoZD1jLGM9dm9pZCAwKTtyZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLGEpO0YoXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwzLGMsITApO3NnKFwiRmlyZWJhc2UuYXV0aFdpdGhPQXV0aFRva2VuXCIsNCxkLCEwKTt2YXIgZT1uZXcgQjtxKGIpPyhxZyhcIkZpcmViYXNlLmF1dGhXaXRoT0F1dGhUb2tlblwiLDIsYiksZmgodGhpcy5rLk8sYStcIi90b2tlblwiLHthY2Nlc3NfdG9rZW46Yn0sZCxDKGUsYykpKTooc2coXCJGaXJlYmFzZS5hdXRoV2l0aE9BdXRoVG9rZW5cIiwyLGIsITEpLGZoKHRoaXMuay5PLGErXCIvdG9rZW5cIixiLGQsQyhlLGMpKSk7cmV0dXJuIGUuRH07WC5wcm90b3R5cGUuYXV0aFdpdGhPQXV0aFRva2VuPVgucHJvdG90eXBlLmtnO1xuWC5wcm90b3R5cGUuZ2c9ZnVuY3Rpb24oYSxiKXtEKFwiRmlyZWJhc2UuYXV0aEFub255bW91c2x5XCIsMCwyLGFyZ3VtZW50cy5sZW5ndGgpOzE9PT1hcmd1bWVudHMubGVuZ3RoJiZIYihhKSYmKGI9YSxhPXZvaWQgMCk7RihcIkZpcmViYXNlLmF1dGhBbm9ueW1vdXNseVwiLDEsYSwhMCk7c2coXCJGaXJlYmFzZS5hdXRoQW5vbnltb3VzbHlcIiwyLGIsITApO3ZhciBjPW5ldyBCO2ZoKHRoaXMuay5PLFwiYW5vbnltb3VzXCIse30sYixDKGMsYSkpO3JldHVybiBjLkR9O1gucHJvdG90eXBlLmF1dGhBbm9ueW1vdXNseT1YLnByb3RvdHlwZS5nZztcblgucHJvdG90eXBlLmxnPWZ1bmN0aW9uKGEsYixjKXtEKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDEsMyxhcmd1bWVudHMubGVuZ3RoKTsyPT09YXJndW1lbnRzLmxlbmd0aCYmSGIoYikmJihjPWIsYj12b2lkIDApO3NnKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDEsYSwhMSk7dGcoXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO3RnKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLGEsXCJwYXNzd29yZFwiKTtGKFwiRmlyZWJhc2UuYXV0aFdpdGhQYXNzd29yZFwiLDIsYiwhMCk7c2coXCJGaXJlYmFzZS5hdXRoV2l0aFBhc3N3b3JkXCIsMyxjLCEwKTt2YXIgZD1uZXcgQjtmaCh0aGlzLmsuTyxcInBhc3N3b3JkXCIsYSxjLEMoZCxiKSk7cmV0dXJuIGQuRH07WC5wcm90b3R5cGUuYXV0aFdpdGhQYXNzd29yZD1YLnByb3RvdHlwZS5sZztcblgucHJvdG90eXBlLnZlPWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7c2coXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMSxhLCExKTt0ZyhcIkZpcmViYXNlLmNyZWF0ZVVzZXJcIixhLFwiZW1haWxcIik7dGcoXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0YoXCJGaXJlYmFzZS5jcmVhdGVVc2VyXCIsMixiLCEwKTt2YXIgYz1uZXcgQjt0aGlzLmsuTy52ZShhLEMoYyxiKSk7cmV0dXJuIGMuRH07WC5wcm90b3R5cGUuY3JlYXRlVXNlcj1YLnByb3RvdHlwZS52ZTtcblgucHJvdG90eXBlLlhlPWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLnJlbW92ZVVzZXJcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7c2coXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMSxhLCExKTt0ZyhcIkZpcmViYXNlLnJlbW92ZVVzZXJcIixhLFwiZW1haWxcIik7dGcoXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsYSxcInBhc3N3b3JkXCIpO0YoXCJGaXJlYmFzZS5yZW1vdmVVc2VyXCIsMixiLCEwKTt2YXIgYz1uZXcgQjt0aGlzLmsuTy5YZShhLEMoYyxiKSk7cmV0dXJuIGMuRH07WC5wcm90b3R5cGUucmVtb3ZlVXNlcj1YLnByb3RvdHlwZS5YZTtcblgucHJvdG90eXBlLnNlPWZ1bmN0aW9uKGEsYil7RChcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO3NnKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIiwxLGEsITEpO3RnKFwiRmlyZWJhc2UuY2hhbmdlUGFzc3dvcmRcIixhLFwiZW1haWxcIik7dGcoXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLGEsXCJvbGRQYXNzd29yZFwiKTt0ZyhcIkZpcmViYXNlLmNoYW5nZVBhc3N3b3JkXCIsYSxcIm5ld1Bhc3N3b3JkXCIpO0YoXCJGaXJlYmFzZS5jaGFuZ2VQYXNzd29yZFwiLDIsYiwhMCk7dmFyIGM9bmV3IEI7dGhpcy5rLk8uc2UoYSxDKGMsYikpO3JldHVybiBjLkR9O1gucHJvdG90eXBlLmNoYW5nZVBhc3N3b3JkPVgucHJvdG90eXBlLnNlO1xuWC5wcm90b3R5cGUucmU9ZnVuY3Rpb24oYSxiKXtEKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIiwxLDIsYXJndW1lbnRzLmxlbmd0aCk7c2coXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLDEsYSwhMSk7dGcoXCJGaXJlYmFzZS5jaGFuZ2VFbWFpbFwiLGEsXCJvbGRFbWFpbFwiKTt0ZyhcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsYSxcIm5ld0VtYWlsXCIpO3RnKFwiRmlyZWJhc2UuY2hhbmdlRW1haWxcIixhLFwicGFzc3dvcmRcIik7RihcIkZpcmViYXNlLmNoYW5nZUVtYWlsXCIsMixiLCEwKTt2YXIgYz1uZXcgQjt0aGlzLmsuTy5yZShhLEMoYyxiKSk7cmV0dXJuIGMuRH07WC5wcm90b3R5cGUuY2hhbmdlRW1haWw9WC5wcm90b3R5cGUucmU7XG5YLnByb3RvdHlwZS5aZT1mdW5jdGlvbihhLGIpe0QoXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsMSwyLGFyZ3VtZW50cy5sZW5ndGgpO3NnKFwiRmlyZWJhc2UucmVzZXRQYXNzd29yZFwiLDEsYSwhMSk7dGcoXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsYSxcImVtYWlsXCIpO0YoXCJGaXJlYmFzZS5yZXNldFBhc3N3b3JkXCIsMixiLCEwKTt2YXIgYz1uZXcgQjt0aGlzLmsuTy5aZShhLEMoYyxiKSk7cmV0dXJuIGMuRH07WC5wcm90b3R5cGUucmVzZXRQYXNzd29yZD1YLnByb3RvdHlwZS5aZTt9KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpcmViYXNlO1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgb3MgPSByZXF1aXJlKFwib3NcIik7XG52YXIgY29udmVydFNvdXJjZU1hcCA9IHJlcXVpcmUoXCJjb252ZXJ0LXNvdXJjZS1tYXBcIik7XG52YXIgU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VNYXBDb25zdW1lcjtcbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgc3RhYmxlU29ydCA9IHJlcXVpcmUoXCJzdGFibGVcIik7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcHBlcihzcmMsIG5vZGVQb3NpdGlvbnMsIGZyYWdtZW50cywgaW5GaWxlLCBzb3VyY2VSb290KSB7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHsgc291cmNlUm9vdDogc291cmNlUm9vdCB9KTtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICAvLyBzdGFibGVTb3J0IGRvZXMgbm90IG11dGF0ZSBpbnB1dCBhcnJheSBzbyBubyBuZWVkIHRvIGNvcHkgaXRcbiAgICB0aGlzLm5vZGVQb3NpdGlvbnMgPSBzdGFibGVTb3J0KG5vZGVQb3NpdGlvbnMsIGNvbXBhcmVMb2MpO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gc3RhYmxlU29ydChmcmFnbWVudHMsIGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0IH0pO1xuICAgIHRoaXMuaW5GaWxlID0gaW5GaWxlO1xuXG4gICAgdGhpcy5nZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudCh0aGlzLmluRmlsZSwgc3JjKTtcbn1cblxuU291cmNlTWFwcGVyLnByb3RvdHlwZS5jYWxjdWxhdGVNYXBwaW5ncyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFRoZXNlIG9mZnNldHMgcmVwcmVzZW50IHRoZSBkaWZmZXJlbmNlIGluIGNvb3JkaW5hdGVzIGJldHdlZW4gYSBub2RlIGluIHRoZSBzb3VyY2VcbiAgICAvLyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG91dHB1dC5cbiAgICB2YXIgbGluZU9mZnNldCA9IDA7XG4gICAgdmFyIGNvbHVtbk9mZnNldCA9IDA7XG5cbiAgICAvLyBTaW5jZSB0aGUgY29sdW1uIHBvc2l0aW9uIHJlc2V0cyB0byB6ZXJvIGFmdGVyIGVhY2ggbmV3bGluZSwgd2UgaGF2ZSB0byBrZWVwIHRyYWNrXG4gICAgLy8gb2YgdGhlIGN1cnJlbnQgbGluZSB0aGF0IGNvbHVtbk9mZnNldCByZWZlcnMgdG8gaW4gb3JkZXIgdG8ga25vdyB3aGV0aGVyIHRvIHJlc2V0IGl0XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gMDtcblxuICAgIHZhciBmcmFnID0gMDtcbiAgICB2YXIgcG9zID0gMDtcblxuICAgIHdoaWxlIChwb3MgPCBzZWxmLm5vZGVQb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChmcmFnIDwgc2VsZi5mcmFnbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICBjb21wYXJlTG9jKHNlbGYuZnJhZ21lbnRzW2ZyYWddLmxvYy5zdGFydCwgc2VsZi5ub2RlUG9zaXRpb25zW3Bvc10pIDwgMSkge1xuXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRMaW5lcyA9IHNlbGYuZnJhZ21lbnRzW2ZyYWddLnN0ci5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIHZhciBhZGRlZE5ld2xpbmVzID0gZnJhZ21lbnRMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICB2YXIgcmVwbGFjZWRMaW5lcyA9IHNlbGYuZnJhZ21lbnRzW2ZyYWddLmxvYy5lbmQubGluZSAtIHNlbGYuZnJhZ21lbnRzW2ZyYWddLmxvYy5zdGFydC5saW5lO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VkQ29sdW1ucyA9IHNlbGYuZnJhZ21lbnRzW2ZyYWddLmxvYy5lbmQuY29sdW1uIC0gc2VsZi5mcmFnbWVudHNbZnJhZ10ubG9jLnN0YXJ0LmNvbHVtbjtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2VyZSBhbnkgbGluZXMgYWRkZWQgYnkgdGhlIGZyYWdtZW50IHN0cmluZywgdGhlIGxpbmUgb2Zmc2V0IHNob3VsZCBpbmNyZWFzZTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIHdlcmUgYW55IGxpbmVzIHJlbW92ZWQgYnkgdGhlIGZyYWdtZW50IHJlcGxhY2VtZW50IHRoZW4gdGhlIGxpbmUgb2Zmc2V0IHNob3VsZCBkZWNyZWFzZVxuICAgICAgICAgICAgbGluZU9mZnNldCA9IGxpbmVPZmZzZXQgKyBhZGRlZE5ld2xpbmVzIC0gcmVwbGFjZWRMaW5lcztcblxuICAgICAgICAgICAgLy8gVGhlIGNvbHVtbiBwb3NpdGlvbiBuZWVkcyB0byByZXNldCBhZnRlciBlYWNoIG5ld2xpbmUuICBTbyBpZiB0aGUgZnJhZ21lbnQgYWRkZWQgYW55XG4gICAgICAgICAgICAvLyBuZXdsaW5lcyB0aGVuIHRoZSBjb2x1bW4gb2Zmc2V0IGlzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGNvbHVtbiBvZiB0aGUgbGFzdCBsaW5lIG9mXG4gICAgICAgICAgICAvLyB0aGUgZnJhZ21lbnQsIGFuZCB0aGUgY29sdW1uIG9mIHRoZSBlbmQgb2YgdGhlIHJlcGxhY2VkIHNlY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBjb2x1bW4gb2Zmc2V0IGp1c3QgbGlrZSBob3cgdGhlIGxpbmUgb2Zmc2V0IHdvcmtzLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IFwicmVwbGFjZWRDb2x1bW5zXCIgbWlnaHQgYmUgbmVnYXRpdmUgaW4gc29tZSBjYXNlcyAoaWYgdGhlIGJlZ2lubmluZyBvZiB0aGUgc291cmNlXG4gICAgICAgICAgICAvLyB3YXMgZnVydGhlciByaWdodCB0aGFuIHRoZSBlbmQgZHVlIHRvIGEgbmV3bGluZSk7IHRoZSBtYXRoIHN0aWxsIHdvcmtzIG91dC5cbiAgICAgICAgICAgIGNvbHVtbk9mZnNldCA9IGZyYWdtZW50TGluZXMubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRMaW5lc1tmcmFnbWVudExpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIHNlbGYuZnJhZ21lbnRzW2ZyYWddLmxvYy5lbmQuY29sdW1uIDpcbiAgICAgICAgICAgICAgICBjb2x1bW5PZmZzZXQgKyBzZWxmLmZyYWdtZW50c1tmcmFnXS5zdHIubGVuZ3RoIC0gcmVwbGFjZWRDb2x1bW5zO1xuXG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IHNlbGYuZnJhZ21lbnRzW2ZyYWddLmxvYy5lbmQubGluZTtcblxuICAgICAgICAgICAgLy8gU2tpcCBjcmVhdGluZyBtYXBwaW5ncyBmb3IgYW55IHNvdXJjZSBub2RlcyB0aGF0IHdlcmUgcmVwbGFjZWQgYnkgdGhpcyBmcmFnbWVudCAoYW5kIGFyZSB0aHVzXG4gICAgICAgICAgICAvLyBubyBsb25nZXIgYSBwYXJ0IG9mIHRoZSBvdXRwdXQpXG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgc2VsZi5ub2RlUG9zaXRpb25zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVMb2Moc2VsZi5mcmFnbWVudHNbZnJhZ10ubG9jLmVuZCwgc2VsZi5ub2RlUG9zaXRpb25zW3Bvc10pID4gMCkge1xuICAgICAgICAgICAgICAgICsrcG9zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICArK2ZyYWc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zIDwgc2VsZi5ub2RlUG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lIDwgc2VsZi5ub2RlUG9zaXRpb25zW3Bvc10ubGluZSlcbiAgICAgICAgICAgICAgICBjb2x1bW5PZmZzZXQgPSAwO1xuICAgICAgICAgICAgc2VsZi5hZGRNYXBwaW5nKHNlbGYubm9kZVBvc2l0aW9uc1twb3NdLCB7XG4gICAgICAgICAgICAgICAgbGluZTogc2VsZi5ub2RlUG9zaXRpb25zW3Bvc10ubGluZSArIGxpbmVPZmZzZXQsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBzZWxmLm5vZGVQb3NpdGlvbnNbcG9zXS5jb2x1bW4gKyBjb2x1bW5PZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKytwb3M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblNvdXJjZU1hcHBlci5wcm90b3R5cGUuYWRkTWFwcGluZyA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgICB0aGlzLmdlbmVyYXRvci5hZGRNYXBwaW5nKHtcbiAgICAgICAgc291cmNlOiB0aGlzLmluRmlsZSxcbiAgICAgICAgb3JpZ2luYWw6IGlucHV0LFxuICAgICAgICBnZW5lcmF0ZWQ6IG91dHB1dFxuICAgIH0pO1xufVxuXG5Tb3VyY2VNYXBwZXIucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID0gZnVuY3Rpb24gKGNvbnN1bWVyKSB7XG4gICAgdGhpcy5nZW5lcmF0b3IuYXBwbHlTb3VyY2VNYXAoY29uc3VtZXIpO1xufVxuXG5Tb3VyY2VNYXBwZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTG9jKGEsIGIpIHtcbiAgICByZXR1cm4gKGEubGluZSAtIGIubGluZSkgfHwgKGEuY29sdW1uIC0gYi5jb2x1bW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlU291cmNlbWFwKHJlc3VsdCwgc3JjLCBub2RlUG9zaXRpb25zLCBmcmFnbWVudHMsIG1hcE9wdHMpIHtcbiAgICB2YXIgZXhpc3RpbmdNYXAgPSBjb252ZXJ0U291cmNlTWFwLmZyb21Tb3VyY2Uoc3JjKTtcbiAgICB2YXIgZXhpc3RpbmdNYXBPYmplY3QgPSBleGlzdGluZ01hcCAmJiBleGlzdGluZ01hcC50b09iamVjdCgpO1xuICAgIHZhciBpbkZpbGUgPSAoZXhpc3RpbmdNYXBPYmplY3QgJiYgZXhpc3RpbmdNYXBPYmplY3QuZmlsZSkgfHwgbWFwT3B0cy5pbkZpbGUgfHwgXCJzb3VyY2UuanNcIjtcbiAgICB2YXIgc291cmNlUm9vdCA9IChleGlzdGluZ01hcE9iamVjdCAmJiBleGlzdGluZ01hcE9iamVjdC5zb3VyY2VSb290KSB8fCBtYXBPcHRzLnNvdXJjZVJvb3Q7XG4gICAgc3JjID0gY29udmVydFNvdXJjZU1hcC5yZW1vdmVNYXBGaWxlQ29tbWVudHMoc3JjKTtcblxuICAgIHZhciBtYXBwZXIgPSBuZXcgU291cmNlTWFwcGVyKHNyYywgbm9kZVBvc2l0aW9ucywgZnJhZ21lbnRzLCBpbkZpbGUsIHNvdXJjZVJvb3QpO1xuICAgIG1hcHBlci5jYWxjdWxhdGVNYXBwaW5ncygpO1xuXG4gICAgaWYgKG1hcE9wdHMuaW5saW5lKSB7XG4gICAgICAgIGlmIChleGlzdGluZ01hcE9iamVjdClcbiAgICAgICAgICAgIG1hcHBlci5hcHBseVNvdXJjZU1hcChuZXcgU291cmNlTWFwQ29uc3VtZXIoZXhpc3RpbmdNYXBPYmplY3QpKTtcblxuICAgICAgICByZXN1bHQuc3JjID0gY29udmVydFNvdXJjZU1hcC5yZW1vdmVNYXBGaWxlQ29tbWVudHMocmVzdWx0LnNyYykgK1xuICAgICAgICAgICAgb3MuRU9MICtcbiAgICAgICAgICAgIGNvbnZlcnRTb3VyY2VNYXAuZnJvbUpTT04obWFwcGVyLmdlbmVyYXRlKCkpLnRvQ29tbWVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5tYXAgPSBtYXBwZXIuZ2VuZXJhdGUoKTtcbiAgICB9XG59XG4iLCIvLyBsdXQuanNcbi8vIE1JVCBsaWNlbnNlZCwgc2VlIExJQ0VOU0UgZmlsZVxuLy8gQ29weXJpZ2h0IChjKSAyMDEzLTIwMTYgT2xvdiBMYXNzdXMgPG9sb3YubGFzc3VzQGdtYWlsLmNvbT5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIHRyYXZlcnNlID0gcmVxdWlyZShcIm9yZGVyZWQtYXN0LXRyYXZlcnNlXCIpO1xudmFyIGlzID0gcmVxdWlyZShcInNpbXBsZS1pc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMdXQ7XG5cbmZ1bmN0aW9uIEx1dChhc3QsIHNyYykge1xuICAgIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgTHV0KTtcblxuICAgIHZhciBzcGFyc2VCZWdpbnMgPSBuZXcgQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGJlZ2lucyA9IFtdO1xuICAgIHZhciBzcGFyc2VFbmRzID0gbmV3IEFycmF5KHNyYy5sZW5ndGgpO1xuICAgIHZhciBlbmRzID0gW107XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciB0MCA9IERhdGUubm93KCk7XG4gICAgdHJhdmVyc2UoYXN0LCB7cHJlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIC8vICAgICAgICBhc3NlcnQgKG5vZGUucmFuZ2VbMF0gPj0gcCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiUHJvZ3JhbVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcCA9IG5vZGUucmFuZ2VbMF07XG4gICAgICAgIGlmICghc3BhcnNlQmVnaW5zW3BdKSB7XG4gICAgICAgICAgICBzcGFyc2VCZWdpbnNbcF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBub2RlLnJhbmdlWzFdO1xuICAgICAgICBpZiAoIXNwYXJzZUVuZHNbcF0pIHtcbiAgICAgICAgICAgIHNwYXJzZUVuZHNbcF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgfX0pO1xuICAgIGZvciAodmFyIGkgaW4gc3BhcnNlQmVnaW5zKSB7XG4gICAgICAgIGJlZ2lucy5wdXNoKHNwYXJzZUJlZ2luc1tpXSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkkMCBpbiBzcGFyc2VFbmRzKSB7XG4gICAgICAgIGVuZHMucHVzaChzcGFyc2VFbmRzW2kkMF0pO1xuICAgIH1cbiAgICB2YXIgdDEgPSBEYXRlLm5vdygpO1xuICAgIC8vICAgIGNvbnNvbGUuZXJyb3IodDEtdDApXG5cbiAgICAvLyBiZWdpbnMgYW5kIGVuZHMgYXJlIGNvbXBhY3QgYXJyYXlzIHdpdGggbm9kZXMsXG4gICAgLy8gc29ydGVkIG9uIG5vZGUucmFuZ2VbMC8xXSAodW5pcXVlKVxuICAgIHRoaXMuYmVnaW5zID0gYmVnaW5zO1xuICAgIHRoaXMuZW5kcyA9IGVuZHM7XG59XG5cbkx1dC5wcm90b3R5cGUuZmluZE5vZGVGcm9tUG9zID0gZmluZE5vZGVGcm9tUG9zO1xuTHV0LnByb3RvdHlwZS5maW5kTm9kZUJlZm9yZVBvcyA9IGZpbmROb2RlQmVmb3JlUG9zO1xuXG4vLyBiaW5hcnkgc2VhcmNoIGx1dCB0byBmaW5kIG5vZGUgYmVnaW5uaW5nIGF0IHBvc1xuLy8gb3IgYXMgY2xvc2UgYWZ0ZXIgcG9zIGFzIHBvc3NpYmxlLiBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGZpbmROb2RlRnJvbVBvcyhwb3MpIHtcbiAgICB2YXIgbHV0ID0gdGhpcy5iZWdpbnM7XG4gICAgYXNzZXJ0KGlzLmZpbml0ZW51bWJlcihwb3MpICYmIHBvcyA+PSAwKTtcblxuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgcmlnaHQgPSBsdXQubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gICAgICAgIGFzc2VydChtaWQgPj0gMCAmJiBtaWQgPCBsdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKHBvcyA+IGx1dFttaWRdLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgYXNzZXJ0KGxhc3QobHV0KS5yYW5nZVswXSA8IHBvcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmb3VuZCA9IGxlZnQ7XG4gICAgdmFyIGZvdW5kUG9zID0gbHV0W2ZvdW5kXS5yYW5nZVswXTtcbiAgICBhc3NlcnQoZm91bmRQb3MgPj0gcG9zKTtcbiAgICBpZiAoZm91bmQgPj0gMSkge1xuICAgICAgICB2YXIgcHJldlBvcyA9IGx1dFtmb3VuZCAtIDFdLnJhbmdlWzBdO1xuICAgICAgICBhc3NlcnQocHJldlBvcyA8IHBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGx1dFtmb3VuZF07XG59XG5cbi8vIGJpbmFyeSBzZWFyY2ggbHV0IHRvIGZpbmQgbm9kZSBlbmRpbmcgKGFzIGluIHJhbmdlWzFdXG4vLyBhdCBvciBiZWZvcmUgcG9zLiBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGZpbmROb2RlQmVmb3JlUG9zKHBvcykge1xuICAgIHZhciBsdXQgPSB0aGlzLmVuZHM7XG4gICAgYXNzZXJ0KGlzLmZpbml0ZW51bWJlcihwb3MpICYmIHBvcyA+PSAwKTtcblxuICAgIHZhciBsZWZ0ID0gMDtcbiAgICB2YXIgcmlnaHQgPSBsdXQubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgIHZhciBtaWQgPSBNYXRoLmNlaWwoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgICAgICAgYXNzZXJ0KG1pZCA+PSAwICYmIG1pZCA8IGx1dC5sZW5ndGgpO1xuICAgICAgICBpZiAocG9zIDwgbHV0W21pZF0ucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQgPiByaWdodCkge1xuICAgICAgICBhc3NlcnQobHV0WzBdLnJhbmdlWzFdID4gcG9zKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kID0gbGVmdDtcbiAgICB2YXIgZm91bmRQb3MgPSBsdXRbZm91bmRdLnJhbmdlWzFdO1xuICAgIGlmKGZvdW5kUG9zID4gcG9zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZm91bmQgPD0gbHV0Lmxlbmd0aCAtIDIpIHtcbiAgICAgICAgdmFyIG5leHRQb3MgPSBsdXRbZm91bmQgKyAxXS5yYW5nZVsxXTtcbiAgICAgICAgYXNzZXJ0KG5leHRQb3MgPiBwb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBsdXRbZm91bmRdO1xufVxuXG5mdW5jdGlvbiBsYXN0KGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuIiwiLy8gbmctYW5ub3RhdGUtbWFpbi5qc1xuLy8gTUlUIGxpY2Vuc2VkLCBzZWUgTElDRU5TRSBmaWxlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNiBPbG92IExhc3N1cyA8b2xvdi5sYXNzdXNAZ21haWwuY29tPlxuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBmbXQgPSByZXF1aXJlKFwic2ltcGxlLWZtdFwiKTtcbnZhciBpcyA9IHJlcXVpcmUoXCJzaW1wbGUtaXNcIik7XG52YXIgYWx0ZXIgPSByZXF1aXJlKFwiYWx0ZXJcIik7XG52YXIgdHJhdmVyc2UgPSByZXF1aXJlKFwib3JkZXJlZC1hc3QtdHJhdmVyc2VcIik7XG52YXIgRU9MID0gcmVxdWlyZShcIm9zXCIpLkVPTDtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIG5nSW5qZWN0ID0gcmVxdWlyZShcIi4vbmdpbmplY3RcIik7XG52YXIgZ2VuZXJhdGVTb3VyY2VtYXAgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZS1zb3VyY2VtYXBcIik7XG52YXIgTHV0ID0gcmVxdWlyZShcIi4vbHV0XCIpO1xudmFyIHNjb3BlVG9vbHMgPSByZXF1aXJlKFwiLi9zY29wZXRvb2xzXCIpO1xudmFyIHN0cmluZ21hcCA9IHJlcXVpcmUoXCJzdHJpbmdtYXBcIik7XG52YXIgb3B0aW9uYWxBbmd1bGFyRGFzaGJvYXJkRnJhbWV3b3JrID0gcmVxdWlyZShcIi4vb3B0aW9uYWxzL2FuZ3VsYXItZGFzaGJvYXJkLWZyYW1ld29ya1wiKTtcbnZhciByZXF1aXJlX2Fjb3JuX3QwID0gRGF0ZS5ub3coKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKFwiYWNvcm5cIikucGFyc2U7XG52YXIgcmVxdWlyZV9hY29ybl90MSA9IERhdGUubm93KCk7XG5cbnZhciBjaGFpbmVkUm91dGVQcm92aWRlciA9IDE7XG52YXIgY2hhaW5lZFVybFJvdXRlclByb3ZpZGVyID0gMjtcbnZhciBjaGFpbmVkU3RhdGVQcm92aWRlciA9IDM7XG52YXIgY2hhaW5lZFJlZ3VsYXIgPSA0O1xuXG5mdW5jdGlvbiBtYXRjaChub2RlLCBjdHgsIG1hdGNoUGx1Z2lucykge1xuICAgIHZhciBpc01ldGhvZENhbGwgPSAoXG4gICAgICAgIG5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiICYmXG4gICAgICAgICAgICBub2RlLmNhbGxlZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJlxuICAgICAgICAgICAgbm9kZS5jYWxsZWUuY29tcHV0ZWQgPT09IGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAvLyBtYXRjaEluamVjdG9ySW52b2tlIG11c3QgaGFwcGVuIGJlZm9yZSBtYXRjaFJlZ3VsYXJcbiAgICAvLyB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlICgkaW5qZWN0b3IuaW52b2tlKCkgb3V0c2lkZSBtb2R1bGUpXG4gICAgLy8gbWF0Y2hQcm92aWRlIG11c3QgaGFwcGVuIGJlZm9yZSBtYXRjaFJlZ3VsYXJcbiAgICAvLyB0byBwcmV2ZW50IHJlZ3VsYXIgZnJvbSBtYXRjaGluZyBpdCBhcyBhIHNob3J0LWZvcm1cbiAgICB2YXIgbWF0Y2hNZXRob2RDYWxscyA9IChpc01ldGhvZENhbGwgJiZcbiAgICAgICAgKG1hdGNoSW5qZWN0b3JJbnZva2Uobm9kZSkgfHwgbWF0Y2hQcm92aWRlKG5vZGUsIGN0eCkgfHwgbWF0Y2hSZWd1bGFyKG5vZGUsIGN0eCkgfHwgbWF0Y2hOZ1JvdXRlKG5vZGUpIHx8IG1hdGNoTWF0ZXJpYWxTaG93TW9kYWxPcGVuKG5vZGUpIHx8IG1hdGNoTmdVaShub2RlKSB8fCBtYXRjaEh0dHBQcm92aWRlcihub2RlKSB8fCBtYXRjaENvbnRyb2xsZXJQcm92aWRlcihub2RlKSkpO1xuXG4gICAgcmV0dXJuIG1hdGNoTWV0aG9kQ2FsbHMgfHxcbiAgICAgICAgKG1hdGNoUGx1Z2lucyAmJiBtYXRjaFBsdWdpbnMobm9kZSkpIHx8XG4gICAgICAgIG1hdGNoRGlyZWN0aXZlUmV0dXJuT2JqZWN0KG5vZGUpIHx8XG4gICAgICAgIG1hdGNoUHJvdmlkZXJHZXQobm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoTWF0ZXJpYWxTaG93TW9kYWxPcGVuKG5vZGUpIHtcbiAgICAvLyAkbWREaWFsb2cuc2hvdyh7Li4gY29udHJvbGxlcjogZm4sIHJlc29sdmU6IHtmOiBmdW5jdGlvbigkc2NvcGUpIHt9LCAuLn19KTtcbiAgICAvLyAkbWRUb2FzdC5zaG93KHsuLiBjb250cm9sbGVyOiBmbiwgcmVzb2x2ZToge2Y6IGZ1bmN0aW9uKCRzY29wZSkge30sIC4ufX0pO1xuICAgIC8vICRtZEJvdHRvbVNoZWV0LnNob3coey4uIGNvbnRyb2xsZXI6IGZuLCByZXNvbHZlOiB7ZjogZnVuY3Rpb24oJHNjb3BlKSB7fSwgLi59fSk7XG4gICAgLy8gJG1vZGFsLm9wZW4oey4uIGNvbnRyb2xsZXI6IGZuLCByZXNvbHZlOiB7ZjogZnVuY3Rpb24oJHNjb3BlKSB7fSwgLi59fSk7XG5cbiAgICAvLyB3ZSBhbHJlYWR5IGtub3cgdGhhdCBub2RlIGlzIGEgKG5vbi1jb21wdXRlZCkgbWV0aG9kIGNhbGxcbiAgICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gICAgdmFyIG9iaiA9IGNhbGxlZS5vYmplY3Q7IC8vIGlkZW50aWZpZXIgb3IgZXhwcmVzc2lvblxuICAgIHZhciBtZXRob2QgPSBjYWxsZWUucHJvcGVydHk7IC8vIGlkZW50aWZpZXJcbiAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzO1xuXG4gICAgaWYgKG9iai50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAoKGlzLnNvbWVvZihvYmoubmFtZSwgW1wiJG1vZGFsXCIsIFwiJHVpYk1vZGFsXCJdKSAmJiBtZXRob2QubmFtZSA9PT0gXCJvcGVuXCIpIHx8IChpcy5zb21lb2Yob2JqLm5hbWUsIFtcIiRtZERpYWxvZ1wiLCBcIiRtZFRvYXN0XCIsIFwiJG1kQm90dG9tU2hlZXRcIl0pICYmIG1ldGhvZC5uYW1lID09PSBcInNob3dcIikpICYmXG4gICAgICAgIGFyZ3MubGVuZ3RoID09PSAxICYmIGFyZ3NbMF0udHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJnc1swXS5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgcmVzID0gW21hdGNoUHJvcChcImNvbnRyb2xsZXJcIiwgcHJvcHMpXTtcbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBtYXRjaFJlc29sdmUocHJvcHMpKTtcbiAgICAgICAgcmV0dXJuIHJlcy5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hEaXJlY3RpdmVSZXR1cm5PYmplY3Qobm9kZSkge1xuICAgIC8vIG9ubHkgbWF0Y2hlcyBpbnNpZGUgZGlyZWN0aXZlc1xuICAgIC8vIHJldHVybiB7IC4uIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCRzY29wZSwgJHRpbWVvdXQpLCAuLi59XG5cbiAgICByZXR1cm4gbGltaXQoXCJkaXJlY3RpdmVcIiwgbm9kZS50eXBlID09PSBcIlJldHVyblN0YXRlbWVudFwiICYmXG4gICAgICAgIG5vZGUuYXJndW1lbnQgJiYgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiAmJlxuICAgICAgICBtYXRjaFByb3AoXCJjb250cm9sbGVyXCIsIG5vZGUuYXJndW1lbnQucHJvcGVydGllcykpO1xufVxuXG5mdW5jdGlvbiBsaW1pdChuYW1lLCBub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgIW5vZGUuJGxpbWl0VG9NZXRob2ROYW1lKSB7XG4gICAgICAgIG5vZGUuJGxpbWl0VG9NZXRob2ROYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUHJvdmlkZXJHZXQobm9kZSkge1xuICAgIC8vIG9ubHkgbWF0Y2hlcyBpbnNpZGUgcHJvdmlkZXJzXG4gICAgLy8gKHRoaXN8c2VsZnx0aGF0KS4kZ2V0ID0gZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dClcbiAgICAvLyB7IC4uLiAkZ2V0OiBmdW5jdGlvbigkc2NvcGUsICR0aW1lb3V0KSwgLi4ufVxuICAgIHZhciBtZW1iZXJFeHByO1xuICAgIHZhciBzZWxmO1xuICAgIHJldHVybiBsaW1pdChcInByb3ZpZGVyXCIsIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiAmJiAobWVtYmVyRXhwciA9IG5vZGUubGVmdCkudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiZcbiAgICAgICAgbWVtYmVyRXhwci5wcm9wZXJ0eS5uYW1lID09PSBcIiRnZXRcIiAmJlxuICAgICAgICAoKHNlbGYgPSBtZW1iZXJFeHByLm9iamVjdCkudHlwZSA9PT0gXCJUaGlzRXhwcmVzc2lvblwiIHx8IChzZWxmLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGlzLnNvbWVvZihzZWxmLm5hbWUsIFtcInNlbGZcIiwgXCJ0aGF0XCJdKSkpICYmXG4gICAgICAgIG5vZGUucmlnaHQpIHx8XG4gICAgICAgIChub2RlLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiICYmIG1hdGNoUHJvcChcIiRnZXRcIiwgbm9kZS5wcm9wZXJ0aWVzKSkpO1xufVxuXG5mdW5jdGlvbiBtYXRjaE5nUm91dGUobm9kZSkge1xuICAgIC8vICRyb3V0ZVByb3ZpZGVyLndoZW4oXCJwYXRoXCIsIHtcbiAgICAvLyAgIC4uLlxuICAgIC8vICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlKSB7fSxcbiAgICAvLyAgIHJlc29sdmU6IHtmOiBmdW5jdGlvbigkc2NvcGUpIHt9LCAuLn1cbiAgICAvLyB9KVxuXG4gICAgLy8gd2UgYWxyZWFkeSBrbm93IHRoYXQgbm9kZSBpcyBhIChub24tY29tcHV0ZWQpIG1ldGhvZCBjYWxsXG4gICAgdmFyIGNhbGxlZSA9IG5vZGUuY2FsbGVlO1xuICAgIHZhciBvYmogPSBjYWxsZWUub2JqZWN0OyAvLyBpZGVudGlmaWVyIG9yIGV4cHJlc3Npb25cbiAgICBpZiAoIShvYmouJGNoYWluZWQgPT09IGNoYWluZWRSb3V0ZVByb3ZpZGVyIHx8IChvYmoudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgb2JqLm5hbWUgPT09IFwiJHJvdXRlUHJvdmlkZXJcIikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbm9kZS4kY2hhaW5lZCA9IGNoYWluZWRSb3V0ZVByb3ZpZGVyO1xuXG4gICAgdmFyIG1ldGhvZCA9IGNhbGxlZS5wcm9wZXJ0eTsgLy8gaWRlbnRpZmllclxuICAgIGlmIChtZXRob2QubmFtZSAhPT0gXCJ3aGVuXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gbm9kZS5hcmd1bWVudHM7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvbmZpZ0FyZyA9IGxhc3QoYXJncylcbiAgICBpZiAoY29uZmlnQXJnLnR5cGUgIT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBjb25maWdBcmcucHJvcGVydGllcztcbiAgICB2YXIgcmVzID0gW1xuICAgICAgICBtYXRjaFByb3AoXCJjb250cm9sbGVyXCIsIHByb3BzKVxuICAgIF07XG4gICAgLy8ge3Jlc29sdmU6IC4ufVxuICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbWF0Y2hSZXNvbHZlKHByb3BzKSk7XG5cbiAgICB2YXIgZmlsdGVyZWRSZXMgPSByZXMuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHJldHVybiAoZmlsdGVyZWRSZXMubGVuZ3RoID09PSAwID8gZmFsc2UgOiBmaWx0ZXJlZFJlcyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoTmdVaShub2RlKSB7XG4gICAgLy8gJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJteVN0YXRlXCIsIHtcbiAgICAvLyAgICAgLi4uXG4gICAgLy8gICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCRzY29wZSlcbiAgICAvLyAgICAgY29udHJvbGxlclByb3ZpZGVyOiBmdW5jdGlvbigkc2NvcGUpXG4gICAgLy8gICAgIHRlbXBsYXRlUHJvdmlkZXI6IGZ1bmN0aW9uKCRzY29wZSlcbiAgICAvLyAgICAgb25FbnRlcjogZnVuY3Rpb24oJHNjb3BlKVxuICAgIC8vICAgICBvbkV4aXQ6IGZ1bmN0aW9uKCRzY29wZSlcbiAgICAvLyB9KTtcbiAgICAvLyAkc3RhdGVQcm92aWRlci5zdGF0ZShcIm15U3RhdGVcIiwgey4uLiByZXNvbHZlOiB7ZjogZnVuY3Rpb24oJHNjb3BlKSB7fSwgLi59IC4ufSlcbiAgICAvLyAkc3RhdGVQcm92aWRlci5zdGF0ZShcIm15U3RhdGVcIiwgey4uLiBwYXJhbXM6IHtwYXJhbXM6IHtzaW1wbGU6IGZ1bmN0aW9uKCRzY29wZSkge30sIGluVmFsdWU6IHsgdmFsdWU6IGZ1bmN0aW9uKCRzY29wZSkge30gfX0gLi59KVxuICAgIC8vICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwibXlTdGF0ZVwiLCB7Li4uIHZpZXdzOiB7Li4uIHNvbWVuYW1lOiB7Li4uIGNvbnRyb2xsZXI6IGZuLCBjb250cm9sbGVyUHJvdmlkZXI6IGZuLCB0ZW1wbGF0ZVByb3ZpZGVyOiBmbiwgcmVzb2x2ZToge2Y6IGZufX19fSlcbiAgICAvL1xuICAgIC8vIHN0YXRlSGVscGVyUHJvdmlkZXIuc2V0TmVzdGVkU3RhdGUoeyBzYW1lYXNyZWd1bGFyc3RhdGUsIGNoaWxkcmVuOiBbc2FtZWFzcmVndWxhcnN0YXRlLCAuLl19KVxuICAgIC8vIHN0YXRlSGVscGVyUHJvdmlkZXIuc2V0TmVzdGVkU3RhdGUoeyBzYW1lYXNyZWd1bGFyc3RhdGUsIGNoaWxkcmVuOiBbc2FtZWFzcmVndWxhcnN0YXRlLCAuLl19LCB0cnVlKVxuICAgIC8vXG4gICAgLy8gJHVybFJvdXRlclByb3ZpZGVyLndoZW4oLi4sIGZ1bmN0aW9uKCRzY29wZSkge30pXG4gICAgLy9cbiAgICAvLyAkbW9kYWwub3BlbiBzZWUgbWF0Y2hNYXRlcmlhbFNob3dNb2RhbE9wZW5cblxuICAgIC8vIHdlIGFscmVhZHkga25vdyB0aGF0IG5vZGUgaXMgYSAobm9uLWNvbXB1dGVkKSBtZXRob2QgY2FsbFxuICAgIHZhciBjYWxsZWUgPSBub2RlLmNhbGxlZTtcbiAgICB2YXIgb2JqID0gY2FsbGVlLm9iamVjdDsgLy8gaWRlbnRpZmllciBvciBleHByZXNzaW9uXG4gICAgdmFyIG1ldGhvZCA9IGNhbGxlZS5wcm9wZXJ0eTsgLy8gaWRlbnRpZmllclxuICAgIHZhciBhcmdzID0gbm9kZS5hcmd1bWVudHM7XG5cbiAgICAvLyBzaG9ydGN1dCBmb3IgJHVybFJvdXRlclByb3ZpZGVyLndoZW4oLi4sIGZ1bmN0aW9uKCRzY29wZSkge30pXG4gICAgaWYgKG9iai4kY2hhaW5lZCA9PT0gY2hhaW5lZFVybFJvdXRlclByb3ZpZGVyIHx8IChvYmoudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgb2JqLm5hbWUgPT09IFwiJHVybFJvdXRlclByb3ZpZGVyXCIpKSB7XG4gICAgICAgIG5vZGUuJGNoYWluZWQgPSBjaGFpbmVkVXJsUm91dGVyUHJvdmlkZXI7XG5cbiAgICAgICAgaWYgKG1ldGhvZC5uYW1lID09PSBcIndoZW5cIiAmJiBhcmdzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZXZlcnl0aGluZyBiZWxvdyBpcyBmb3IgJHN0YXRlUHJvdmlkZXIgYW5kIHN0YXRlSGVscGVyUHJvdmlkZXIgYWxvbmVcbiAgICBpZiAoIShvYmouJGNoYWluZWQgPT09IGNoYWluZWRTdGF0ZVByb3ZpZGVyIHx8IChvYmoudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgaXMuc29tZW9mKG9iai5uYW1lLCBbXCIkc3RhdGVQcm92aWRlclwiLCBcInN0YXRlSGVscGVyUHJvdmlkZXJcIl0pKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBub2RlLiRjaGFpbmVkID0gY2hhaW5lZFN0YXRlUHJvdmlkZXI7XG5cbiAgICBpZiAoaXMubm9uZW9mKG1ldGhvZC5uYW1lLCBbXCJzdGF0ZVwiLCBcInNldE5lc3RlZFN0YXRlXCJdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gJHN0YXRlUHJvdmlkZXIuc3RhdGUoeyAuLi4gfSkgYW5kICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwibmFtZVwiLCB7IC4uLiB9KVxuICAgIC8vIHN0YXRlSGVscGVyUHJvdmlkZXIuc2V0TmVzdGVkU3RhdGUoeyAuLiB9KSBhbmQgc3RhdGVIZWxwZXJQcm92aWRlci5zZXROZXN0ZWRTdGF0ZSh7IC4uIH0sIHRydWUpXG4gICAgaWYgKCEoYXJncy5sZW5ndGggPj0gMSAmJiBhcmdzLmxlbmd0aCA8PSAyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNvbmZpZ0FyZyA9IChtZXRob2QubmFtZSA9PT0gXCJzdGF0ZVwiID8gbGFzdChhcmdzKSA6IGFyZ3NbMF0pO1xuXG4gICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgcmVjdXJzaXZlTWF0Y2goY29uZmlnQXJnKTtcblxuICAgIHZhciBmaWx0ZXJlZFJlcyA9IHJlcy5maWx0ZXIoQm9vbGVhbik7XG4gICAgcmV0dXJuIChmaWx0ZXJlZFJlcy5sZW5ndGggPT09IDAgPyBmYWxzZSA6IGZpbHRlcmVkUmVzKTtcblxuXG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlTWF0Y2gob2JqZWN0RXhwcmVzc2lvbk5vZGUpIHtcbiAgICAgICAgaWYgKCFvYmplY3RFeHByZXNzaW9uTm9kZSB8fCBvYmplY3RFeHByZXNzaW9uTm9kZS50eXBlICE9PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBvYmplY3RFeHByZXNzaW9uTm9kZS5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIG1hdGNoU3RhdGVQcm9wcyhwcm9wZXJ0aWVzLCByZXMpO1xuXG4gICAgICAgIHZhciBjaGlsZHJlbkFycmF5RXhwcmVzc2lvbiA9IG1hdGNoUHJvcChcImNoaWxkcmVuXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZHJlbkFycmF5RXhwcmVzc2lvbiAmJiBjaGlsZHJlbkFycmF5RXhwcmVzc2lvbi5lbGVtZW50cztcblxuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWN1cnNpdmVNYXRjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hTdGF0ZVByb3BzKHByb3BzLCByZXMpIHtcbiAgICAgICAgdmFyIHNpbXBsZSA9IFtcbiAgICAgICAgICAgIG1hdGNoUHJvcChcImNvbnRyb2xsZXJcIiwgcHJvcHMpLFxuICAgICAgICAgICAgbWF0Y2hQcm9wKFwiY29udHJvbGxlclByb3ZpZGVyXCIsIHByb3BzKSxcbiAgICAgICAgICAgIG1hdGNoUHJvcChcInRlbXBsYXRlUHJvdmlkZXJcIiwgcHJvcHMpLFxuICAgICAgICAgICAgbWF0Y2hQcm9wKFwib25FbnRlclwiLCBwcm9wcyksXG4gICAgICAgICAgICBtYXRjaFByb3AoXCJvbkV4aXRcIiwgcHJvcHMpLFxuICAgICAgICBdO1xuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIHNpbXBsZSk7XG5cbiAgICAgICAgLy8ge3Jlc29sdmU6IC4ufVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIG1hdGNoUmVzb2x2ZShwcm9wcykpO1xuXG4gICAgICAgIC8vIHtwYXJhbXM6IHtzaW1wbGU6IGZ1bmN0aW9uKCRzY29wZSkge30sIGluVmFsdWU6IHsgdmFsdWU6IGZ1bmN0aW9uKCRzY29wZSkge30gfX1cbiAgICAgICAgdmFyIGEgPSBtYXRjaFByb3AoXCJwYXJhbXNcIiwgcHJvcHMpO1xuICAgICAgICBpZiAoYSAmJiBhLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICBhLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AudmFsdWUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobWF0Y2hQcm9wKFwidmFsdWVcIiwgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gocHJvcC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB7dmlldzogLi4ufVxuICAgICAgICB2YXIgdmlld09iamVjdCA9IG1hdGNoUHJvcChcInZpZXdzXCIsIHByb3BzKTtcbiAgICAgICAgaWYgKHZpZXdPYmplY3QgJiYgdmlld09iamVjdC50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgdmlld09iamVjdC5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLnZhbHVlLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG1hdGNoUHJvcChcImNvbnRyb2xsZXJcIiwgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKG1hdGNoUHJvcChcImNvbnRyb2xsZXJQcm92aWRlclwiLCBwcm9wLnZhbHVlLnByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gobWF0Y2hQcm9wKFwidGVtcGxhdGVQcm92aWRlclwiLCBwcm9wLnZhbHVlLnByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBtYXRjaFJlc29sdmUocHJvcC52YWx1ZS5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoSW5qZWN0b3JJbnZva2Uobm9kZSkge1xuICAgIC8vICRpbmplY3Rvci5pbnZva2UoZnVuY3Rpb24oJGNvbXBpbGUpIHsgLi4uIH0pO1xuXG4gICAgLy8gd2UgYWxyZWFkeSBrbm93IHRoYXQgbm9kZSBpcyBhIChub24tY29tcHV0ZWQpIG1ldGhvZCBjYWxsXG4gICAgdmFyIGNhbGxlZSA9IG5vZGUuY2FsbGVlO1xuICAgIHZhciBvYmogPSBjYWxsZWUub2JqZWN0OyAvLyBpZGVudGlmaWVyIG9yIGV4cHJlc3Npb25cbiAgICB2YXIgbWV0aG9kID0gY2FsbGVlLnByb3BlcnR5OyAvLyBpZGVudGlmaWVyXG5cbiAgICByZXR1cm4gbWV0aG9kLm5hbWUgPT09IFwiaW52b2tlXCIgJiZcbiAgICAgICAgb2JqLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG9iai5uYW1lID09PSBcIiRpbmplY3RvclwiICYmXG4gICAgICAgIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmIG5vZGUuYXJndW1lbnRzO1xufVxuXG5mdW5jdGlvbiBtYXRjaEh0dHBQcm92aWRlcihub2RlKSB7XG4gICAgLy8gJGh0dHBQcm92aWRlci5pbnRlcmNlcHRvcnMucHVzaChmdW5jdGlvbigkc2NvcGUpIHt9KTtcbiAgICAvLyAkaHR0cFByb3ZpZGVyLnJlc3BvbnNlSW50ZXJjZXB0b3JzLnB1c2goZnVuY3Rpb24oJHNjb3BlKSB7fSk7XG5cbiAgICAvLyB3ZSBhbHJlYWR5IGtub3cgdGhhdCBub2RlIGlzIGEgKG5vbi1jb21wdXRlZCkgbWV0aG9kIGNhbGxcbiAgICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gICAgdmFyIG9iaiA9IGNhbGxlZS5vYmplY3Q7IC8vIGlkZW50aWZpZXIgb3IgZXhwcmVzc2lvblxuICAgIHZhciBtZXRob2QgPSBjYWxsZWUucHJvcGVydHk7IC8vIGlkZW50aWZpZXJcblxuICAgIHJldHVybiAobWV0aG9kLm5hbWUgPT09IFwicHVzaFwiICYmXG4gICAgICAgIG9iai50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAhb2JqLmNvbXB1dGVkICYmXG4gICAgICAgIG9iai5vYmplY3QubmFtZSA9PT0gXCIkaHR0cFByb3ZpZGVyXCIgJiYgaXMuc29tZW9mKG9iai5wcm9wZXJ0eS5uYW1lLCAgW1wiaW50ZXJjZXB0b3JzXCIsIFwicmVzcG9uc2VJbnRlcmNlcHRvcnNcIl0pICYmXG4gICAgICAgIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmIG5vZGUuYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hDb250cm9sbGVyUHJvdmlkZXIobm9kZSkge1xuICAgIC8vICRjb250cm9sbGVyUHJvdmlkZXIucmVnaXN0ZXIoXCJmb29cIiwgZnVuY3Rpb24oJHNjb3BlKSB7fSk7XG5cbiAgICAvLyB3ZSBhbHJlYWR5IGtub3cgdGhhdCBub2RlIGlzIGEgKG5vbi1jb21wdXRlZCkgbWV0aG9kIGNhbGxcbiAgICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gICAgdmFyIG9iaiA9IGNhbGxlZS5vYmplY3Q7IC8vIGlkZW50aWZpZXIgb3IgZXhwcmVzc2lvblxuICAgIHZhciBtZXRob2QgPSBjYWxsZWUucHJvcGVydHk7IC8vIGlkZW50aWZpZXJcbiAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzO1xuXG4gICAgdmFyIHRhcmdldCA9IG9iai50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBvYmoubmFtZSA9PT0gXCIkY29udHJvbGxlclByb3ZpZGVyXCIgJiZcbiAgICAgICAgbWV0aG9kLm5hbWUgPT09IFwicmVnaXN0ZXJcIiAmJiBhcmdzLmxlbmd0aCA9PT0gMiAmJiBhcmdzWzFdO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuJG1ldGhvZE5hbWUgPSBtZXRob2QubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hQcm92aWRlKG5vZGUsIGN0eCkge1xuICAgIC8vICRwcm92aWRlLmRlY29yYXRvcihcImZvb1wiLCBmdW5jdGlvbigkc2NvcGUpIHt9KTtcbiAgICAvLyAkcHJvdmlkZS5zZXJ2aWNlKFwiZm9vXCIsIGZ1bmN0aW9uKCRzY29wZSkge30pO1xuICAgIC8vICRwcm92aWRlLmZhY3RvcnkoXCJmb29cIiwgZnVuY3Rpb24oJHNjb3BlKSB7fSk7XG4gICAgLy8gJHByb3ZpZGUucHJvdmlkZXIoXCJmb29cIiwgZnVuY3Rpb24oJHNjb3BlKSB7fSk7XG5cbiAgICAvLyB3ZSBhbHJlYWR5IGtub3cgdGhhdCBub2RlIGlzIGEgKG5vbi1jb21wdXRlZCkgbWV0aG9kIGNhbGxcbiAgICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gICAgdmFyIG9iaiA9IGNhbGxlZS5vYmplY3Q7IC8vIGlkZW50aWZpZXIgb3IgZXhwcmVzc2lvblxuICAgIHZhciBtZXRob2QgPSBjYWxsZWUucHJvcGVydHk7IC8vIGlkZW50aWZpZXJcbiAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzO1xuXG4gICAgdmFyIHRhcmdldCA9IG9iai50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBvYmoubmFtZSA9PT0gXCIkcHJvdmlkZVwiICYmXG4gICAgICAgIGlzLnNvbWVvZihtZXRob2QubmFtZSwgW1wiZGVjb3JhdG9yXCIsIFwic2VydmljZVwiLCBcImZhY3RvcnlcIiwgXCJwcm92aWRlclwiXSkgJiZcbiAgICAgICAgYXJncy5sZW5ndGggPT09IDIgJiYgYXJnc1sxXTtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LiRtZXRob2ROYW1lID0gbWV0aG9kLm5hbWU7XG5cbiAgICAgICAgaWYgKGN0eC5yZW5hbWUpIHtcbiAgICAgICAgICAgIC8vIGZvciBldmVudHVhbCByZW5hbWUgcHVycG9zZXNcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUmVndWxhcihub2RlLCBjdHgpIHtcbiAgICAvLyB3ZSBhbHJlYWR5IGtub3cgdGhhdCBub2RlIGlzIGEgKG5vbi1jb21wdXRlZCkgbWV0aG9kIGNhbGxcbiAgICB2YXIgY2FsbGVlID0gbm9kZS5jYWxsZWU7XG4gICAgdmFyIG9iaiA9IGNhbGxlZS5vYmplY3Q7IC8vIGlkZW50aWZpZXIgb3IgZXhwcmVzc2lvblxuICAgIHZhciBtZXRob2QgPSBjYWxsZWUucHJvcGVydHk7IC8vIGlkZW50aWZpZXJcblxuICAgIC8vIHNob3J0LWN1dCBpbXBsaWNpdCBjb25maWcgc3BlY2lhbCBjYXNlOlxuICAgIC8vIGFuZ3VsYXIubW9kdWxlKFwiTXlNb2RcIiwgZnVuY3Rpb24oYSkge30pXG4gICAgaWYgKG9iai5uYW1lID09PSBcImFuZ3VsYXJcIiAmJiBtZXRob2QubmFtZSA9PT0gXCJtb2R1bGVcIikge1xuICAgICAgICB2YXIgYXJncyQwID0gbm9kZS5hcmd1bWVudHM7XG4gICAgICAgIGlmIChhcmdzJDAubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIG5vZGUuJGNoYWluZWQgPSBjaGFpbmVkUmVndWxhcjtcbiAgICAgICAgICAgIHJldHVybiBsYXN0KGFyZ3MkMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYXJkY29kZWQgZXhjZXB0aW9uOiBmb28uZGVjb3JhdG9yIGlzIGdlbmVyYWxseSBjb25zaWRlcmVkIGEgc2hvcnQtZm9ybVxuICAgIC8vIGRlY2xhcmF0aW9uIGJ1dCAkc3RhdGVQcm92aWRlci5kZWNvcmF0b3IgaXMgbm90LiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29sb3YvbmctYW5ub3RhdGUvaXNzdWVzLzgyXG4gICAgaWYgKG9iai5uYW1lID09PSBcIiRzdGF0ZVByb3ZpZGVyXCIgJiYgbWV0aG9kLm5hbWUgPT09IFwiZGVjb3JhdG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaEFuZ3VsYXJNb2R1bGUgPSAob2JqLiRjaGFpbmVkID09PSBjaGFpbmVkUmVndWxhciB8fCBpc1JlRGVmKG9iaiwgY3R4KSB8fCBpc0xvbmdEZWYob2JqKSkgJiZcbiAgICAgICAgaXMuc29tZW9mKG1ldGhvZC5uYW1lLCBbXCJwcm92aWRlclwiLCBcInZhbHVlXCIsIFwiY29uc3RhbnRcIiwgXCJib290c3RyYXBcIiwgXCJjb25maWdcIiwgXCJmYWN0b3J5XCIsIFwiZGlyZWN0aXZlXCIsIFwiZmlsdGVyXCIsIFwicnVuXCIsIFwiY29udHJvbGxlclwiLCBcInNlcnZpY2VcIiwgXCJhbmltYXRpb25cIiwgXCJpbnZva2VcIiwgXCJzdG9yZVwiLCBcImRlY29yYXRvclwiLCBcImNvbXBvbmVudFwiXSk7XG4gICAgaWYgKCFtYXRjaEFuZ3VsYXJNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBub2RlLiRjaGFpbmVkID0gY2hhaW5lZFJlZ3VsYXI7XG5cbiAgICBpZiAoaXMuc29tZW9mKG1ldGhvZC5uYW1lLCBbXCJ2YWx1ZVwiLCBcImNvbnN0YW50XCIsIFwiYm9vdHN0cmFwXCJdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGFmZmVjdHMgbWF0Y2hBbmd1bGFyTW9kdWxlIGJlY2F1c2Ugb2YgY2hhaW5pbmdcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzO1xuICAgIHZhciB0YXJnZXQgPSAoaXMuc29tZW9mKG1ldGhvZC5uYW1lLCBbXCJjb25maWdcIiwgXCJydW5cIl0pID9cbiAgICAgICAgYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXSA6XG4gICAgICAgIGFyZ3MubGVuZ3RoID09PSAyICYmIGFyZ3NbMF0udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgaXMuc3RyaW5nKGFyZ3NbMF0udmFsdWUpICYmIGFyZ3NbMV0pO1xuXG4gICAgaWYgKG1ldGhvZC5uYW1lID09PSBcImNvbXBvbmVudFwiKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyUHJvcCA9ICh0YXJnZXQgJiYgdGFyZ2V0LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiICYmIG1hdGNoUHJvcChcImNvbnRyb2xsZXJcIiwgdGFyZ2V0LnByb3BlcnRpZXMpKTtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyUHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGNvbnRyb2xsZXJQcm9wO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LiRtZXRob2ROYW1lID0gbWV0aG9kLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGN0eC5yZW5hbWUgJiYgYXJncy5sZW5ndGggPT09IDIgJiYgdGFyZ2V0KSB7XG4gICAgICAgIC8vIGZvciBldmVudHVhbCByZW5hbWUgcHVycG9zZXNcbiAgICAgICAgdmFyIHNvbWV0aGluZ05hbWVMaXRlcmFsID0gYXJnc1swXTtcbiAgICAgICAgcmV0dXJuIFtzb21ldGhpbmdOYW1lTGl0ZXJhbCwgdGFyZ2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gbWF0Y2hlcyB3aXRoIGRlZmF1bHQgcmVnZXhwXG4vLyAgICouY29udHJvbGxlcihcIk15Q3RybFwiLCBmdW5jdGlvbigkc2NvcGUsICR0aW1lb3V0KSB7fSk7XG4vLyAgICouKi5jb250cm9sbGVyKFwiTXlDdHJsXCIsIGZ1bmN0aW9uKCRzY29wZSwgJHRpbWVvdXQpIHt9KTtcbi8vIG1hdGNoZXMgd2l0aCAtLXJlZ2V4cCBcIl5yZXF1aXJlKC4qKSRcIlxuLy8gICByZXF1aXJlKFwiYXBwLW1vZHVsZVwiKS5jb250cm9sbGVyKFwiTXlDdHJsXCIsIGZ1bmN0aW9uKCRzY29wZSkge30pO1xuZnVuY3Rpb24gaXNSZURlZihub2RlLCBjdHgpIHtcbiAgICByZXR1cm4gY3R4LnJlLnRlc3QoY3R4LnNyY0ZvclJhbmdlKG5vZGUucmFuZ2UpKTtcbn1cblxuLy8gTG9uZyBmb3JtOiBhbmd1bGFyLm1vZHVsZSgqKS5jb250cm9sbGVyKFwiTXlDdHJsXCIsIGZ1bmN0aW9uKCRzY29wZSwgJHRpbWVvdXQpIHt9KTtcbmZ1bmN0aW9uIGlzTG9uZ0RlZihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY2FsbGVlICYmXG4gICAgICAgIG5vZGUuY2FsbGVlLm9iamVjdCAmJiBub2RlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gXCJhbmd1bGFyXCIgJiZcbiAgICAgICAgbm9kZS5jYWxsZWUucHJvcGVydHkgJiYgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gXCJtb2R1bGVcIjtcbn1cblxuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hQcm9wKG5hbWUsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICBpZiAoKHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IG5hbWUpIHx8XG4gICAgICAgICAgICAocHJvcC5rZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgcHJvcC5rZXkudmFsdWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcC52YWx1ZTsgLy8gRnVuY3Rpb25FeHByZXNzaW9uIG9yIEFycmF5RXhwcmVzc2lvblxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJlc29sdmUocHJvcHMpIHtcbiAgICB2YXIgcmVzb2x2ZU9iamVjdCA9IG1hdGNoUHJvcChcInJlc29sdmVcIiwgcHJvcHMpO1xuICAgIGlmIChyZXNvbHZlT2JqZWN0ICYmIHJlc29sdmVPYmplY3QudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVPYmplY3QucHJvcGVydGllcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG5mdW5jdGlvbiByZW5hbWVkU3RyaW5nKGN0eCwgb3JpZ2luYWxTdHJpbmcpIHtcbiAgICBpZiAoY3R4LnJlbmFtZSkge1xuICAgICAgICByZXR1cm4gY3R4LnJlbmFtZS5nZXQob3JpZ2luYWxTdHJpbmcpIHx8IG9yaWdpbmFsU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luYWxTdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShjdHgsIGFyciwgcXVvdCkge1xuICAgIHJldHVybiBcIltcIiArIGFyci5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiBxdW90ICsgcmVuYW1lZFN0cmluZyhjdHgsIGFyZy5uYW1lKSArIHF1b3Q7XG4gICAgfSkuam9pbihcIiwgXCIpICsgXCJdXCI7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbk9mVHlwZShzdHIsIHR5cGUpIHtcbiAgICB2YXIgbm9kZSA9IHBhcnNlcihzdHIpLmJvZHlbMF0uZXhwcmVzc2lvbjtcbiAgICBhc3NlcnQobm9kZS50eXBlID09PSB0eXBlKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLy8gc3RhbmQtaW4gZm9yIG5vdCBoYXZpbmcgYSBqc3NoYXBlci1zdHlsZSByZWYnc1xuZnVuY3Rpb24gcmVwbGFjZU5vZGVXaXRoKG5vZGUsIG5ld05vZGUpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHZhciBwYXJlbnQgPSBub2RlLiRwYXJlbnQ7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJlbnQpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHBhcmVudFtrZXldID09PSBub2RlKSB7XG4gICAgICAgICAgICBwYXJlbnRba2V5XSA9IG5ld05vZGU7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNlY29uZCBwYXNzLCBub3cgY2hlY2sgYXJyYXlzXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBwYXJlbnRba2V5XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJbaV0gPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFzc2VydChkb25lKTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QXJyYXkoY3R4LCBmdW5jdGlvbkV4cHJlc3Npb24sIGZyYWdtZW50cywgcXVvdCkge1xuICAgIHZhciBhcmdzID0gc3RyaW5naWZ5KGN0eCwgZnVuY3Rpb25FeHByZXNzaW9uLnBhcmFtcywgcXVvdCk7XG5cbiAgICBmcmFnbWVudHMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbkV4cHJlc3Npb24ucmFuZ2VbMF0sXG4gICAgICAgIGVuZDogZnVuY3Rpb25FeHByZXNzaW9uLnJhbmdlWzBdLFxuICAgICAgICBzdHI6IGFyZ3Muc2xpY2UoMCwgLTEpICsgXCIsIFwiLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbkV4cHJlc3Npb24ubG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbkV4cHJlc3Npb24ubG9jLnN0YXJ0XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmcmFnbWVudHMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbkV4cHJlc3Npb24ucmFuZ2VbMV0sXG4gICAgICAgIGVuZDogZnVuY3Rpb25FeHByZXNzaW9uLnJhbmdlWzFdLFxuICAgICAgICBzdHI6IFwiXVwiLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbkV4cHJlc3Npb24ubG9jLmVuZCxcbiAgICAgICAgICAgIGVuZDogZnVuY3Rpb25FeHByZXNzaW9uLmxvYy5lbmRcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQXJyYXkoY3R4LCBhcnJheSwgZnJhZ21lbnRzLCBxdW90KSB7XG4gICAgdmFyIGZ1bmN0aW9uRXhwcmVzc2lvbiA9IGxhc3QoYXJyYXkuZWxlbWVudHMpO1xuXG4gICAgaWYgKGZ1bmN0aW9uRXhwcmVzc2lvbi5wYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVBcnJheShhcnJheSwgZnJhZ21lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IHN0cmluZ2lmeShjdHgsIGZ1bmN0aW9uRXhwcmVzc2lvbi5wYXJhbXMsIHF1b3QpO1xuICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IGFycmF5LnJhbmdlWzBdLFxuICAgICAgICBlbmQ6IGZ1bmN0aW9uRXhwcmVzc2lvbi5yYW5nZVswXSxcbiAgICAgICAgc3RyOiBhcmdzLnNsaWNlKDAsIC0xKSArIFwiLCBcIixcbiAgICAgICAgbG9jOiB7XG4gICAgICAgICAgICBzdGFydDogYXJyYXkubG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbkV4cHJlc3Npb24ubG9jLnN0YXJ0XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQXJyYXkoYXJyYXksIGZyYWdtZW50cykge1xuICAgIHZhciBmdW5jdGlvbkV4cHJlc3Npb24gPSBsYXN0KGFycmF5LmVsZW1lbnRzKTtcblxuICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IGFycmF5LnJhbmdlWzBdLFxuICAgICAgICBlbmQ6IGZ1bmN0aW9uRXhwcmVzc2lvbi5yYW5nZVswXSxcbiAgICAgICAgc3RyOiBcIlwiLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBhcnJheS5sb2Muc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGZ1bmN0aW9uRXhwcmVzc2lvbi5sb2Muc3RhcnRcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uRXhwcmVzc2lvbi5yYW5nZVsxXSxcbiAgICAgICAgZW5kOiBhcnJheS5yYW5nZVsxXSxcbiAgICAgICAgc3RyOiBcIlwiLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbkV4cHJlc3Npb24ubG9jLmVuZCxcbiAgICAgICAgICAgIGVuZDogYXJyYXkubG9jLmVuZFxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmFtZVByb3ZpZGVyRGVjbGFyYXRpb25TaXRlKGN0eCwgbGl0ZXJhbE5vZGUsIGZyYWdtZW50cykge1xuICAgIGZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IGxpdGVyYWxOb2RlLnJhbmdlWzBdICsgMSxcbiAgICAgICAgZW5kOiBsaXRlcmFsTm9kZS5yYW5nZVsxXSAtIDEsXG4gICAgICAgIHN0cjogcmVuYW1lZFN0cmluZyhjdHgsIGxpdGVyYWxOb2RlLnZhbHVlKSxcbiAgICAgICAgbG9jOiB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpdGVyYWxOb2RlLmxvYy5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbGl0ZXJhbE5vZGUubG9jLnN0YXJ0LmNvbHVtbiArIDFcbiAgICAgICAgICAgIH0sIGVuZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpdGVyYWxOb2RlLmxvYy5lbmQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGxpdGVyYWxOb2RlLmxvYy5lbmQuY29sdW1uIC0gMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGp1ZGdlU3VzcGVjdHMoY3R4KSB7XG4gICAgdmFyIG1vZGUgPSBjdHgubW9kZTtcbiAgICB2YXIgZnJhZ21lbnRzID0gY3R4LmZyYWdtZW50cztcbiAgICB2YXIgcXVvdCA9IGN0eC5xdW90O1xuICAgIHZhciBibG9ja2VkID0gY3R4LmJsb2NrZWQ7XG5cbiAgICB2YXIgc3VzcGVjdHMgPSBtYWtlVW5pcXVlKGN0eC5zdXNwZWN0cywgMSk7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDQyOyBuKyspIHtcbiAgICAgICAgLy8gY291bGQgYmUgd2hpbGUodHJ1ZSksIGFib3ZlIGlzIGp1c3QgYSBzYWZldHktbmV0XG4gICAgICAgIC8vIGluIHByYWN0aWNlIGl0IHdpbGwgbG9vcCBqdXN0IGEgY291cGxlIG9mIHRpbWVzXG4gICAgICAgIHByb3BhZ2F0ZU1vZHVsZUNvbnRleHRBbmRNZXRob2ROYW1lKHN1c3BlY3RzKTtcbiAgICAgICAgaWYgKCFzZXRDaGFpbmVkQW5kTWV0aG9kTmFtZVRocm91Z2hJaWZlc0FuZFJlZmVyZW5jZXMoc3VzcGVjdHMpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBmaW5hbCBzdXNwZWN0cyBieSBqdW1waW5nLCBmb2xsb3dpbmcsIHVuaXEnaW5nLCBibG9ja2luZ1xuICAgIHZhciBmaW5hbFN1c3BlY3RzID0gbWFrZVVuaXF1ZShzdXNwZWN0cy5tYXAoZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHZhciBqdW1wZWQgPSBqdW1wT3ZlcklpZmUodGFyZ2V0KTtcbiAgICAgICAgdmFyIGp1bXBlZEFuZEZvbGxvd2VkID0gZm9sbG93UmVmZXJlbmNlKGp1bXBlZCkgfHwganVtcGVkO1xuXG4gICAgICAgIGlmICh0YXJnZXQuJGxpbWl0VG9NZXRob2ROYW1lICYmIHRhcmdldC4kbGltaXRUb01ldGhvZE5hbWUgIT09IFwiKm5ldmVyKlwiICYmIGZpbmRPdXRlck1ldGhvZE5hbWUodGFyZ2V0KSAhPT0gdGFyZ2V0LiRsaW1pdFRvTWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2tlZC5pbmRleE9mKGp1bXBlZEFuZEZvbGxvd2VkKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqdW1wZWRBbmRGb2xsb3dlZDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbiksIDIpO1xuXG4gICAgZmluYWxTdXNwZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LiRjaGFpbmVkICE9PSBjaGFpbmVkUmVndWxhcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGUgPT09IFwicmVidWlsZFwiICYmIGlzQW5ub3RhdGVkQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmVwbGFjZUFycmF5KGN0eCwgdGFyZ2V0LCBmcmFnbWVudHMsIHF1b3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwicmVtb3ZlXCIgJiYgaXNBbm5vdGF0ZWRBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZW1vdmVBcnJheSh0YXJnZXQsIGZyYWdtZW50cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc29tZW9mKG1vZGUsIFtcImFkZFwiLCBcInJlYnVpbGRcIl0pICYmIGlzRnVuY3Rpb25FeHByZXNzaW9uV2l0aEFyZ3ModGFyZ2V0KSkge1xuICAgICAgICAgICAgaW5zZXJ0QXJyYXkoY3R4LCB0YXJnZXQsIGZyYWdtZW50cywgcXVvdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNHZW5lcmljUHJvdmlkZXJOYW1lKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJlbmFtZVByb3ZpZGVyRGVjbGFyYXRpb25TaXRlKGN0eCwgdGFyZ2V0LCBmcmFnbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYXJyYXkgb3IgZnVuY3Rpb24tZXhwcmVzc2lvbiwgdGhlbiBpdCdzIGEgY2FuZGlkYXRlIGZvciBmb28uJGluamVjdCA9IFsuLl1cbiAgICAgICAgICAgIGp1ZGdlSW5qZWN0QXJyYXlTdXNwZWN0KHRhcmdldCwgY3R4KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVNb2R1bGVDb250ZXh0QW5kTWV0aG9kTmFtZShzdXNwZWN0cykge1xuICAgICAgICBzdXNwZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC4kY2hhaW5lZCAhPT0gY2hhaW5lZFJlZ3VsYXIgJiYgaXNJbnNpZGVNb2R1bGVDb250ZXh0KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuJGNoYWluZWQgPSBjaGFpbmVkUmVndWxhcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQuJG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGZpbmRPdXRlck1ldGhvZE5hbWUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuJG1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZE91dGVyTWV0aG9kTmFtZShub2RlKSB7XG4gICAgICAgIGZvciAoOyBub2RlICYmICFub2RlLiRtZXRob2ROYW1lOyBub2RlID0gbm9kZS4kcGFyZW50KSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLiRtZXRob2ROYW1lIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDaGFpbmVkQW5kTWV0aG9kTmFtZVRocm91Z2hJaWZlc0FuZFJlZmVyZW5jZXMoc3VzcGVjdHMpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHN1c3BlY3RzLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIganVtcGVkID0ganVtcE92ZXJJaWZlKHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoanVtcGVkICE9PSB0YXJnZXQpIHsgLy8gd2UgZGlkIHNraXAgYW4gSUlGRVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuJGNoYWluZWQgPT09IGNoYWluZWRSZWd1bGFyICYmIGp1bXBlZC4kY2hhaW5lZCAhPT0gY2hhaW5lZFJlZ3VsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBqdW1wZWQuJGNoYWluZWQgPSBjaGFpbmVkUmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC4kbWV0aG9kTmFtZSAmJiAhanVtcGVkLiRtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAganVtcGVkLiRtZXRob2ROYW1lID0gdGFyZ2V0LiRtZXRob2ROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGp1bXBlZEFuZEZvbGxvd2VkID0gZm9sbG93UmVmZXJlbmNlKGp1bXBlZCkgfHwganVtcGVkO1xuICAgICAgICAgICAgaWYgKGp1bXBlZEFuZEZvbGxvd2VkICE9PSBqdW1wZWQpIHsgLy8gd2UgZGlkIGZvbGxvdyBhIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmIChqdW1wZWQuJGNoYWluZWQgPT09IGNoYWluZWRSZWd1bGFyICYmIGp1bXBlZEFuZEZvbGxvd2VkLiRjaGFpbmVkICE9PSBjaGFpbmVkUmVndWxhcikge1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGp1bXBlZEFuZEZvbGxvd2VkLiRjaGFpbmVkID0gY2hhaW5lZFJlZ3VsYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqdW1wZWQuJG1ldGhvZE5hbWUgJiYgIWp1bXBlZEFuZEZvbGxvd2VkLiRtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAganVtcGVkQW5kRm9sbG93ZWQuJG1ldGhvZE5hbWUgPSBqdW1wZWQuJG1ldGhvZE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5zaWRlTW9kdWxlQ29udGV4dChub2RlKSB7XG4gICAgICAgIHZhciAkcGFyZW50ID0gbm9kZS4kcGFyZW50O1xuICAgICAgICBmb3IgKDsgJHBhcmVudCAmJiAkcGFyZW50LiRjaGFpbmVkICE9PSBjaGFpbmVkUmVndWxhcjsgJHBhcmVudCA9ICRwYXJlbnQuJHBhcmVudCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb29sZWFuKCRwYXJlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VVbmlxdWUoc3VzcGVjdHMsIHZhbCkge1xuICAgICAgICByZXR1cm4gc3VzcGVjdHMuZmlsdGVyKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC4kc2VlbiA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LiRzZWVuID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9sbG93UmVmZXJlbmNlKG5vZGUpIHtcbiAgICBpZiAoIXNjb3BlVG9vbHMuaXNSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0gbm9kZS4kc2NvcGUubG9va3VwKG5vZGUubmFtZSk7XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gc2NvcGUuZ2V0Tm9kZShub2RlLm5hbWUpLiRwYXJlbnQ7XG4gICAgdmFyIGtpbmQgPSBzY29wZS5nZXRLaW5kKG5vZGUubmFtZSk7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBwdHlwZSA9IHBhcmVudC50eXBlO1xuXG4gICAgaWYgKGlzLnNvbWVvZihraW5kLCBbXCJjb25zdFwiLCBcImxldFwiLCBcInZhclwiXSkpIHtcbiAgICAgICAgYXNzZXJ0KHB0eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKTtcbiAgICAgICAgLy8ge3R5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIGlkOiB7dHlwZTogXCJJZGVudGlmaWVyXCIsIG5hbWU6IFwiZm9vXCJ9LCBpbml0OiAuLn1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiZnVuXCIpIHtcbiAgICAgICAgYXNzZXJ0KHB0eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiB8fCBwdHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgICAgICAgLy8gRnVuY3Rpb25EZWNsYXJhdGlvbiBpcyB0aGUgY29tbW9uIGNhc2UsIGkuZS5cbiAgICAgICAgLy8gZnVuY3Rpb24gZm9vKGEsIGIpIHt9XG5cbiAgICAgICAgLy8gRnVuY3Rpb25FeHByZXNzaW9uIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgY2FzZXMgc2ltaWxhciB0b1xuICAgICAgICAvLyB2YXIgZiA9IGZ1bmN0aW9uIGFzZGYoYSxiKSB7IG15bW9kLmNvbnRyb2xsZXIoXCJhc2RmXCIsIGFzZGYpIH07XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgLy8gb3RoZXIga2luZHMgc2hvdWxkIG5vdCBiZSBoYW5kbGVkIChcInBhcmFtXCIsIFwiY2F1Z2h0XCIpXG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTyhzcmNsZW5ndGgpIHNvIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcywgZWxzZSByZXBsYWNlIHdpdGggbHV0XG5mdW5jdGlvbiBwb3NUb0xpbmUocG9zLCBzcmMpIHtcbiAgICBpZiAocG9zID49IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgcG9zID0gc3JjLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA8PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGxpbmUgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zOyBpKyspIHtcbiAgICAgICAgaWYgKHNyY1tpXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIGZpcnN0Tm9uUHJvbG9ndWVTdGF0ZW1lbnQoYm9keSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYm9keVtpXS50eXBlICE9PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHlbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwciA9IGJvZHlbaV0uZXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIGlzU3RyaW5nTGl0ZXJhbCA9IChleHByLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHR5cGVvZiBleHByLnZhbHVlID09PSBcInN0cmluZ1wiKTtcbiAgICAgICAgaWYgKCFpc1N0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBqdWRnZUluamVjdEFycmF5U3VzcGVjdChub2RlLCBjdHgpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgICAgICAvLyBzdXNwZWN0IGNhbiBvbmx5IGJlIGEgVmFyaWFibGVEZWNsYXJhdGlvbiAoc3RhdGVtZW50KSBpbiBjYXNlIG9mXG4gICAgICAgIC8vIGV4cGxpY2l0bHkgbWFya2VkIHZpYSAvKkBuZ0luamVjdCovLCBub3QgdmlhIHJlZmVyZW5jZXMgYmVjYXVzZVxuICAgICAgICAvLyByZWZlcmVuY2VzIGZvbGxvdyB0byBWYXJpYWJsZURlY2xhcmF0b3IgKGNoaWxkKVxuXG4gICAgICAgIC8vIC8qQG5nSW5qZWN0Ki8gdmFyIGZvbyA9IGZ1bmN0aW9uKCRzY29wZSkge30gYW5kXG5cbiAgICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgLy8gbW9yZSB0aGFuIG9uZSBkZWNsYXJhdG9yID0+IGV4aXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uZSBkZWNsYXJhdG9yID0+IGp1bXAgb3ZlciBkZWNsYXJhdGlvbiBpbnRvIGRlY2xhcmF0b3JcbiAgICAgICAgLy8gcmVzdCBvZiBjb2RlIHdpbGwgdHJlYXQgaXQgYXMgYW55IChyZWZlcmVuY2VkKSBkZWNsYXJhdG9yXG4gICAgICAgIG5vZGUgPSBub2RlLmRlY2xhcmF0aW9uc1swXTtcbiAgICB9XG5cbiAgICAvLyBvbm9kZSBpcyBhIHRvcC1sZXZlbCBub2RlIChpbnNpZGUgZnVuY3Rpb24gYmxvY2spLCBsYXRlciB2ZXJpZmllZFxuICAgIC8vIG5vZGUgaXMgaW5uZXIgbWF0Y2gsIGRlc2NlbnQgaW4gbXVsdGlwbGUgc3RlcHNcbiAgICB2YXIgb25vZGUgPSBudWxsO1xuICAgIHZhciBkZWNsYXJhdG9yTmFtZSA9IG51bGw7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIikge1xuICAgICAgICBvbm9kZSA9IG5vZGUuJHBhcmVudDtcbiAgICAgICAgZGVjbGFyYXRvck5hbWUgPSBub2RlLmlkLm5hbWU7XG4gICAgICAgIG5vZGUgPSBub2RlLmluaXQ7IC8vIHZhciBmb28gPSBfX187XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb25vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIC8vIHN1c3BlY3QgbXVzdCBiZSBpbnNpZGUgb2YgYSBibG9jayBvciBhdCB0aGUgdG9wLWxldmVsIChpLmUuIGluc2lkZSBvZiBub2RlLiRwYXJlbnQuYm9keVtdKVxuICAgIGlmICghbm9kZSB8fCAhb25vZGUuJHBhcmVudCB8fCBpcy5ub25lb2Yob25vZGUuJHBhcmVudC50eXBlLCBbXCJQcm9ncmFtXCIsIFwiQmxvY2tTdGF0ZW1lbnRcIl0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5zZXJ0UG9zID0ge1xuICAgICAgICBwb3M6IG9ub2RlLnJhbmdlWzFdLFxuICAgICAgICBsb2M6IG9ub2RlLmxvYy5lbmRcbiAgICB9O1xuICAgIHZhciBpc1NlbWljb2xvblRlcm1pbmF0ZWQgPSAoY3R4LnNyY1tpbnNlcnRQb3MucG9zIC0gMV0gPT09IFwiO1wiKTtcblxuICAgIG5vZGUgPSBqdW1wT3ZlcklpZmUobm9kZSk7XG5cbiAgICBpZiAoY3R4LmlzRnVuY3Rpb25FeHByZXNzaW9uV2l0aEFyZ3Mobm9kZSkpIHtcbiAgICAgICAgLy8gdmFyIHggPSAxLCB5ID0gZnVuY3Rpb24oYSxiKSB7fSwgejtcblxuICAgICAgICBhc3NlcnQoZGVjbGFyYXRvck5hbWUpO1xuICAgICAgICBhZGRSZW1vdmVJbmplY3RBcnJheShcbiAgICAgICAgICAgIG5vZGUucGFyYW1zLFxuICAgICAgICAgICAgaXNTZW1pY29sb25UZXJtaW5hdGVkID8gaW5zZXJ0UG9zIDoge1xuICAgICAgICAgICAgICAgIHBvczogbm9kZS5yYW5nZVsxXSxcbiAgICAgICAgICAgICAgICBsb2M6IG5vZGUubG9jLmVuZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY2xhcmF0b3JOYW1lKTtcblxuICAgIH0gZWxzZSBpZiAoY3R4LmlzRnVuY3Rpb25EZWNsYXJhdGlvbldpdGhBcmdzKG5vZGUpKSB7XG4gICAgICAgIC8vIC8qQG5nSW5qZWN0Ki8gZnVuY3Rpb24gZm9vKCRzY29wZSkge31cblxuICAgICAgICBhZGRSZW1vdmVJbmplY3RBcnJheShcbiAgICAgICAgICAgIG5vZGUucGFyYW1zLFxuICAgICAgICAgICAgaW5zZXJ0UG9zLFxuICAgICAgICAgICAgbm9kZS5pZC5uYW1lKTtcblxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmXG4gICAgICAgIGN0eC5pc0Z1bmN0aW9uRXhwcmVzc2lvbldpdGhBcmdzKG5vZGUuZXhwcmVzc2lvbi5yaWdodCkpIHtcbiAgICAgICAgLy8gLypAbmdJbmplY3QqLyBmb28uYmFyWzBdID0gZnVuY3Rpb24oJHNjb3BlKSB7fVxuXG4gICAgICAgIHZhciBuYW1lID0gY3R4LnNyY0ZvclJhbmdlKG5vZGUuZXhwcmVzc2lvbi5sZWZ0LnJhbmdlKTtcbiAgICAgICAgYWRkUmVtb3ZlSW5qZWN0QXJyYXkoXG4gICAgICAgICAgICBub2RlLmV4cHJlc3Npb24ucmlnaHQucGFyYW1zLFxuICAgICAgICAgICAgaXNTZW1pY29sb25UZXJtaW5hdGVkID8gaW5zZXJ0UG9zIDoge1xuICAgICAgICAgICAgICAgIHBvczogbm9kZS5leHByZXNzaW9uLnJpZ2h0LnJhbmdlWzFdLFxuICAgICAgICAgICAgICAgIGxvYzogbm9kZS5leHByZXNzaW9uLnJpZ2h0LmxvYy5lbmRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lKTtcblxuICAgIH0gZWxzZSBpZiAobm9kZSA9IGZvbGxvd1JlZmVyZW5jZShub2RlKSkge1xuICAgICAgICAvLyBub2RlIHdhcyBhIHJlZmVyZW5jZSBhbmQgZm9sbG93ZWQgbm9kZSBub3cgaXMgZWl0aGVyIGFcbiAgICAgICAgLy8gRnVuY3Rpb25EZWNsYXJhdGlvbiBvciBhIFZhcmlhYmxlRGVjbGFyYXRvclxuICAgICAgICAvLyA9PiByZWN1cnNlXG5cbiAgICAgICAganVkZ2VJbmplY3RBcnJheVN1c3BlY3Qobm9kZSwgY3R4KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEluZGVudChwb3MpIHtcbiAgICAgICAgdmFyIHNyYyA9IGN0eC5zcmM7XG4gICAgICAgIHZhciBsaW5lU3RhcnQgPSBzcmMubGFzdEluZGV4T2YoXCJcXG5cIiwgcG9zIC0gMSkgKyAxO1xuICAgICAgICB2YXIgaSA9IGxpbmVTdGFydDtcbiAgICAgICAgZm9yICg7IHNyY1tpXSA9PT0gXCIgXCIgfHwgc3JjW2ldID09PSBcIlxcdFwiOyBpKyspIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjLnNsaWNlKGxpbmVTdGFydCwgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUmVtb3ZlSW5qZWN0QXJyYXkocGFyYW1zLCBwb3NBZnRlckZ1bmN0aW9uRGVjbGFyYXRpb24sIG5hbWUpIHtcbiAgICAgICAgLy8gaWYgYW4gZXhpc3Rpbmcgc29tZXRoaW5nLiRpbmplY3QgPSBbLi5dIGV4aXN0cyB0aGVuIGlzIHdpbGwgYWx3YXlzIGJlIHJlY3ljbGVkIHdoZW4gcmVidWlsZGluZ1xuXG4gICAgICAgIHZhciBpbmRlbnQgPSBnZXRJbmRlbnQocG9zQWZ0ZXJGdW5jdGlvbkRlY2xhcmF0aW9uLnBvcyk7XG5cbiAgICAgICAgdmFyIGZvdW5kU3VzcGVjdEluQm9keSA9IGZhbHNlO1xuICAgICAgICB2YXIgZXhpc3RpbmdFeHByZXNzaW9uU3RhdGVtZW50V2l0aEFycmF5ID0gbnVsbDtcbiAgICAgICAgdmFyIG5vZGVBZnRlckV4dGVuZHMgPSBudWxsO1xuICAgICAgICBvbm9kZS4kcGFyZW50LmJvZHkuZm9yRWFjaChmdW5jdGlvbihibm9kZSwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoYm5vZGUgPT09IG9ub2RlKSB7XG4gICAgICAgICAgICAgICAgZm91bmRTdXNwZWN0SW5Cb2R5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0luamVjdEFycmF5KGJub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0V4cHJlc3Npb25TdGF0ZW1lbnRXaXRoQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZm10KFwiY29uZmxpY3RpbmcgaW5qZWN0IGFycmF5cyBhdCBsaW5lIHswfSBhbmQgezF9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NUb0xpbmUoZXhpc3RpbmdFeHByZXNzaW9uU3RhdGVtZW50V2l0aEFycmF5LnJhbmdlWzBdLCBjdHguc3JjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1RvTGluZShibm9kZS5yYW5nZVswXSwgY3R4LnNyYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGlzdGluZ0V4cHJlc3Npb25TdGF0ZW1lbnRXaXRoQXJyYXkgPSBibm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICBpZiAoIW5vZGVBZnRlckV4dGVuZHMgJiYgIWZvdW5kU3VzcGVjdEluQm9keSAmJiBibm9kZS50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiAoZSA9IGJub2RlLmV4cHJlc3Npb24pLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiBlLmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBlLmNhbGxlZS5uYW1lID09PSBcIl9fZXh0ZW5kc1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZW1lbnQgPSBvbm9kZS4kcGFyZW50LmJvZHlbaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUFmdGVyRXh0ZW5kcyA9IG5leHRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KGZvdW5kU3VzcGVjdEluQm9keSk7XG4gICAgICAgIGlmIChvbm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgICAgaWYgKCFub2RlQWZ0ZXJFeHRlbmRzKSB7XG4gICAgICAgICAgICAgICAgbm9kZUFmdGVyRXh0ZW5kcyA9IGZpcnN0Tm9uUHJvbG9ndWVTdGF0ZW1lbnQob25vZGUuJHBhcmVudC5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlQWZ0ZXJFeHRlbmRzICYmICFleGlzdGluZ0V4cHJlc3Npb25TdGF0ZW1lbnRXaXRoQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBwb3NBZnRlckZ1bmN0aW9uRGVjbGFyYXRpb24gPSBza2lwUHJldk5ld2xpbmUobm9kZUFmdGVyRXh0ZW5kcy5yYW5nZVswXSwgbm9kZUFmdGVyRXh0ZW5kcy5sb2Muc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzSW5qZWN0QXJyYXkobm9kZSkge1xuICAgICAgICAgICAgdmFyIGx2YWx1ZTtcbiAgICAgICAgICAgIHZhciBhc3NpZ25tZW50O1xuICAgICAgICAgICAgcmV0dXJuIChub2RlICYmIG5vZGUudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgKGFzc2lnbm1lbnQgPSBub2RlLmV4cHJlc3Npb24pLnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiAmJlxuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQub3BlcmF0b3IgPT09IFwiPVwiICYmXG4gICAgICAgICAgICAgICAgKGx2YWx1ZSA9IGFzc2lnbm1lbnQubGVmdCkudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiZcbiAgICAgICAgICAgICAgICAoKGx2YWx1ZS5jb21wdXRlZCA9PT0gZmFsc2UgJiYgY3R4LnNyY0ZvclJhbmdlKGx2YWx1ZS5vYmplY3QucmFuZ2UpID09PSBuYW1lICYmIGx2YWx1ZS5wcm9wZXJ0eS5uYW1lID09PSBcIiRpbmplY3RcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgKGx2YWx1ZS5jb21wdXRlZCA9PT0gdHJ1ZSAmJiBjdHguc3JjRm9yUmFuZ2UobHZhbHVlLm9iamVjdC5yYW5nZSkgPT09IG5hbWUgJiYgbHZhbHVlLnByb3BlcnR5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGx2YWx1ZS5wcm9wZXJ0eS52YWx1ZSA9PT0gXCIkaW5qZWN0XCIpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBza2lwUHJldk5ld2xpbmUocG9zLCBsb2MpIHtcbiAgICAgICAgICAgIHZhciBwcmV2TEYgPSBjdHguc3JjLmxhc3RJbmRleE9mKFwiXFxuXCIsIHBvcyk7XG4gICAgICAgICAgICBpZiAocHJldkxGID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBvczogcG9zLCBsb2M6IGxvYyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZMRiA+PSAxICYmIGN0eC5zcmNbcHJldkxGIC0gMV0gPT09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgICAgICAtLXByZXZMRjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKC9cXFMvZy50ZXN0KGN0eC5zcmMuc2xpY2UocHJldkxGLCBwb3MgLSAxKSkpIHsgLy8gYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJzIGJldHdlZW4gcHJldiBuZXdsaW5lIGFuZCBwb3M/XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcG9zOiBwb3MsIGxvYzogbG9jIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zOiBwcmV2TEYsXG4gICAgICAgICAgICAgICAgbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxvYy5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBwcmV2TEYgLSBjdHguc3JjLmxhc3RJbmRleE9mKFwiXFxuXCIsIHByZXZMRikgLSAxLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3R4Lm1vZGUgPT09IFwicmVidWlsZFwiICYmIGV4aXN0aW5nRXhwcmVzc2lvblN0YXRlbWVudFdpdGhBcnJheSkge1xuICAgICAgICAgICAgdmFyIHN0ck5vV2hpdGVzcGFjZSA9IGZtdChcInsyfS4kaW5qZWN0ID0gezN9O1wiLCBudWxsLCBudWxsLCBuYW1lLCBjdHguc3RyaW5naWZ5KGN0eCwgcGFyYW1zLCBjdHgucXVvdCkpO1xuICAgICAgICAgICAgY3R4LmZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogZXhpc3RpbmdFeHByZXNzaW9uU3RhdGVtZW50V2l0aEFycmF5LnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgIGVuZDogZXhpc3RpbmdFeHByZXNzaW9uU3RhdGVtZW50V2l0aEFycmF5LnJhbmdlWzFdLFxuICAgICAgICAgICAgICAgIHN0cjogc3RyTm9XaGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgIGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogZXhpc3RpbmdFeHByZXNzaW9uU3RhdGVtZW50V2l0aEFycmF5LmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBleGlzdGluZ0V4cHJlc3Npb25TdGF0ZW1lbnRXaXRoQXJyYXkubG9jLmVuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC5tb2RlID09PSBcInJlbW92ZVwiICYmIGV4aXN0aW5nRXhwcmVzc2lvblN0YXRlbWVudFdpdGhBcnJheSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2tpcFByZXZOZXdsaW5lKGV4aXN0aW5nRXhwcmVzc2lvblN0YXRlbWVudFdpdGhBcnJheS5yYW5nZVswXSwgZXhpc3RpbmdFeHByZXNzaW9uU3RhdGVtZW50V2l0aEFycmF5LmxvYy5zdGFydCk7XG4gICAgICAgICAgICBjdHguZnJhZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5wb3MsXG4gICAgICAgICAgICAgICAgZW5kOiBleGlzdGluZ0V4cHJlc3Npb25TdGF0ZW1lbnRXaXRoQXJyYXkucmFuZ2VbMV0sXG4gICAgICAgICAgICAgICAgc3RyOiBcIlwiLFxuICAgICAgICAgICAgICAgIGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQubG9jLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGV4aXN0aW5nRXhwcmVzc2lvblN0YXRlbWVudFdpdGhBcnJheS5sb2MuZW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc29tZW9mKGN0eC5tb2RlLCBbXCJhZGRcIiwgXCJyZWJ1aWxkXCJdKSAmJiAhZXhpc3RpbmdFeHByZXNzaW9uU3RhdGVtZW50V2l0aEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gZm10KFwiezB9ezF9ezJ9LiRpbmplY3QgPSB7M307XCIsIEVPTCwgaW5kZW50LCBuYW1lLCBjdHguc3RyaW5naWZ5KGN0eCwgcGFyYW1zLCBjdHgucXVvdCkpO1xuICAgICAgICAgICAgY3R4LmZyYWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogcG9zQWZ0ZXJGdW5jdGlvbkRlY2xhcmF0aW9uLnBvcyxcbiAgICAgICAgICAgICAgICBlbmQ6IHBvc0FmdGVyRnVuY3Rpb25EZWNsYXJhdGlvbi5wb3MsXG4gICAgICAgICAgICAgICAgc3RyOiBzdHIsXG4gICAgICAgICAgICAgICAgbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwb3NBZnRlckZ1bmN0aW9uRGVjbGFyYXRpb24ubG9jLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHBvc0FmdGVyRnVuY3Rpb25EZWNsYXJhdGlvbi5sb2NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24ganVtcE92ZXJJaWZlKG5vZGUpIHtcbiAgICB2YXIgb3V0ZXJmbjtcbiAgICBpZiAoIShub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiAob3V0ZXJmbiA9IG5vZGUuY2FsbGVlKS50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJib2R5ID0gb3V0ZXJmbi5ib2R5LmJvZHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlcmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudCA9IG91dGVyYm9keVtpXTtcbiAgICAgICAgaWYgKHN0YXRlbWVudC50eXBlID09PSBcIlJldHVyblN0YXRlbWVudFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50LmFyZ3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGFkZE1vZHVsZUNvbnRleHREZXBlbmRlbnRTdXNwZWN0KHRhcmdldCwgY3R4KSB7XG4gICAgY3R4LnN1c3BlY3RzLnB1c2godGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWRkTW9kdWxlQ29udGV4dEluZGVwZW5kZW50U3VzcGVjdCh0YXJnZXQsIGN0eCkge1xuICAgIHRhcmdldC4kY2hhaW5lZCA9IGNoYWluZWRSZWd1bGFyO1xuICAgIGN0eC5zdXNwZWN0cy5wdXNoKHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGlzQW5ub3RhdGVkQXJyYXkobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwiQXJyYXlFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudHMgPSBub2RlLmVsZW1lbnRzO1xuXG4gICAgLy8gbGFzdCBzaG91bGQgYmUgYSBmdW5jdGlvbiBleHByZXNzaW9uXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBsYXN0KGVsZW1lbnRzKS50eXBlICE9PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhbGwgYnV0IGxhc3Qgc2hvdWxkIGJlIHN0cmluZyBsaXRlcmFsc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gZWxlbWVudHNbaV07XG4gICAgICAgIGlmIChuLnR5cGUgIT09IFwiTGl0ZXJhbFwiIHx8ICFpcy5zdHJpbmcobi52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbkV4cHJlc3Npb25XaXRoQXJncyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBub2RlLnBhcmFtcy5sZW5ndGggPj0gMTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25EZWNsYXJhdGlvbldpdGhBcmdzKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiAmJiBub2RlLnBhcmFtcy5sZW5ndGggPj0gMTtcbn1cbmZ1bmN0aW9uIGlzR2VuZXJpY1Byb3ZpZGVyTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgaXMuc3RyaW5nKG5vZGUudmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1bmlxaWZ5RnJhZ21lbnRzKGZyYWdtZW50cykge1xuICAgIC8vIG11c3QgZG8gaW4tcGxhY2UgbW9kaWZpY2F0aW9uIG9mIGN0eC5mcmFnbWVudHMgYmVjYXVzZSBzaGFyZWQgcmVmZXJlbmNlXG5cbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KHtzdGFydDogZnJhZy5zdGFydCwgZW5kOiBmcmFnLmVuZCwgc3RyOiBmcmFnLnN0cn0pO1xuICAgICAgICBpZiAobWFwW3N0cl0pIHtcbiAgICAgICAgICAgIGZyYWdtZW50cy5zcGxpY2UoaSwgMSk7IC8vIHJlbW92ZVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwW3N0cl0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYWxsT3B0aW9uYWxzID3CoHtcbiAgICBcImFuZ3VsYXItZGFzaGJvYXJkLWZyYW1ld29ya1wiOiBvcHRpb25hbEFuZ3VsYXJEYXNoYm9hcmRGcmFtZXdvcmssXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5nQW5ub3RhdGUoc3JjLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubGlzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGlzdDogT2JqZWN0LmtleXMoYWxsT3B0aW9uYWxzKS5zb3J0KCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSAob3B0aW9ucy5hZGQgJiYgb3B0aW9ucy5yZW1vdmUgPyBcInJlYnVpbGRcIiA6XG4gICAgICAgIG9wdGlvbnMucmVtb3ZlID8gXCJyZW1vdmVcIiA6XG4gICAgICAgICAgICBvcHRpb25zLmFkZCA/IFwiYWRkXCIgOiBudWxsKTtcblxuICAgIGlmICghbW9kZSkge1xuICAgICAgICByZXR1cm4ge3NyYzogc3JjfTtcbiAgICB9XG5cbiAgICB2YXIgcXVvdCA9IG9wdGlvbnMuc2luZ2xlX3F1b3RlcyA/IFwiJ1wiIDogJ1wiJztcbiAgICB2YXIgcmUgPSAob3B0aW9ucy5yZWdleHAgPyBuZXcgUmVnRXhwKG9wdGlvbnMucmVnZXhwKSA6IC9eW2EtekEtWjAtOV9cXCRcXC5cXHNdKyQvKTtcbiAgICB2YXIgcmVuYW1lID0gbmV3IHN0cmluZ21hcCgpO1xuICAgIGlmIChvcHRpb25zLnJlbmFtZSkge1xuICAgICAgICBvcHRpb25zLnJlbmFtZS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZW5hbWUuc2V0KHZhbHVlLmZyb20sIHZhbHVlLnRvKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBhc3Q7XG4gICAgdmFyIHN0YXRzID0ge307XG5cbiAgICAvLyBkZXRlY3QgbmV3bGluZSBhbmQgb3ZlcnJpZGUgb3MuRU9MXG4gICAgdmFyIGxmID0gc3JjLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICAgIGlmIChsZiA+PSAxKSB7XG4gICAgICAgIEVPTCA9IChzcmNbbGYgLSAxXSA9PT0gXCJcXHJcIiA/IFwiXFxyXFxuXCIgOiBcIlxcblwiKTtcbiAgICB9XG5cbiAgICAvLyBbe3R5cGU6IFwiQmxvY2tcInxcIkxpbmVcIiwgdmFsdWU6IHN0ciwgcmFuZ2U6IFtmcm9tLHRvXX0sIC4uXVxuICAgIHZhciBjb21tZW50cyA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgc3RhdHMucGFyc2VyX3JlcXVpcmVfdDAgPSByZXF1aXJlX2Fjb3JuX3QwO1xuICAgICAgICBzdGF0cy5wYXJzZXJfcmVxdWlyZV90MSA9IHJlcXVpcmVfYWNvcm5fdDE7XG4gICAgICAgIHN0YXRzLnBhcnNlcl9wYXJzZV90MCA9IERhdGUubm93KCk7XG4gICAgICAgIC8vIGFjb3JuXG4gICAgICAgIGFzdCA9IHBhcnNlcihzcmMsIHtcbiAgICAgICAgICAgIGVjbWFWZXJzaW9uOiA2LFxuICAgICAgICAgICAgYWxsb3dSZXNlcnZlZDogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2F0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgIHJhbmdlczogdHJ1ZSxcbiAgICAgICAgICAgIG9uQ29tbWVudDogY29tbWVudHMsXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0cy5wYXJzZXJfcGFyc2VfdDEgPSBEYXRlLm5vdygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBbXCJlcnJvcjogY291bGRuJ3QgcHJvY2VzcyBzb3VyY2UgZHVlIHRvIHBhcnNlIGVycm9yXCIsIGUubWVzc2FnZV0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIGEgZHVtbXktbm9kZSB0byBhc3Qgc28gdGhhdCBsdXQuZmluZE5vZGVGcm9tUG9zKGxhc3RQb3MpIHJldHVybnMgc29tZXRoaW5nXG4gICAgYXN0LmJvZHkucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiRGVidWdnZXJTdGF0ZW1lbnRcIixcbiAgICAgICAgcmFuZ2U6IFthc3QucmFuZ2VbMV0sIGFzdC5yYW5nZVsxXV0sXG4gICAgICAgIGxvYzoge1xuICAgICAgICAgICAgc3RhcnQ6IGFzdC5sb2MuZW5kLFxuICAgICAgICAgICAgZW5kOiBhc3QubG9jLmVuZFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhbGwgc291cmNlIG1vZGlmaWNhdGlvbnMgYXJlIGJ1aWx0IHVwIGFzIG9wZXJhdGlvbnMgaW4gdGhlXG4gICAgLy8gZnJhZ21lbnRzIGFycmF5LCBsYXRlciBzZW50IHRvIGFsdGVyIGluIG9uZSBzaG90XG4gICAgdmFyIGZyYWdtZW50cyA9IFtdO1xuXG4gICAgLy8gc3VzcGVjdHMgaXMgYnVpbHQgdXAgd2l0aCBzdXNwZWN0IG5vZGVzIGJ5IG1hdGNoLlxuICAgIC8vIEEgc3VzcGVjdCBub2RlIHdpbGwgZ2V0IGFubm90YXRpb25zIGFkZGVkIC8gcmVtb3ZlZCBpZiBpdFxuICAgIC8vIGZ1bGZpbGxzIHRoZSBhcnJheWV4cHJlc3Npb24gb3IgZnVuY3Rpb25leHByZXNzaW9uIGxvb2ssXG4gICAgLy8gYW5kIGlmIGl0IGlzIGluIHRoZSBjb3JyZWN0IGNvbnRleHQgKGluc2lkZSBhbiBhbmd1bGFyXG4gICAgLy8gbW9kdWxlIGRlZmluaXRpb24pXG4gICAgdmFyIHN1c3BlY3RzID0gW107XG5cbiAgICAvLyBibG9ja2VkIGlzIGFuIGFycmF5IG9mIGJsb2NrZWQgc3VzcGVjdHMuIEFueSB0YXJnZXQgbm9kZVxuICAgIC8vIChmaW5hbCwgaS5lLiBJSUZFLWp1bXBlZCwgcmVmZXJlbmNlLWZvbGxvd2VkIGFuZCBzdWNoKSBpbmNsdWRlZFxuICAgIC8vIGluIGJsb2NrZWQgd2lsbCBiZSBpZ25vcmVkIGJ5IGp1ZGdlU3VzcGVjdHNcbiAgICB2YXIgYmxvY2tlZCA9IFtdO1xuXG4gICAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIGFsbCBub2RlcyBpbiB0aGUgQVNULFxuICAgIC8vIHVzZWQgZm9yIHNvdXJjZW1hcCBnZW5lcmF0aW9uXG4gICAgdmFyIG5vZGVQb3NpdGlvbnMgPSBbXTtcblxuICAgIHZhciBsdXQgPSBuZXcgTHV0KGFzdCwgc3JjKTtcblxuICAgIHNjb3BlVG9vbHMuc2V0dXBTY29wZUFuZFJlZmVyZW5jZXMoYXN0KTtcblxuICAgIHZhciBjdHggPSB7XG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIHF1b3Q6IHF1b3QsXG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICBzcmNGb3JSYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuc2xpY2UocmFuZ2VbMF0sIHJhbmdlWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmU6IHJlLFxuICAgICAgICByZW5hbWU6IHJlbmFtZSxcbiAgICAgICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgICAgICBmcmFnbWVudHM6IGZyYWdtZW50cyxcbiAgICAgICAgc3VzcGVjdHM6IHN1c3BlY3RzLFxuICAgICAgICBibG9ja2VkOiBibG9ja2VkLFxuICAgICAgICBsdXQ6IGx1dCxcbiAgICAgICAgaXNGdW5jdGlvbkV4cHJlc3Npb25XaXRoQXJnczogaXNGdW5jdGlvbkV4cHJlc3Npb25XaXRoQXJncyxcbiAgICAgICAgaXNGdW5jdGlvbkRlY2xhcmF0aW9uV2l0aEFyZ3M6IGlzRnVuY3Rpb25EZWNsYXJhdGlvbldpdGhBcmdzLFxuICAgICAgICBpc0Fubm90YXRlZEFycmF5OiBpc0Fubm90YXRlZEFycmF5LFxuICAgICAgICBhZGRNb2R1bGVDb250ZXh0RGVwZW5kZW50U3VzcGVjdDogYWRkTW9kdWxlQ29udGV4dERlcGVuZGVudFN1c3BlY3QsXG4gICAgICAgIGFkZE1vZHVsZUNvbnRleHRJbmRlcGVuZGVudFN1c3BlY3Q6IGFkZE1vZHVsZUNvbnRleHRJbmRlcGVuZGVudFN1c3BlY3QsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5LFxuICAgICAgICBub2RlUG9zaXRpb25zOiBub2RlUG9zaXRpb25zLFxuICAgICAgICBtYXRjaFJlc29sdmU6IG1hdGNoUmVzb2x2ZSxcbiAgICAgICAgbWF0Y2hQcm9wOiBtYXRjaFByb3AsXG4gICAgICAgIGxhc3Q6IGxhc3QsXG4gICAgfTtcblxuICAgIC8vIHNldHVwIG9wdGlvbmFsc1xuICAgIHZhciBvcHRpb25hbHMgPSBvcHRpb25zLmVuYWJsZSB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3B0aW9uYWwgPSBTdHJpbmcob3B0aW9uYWxzW2ldKTtcbiAgICAgICAgaWYgKCFhbGxPcHRpb25hbHMuaGFzT3duUHJvcGVydHkob3B0aW9uYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVycm9yczogW1wiZXJyb3I6IGZvdW5kIG5vIG9wdGlvbmFsIG5hbWVkIFwiICsgb3B0aW9uYWxdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3B0aW9uYWxzUGx1Z2lucyA9IG9wdGlvbmFscy5tYXAoZnVuY3Rpb24ob3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIGFsbE9wdGlvbmFsc1tvcHRpb25hbF07XG4gICAgfSk7XG5cbiAgICB2YXIgcGx1Z2lucyA9IFtdLmNvbmNhdChvcHRpb25hbHNQbHVnaW5zLCBvcHRpb25zLnBsdWdpbiB8fCBbXSk7XG5cbiAgICBmdW5jdGlvbiBtYXRjaFBsdWdpbnMobm9kZSwgaXNNZXRob2RDYWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHBsdWdpbnNbaV0ubWF0Y2gobm9kZSwgaXNNZXRob2RDYWxsKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoUGx1Z2luc09yTnVsbCA9IChwbHVnaW5zLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBtYXRjaFBsdWdpbnMpO1xuXG4gICAgbmdJbmplY3QuaW5zcGVjdENvbW1lbnRzKGN0eCk7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICBwbHVnaW4uaW5pdChjdHgpO1xuICAgIH0pO1xuXG4gICAgdHJhdmVyc2UoYXN0LCB7cHJlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5nSW5qZWN0Lmluc3BlY3ROb2RlKG5vZGUsIGN0eCk7XG5cbiAgICB9LCBwb3N0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGN0eC5ub2RlUG9zaXRpb25zLnB1c2gobm9kZS5sb2Muc3RhcnQpO1xuICAgICAgICB2YXIgdGFyZ2V0cyA9IG1hdGNoKG5vZGUsIGN0eCwgbWF0Y2hQbHVnaW5zT3JOdWxsKTtcbiAgICAgICAgaWYgKCF0YXJnZXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpcy5hcnJheSh0YXJnZXRzKSkge1xuICAgICAgICAgICAgdGFyZ2V0cyA9IFt0YXJnZXRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkTW9kdWxlQ29udGV4dERlcGVuZGVudFN1c3BlY3QodGFyZ2V0c1tpXSwgY3R4KTtcbiAgICAgICAgfVxuICAgIH19KTtcblxuICAgIHRyeSB7XG4gICAgICAgIGp1ZGdlU3VzcGVjdHMoY3R4KTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yczogW1wiZXJyb3I6IFwiICsgZV0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdW5pcWlmeUZyYWdtZW50cyhjdHguZnJhZ21lbnRzKTtcblxuICAgIHZhciBvdXQgPSBhbHRlcihzcmMsIGZyYWdtZW50cyk7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc3JjOiBvdXQsXG4gICAgICAgIF9zdGF0czogc3RhdHMsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLm1hcCkge1xuICAgICAgICBpZiAodHlwZW9mKG9wdGlvbnMubWFwKSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICBvcHRpb25zLm1hcCA9IHt9O1xuICAgICAgICBzdGF0cy5zb3VyY2VtYXBfdDAgPSBEYXRlLm5vdygpO1xuICAgICAgICBnZW5lcmF0ZVNvdXJjZW1hcChyZXN1bHQsIHNyYywgbm9kZVBvc2l0aW9ucywgZnJhZ21lbnRzLCBvcHRpb25zLm1hcCk7XG4gICAgICAgIHN0YXRzLnNvdXJjZW1hcF90MSA9IERhdGUubm93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8vIG5naW5qZWN0LmpzXG4vLyBNSVQgbGljZW5zZWQsIHNlZSBMSUNFTlNFIGZpbGVcbi8vIENvcHlyaWdodCAoYykgMjAxMy0yMDE2IE9sb3YgTGFzc3VzIDxvbG92Lmxhc3N1c0BnbWFpbC5jb20+XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXMgPSByZXF1aXJlKFwic2ltcGxlLWlzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpbnNwZWN0Q29tbWVudHM6IGluc3BlY3RDb21tZW50cyxcbiAgICBpbnNwZWN0Tm9kZTogaW5zcGVjdE5vZGUsXG59O1xuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShub2RlLCBjdHgpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaW5zcGVjdENhbGxFeHByZXNzaW9uKG5vZGUsIGN0eCk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIikge1xuICAgICAgICBpbnNwZWN0RnVuY3Rpb24obm9kZSwgY3R4KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RDYWxsRXhwcmVzc2lvbihub2RlLCBjdHgpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUuY2FsbGVlLm5hbWU7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChuYW1lID09PSBcIm5nSW5qZWN0XCIgfHwgbmFtZSA9PT0gXCJuZ05vSW5qZWN0XCIpICYmIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgYmxvY2sgPSAobmFtZSA9PT0gXCJuZ05vSW5qZWN0XCIpO1xuICAgICAgICBhZGRTdXNwZWN0KG5vZGUuYXJndW1lbnRzWzBdLCBjdHgsIGJsb2NrKTtcbiAgICB9XG59XG5cbnZhciBuZ0Fubm90YXRlUHJvbG9ndWVEaXJlY3RpdmVzID0gW1wibmdJbmplY3RcIiwgXCJuZ05vSW5qZWN0XCJdO1xuXG5mdW5jdGlvbiBpbnNwZWN0RnVuY3Rpb24obm9kZSwgY3R4KSB7XG4gICAgdmFyIHN0ciA9IG1hdGNoUHJvbG9ndWVEaXJlY3RpdmVzKG5nQW5ub3RhdGVQcm9sb2d1ZURpcmVjdGl2ZXMsIG5vZGUpO1xuICAgIGlmICghc3RyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJsb2NrID0gKHN0ciA9PT0gXCJuZ05vSW5qZWN0XCIpO1xuXG4gICAgLy8gbm93IGFkZCB0aGUgY29ycmVjdCBzdXNwZWN0XG5cbiAgICAvLyBmb3IgZnVuY3Rpb24gZGVjbGFyYXRpb25zLCBpdCBpcyBhbHdheXMgdGhlIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIG5vZGUgaXRzZWxmXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgYWRkU3VzcGVjdChub2RlLCBjdHgsIGJsb2NrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG5vZGUgaXMgYSBmdW5jdGlvbiBleHByZXNzaW9uIGJlbG93XG5cbiAgICAvLyBjYXNlIDE6IGEgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aGljaCBpcyB0aGUgcmhzIG9mIGEgdmFyaWFibGUgZGVjbGFyYXRvciwgc3VjaCBhc1xuICAgIC8vIHZhciBmMSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAvLyAgICAgXCJuZ0luamVjdFwiXG4gICAgLy8gfTtcbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgY2FuIG1hcmsgdGhlIGRlY2xhcmF0b3IsIHNhbWUgYXMgc2F5aW5nIHZhciAvKkBuZ0luamVjdCovIGYxID0gZnVuY3Rpb24oYSkgLi5cbiAgICAvLyBvciAvKkBuZ0luamVjdCovIHZhciBmMSA9IGZ1bmN0aW9uKGEpIC4uXG4gICAgLy8gZjEuJGluamVjdCA9IFtcImFcIl07IHdpbGwgYmUgYWRkZWQgKG9yIHJlYnVpbHQvcmVtb3ZlZClcbiAgICBpZiAobm9kZS4kcGFyZW50LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpIHtcbiAgICAgICAgYWRkU3VzcGVjdChub2RlLiRwYXJlbnQsIGN0eCwgYmxvY2spO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2FzZSAyOiBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gZXhwcmVzc2lvbiwgc3VjaCBhc1xuICAgIC8vIGcoZnVuY3Rpb24oYSkge1xuICAgIC8vICAgICBcIm5nSW5qZWN0XCJcbiAgICAvLyB9KTtcbiAgICAvL1xuICAgIC8vIHRoZSBzdXNwZWN0IGlzIG5vdyBpdHMgcGFyZW50IGFubm90YXRlZCBhcnJheSAoaWYgYW55KSwgb3RoZXJ3aXNlIGl0c2VsZlxuICAgIC8vIHRoZXJlIGlzIGEgcmlzayBvZiBmYWxzZSBzdXNwZWN0cyBoZXJlLCBpbiBjYXNlIHRoZSBwYXJlbnQgYW5ub3RhdGVkIGFycmF5IGhhcyBub3RoaW5nIHRvIGRvXG4gICAgLy8gd2l0aCBhbm5vdGF0aW9ucy4gdGhlIHJpc2sgc2hvdWxkIGJlIHZlcnkgbG93IGFuZCBob3BlZnVsbHkgZWFzeSB0byB3b3JrYXJvdW5kXG4gICAgLy9cbiAgICAvLyBhZGRlZC9yZWJ1aWx0L3JlbW92ZWQgPT4gZyhbXCJhXCIsIGZ1bmN0aW9uKGEpIHtcbiAgICAvLyAgICAgXCJuZ0luamVjdFwiXG4gICAgLy8gfV0pO1xuICAgIHZhciBtYXliZUFycmF5RXhwcmVzc2lvbiA9IG5vZGUuJHBhcmVudDtcbiAgICBpZiAoY3R4LmlzQW5ub3RhdGVkQXJyYXkobWF5YmVBcnJheUV4cHJlc3Npb24pKSB7XG4gICAgICAgIGFkZFN1c3BlY3QobWF5YmVBcnJheUV4cHJlc3Npb24sIGN0eCwgYmxvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFN1c3BlY3Qobm9kZSwgY3R4LCBibG9jayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFByb2xvZ3VlRGlyZWN0aXZlcyhwcm9sb2d1ZURpcmVjdGl2ZXMsIG5vZGUpIHtcbiAgICB2YXIgYm9keSA9IG5vZGUuYm9keS5ib2R5O1xuXG4gICAgdmFyIGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJvZHlbaV0udHlwZSAhPT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cHIgPSBib2R5W2ldLmV4cHJlc3Npb247XG4gICAgICAgIHZhciBpc1N0cmluZ0xpdGVyYWwgPSAoZXhwci50eXBlID09PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2YgZXhwci52YWx1ZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgICAgIGlmICghaXNTdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9sb2d1ZURpcmVjdGl2ZXMuaW5kZXhPZihleHByLnZhbHVlKSA+PSAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGV4cHIudmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdENvbW1lbnRzKGN0eCkge1xuICAgIHZhciBjb21tZW50cyA9IGN0eC5jb21tZW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0gY29tbWVudHNbaV07XG4gICAgICAgIHZhciB5ZXNQb3MgPSBjb21tZW50LnZhbHVlLmluZGV4T2YoXCJAbmdJbmplY3RcIik7XG4gICAgICAgIHZhciBub1BvcyA9ICh5ZXNQb3MgPT09IC0xID8gY29tbWVudC52YWx1ZS5pbmRleE9mKFwiQG5nTm9JbmplY3RcIikgOiAtMSk7XG4gICAgICAgIGlmICh5ZXNQb3MgPT09IC0xICYmIG5vUG9zID09PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0ID0gY3R4Lmx1dC5maW5kTm9kZUZyb21Qb3MoY29tbWVudC5yYW5nZVsxXSk7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFN1c3BlY3QodGFyZ2V0LCBjdHgsIG5vUG9zID49IDApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdBcnJheShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmVsZW1lbnRzLmxlbmd0aCA+PSAxICYmIG5vZGUuZWxlbWVudHMuZXZlcnkoZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBpcy5zdHJpbmcobi52YWx1ZSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0U3RhdGVtZW50KG5vZGUpIHtcbiAgICB2YXIgYm9keSA9IG5vZGUuJHBhcmVudC5ib2R5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYm9keVtpXSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHlbaSArIDFdIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZFN1c3BlY3QodGFyZ2V0LCBjdHgsIGJsb2NrKSB7XG4gICAgaWYgKHRhcmdldC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiB0YXJnZXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgJiYgaXNTdHJpbmdBcnJheSh0YXJnZXQuZXhwcmVzc2lvbi5yaWdodCkpIHtcbiAgICAgICAgLy8gLypAbmdJbmplY3QqL1xuICAgICAgICAvLyBGb29CYXIuJGluamVjdCA9IFtcIiRhXCIsIFwiJGJcIl07XG4gICAgICAgIC8vIGZ1bmN0aW9uIEZvb0JhcigkYSwgJGIpIHt9XG4gICAgICAgIHZhciBhZGp1c3RlZFRhcmdldCA9IGZpbmROZXh0U3RhdGVtZW50KHRhcmdldCk7XG4gICAgICAgIGlmIChhZGp1c3RlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFN1c3BlY3QoYWRqdXN0ZWRUYXJnZXQsIGN0eCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgICAgICAvLyAvKkBuZ0luamVjdCovIHtmMTogZnVuY3Rpb24oYSksIC4uLCB7ZjI6IGZ1bmN0aW9uKGIpfX1cbiAgICAgICAgYWRkT2JqZWN0RXhwcmVzc2lvbih0YXJnZXQsIGN0eCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIHRhcmdldC5yaWdodC50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgICAgICAvLyAvKkBuZ0luamVjdCovIGYoeC55ID0ge2YxOiBmdW5jdGlvbihhKSwgLi4sIHtmMjogZnVuY3Rpb24oYil9fSlcbiAgICAgICAgYWRkT2JqZWN0RXhwcmVzc2lvbih0YXJnZXQucmlnaHQsIGN0eCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgdGFyZ2V0LmV4cHJlc3Npb24udHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIHRhcmdldC5leHByZXNzaW9uLnJpZ2h0LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIC8vIC8qQG5nSW5qZWN0Ki8geC55ID0ge2YxOiBmdW5jdGlvbihhKSwgLi4sIHtmMjogZnVuY3Rpb24oYil9fVxuICAgICAgICBhZGRPYmplY3RFeHByZXNzaW9uKHRhcmdldC5leHByZXNzaW9uLnJpZ2h0LCBjdHgpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIHRhcmdldC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIHRhcmdldC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAmJiB0YXJnZXQuZGVjbGFyYXRpb25zWzBdLmluaXQudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgLy8gLypAbmdJbmplY3QqLyB2YXIgeCA9IHtmMTogZnVuY3Rpb24oYSksIC4uLCB7ZjI6IGZ1bmN0aW9uKGIpfX1cbiAgICAgICAgYWRkT2JqZWN0RXhwcmVzc2lvbih0YXJnZXQuZGVjbGFyYXRpb25zWzBdLmluaXQsIGN0eCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQudHlwZSA9PT0gXCJQcm9wZXJ0eVwiKSB7XG4gICAgICAgIC8vIHsvKkBuZ0luamVjdCovIGp1c3R0aGlzb25lOiBmdW5jdGlvbihhKSwgLi59XG4gICAgICAgIHRhcmdldC52YWx1ZS4kbGltaXRUb01ldGhvZE5hbWUgPSBcIipuZXZlcipcIjtcbiAgICAgICAgYWRkT3JCbG9jayh0YXJnZXQudmFsdWUsIGN0eCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gLypAbmdJbmplY3QqLyBmdW5jdGlvbihhKSB7fVxuICAgICAgICB0YXJnZXQuJGxpbWl0VG9NZXRob2ROYW1lID0gXCIqbmV2ZXIqXCI7XG4gICAgICAgIGFkZE9yQmxvY2sodGFyZ2V0LCBjdHgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjdHgpIHtcbiAgICAgICAgbmVzdGVkT2JqZWN0VmFsdWVzKG5vZGUpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgICAgICAgbi4kbGltaXRUb01ldGhvZE5hbWUgPSBcIipuZXZlcipcIjtcbiAgICAgICAgICAgIGFkZE9yQmxvY2sobiwgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkT3JCbG9jayhub2RlLCBjdHgpIHtcbiAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICBjdHguYmxvY2tlZC5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmFkZE1vZHVsZUNvbnRleHRJbmRlcGVuZGVudFN1c3BlY3Qobm9kZSwgY3R4KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBuZXN0ZWRPYmplY3RWYWx1ZXMobm9kZSwgcmVzKSB7XG4gICAgcmVzID0gcmVzIHx8IFtdO1xuXG4gICAgbm9kZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB2YXIgdiA9IHByb3AudmFsdWU7XG4gICAgICAgIGlmIChpcy5zb21lb2Yodi50eXBlLCBbXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwgXCJBcnJheUV4cHJlc3Npb25cIl0pKSB7XG4gICAgICAgICAgICByZXMucHVzaCh2KTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICBuZXN0ZWRPYmplY3RWYWx1ZXModiwgcmVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY3R4ID0gbnVsbDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKF9jdHgpIHtcbiAgICAgICAgY3R4ID0gX2N0eDtcbiAgICB9LFxuXG4gICAgbWF0Y2g6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgLy8gZGFzaGJvYXJkUHJvdmlkZXIud2lkZ2V0KFwibmFtZVwiLCB7XG4gICAgICAgIC8vICAgLi4uXG4gICAgICAgIC8vICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlKSB7fSxcbiAgICAgICAgLy8gICByZXNvbHZlOiB7ZjogZnVuY3Rpb24oJHNjb3BlKSB7fSwgLi59XG4gICAgICAgIC8vIH0pXG5cbiAgICAgICAgdmFyIGNhbGxlZSA9IG5vZGUuY2FsbGVlO1xuICAgICAgICBpZiAoIWNhbGxlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9iaiA9IGNhbGxlZS5vYmplY3Q7XG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZGVudGlmaWVyIG9yIGV4cHJlc3Npb25cbiAgICAgICAgaWYgKCEob2JqLiRjaGFpbmVkID09PSAxIHx8IChvYmoudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgb2JqLm5hbWUgPT09IFwiZGFzaGJvYXJkUHJvdmlkZXJcIikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLiRjaGFpbmVkID0gMTtcblxuICAgICAgICB2YXIgbWV0aG9kID0gY2FsbGVlLnByb3BlcnR5OyAvLyBpZGVudGlmaWVyXG4gICAgICAgIGlmIChtZXRob2QubmFtZSAhPT0gXCJ3aWRnZXRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBub2RlLmFyZ3VtZW50cztcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29uZmlnQXJnID0gY3R4Lmxhc3QoYXJncyk7XG4gICAgICAgIGlmIChjb25maWdBcmcudHlwZSAhPT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wcyA9IGNvbmZpZ0FyZy5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgcmVzID0gW1xuICAgICAgICAgICAgY3R4Lm1hdGNoUHJvcChcImNvbnRyb2xsZXJcIiwgcHJvcHMpXG4gICAgICAgIF07XG4gICAgICAgIC8vIHtyZXNvbHZlOiAuLn1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjdHgubWF0Y2hSZXNvbHZlKHByb3BzKSk7XG5cbiAgICAgICAgLy8gZWRpdDoge2NvbnRyb2xsZXI6IGZ1bmN0aW9uKCksIHJlc29sdmU6IHt9LCBhcHBseTogZnVuY3Rpb24oKX1cbiAgICAgICAgdmFyIGVkaXQgPSBjdHgubWF0Y2hQcm9wKCdlZGl0JywgcHJvcHMpO1xuICAgICAgICBpZiAoZWRpdCAmJiBlZGl0LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICB2YXIgZWRpdFByb3BzID0gZWRpdC5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgcmVzLnB1c2goY3R4Lm1hdGNoUHJvcCgnY29udHJvbGxlcicsIGVkaXRQcm9wcykpO1xuICAgICAgICAgICAgcmVzLnB1c2goY3R4Lm1hdGNoUHJvcCgnYXBwbHknLCBlZGl0UHJvcHMpKTtcbiAgICAgICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgY3R4Lm1hdGNoUmVzb2x2ZShlZGl0UHJvcHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXJlZFJlcyA9IHJlcy5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIHJldHVybiAoZmlsdGVyZWRSZXMubGVuZ3RoID09PSAwID8gZmFsc2UgOiBmaWx0ZXJlZFJlcyk7XG4gICAgfVxufTtcbiIsIi8vIHNjb3BlLmpzXG4vLyBNSVQgbGljZW5zZWQsIHNlZSBMSUNFTlNFIGZpbGVcbi8vIENvcHlyaWdodCAoYykgMjAxMy0yMDE2IE9sb3YgTGFzc3VzIDxvbG92Lmxhc3N1c0BnbWFpbC5jb20+XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciBzdHJpbmdtYXAgPSByZXF1aXJlKFwic3RyaW5nbWFwXCIpO1xudmFyIHN0cmluZ3NldCA9IHJlcXVpcmUoXCJzdHJpbmdzZXRcIik7XG52YXIgaXMgPSByZXF1aXJlKFwic2ltcGxlLWlzXCIpO1xudmFyIGZtdCA9IHJlcXVpcmUoXCJzaW1wbGUtZm10XCIpO1xuXG5mdW5jdGlvbiBTY29wZShhcmdzKSB7XG4gICAgYXNzZXJ0KGlzLnNvbWVvZihhcmdzLmtpbmQsIFtcImhvaXN0XCIsIFwiYmxvY2tcIiwgXCJjYXRjaC1ibG9ja1wiXSkpO1xuICAgIGFzc2VydChpcy5vYmplY3QoYXJncy5ub2RlKSk7XG4gICAgYXNzZXJ0KGFyZ3MucGFyZW50ID09PSBudWxsIHx8IGlzLm9iamVjdChhcmdzLnBhcmVudCkpO1xuXG4gICAgLy8ga2luZCA9PT0gXCJob2lzdFwiOiBmdW5jdGlvbiBzY29wZXMsIHByb2dyYW0gc2NvcGUsIGluamVjdGVkIGdsb2JhbHNcbiAgICAvLyBraW5kID09PSBcImJsb2NrXCI6IEVTNiBibG9jayBzY29wZXNcbiAgICAvLyBraW5kID09PSBcImNhdGNoLWJsb2NrXCI6IGNhdGNoIGJsb2NrIHNjb3Blc1xuICAgIHRoaXMua2luZCA9IGFyZ3Mua2luZDtcblxuICAgIC8vIHRoZSBBU1Qgbm9kZSB0aGUgYmxvY2sgY29ycmVzcG9uZHMgdG9cbiAgICB0aGlzLm5vZGUgPSBhcmdzLm5vZGU7XG5cbiAgICAvLyBwYXJlbnQgc2NvcGVcbiAgICB0aGlzLnBhcmVudCA9IGFyZ3MucGFyZW50O1xuXG4gICAgLy8gY2hpbGRyZW4gc2NvcGVzIGZvciBlYXNpZXIgdHJhdmVyc2FsIChwb3B1bGF0ZWQgaW50ZXJuYWxseSlcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICAvLyBzY29wZSBkZWNsYXJhdGlvbnMuIGRlY2xzW3ZhcmlhYmxlX25hbWVdID0ge1xuICAgIC8vICAgICBraW5kOiBcImZ1blwiIGZvciBmdW5jdGlvbnMsXG4gICAgLy8gICAgICAgICAgIFwicGFyYW1cIiBmb3IgZnVuY3Rpb24gcGFyYW1ldGVycyxcbiAgICAvLyAgICAgICAgICAgXCJjYXVnaHRcIiBmb3IgY2F0Y2ggcGFyYW1ldGVyXG4gICAgLy8gICAgICAgICAgIFwidmFyXCIsXG4gICAgLy8gICAgICAgICAgIFwiY29uc3RcIixcbiAgICAvLyAgICAgICAgICAgXCJsZXRcIlxuICAgIC8vICAgICBub2RlOiB0aGUgQVNUIG5vZGUgdGhlIGRlY2xhcmF0aW9uIGNvcnJlc3BvbmRzIHRvXG4gICAgLy8gICAgIGZyb206IHNvdXJjZSBjb2RlIGluZGV4IGZyb20gd2hpY2ggaXQgaXMgdmlzaWJsZSBhdCBlYXJsaWVzdFxuICAgIC8vICAgICAgICAgICAob25seSBzdG9yZWQgZm9yIFwiY29uc3RcIiwgXCJsZXRcIiBbYW5kIFwidmFyXCJdIG5vZGVzKVxuICAgIC8vIH1cbiAgICB0aGlzLmRlY2xzID0gc3RyaW5nbWFwKCk7XG5cbiAgICAvLyBuYW1lcyBvZiBhbGwgdmFyaWFibGVzIGRlY2xhcmVkIG91dHNpZGUgdGhpcyBob2lzdCBzY29wZSBidXRcbiAgICAvLyByZWZlcmVuY2VkIGluIHRoaXMgc2NvcGUgKGltbWVkaWF0ZWx5IG9yIGluIGNoaWxkKS5cbiAgICAvLyBvbmx5IHN0b3JlZCBvbiBob2lzdCBzY29wZXMgZm9yIGVmZmljaWVuY3lcbiAgICAvLyAoYmVjYXVzZSB3ZSBjdXJyZW50bHkgZ2VuZXJhdGUgbG90cyBvZiBlbXB0eSBibG9jayBzY29wZXMpXG4gICAgdGhpcy5wcm9wYWdhdGVzID0gKHRoaXMua2luZCA9PT0gXCJob2lzdFwiID8gc3RyaW5nc2V0KCkgOiBudWxsKTtcblxuICAgIC8vIHNjb3BlcyByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggdGhlaXIgcGFyZW50cyBmb3IgZWFzaWVyIHRyYXZlcnNhbFxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgIH1cbn1cblxuU2NvcGUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24oaW5kZW50KSB7XG4gICAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICB2YXIgbmFtZXMgPSB0aGlzLmRlY2xzLmtleXMoKS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gZm10KFwiezB9IFt7MX1dXCIsIG5hbWUsIHNjb3BlLmRlY2xzLmdldChuYW1lKS5raW5kKTtcbiAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgdmFyIHByb3BhZ2F0ZXMgPSB0aGlzLnByb3BhZ2F0ZXMgPyB0aGlzLnByb3BhZ2F0ZXMuaXRlbXMoKS5qb2luKFwiLCBcIikgOiBcIlwiO1xuICAgIGNvbnNvbGUubG9nKGZtdChcInswfXsxfTogezJ9LiBwcm9wYWdhdGVzOiB7M31cIiwgZm10LnJlcGVhdChcIiBcIiwgaW5kZW50KSwgdGhpcy5ub2RlLnR5cGUsIG5hbWVzLCBwcm9wYWdhdGVzKSk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYy5wcmludChpbmRlbnQgKyAyKTtcbiAgICB9KTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuYW1lLCBraW5kLCBub2RlLCByZWZlcmFibGVGcm9tUG9zKSB7XG4gICAgYXNzZXJ0KGlzLnNvbWVvZihraW5kLCBbXCJmdW5cIiwgXCJwYXJhbVwiLCBcInZhclwiLCBcImNhdWdodFwiLCBcImNvbnN0XCIsIFwibGV0XCJdKSk7XG5cbiAgICBmdW5jdGlvbiBpc0NvbnN0TGV0KGtpbmQpIHtcbiAgICAgICAgcmV0dXJuIGlzLnNvbWVvZihraW5kLCBbXCJjb25zdFwiLCBcImxldFwiXSk7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIC8vIHNlYXJjaCBuZWFyZXN0IGhvaXN0LXNjb3BlIGZvciBmdW4sIHBhcmFtIGFuZCB2YXInc1xuICAgIC8vIGNvbnN0LCBsZXQgYW5kIGNhdWdodCB2YXJpYWJsZXMgZ28gZGlyZWN0bHkgaW4gdGhlIHNjb3BlICh3aGljaCBtYXkgYmUgaG9pc3QsIGJsb2NrIG9yIGNhdGNoLWJsb2NrKVxuICAgIGlmIChpcy5zb21lb2Yoa2luZCwgW1wiZnVuXCIsIFwicGFyYW1cIiwgXCJ2YXJcIl0pKSB7XG4gICAgICAgIHdoaWxlIChzY29wZS5raW5kICE9PSBcImhvaXN0XCIpIHtcbi8vICAgICAgICAgICAgaWYgKHNjb3BlLmRlY2xzLmhhcyhuYW1lKSAmJiBpc0NvbnN0TGV0KHNjb3BlLmRlY2xzLmdldChuYW1lKS5raW5kKSkgeyAvLyBjb3VsZCBiZSBjYXVnaHRcbi8vICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihnZXRsaW5lKG5vZGUpLCBcInswfSBpcyBhbHJlYWR5IGRlY2xhcmVkXCIsIG5hbWUpO1xuLy8gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBuYW1lIGV4aXN0cyBpbiBzY29wZSBhbmQgZWl0aGVyIG5ldyBvciBleGlzdGluZyBraW5kIGlzIGNvbnN0fGxldCA9PiBlcnJvclxuLy8gICAgaWYgKHNjb3BlLmRlY2xzLmhhcyhuYW1lKSAmJiAoaXNDb25zdExldChzY29wZS5kZWNscy5nZXQobmFtZSkua2luZCkgfHwgaXNDb25zdExldChraW5kKSkpIHtcbi8vICAgICAgICByZXR1cm4gZXJyb3IoZ2V0bGluZShub2RlKSwgXCJ7MH0gaXMgYWxyZWFkeSBkZWNsYXJlZFwiLCBuYW1lKTtcbi8vICAgIH1cblxuICAgIHZhciBkZWNsYXJhdGlvbiA9IHtcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICB9O1xuICAgIGlmIChyZWZlcmFibGVGcm9tUG9zKSB7XG4gICAgICAgIGFzc2VydChpcy5zb21lb2Yoa2luZCwgW1widmFyXCIsIFwiY29uc3RcIiwgXCJsZXRcIl0pKTtcbiAgICAgICAgZGVjbGFyYXRpb24uZnJvbSA9IHJlZmVyYWJsZUZyb21Qb3M7XG4gICAgfVxuICAgIHNjb3BlLmRlY2xzLnNldChuYW1lLCBkZWNsYXJhdGlvbik7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuZ2V0S2luZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBhc3NlcnQoaXMuc3RyaW5nKG5hbWUpKTtcbiAgICB2YXIgZGVjbCA9IHRoaXMuZGVjbHMuZ2V0KG5hbWUpO1xuICAgIHJldHVybiBkZWNsID8gZGVjbC5raW5kIDogbnVsbDtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGFzc2VydChpcy5zdHJpbmcobmFtZSkpO1xuICAgIHZhciBkZWNsID0gdGhpcy5kZWNscy5nZXQobmFtZSk7XG4gICAgcmV0dXJuIGRlY2wgPyBkZWNsLm5vZGUgOiBudWxsO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmdldEZyb21Qb3MgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgYXNzZXJ0KGlzLnN0cmluZyhuYW1lKSk7XG4gICAgdmFyIGRlY2wgPSB0aGlzLmRlY2xzLmdldChuYW1lKTtcbiAgICByZXR1cm4gZGVjbCA/IGRlY2wuZnJvbSA6IG51bGw7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuaGFzT3duID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmRlY2xzLmhhcyhuYW1lKTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbHMucmVtb3ZlKG5hbWUpO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmRvZXNQcm9wYWdhdGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGFnYXRlcy5oYXMobmFtZSk7XG59O1xuXG5TY29wZS5wcm90b3R5cGUubWFya1Byb3BhZ2F0ZXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdGhpcy5wcm9wYWdhdGVzLmFkZChuYW1lKTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5jbG9zZXN0SG9pc3RTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgd2hpbGUgKHNjb3BlLmtpbmQgIT09IFwiaG9pc3RcIikge1xuICAgICAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBmb3IgKHZhciBzY29wZSA9IHRoaXM7IHNjb3BlOyBzY29wZSA9IHNjb3BlLnBhcmVudCkge1xuICAgICAgICBpZiAoc2NvcGUuZGVjbHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NvcGUua2luZCA9PT0gXCJob2lzdFwiKSB7XG4gICAgICAgICAgICBzY29wZS5wcm9wYWdhdGVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2NvcGU7XG4iLCIvLyBzY29wZXRvb2xzLmpzXG4vLyBNSVQgbGljZW5zZWQsIHNlZSBMSUNFTlNFIGZpbGVcbi8vIENvcHlyaWdodCAoYykgMjAxMy0yMDE2IE9sb3YgTGFzc3VzIDxvbG92Lmxhc3N1c0BnbWFpbC5jb20+XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoXCJvcmRlcmVkLWFzdC10cmF2ZXJzZVwiKTtcbnZhciBTY29wZSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIGlzID0gcmVxdWlyZShcInNpbXBsZS1pc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2V0dXBTY29wZUFuZFJlZmVyZW5jZXM6IHNldHVwU2NvcGVBbmRSZWZlcmVuY2VzLFxuICAgIGlzUmVmZXJlbmNlOiBpc1JlZmVyZW5jZSxcbn07XG5cbmZ1bmN0aW9uIHNldHVwU2NvcGVBbmRSZWZlcmVuY2VzKHJvb3QpIHtcbiAgICB0cmF2ZXJzZShyb290LCB7cHJlOiBjcmVhdGVTY29wZXN9KTtcbiAgICBjcmVhdGVUb3BTY29wZShyb290LiRzY29wZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjb3Blcyhub2RlLCBwYXJlbnQpIHtcbiAgICBub2RlLiRwYXJlbnQgPSBwYXJlbnQ7XG4gICAgbm9kZS4kc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuJHNjb3BlIDogbnVsbDsgLy8gbWF5IGJlIG92ZXJyaWRkZW5cblxuICAgIGlmIChpc05vbkZ1bmN0aW9uQmxvY2sobm9kZSwgcGFyZW50KSkge1xuICAgICAgICAvLyBBIGJsb2NrIG5vZGUgaXMgYSBzY29wZSB1bmxlc3MgcGFyZW50IGlzIGEgZnVuY3Rpb25cbiAgICAgICAgbm9kZS4kc2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgICAga2luZDogXCJibG9ja1wiLFxuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LiRzY29wZSxcbiAgICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgLy8gVmFyaWFibGUgZGVjbGFyYXRpb25zIG5hbWVzIGdvZXMgaW4gY3VycmVudCBzY29wZVxuICAgICAgICBub2RlLmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlY2xhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZGVjbGFyYXRvci5pZC5uYW1lO1xuICAgICAgICAgICAgbm9kZS4kc2NvcGUuYWRkKG5hbWUsIG5vZGUua2luZCwgZGVjbGFyYXRvci5pZCwgZGVjbGFyYXRvci5yYW5nZVsxXSk7XG4gICAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG5vZGUpKSB7XG4gICAgICAgIC8vIEZ1bmN0aW9uIGlzIGEgc2NvcGUsIHdpdGggcGFyYW1zIGluIGl0XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gYmxvY2stc2NvcGUgdW5kZXIgaXRcblxuICAgICAgICBub2RlLiRzY29wZSA9IG5ldyBTY29wZSh7XG4gICAgICAgICAgICBraW5kOiBcImhvaXN0XCIsXG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQuJHNjb3BlLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmdW5jdGlvbiBoYXMgYSBuYW1lXG4gICAgICAgIGlmIChub2RlLmlkKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIG5hbWUgZ29lcyBpbiBwYXJlbnQgc2NvcGUgZm9yIGRlY2xhcmVkIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgIHBhcmVudC4kc2NvcGUuYWRkKG5vZGUuaWQubmFtZSwgXCJmdW5cIiwgbm9kZS5pZCwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIG5hbWUgZ29lcyBpbiBmdW5jdGlvbidzIHNjb3BlIGZvciBuYW1lZCBmdW5jdGlvbiBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIG5vZGUuJHNjb3BlLmFkZChub2RlLmlkLm5hbWUsIFwiZnVuXCIsIG5vZGUuaWQsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgbm9kZS4kc2NvcGUuYWRkKHBhcmFtLm5hbWUsIFwicGFyYW1cIiwgcGFyYW0sIG51bGwpO1xuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAoaXNGb3JXaXRoQ29uc3RMZXQobm9kZSkgfHwgaXNGb3JJbk9mV2l0aENvbnN0TGV0KG5vZGUpKSB7XG4gICAgICAgIC8vIEZvcihJbi9PZikgbG9vcCB3aXRoIGNvbnN0fGxldCBkZWNsYXJhdGlvbiBpcyBhIHNjb3BlLCB3aXRoIGRlY2xhcmF0aW9uIGluIGl0XG4gICAgICAgIC8vIFRoZXJlIG1heSBiZSBhIGJsb2NrLXNjb3BlIHVuZGVyIGl0XG4gICAgICAgIG5vZGUuJHNjb3BlID0gbmV3IFNjb3BlKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudC4kc2NvcGUsXG4gICAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQ2F0Y2hDbGF1c2VcIikge1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IG5vZGUucGFyYW07XG5cbiAgICAgICAgbm9kZS4kc2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgICAga2luZDogXCJjYXRjaC1ibG9ja1wiLFxuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LiRzY29wZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuJHNjb3BlLmFkZChpZGVudGlmaWVyLm5hbWUsIFwiY2F1Z2h0XCIsIGlkZW50aWZpZXIsIG51bGwpO1xuXG4gICAgICAgIC8vIEFsbCBob2lzdC1zY29wZSBrZWVwcyB0cmFjayBvZiB3aGljaCB2YXJpYWJsZXMgdGhhdCBhcmUgcHJvcGFnYXRlZCB0aHJvdWdoLFxuICAgICAgICAvLyBpLmUuIGFuIHJlZmVyZW5jZSBpbnNpZGUgdGhlIHNjb3BlIHBvaW50cyB0byBhIGRlY2xhcmF0aW9uIG91dHNpZGUgdGhlIHNjb3BlLlxuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gbWFyayBcInRhaW50XCIgdGhlIG5hbWUgc2luY2UgYWRkaW5nIGEgbmV3IHZhcmlhYmxlIGluIHRoZSBzY29wZSxcbiAgICAgICAgLy8gd2l0aCBhIHByb3BhZ2F0ZWQgbmFtZSwgd291bGQgY2hhbmdlIHRoZSBtZWFuaW5nIG9mIHRoZSBleGlzdGluZyByZWZlcmVuY2VzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBjYXRjaChlKSBpcyBzcGVjaWFsIGJlY2F1c2UgZXZlbiB0aG91Z2ggZSBpcyBhIHZhcmlhYmxlIGluIGl0cyBvd24gc2NvcGUsXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgY2F0Y2goZSl7bGV0IGV9IGlzIG5ldmVyIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIGNhdGNoKGUpe3ZhciBlfSAoYnV0IHJhdGhlciB2YXIgZSQwKS4gRm9yIHRoYXQgcmVhc29uIHdlIHRhaW50IHRoZSB1c2Ugb2YgZVxuICAgICAgICAvLyBpbiB0aGUgY2xvc2VzdCBob2lzdC1zY29wZSwgaS5lLiB3aGVyZSB2YXIgZSQwIGJlbG9uZ3MuXG4gICAgICAgIG5vZGUuJHNjb3BlLmNsb3Nlc3RIb2lzdFNjb3BlKCkubWFya1Byb3BhZ2F0ZXMoaWRlbnRpZmllci5uYW1lKTtcblxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlByb2dyYW1cIikge1xuICAgICAgICAvLyBUb3AtbGV2ZWwgcHJvZ3JhbSBpcyBhIHNjb3BlXG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gYmxvY2stc2NvcGUgdW5kZXIgaXRcbiAgICAgICAgbm9kZS4kc2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgICAga2luZDogXCJob2lzdFwiLFxuICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUb3BTY29wZShwcm9ncmFtU2NvcGUpIHtcbiAgICBmdW5jdGlvbiBpbmplY3Qob2JqKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVhYmxlID0gb2JqW25hbWVdO1xuICAgICAgICAgICAgdmFyIGtpbmQgPSAod3JpdGVhYmxlID8gXCJ2YXJcIiA6IFwiY29uc3RcIik7XG4gICAgICAgICAgICBpZiAodG9wU2NvcGUuaGFzT3duKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdG9wU2NvcGUucmVtb3ZlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wU2NvcGUuYWRkKG5hbWUsIGtpbmQsIHtsb2M6IHtzdGFydDoge2xpbmU6IC0xfX19LCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdG9wU2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICBraW5kOiBcImhvaXN0XCIsXG4gICAgICAgIG5vZGU6IHt9LFxuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgfSk7XG5cbiAgICB2YXIgY29tcGxlbWVudGFyeSA9IHtcbiAgICAgICAgdW5kZWZpbmVkOiBmYWxzZSxcbiAgICAgICAgSW5maW5pdHk6IGZhbHNlLFxuICAgICAgICBjb25zb2xlOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgaW5qZWN0KGNvbXBsZW1lbnRhcnkpO1xuLy8gICAgaW5qZWN0KGpzaGludF92YXJzLnJlc2VydmVkVmFycyk7XG4vLyAgICBpbmplY3QoanNoaW50X3ZhcnMuZWNtYUlkZW50aWZpZXJzKTtcblxuICAgIC8vIGxpbmsgaXQgaW5cbiAgICBwcm9ncmFtU2NvcGUucGFyZW50ID0gdG9wU2NvcGU7XG4gICAgdG9wU2NvcGUuY2hpbGRyZW4ucHVzaChwcm9ncmFtU2NvcGUpO1xuXG4gICAgcmV0dXJuIHRvcFNjb3BlO1xufVxuXG5mdW5jdGlvbiBpc0NvbnN0TGV0KGtpbmQpIHtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJjb25zdFwiIHx8IGtpbmQgPT09IFwibGV0XCI7XG59XG5cbmZ1bmN0aW9uIGlzTm9uRnVuY3Rpb25CbG9jayhub2RlLCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgJiYgcGFyZW50LnR5cGUgIT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiICYmIHBhcmVudC50eXBlICE9PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiO1xufVxuXG5mdW5jdGlvbiBpc0ZvcldpdGhDb25zdExldChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJGb3JTdGF0ZW1lbnRcIiAmJiBub2RlLmluaXQgJiYgbm9kZS5pbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIGlzQ29uc3RMZXQobm9kZS5pbml0LmtpbmQpO1xufVxuXG5mdW5jdGlvbiBpc0ZvckluT2ZXaXRoQ29uc3RMZXQobm9kZSkge1xuICAgIHJldHVybiBpc0ZvckluT2Yobm9kZSkgJiYgbm9kZS5sZWZ0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIGlzQ29uc3RMZXQobm9kZS5sZWZ0LmtpbmQpO1xufVxuXG5mdW5jdGlvbiBpc0ZvckluT2Yobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiRm9ySW5TdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiO1xufVxuXG5mdW5jdGlvbiBpc1JlZmVyZW5jZShub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUuJHBhcmVudDtcbiAgICByZXR1cm4gbm9kZS4kcmVmVG9TY29wZSB8fFxuICAgICAgICBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAhKHBhcmVudC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiICYmIHBhcmVudC5pZCA9PT0gbm9kZSkgJiYgLy8gdmFyfGxldHxjb25zdCAkXG4gICAgICAgICAgICAhKHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBwYXJlbnQuY29tcHV0ZWQgPT09IGZhbHNlICYmIHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSkgJiYgLy8gb2JqLiRcbiAgICAgICAgICAgICEocGFyZW50LnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiBwYXJlbnQua2V5ID09PSBub2RlKSAmJiAvLyB7JDogLi4ufVxuICAgICAgICAgICAgIShwYXJlbnQudHlwZSA9PT0gXCJMYWJlbGVkU3RhdGVtZW50XCIgJiYgcGFyZW50LmxhYmVsID09PSBub2RlKSAmJiAvLyAkOiAuLi5cbiAgICAgICAgICAgICEocGFyZW50LnR5cGUgPT09IFwiQ2F0Y2hDbGF1c2VcIiAmJiBwYXJlbnQucGFyYW0gPT09IG5vZGUpICYmIC8vIGNhdGNoKCQpXG4gICAgICAgICAgICAhKGlzRnVuY3Rpb24ocGFyZW50KSAmJiBwYXJlbnQuaWQgPT09IG5vZGUpICYmIC8vIGZ1bmN0aW9uICQoLi5cbiAgICAgICAgICAgICEoaXNGdW5jdGlvbihwYXJlbnQpICYmIGlzLnNvbWVvZihub2RlLCBwYXJlbnQucGFyYW1zKSkgJiYgLy8gZnVuY3Rpb24gZigkKS4uXG4gICAgICAgICAgICB0cnVlO1xufVxuIiwiLy8gb3JkZXJlZC1hc3QtdHJhdmVyc2UuanNcbi8vIE1JVCBsaWNlbnNlZCwgc2VlIExJQ0VOU0UgZmlsZVxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUgT2xvdiBMYXNzdXMgPG9sb3YubGFzc3VzQGdtYWlsLmNvbT5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBwcm9wcyA9IHJlcXVpcmUoXCJvcmRlcmVkLWVzcHJpbWEtcHJvcHNcIik7XG52YXIgbm9Qcm9wcyA9IFtdO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZShyb290LCBvcHRpb25zKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcHJlID0gb3B0aW9ucy5wcmU7XG4gICAgdmFyIHBvc3QgPSBvcHRpb25zLnBvc3Q7XG4gICAgdmFyIHNraXBQcm9wZXJ0eSA9IG9wdGlvbnMuc2tpcFByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gdmlzaXQobm9kZSwgcGFyZW50LCBwcm9wLCBpZHgpIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwcmUpIHtcbiAgICAgICAgICAgIHJlcyA9IHByZShub2RlLCBwYXJlbnQsIHByb3AsIGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVQcm9wcyA9IChwcm9wc1tub2RlLnR5cGVdIHx8IG5vUHJvcHMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBub2RlUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gbm9kZVByb3BzW2lkeF07XG5cbiAgICAgICAgICAgICAgICBpZiAoc2tpcFByb3BlcnR5ICYmIHNraXBQcm9wZXJ0eShwcm9wLCBub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlW3Byb3BdO1xuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gY2hpbGRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdChjLCBub2RlLCBwcm9wLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0KGNoaWxkLCBub2RlLCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zdCkge1xuICAgICAgICAgICAgcG9zdChub2RlLCBwYXJlbnQsIHByb3AsIGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdChyb290LCBudWxsKTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2U7XG59XG4iLCIvLyBvcmRlcmVkLWVzcHJpbWEtcHJvcHMuanNcbi8vIE1JVCBsaWNlbnNlZCwgc2VlIExJQ0VOU0UgZmlsZVxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IE9sb3YgTGFzc3VzIDxvbG92Lmxhc3N1c0BnbWFpbC5jb20+XG5cbi8vIEEgbWFwIGZyb20gdHlwZSAoc3RyaW5nKSB0byBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyAoc3RyaW5ncylcbi8vIGluIGxleGljYWwgb3JkZXIsIGkuZS4gYW4gQVNULXRyYXZlcnNhbCBpbiB0aGlzIG9yZGVyIHdpbGwgdmlzaXRcbi8vIG5vZGVzIGluIGluY3JlYXNpbmcgc291cmNlIGNvZGUgcG9zaXRpb24uXG4vL1xuLy8gVGVzdGVkIHdpdGggRXNwcmltYSBidXQgc2hvdWxkIHdvcmsgZm9yIGFueSBNb3ppbGxhIFBhcnNlciBBUElcbi8vIGNvbXBhdGlibGUgQVNULCBzZWVcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTW96aWxsYS9Qcm9qZWN0cy9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIGlkKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgdmFyIEV4cHJlc3Npb24gPSBpZDtcbiAgICB2YXIgRXhwcmVzc2lvbnMgPSBpZDtcbiAgICB2YXIgU3RhdGVtZW50ID0gaWQ7XG4gICAgdmFyIFN0YXRlbWVudHMgPSBpZDtcbiAgICB2YXIgSWRlbnRpZmllciA9IGlkO1xuICAgIHZhciBJZGVudGlmaWVycyA9IGlkO1xuICAgIHZhciBMdmFsdWUgPSBpZDtcbiAgICB2YXIgQmxvY2tTdGF0ZW1lbnQgPSBpZDtcbiAgICB2YXIgQ2F0Y2hDbGF1c2UgPSBpZDtcbiAgICB2YXIgQ2F0Y2hDbGF1c2VzX3NpbmdsZWFycmF5ID0gaWQ7XG4gICAgdmFyIFZhcmlhYmxlRGVjbGFyYXRpb25PcklkZW50aWZpZXIgPSBpZDtcbiAgICB2YXIgVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbiA9IGlkO1xuICAgIHZhciBWYXJpYWJsZURlY2xhcmF0b3JzID0gaWQ7XG4gICAgdmFyIFByb3BlcnRpZXMgPSBpZDtcbiAgICB2YXIgU3dpdGNoQ2FzZXMgPSBpZDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogW0V4cHJlc3Npb25zKFwiZWxlbWVudHNcIildLFxuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogW0x2YWx1ZShcImxlZnRcIiksIEV4cHJlc3Npb24oXCJyaWdodFwiKV0sXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246IFtFeHByZXNzaW9uKFwibGVmdFwiKSwgRXhwcmVzc2lvbihcInJpZ2h0XCIpXSxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6IFtTdGF0ZW1lbnRzKFwiYm9keVwiKV0sXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiBbSWRlbnRpZmllcihcImxhYmVsXCIpXSxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IFtFeHByZXNzaW9uKFwiY2FsbGVlXCIpLCBFeHByZXNzaW9ucyhcImFyZ3VtZW50c1wiKV0sXG4gICAgICAgIENhdGNoQ2xhdXNlOiBbSWRlbnRpZmllcihcInBhcmFtXCIpLCAvKlwiZ3VhcmRcIiwqLyBCbG9ja1N0YXRlbWVudChcImJvZHlcIildLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IFtFeHByZXNzaW9uKFwidGVzdFwiKSwgRXhwcmVzc2lvbihcImNvbnNlcXVlbnRcIiksIEV4cHJlc3Npb24oXCJhbHRlcm5hdGVcIildLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogW0lkZW50aWZpZXIoXCJsYWJlbFwiKV0sXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogW1N0YXRlbWVudChcImJvZHlcIiksIEV4cHJlc3Npb24oXCJ0ZXN0XCIpXSxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBbRXhwcmVzc2lvbihcImV4cHJlc3Npb25cIildLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogW1ZhcmlhYmxlRGVjbGFyYXRpb25PcklkZW50aWZpZXIoXCJsZWZ0XCIpLCBFeHByZXNzaW9uKFwicmlnaHRcIiksIFN0YXRlbWVudChcImJvZHlcIildLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IFtWYXJpYWJsZURlY2xhcmF0aW9uT3JFeHByZXNzaW9uKFwiaW5pdFwiKSwgRXhwcmVzc2lvbihcInRlc3RcIiksIEV4cHJlc3Npb24oXCJ1cGRhdGVcIiksIFN0YXRlbWVudChcImJvZHlcIildLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBbSWRlbnRpZmllcihcImlkXCIpLCBJZGVudGlmaWVycyhcInBhcmFtc1wiKSwgQmxvY2tTdGF0ZW1lbnQoXCJib2R5XCIpXSxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBbSWRlbnRpZmllcihcImlkXCIpLCBJZGVudGlmaWVycyhcInBhcmFtc1wiKSwgQmxvY2tTdGF0ZW1lbnQoXCJib2R5XCIpXSxcbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbRXhwcmVzc2lvbihcInRlc3RcIiksIFN0YXRlbWVudChcImNvbnNlcXVlbnRcIiksIFN0YXRlbWVudChcImFsdGVybmF0ZVwiKV0sXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IFtJZGVudGlmaWVyKFwibGFiZWxcIiksIFN0YXRlbWVudChcImJvZHlcIildLFxuICAgICAgICBMaXRlcmFsOiBbXSxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IFtFeHByZXNzaW9uKFwibGVmdFwiKSwgRXhwcmVzc2lvbihcInJpZ2h0XCIpXSxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogW0V4cHJlc3Npb24oXCJvYmplY3RcIiksIElkZW50aWZpZXIoXCJwcm9wZXJ0eVwiKV0sXG4gICAgICAgIE5ld0V4cHJlc3Npb246IFtFeHByZXNzaW9uKFwiY2FsbGVlXCIpLCBJZGVudGlmaWVycyhcImFyZ3VtZW50c1wiKV0sXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246IFtQcm9wZXJ0aWVzKFwicHJvcGVydGllc1wiKV0sXG4gICAgICAgIFByb2dyYW06IFtTdGF0ZW1lbnRzKFwiYm9keVwiKV0sXG4gICAgICAgIFByb3BlcnR5OiBbSWRlbnRpZmllcihcImtleVwiKSwgRXhwcmVzc2lvbihcInZhbHVlXCIpXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbRXhwcmVzc2lvbihcImFyZ3VtZW50XCIpXSxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiBbRXhwcmVzc2lvbnMoXCJleHByZXNzaW9uc1wiKV0sXG4gICAgICAgIFN3aXRjaENhc2U6IFtFeHByZXNzaW9uKFwidGVzdFwiKSwgU3RhdGVtZW50cyhcImNvbnNlcXVlbnRcIildLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6IFtFeHByZXNzaW9uKFwiZGlzY3JpbWluYW50XCIpLCBTd2l0Y2hDYXNlcyhcImNhc2VzXCIpXSxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246IFtdLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogW0V4cHJlc3Npb24oXCJhcmd1bWVudFwiKV0sXG4gICAgICAgIFRyeVN0YXRlbWVudDogW0Jsb2NrU3RhdGVtZW50KFwiYmxvY2tcIiksIC8qc3RhbmRhcmQsIGFjb3JuKi8gQ2F0Y2hDbGF1c2UoXCJoYW5kbGVyXCIpLCAvKmVzcHJpbWEqLyBDYXRjaENsYXVzZXNfc2luZ2xlYXJyYXkoXCJoYW5kbGVyc1wiKSwgLypcImd1YXJkZWRIYW5kbGVyc1wiLCovIEJsb2NrU3RhdGVtZW50KFwiZmluYWxpemVyXCIpXSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBbRXhwcmVzc2lvbihcImFyZ3VtZW50XCIpXSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogW0x2YWx1ZShcImFyZ3VtZW50XCIpXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogW1ZhcmlhYmxlRGVjbGFyYXRvcnMoXCJkZWNsYXJhdGlvbnNcIildLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IFtJZGVudGlmaWVyKFwiaWRcIiksIEV4cHJlc3Npb24oXCJpbml0XCIpXSxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IFtFeHByZXNzaW9uKFwidGVzdFwiKSwgU3RhdGVtZW50KFwiYm9keVwiKV0sXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IFtFeHByZXNzaW9uKFwib2JqZWN0XCIpLCBTdGF0ZW1lbnQoXCJib2R5XCIpXSxcbiAgICB9O1xufSkoKTtcbiIsImV4cG9ydHMuZW5kaWFubmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdMRScgfTtcblxuZXhwb3J0cy5ob3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLmxvYWRhdmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnVwdGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy50b3RhbG1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMuY3B1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdCcm93c2VyJyB9O1xuXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlc1xuPSBleHBvcnRzLmdldE5ldHdvcmtJbnRlcmZhY2VzXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XG5cbmV4cG9ydHMuYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdqYXZhc2NyaXB0JyB9O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2Jyb3dzZXInIH07XG5cbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcvdG1wJztcbn07XG5cbmV4cG9ydHMuRU9MID0gJ1xcbic7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gc2ltcGxlLWZtdC5qc1xuLy8gTUlUIGxpY2Vuc2VkLCBzZWUgTElDRU5TRSBmaWxlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgT2xvdiBMYXNzdXMgPG9sb3YubGFzc3VzQGdtYWlsLmNvbT5cblxudmFyIGZtdCA9IChmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIGZtdChzdHIsIHZhcl9hcmdzKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHsoXFxkKylcXH0vZywgZnVuY3Rpb24ocywgbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiAobWF0Y2ggaW4gYXJncyA/IGFyZ3NbbWF0Y2hdIDogcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9iaihzdHIsIG9iaikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xceyhbXyRhLXpBLVowLTldW18kYS16QS1aMC05XSopXFx9L2csIGZ1bmN0aW9uKHMsIG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gKG1hdGNoIGluIG9iaiA/IG9ialttYXRjaF0gOiBzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0ciwgbikge1xuICAgICAgICByZXR1cm4gKG5ldyBBcnJheShuICsgMSkpLmpvaW4oc3RyKTtcbiAgICB9XG5cbiAgICBmbXQuZm10ID0gZm10O1xuICAgIGZtdC5vYmogPSBvYmo7XG4gICAgZm10LnJlcGVhdCA9IHJlcGVhdDtcbiAgICByZXR1cm4gZm10O1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmbXQ7XG59XG4iLCIvLyBzaW1wbGUtaXMuanNcbi8vIE1JVCBsaWNlbnNlZCwgc2VlIExJQ0VOU0UgZmlsZVxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIE9sb3YgTGFzc3VzIDxvbG92Lmxhc3N1c0BnbWFpbC5jb20+XG5cbnZhciBpcyA9IChmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICB2YXIgX3VuZGVmaW5lZCA9IHZvaWQgMDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbjogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHYgIT09IHY7XG4gICAgICAgIH0sXG4gICAgICAgIGJvb2xlYW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCI7XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZm46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9LFxuICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2ICE9PSBudWxsICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiO1xuICAgICAgICB9LFxuICAgICAgICBwcmltaXRpdmU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdHlwZW9mIHY7XG4gICAgICAgICAgICByZXR1cm4gdiA9PT0gbnVsbCB8fCB2ID09PSBfdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdCA9PT0gXCJib29sZWFuXCIgfHwgdCA9PT0gXCJudW1iZXJcIiB8fCB0ID09PSBcInN0cmluZ1wiO1xuICAgICAgICB9LFxuICAgICAgICBhcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pdGVudW1iZXI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgc29tZW9mOiBmdW5jdGlvbih2LCB2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuaW5kZXhPZih2KSA+PSAwO1xuICAgICAgICB9LFxuICAgICAgICBub25lb2Y6IGZ1bmN0aW9uKHYsIHZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKHYpID09PSAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duOiBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaXM7XG59XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbmV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAvL1xuICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAvL1xuICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gIC8vICAgICAgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50LlxuICAvL1xuICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIHJldHVybiBtaWQ7XG4gIH1cbiAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICpcbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKi9cbmV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgLy8gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgc3VjaFxuICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgIGlmIChhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLCBhSGF5c3RhY2tbaW5kZXggLSAxXSwgdHJ1ZSkgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAtLWluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gIH1cbn1cbmV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG52YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgISFhUGF0aC5tYXRjaCh1cmxSZWdleHApO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwiLy8hIHN0YWJsZS5qcyAwLjEuNSwgaHR0cHM6Ly9naXRodWIuY29tL1R3by1TY3JlZW4vc3RhYmxlXG4vLyEgwqkgMjAxNCBBbmdyeSBCeXRlcyBhbmQgY29udHJpYnV0b3JzLiBNSVQgbGljZW5zZWQuXG5cbihmdW5jdGlvbigpIHtcblxuLy8gQSBzdGFibGUgYXJyYXkgc29ydCwgYmVjYXVzZSBgQXJyYXkjc29ydCgpYCBpcyBub3QgZ3VhcmFudGVlZCBzdGFibGUuXG4vLyBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIG1lcmdlIHNvcnQsIHdpdGhvdXQgcmVjdXJzaW9uLlxuXG52YXIgc3RhYmxlID0gZnVuY3Rpb24oYXJyLCBjb21wKSB7XG4gICAgcmV0dXJuIGV4ZWMoYXJyLnNsaWNlKCksIGNvbXApO1xufTtcblxuc3RhYmxlLmlucGxhY2UgPSBmdW5jdGlvbihhcnIsIGNvbXApIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYyhhcnIsIGNvbXApO1xuXG4gICAgLy8gVGhpcyBzaW1wbHkgY29waWVzIGJhY2sgaWYgdGhlIHJlc3VsdCBpc24ndCBpbiB0aGUgb3JpZ2luYWwgYXJyYXksXG4gICAgLy8gd2hpY2ggaGFwcGVucyBvbiBhbiBvZGQgbnVtYmVyIG9mIHBhc3Nlcy5cbiAgICBpZiAocmVzdWx0ICE9PSBhcnIpIHtcbiAgICAgICAgcGFzcyhyZXN1bHQsIG51bGwsIGFyci5sZW5ndGgsIGFycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbi8vIEV4ZWN1dGUgdGhlIHNvcnQgdXNpbmcgdGhlIGlucHV0IGFycmF5IGFuZCBhIHNlY29uZCBidWZmZXIgYXMgd29yayBzcGFjZS5cbi8vIFJldHVybnMgb25lIG9mIHRob3NlIHR3bywgY29udGFpbmluZyB0aGUgZmluYWwgcmVzdWx0LlxuZnVuY3Rpb24gZXhlYyhhcnIsIGNvbXApIHtcbiAgICBpZiAodHlwZW9mKGNvbXApICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbXAgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoYik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2hvcnQtY2lyY3VpdCB3aGVuIHRoZXJlJ3Mgbm90aGluZyB0byBzb3J0LlxuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGlmIChsZW4gPD0gMSkge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIC8vIFJhdGhlciB0aGFuIGRpdmlkaW5nIGlucHV0LCBzaW1wbHkgaXRlcmF0ZSBjaHVua3Mgb2YgMSwgMiwgNCwgOCwgZXRjLlxuICAgIC8vIENodW5rcyBhcmUgdGhlIHNpemUgb2YgdGhlIGxlZnQgb3IgcmlnaHQgaGFuZCBpbiBtZXJnZSBzb3J0LlxuICAgIC8vIFN0b3Agd2hlbiB0aGUgbGVmdC1oYW5kIGNvdmVycyBhbGwgb2YgdGhlIGFycmF5LlxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBjaGsgPSAxOyBjaGsgPCBsZW47IGNoayAqPSAyKSB7XG4gICAgICAgIHBhc3MoYXJyLCBjb21wLCBjaGssIGJ1ZmZlcik7XG5cbiAgICAgICAgdmFyIHRtcCA9IGFycjtcbiAgICAgICAgYXJyID0gYnVmZmVyO1xuICAgICAgICBidWZmZXIgPSB0bXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn1cblxuLy8gUnVuIGEgc2luZ2xlIHBhc3Mgd2l0aCB0aGUgZ2l2ZW4gY2h1bmsgc2l6ZS5cbnZhciBwYXNzID0gZnVuY3Rpb24oYXJyLCBjb21wLCBjaGssIHJlc3VsdCkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICAvLyBTdGVwIHNpemUgLyBkb3VibGUgY2h1bmsgc2l6ZS5cbiAgICB2YXIgZGJsID0gY2hrICogMjtcbiAgICAvLyBCb3VuZHMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IGNodW5rcy5cbiAgICB2YXIgbCwgciwgZTtcbiAgICAvLyBJdGVyYXRvcnMgb3ZlciB0aGUgbGVmdCBhbmQgcmlnaHQgY2h1bmsuXG4gICAgdmFyIGxpLCByaTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBwYWlycyBvZiBjaHVua3MuXG4gICAgZm9yIChsID0gMDsgbCA8IGxlbjsgbCArPSBkYmwpIHtcbiAgICAgICAgciA9IGwgKyBjaGs7XG4gICAgICAgIGUgPSByICsgY2hrO1xuICAgICAgICBpZiAociA+IGxlbikgciA9IGxlbjtcbiAgICAgICAgaWYgKGUgPiBsZW4pIGUgPSBsZW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBib3RoIGNodW5rcyBpbiBwYXJhbGxlbC5cbiAgICAgICAgbGkgPSBsO1xuICAgICAgICByaSA9IHI7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBDb21wYXJlIHRoZSBjaHVua3MuXG4gICAgICAgICAgICBpZiAobGkgPCByICYmIHJpIDwgZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd29ya3MgZm9yIGEgcmVndWxhciBgc29ydCgpYCBjb21wYXRpYmxlIGNvbXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGFsc28gZm9yIGEgc2ltcGxlIGNvbXBhcmF0b3IgbGlrZTogYGEgPiBiYFxuICAgICAgICAgICAgICAgIGlmIChjb21wKGFycltsaV0sIGFycltyaV0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBhcnJbbGkrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGFycltyaSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGNvbXBhcmUsIGp1c3QgZmx1c2ggd2hhdCdzIGxlZnQuXG4gICAgICAgICAgICBlbHNlIGlmIChsaSA8IHIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaSsrXSA9IGFycltsaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJpIDwgZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQm90aCBpdGVyYXRvcnMgYXJlIGF0IHRoZSBjaHVuayBlbmRzLlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBFeHBvcnQgdXNpbmcgQ29tbW9uSlMgb3IgdG8gdGhlIHdpbmRvdy5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0YWJsZTtcbn1cbmVsc2Uge1xuICAgIHdpbmRvdy5zdGFibGUgPSBzdGFibGU7XG59XG5cbn0pKCk7XG4iLCIvLyBzdHJpbmdtYXAuanNcbi8vIE1JVCBsaWNlbnNlZCwgc2VlIExJQ0VOU0UgZmlsZVxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIE9sb3YgTGFzc3VzIDxvbG92Lmxhc3N1c0BnbWFpbC5jb20+XG5cbnZhciBTdHJpbmdNYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyB0byBzYXZlIHVzIGEgZmV3IGNoYXJhY3RlcnNcbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgdmFyIGNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gaGFzT3duRW51bWVyYWJsZVByb3BzKG9iaikge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGRiA8PSAzLjY6XG4gICAgICAgIC8vIG8gPSB7fTsgby5oYXNPd25Qcm9wZXJ0eShcIl9fcHJvdG9fX1wiIG9yIFwiX19jb3VudF9fXCIgb3IgXCJfX3BhcmVudF9fXCIpID0+IHRydWVcbiAgICAgICAgLy8gbyA9IHtcIl9fcHJvdG9fX1wiOiBudWxsfTsgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIFwiX19wcm90b19fXCIgb3IgXCJfX2NvdW50X19cIiBvciBcIl9fcGFyZW50X19cIikgPT4gZmFsc2VcbiAgICAgICAgZnVuY3Rpb24gaGFzT3duUG9sbHV0ZWRQcm9wcyhvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgXCJfX2NvdW50X19cIikgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIFwiX19wYXJlbnRfX1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1c2VPYmplY3RDcmVhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BzKE9iamVjdC5jcmVhdGUobnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgdXNlT2JqZWN0Q3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlT2JqZWN0Q3JlYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wcyh7fSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdNYXAgZW52aXJvbm1lbnQgZXJyb3IgMCwgcGxlYXNlIGZpbGUgYSBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL29sb3Yvc3RyaW5nbWFwL2lzc3Vlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyB0aHJvdyB5ZXQgbWVhbnMgd2UgY2FuIGNyZWF0ZSBvYmplY3RzIHdpdGhvdXQgb3duIGVudW1lcmFibGUgcHJvcHMgKHNhZmUtZ3VhcmQgYWdhaW5zdCBWTXMgYW5kIHNoaW1zKVxuXG4gICAgICAgIHZhciBvID0gKHVzZU9iamVjdENyZWF0ZSA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fSk7XG4gICAgICAgIHZhciB1c2VQcm90b0NsZWFyID0gZmFsc2U7XG4gICAgICAgIGlmIChoYXNPd25Qb2xsdXRlZFByb3BzKG8pKSB7XG4gICAgICAgICAgICBvLl9fcHJvdG9fXyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BzKG8pIHx8IGhhc093blBvbGx1dGVkUHJvcHMobykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdNYXAgZW52aXJvbm1lbnQgZXJyb3IgMSwgcGxlYXNlIGZpbGUgYSBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL29sb3Yvc3RyaW5nbWFwL2lzc3Vlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZVByb3RvQ2xlYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIHRocm93IHlldCBtZWFucyB3ZSBjYW4gY3JlYXRlIG9iamVjdHMgd2l0aG91dCBvd24gcG9sbHV0ZWQgcHJvcHMgKHNhZmUtZ3VhcmQgYWdhaW5zdCBWTXMgYW5kIHNoaW1zKVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvID0gKHVzZU9iamVjdENyZWF0ZSA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fSk7XG4gICAgICAgICAgICBpZiAodXNlUHJvdG9DbGVhcikge1xuICAgICAgICAgICAgICAgIG8uX19wcm90b19fID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvLyBzdHJpbmdtYXAgY3RvclxuICAgIGZ1bmN0aW9uIHN0cmluZ21hcChvcHRpb25hbF9vYmplY3QpIHtcbiAgICAgICAgLy8gdXNlIHdpdGggb3Igd2l0aG91dCBuZXdcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHN0cmluZ21hcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RyaW5nbWFwKG9wdGlvbmFsX29iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYmogPSBjcmVhdGUoKTtcbiAgICAgICAgdGhpcy5oYXNQcm90byA9IGZhbHNlOyAvLyBmYWxzZSAobm8gX19wcm90b19fIGtleSkgb3IgdHJ1ZSAoaGFzIF9fcHJvdG9fXyBrZXkpXG4gICAgICAgIHRoaXMucHJvdG8gPSB1bmRlZmluZWQ7IC8vIHZhbHVlIGZvciBfX3Byb3RvX18ga2V5IHdoZW4gaGFzUHJvdG8gaXMgdHJ1ZSwgdW5kZWZpbmVkIG90aGVyd2lzZVxuXG4gICAgICAgIGlmIChvcHRpb25hbF9vYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWFueShvcHRpb25hbF9vYmplY3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByaW1pdGl2ZSBtZXRob2RzIHRoYXQgZGVhbHMgd2l0aCBkYXRhIHJlcHJlc2VudGF0aW9uXG4gICAgc3RyaW5nbWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy8gVGhlIHR5cGUtY2hlY2sgb2Yga2V5IGluIGhhcywgZ2V0LCBzZXQgYW5kIGRlbGV0ZSBpcyBpbXBvcnRhbnQgYmVjYXVzZSBvdGhlcndpc2UgYW4gb2JqZWN0XG4gICAgICAgIC8vIHt0b1N0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiBcIl9fcHJvdG9fX1wiOyB9fSBjYW4gYXZvaWQgdGhlIGtleSA9PT0gXCJfX3Byb3RvX19cIiB0ZXN0LlxuICAgICAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgdG8gdHlwZS1jaGVja2luZyB3b3VsZCBiZSB0byBmb3JjZSBzdHJpbmcgY29udmVyc2lvbiwgaS5lLiBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZ01hcCBleHBlY3RlZCBzdHJpbmcga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiID9cbiAgICAgICAgICAgIHRoaXMuaGFzUHJvdG8gOlxuICAgICAgICAgICAgaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9iaiwga2V5KSk7XG4gICAgfTtcblxuICAgIHN0cmluZ21hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdNYXAgZXhwZWN0ZWQgc3RyaW5nIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGtleSA9PT0gXCJfX3Byb3RvX19cIiA/XG4gICAgICAgICAgICB0aGlzLnByb3RvIDpcbiAgICAgICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub2JqLCBrZXkpID8gdGhpcy5vYmpba2V5XSA6IHVuZGVmaW5lZCkpO1xuICAgIH07XG5cbiAgICBzdHJpbmdtYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZ01hcCBleHBlY3RlZCBzdHJpbmcga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzUHJvdG8gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm90byA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0cmluZ21hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdNYXAgZXhwZWN0ZWQgc3RyaW5nIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlkRXhpc3QgPSB0aGlzLmhhcyhrZXkpO1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1Byb3RvID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByb3RvID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZEV4aXN0O1xuICAgIH07XG5cbiAgICAvLyBhbGlhcyByZW1vdmUgdG8gZGVsZXRlIGJ1dCBiZXdhcmU6XG4gICAgLy8gc20uZGVsZXRlKFwia2V5XCIpOyAvLyBPSyBpbiBFUzUgYW5kIGxhdGVyXG4gICAgLy8gc21bJ2RlbGV0ZSddKFwia2V5XCIpOyAvLyBPSyBpbiBhbGwgRVMgdmVyc2lvbnNcbiAgICAvLyBzbS5yZW1vdmUoXCJrZXlcIik7IC8vIE9LIGluIGFsbCBFUyB2ZXJzaW9uc1xuICAgIHN0cmluZ21hcC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RyaW5nbWFwLnByb3RvdHlwZS5yZW1vdmU7XG5cbiAgICBzdHJpbmdtYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMub2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMuaGFzUHJvdG87XG4gICAgfTtcblxuICAgIHN0cmluZ21hcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMub2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICsrbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5oYXNQcm90byA/IGxlbiArIDEgOiBsZW4pO1xuICAgIH07XG5cbiAgICBzdHJpbmdtYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMub2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1Byb3RvKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goXCJfX3Byb3RvX19cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIHN0cmluZ21hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMub2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMub2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1Byb3RvKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICBzdHJpbmdtYXAucHJvdG90eXBlLml0ZW1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5vYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChba2V5LCB0aGlzLm9ialtrZXldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzUHJvdG8pIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goW1wiX19wcm90b19fXCIsIHRoaXMucHJvdG9dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfTtcblxuXG4gICAgLy8gbWV0aG9kcyB0aGF0IHJlbHkgb24gdGhlIGFib3ZlIHByaW1pdGl2ZXNcbiAgICBzdHJpbmdtYXAucHJvdG90eXBlLnNldE1hbnkgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqZWN0ICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdNYXAgZXhwZWN0ZWQgT2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBzdHJpbmdtYXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgdmFyIGtleXMgPSBvdGhlci5rZXlzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIG90aGVyLmdldChrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgc3RyaW5nbWFwLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmbikge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAga2V5c1tpXSA9IGZuKHRoaXMuZ2V0KGtleSksIGtleSk7IC8vIHJlLXVzZSBrZXlzIGFycmF5IGZvciByZXN1bHRzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIHN0cmluZ21hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBmbih0aGlzLmdldChrZXkpLCBrZXkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0cmluZ21hcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG90aGVyID0gc3RyaW5nbWFwKCk7XG4gICAgICAgIHJldHVybiBvdGhlci5tZXJnZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgc3RyaW5nbWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBcIntcIiArIHRoaXMua2V5cygpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeShzZWxmLmdldChrZXkpKTtcbiAgICAgICAgfSkuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmluZ21hcDtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gU3RyaW5nTWFwO1xufVxuIiwiLy8gc3RyaW5nc2V0LmpzXG4vLyBNSVQgbGljZW5zZWQsIHNlZSBMSUNFTlNFIGZpbGVcbi8vIENvcHlyaWdodCAoYykgMjAxMyBPbG92IExhc3N1cyA8b2xvdi5sYXNzdXNAZ21haWwuY29tPlxuXG52YXIgU3RyaW5nU2V0ID0gKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gdG8gc2F2ZSB1cyBhIGZldyBjaGFyYWN0ZXJzXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIHZhciBjcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGhhc093bkVudW1lcmFibGVQcm9wcyhvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGRiA8PSAzLjY6XG4gICAgICAgIC8vIG8gPSB7fTsgby5oYXNPd25Qcm9wZXJ0eShcIl9fcHJvdG9fX1wiIG9yIFwiX19jb3VudF9fXCIgb3IgXCJfX3BhcmVudF9fXCIpID0+IHRydWVcbiAgICAgICAgLy8gbyA9IHtcIl9fcHJvdG9fX1wiOiBudWxsfTsgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIFwiX19wcm90b19fXCIgb3IgXCJfX2NvdW50X19cIiBvciBcIl9fcGFyZW50X19cIikgPT4gZmFsc2VcbiAgICAgICAgZnVuY3Rpb24gaGFzT3duUG9sbHV0ZWRQcm9wcyhvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgXCJfX2NvdW50X19cIikgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIFwiX19wYXJlbnRfX1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1c2VPYmplY3RDcmVhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BzKE9iamVjdC5jcmVhdGUobnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgdXNlT2JqZWN0Q3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlT2JqZWN0Q3JlYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wcyh7fSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdTZXQgZW52aXJvbm1lbnQgZXJyb3IgMCwgcGxlYXNlIGZpbGUgYSBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL29sb3Yvc3RyaW5nc2V0L2lzc3Vlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBubyB0aHJvdyB5ZXQgbWVhbnMgd2UgY2FuIGNyZWF0ZSBvYmplY3RzIHdpdGhvdXQgb3duIGVudW1lcmFibGUgcHJvcHMgKHNhZmUtZ3VhcmQgYWdhaW5zdCBWTXMgYW5kIHNoaW1zKVxuXG4gICAgICAgIHZhciBvID0gKHVzZU9iamVjdENyZWF0ZSA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fSk7XG4gICAgICAgIHZhciB1c2VQcm90b0NsZWFyID0gZmFsc2U7XG4gICAgICAgIGlmIChoYXNPd25Qb2xsdXRlZFByb3BzKG8pKSB7XG4gICAgICAgICAgICBvLl9fcHJvdG9fXyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BzKG8pIHx8IGhhc093blBvbGx1dGVkUHJvcHMobykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmdTZXQgZW52aXJvbm1lbnQgZXJyb3IgMSwgcGxlYXNlIGZpbGUgYSBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL29sb3Yvc3RyaW5nc2V0L2lzc3Vlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZVByb3RvQ2xlYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIHRocm93IHlldCBtZWFucyB3ZSBjYW4gY3JlYXRlIG9iamVjdHMgd2l0aG91dCBvd24gcG9sbHV0ZWQgcHJvcHMgKHNhZmUtZ3VhcmQgYWdhaW5zdCBWTXMgYW5kIHNoaW1zKVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvID0gKHVzZU9iamVjdENyZWF0ZSA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fSk7XG4gICAgICAgICAgICBpZiAodXNlUHJvdG9DbGVhcikge1xuICAgICAgICAgICAgICAgIG8uX19wcm90b19fID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvLyBzdHJpbmdzZXQgY3RvclxuICAgIGZ1bmN0aW9uIHN0cmluZ3NldChvcHRpb25hbF9hcnJheSkge1xuICAgICAgICAvLyB1c2Ugd2l0aCBvciB3aXRob3V0IG5ld1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2Ygc3RyaW5nc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJpbmdzZXQob3B0aW9uYWxfYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JqID0gY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuaGFzUHJvdG8gPSBmYWxzZTsgLy8gZmFsc2UgKG5vIF9fcHJvdG9fXyBpdGVtKSBvciB0cnVlIChoYXMgX19wcm90b19fIGl0ZW0pXG5cbiAgICAgICAgaWYgKG9wdGlvbmFsX2FycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hbnkob3B0aW9uYWxfYXJyYXkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByaW1pdGl2ZSBtZXRob2RzIHRoYXQgZGVhbHMgd2l0aCBkYXRhIHJlcHJlc2VudGF0aW9uXG4gICAgc3RyaW5nc2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIC8vIFRoZSB0eXBlLWNoZWNrIG9mIGl0ZW0gaW4gaGFzLCBnZXQsIHNldCBhbmQgZGVsZXRlIGlzIGltcG9ydGFudCBiZWNhdXNlIG90aGVyd2lzZSBhbiBvYmplY3RcbiAgICAgICAgLy8ge3RvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiX19wcm90b19fXCI7IH19IGNhbiBhdm9pZCB0aGUgaXRlbSA9PT0gXCJfX3Byb3RvX19cIiB0ZXN0LlxuICAgICAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgdG8gdHlwZS1jaGVja2luZyB3b3VsZCBiZSB0byBmb3JjZSBzdHJpbmcgY29udmVyc2lvbiwgaS5lLiBpdGVtID0gU3RyaW5nKGl0ZW0pO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZ1NldCBleHBlY3RlZCBzdHJpbmcgaXRlbVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGl0ZW0gPT09IFwiX19wcm90b19fXCIgP1xuICAgICAgICAgICAgdGhpcy5oYXNQcm90byA6XG4gICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub2JqLCBpdGVtKSk7XG4gICAgfTtcblxuICAgIHN0cmluZ3NldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZ1NldCBleHBlY3RlZCBzdHJpbmcgaXRlbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgICAgICAgdGhpcy5oYXNQcm90byA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ialtpdGVtXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RyaW5nc2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nU2V0IGV4cGVjdGVkIHN0cmluZyBpdGVtXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWRFeGlzdCA9IHRoaXMuaGFzKGl0ZW0pO1xuICAgICAgICBpZiAoaXRlbSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgICAgICAgdGhpcy5oYXNQcm90byA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub2JqW2l0ZW1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWRFeGlzdDtcbiAgICB9O1xuXG4gICAgLy8gYWxpYXMgcmVtb3ZlIHRvIGRlbGV0ZSBidXQgYmV3YXJlOlxuICAgIC8vIHNzLmRlbGV0ZShcImtleVwiKTsgLy8gT0sgaW4gRVM1IGFuZCBsYXRlclxuICAgIC8vIHNzWydkZWxldGUnXShcImtleVwiKTsgLy8gT0sgaW4gYWxsIEVTIHZlcnNpb25zXG4gICAgLy8gc3MucmVtb3ZlKFwia2V5XCIpOyAvLyBPSyBpbiBhbGwgRVMgdmVyc2lvbnNcbiAgICBzdHJpbmdzZXQucHJvdG90eXBlWydkZWxldGUnXSA9IHN0cmluZ3NldC5wcm90b3R5cGUucmVtb3ZlO1xuXG4gICAgc3RyaW5nc2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGl0ZW0gaW4gdGhpcy5vYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub2JqLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMuaGFzUHJvdG87XG4gICAgfTtcblxuICAgIHN0cmluZ3NldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaXRlbSBpbiB0aGlzLm9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodGhpcy5vYmosIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgKytsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc1Byb3RvID8gbGVuICsgMSA6IGxlbik7XG4gICAgfTtcblxuICAgIHN0cmluZ3NldC5wcm90b3R5cGUuaXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGl0ZW0gaW4gdGhpcy5vYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub2JqLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzUHJvdG8pIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goXCJfX3Byb3RvX19cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH07XG5cblxuICAgIC8vIG1ldGhvZHMgdGhhdCByZWx5IG9uIHRoZSBhYm92ZSBwcmltaXRpdmVzXG4gICAgc3RyaW5nc2V0LnByb3RvdHlwZS5hZGRNYW55ID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nU2V0IGV4cGVjdGVkIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgc3RyaW5nc2V0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYWRkTWFueShvdGhlci5pdGVtcygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHN0cmluZ3NldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG90aGVyID0gc3RyaW5nc2V0KCk7XG4gICAgICAgIHJldHVybiBvdGhlci5tZXJnZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgc3RyaW5nc2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyB0aGlzLml0ZW1zKCkubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5nc2V0O1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdTZXQ7XG59XG4iLCIvKlxuICogIFN1Z2FyIExpYnJhcnkgdjEuNC4xXG4gKlxuICogIEZyZWVseSBkaXN0cmlidXRhYmxlIGFuZCBsaWNlbnNlZCB1bmRlciB0aGUgTUlULXN0eWxlIGxpY2Vuc2UuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDEzIEFuZHJldyBQbHVtbWVyXG4gKiAgaHR0cDovL3N1Z2FyanMuY29tL1xuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbihmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqKlxuICAgKiBAcGFja2FnZSBDb3JlXG4gICAqIEBkZXNjcmlwdGlvbiBJbnRlcm5hbCB1dGlsaXR5IGFuZCBjb21tb24gbWV0aG9kcy5cbiAgICoqKi9cblxuXG4gIC8vIEEgZmV3IG9wdGltaXphdGlvbnMgZm9yIEdvb2dsZSBDbG9zdXJlIENvbXBpbGVyIHdpbGwgc2F2ZSB1cyBhIGNvdXBsZSBrYiBpbiB0aGUgcmVsZWFzZSBzY3JpcHQuXG4gIHZhciBvYmplY3QgPSBPYmplY3QsIGFycmF5ID0gQXJyYXksIHJlZ2V4cCA9IFJlZ0V4cCwgZGF0ZSA9IERhdGUsIHN0cmluZyA9IFN0cmluZywgbnVtYmVyID0gTnVtYmVyLCBtYXRoID0gTWF0aCwgVW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBnbG9iYWwgY29udGV4dFxuICB2YXIgZ2xvYmFsQ29udGV4dCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdGhpcztcblxuICAvLyBJbnRlcm5hbCB0b1N0cmluZ1xuICB2YXIgaW50ZXJuYWxUb1N0cmluZyA9IG9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgLy8gSW50ZXJuYWwgaGFzT3duUHJvcGVydHlcbiAgdmFyIGludGVybmFsSGFzT3duUHJvcGVydHkgPSBvYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIC8vIGRlZmluZVByb3BlcnR5IGV4aXN0cyBpbiBJRTggYnV0IHdpbGwgZXJyb3Igd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgcHJvcGVydHkgb25cbiAgLy8gbmF0aXZlIG9iamVjdHMuIElFOCBkb2VzIG5vdCBoYXZlIGRlZmluZVByb3BlcmllcywgaG93ZXZlciwgc28gdGhpcyBjaGVjayBzYXZlcyBhIHRyeS9jYXRjaCBibG9jay5cbiAgdmFyIGRlZmluZVByb3BlcnR5U3VwcG9ydCA9IG9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBvYmplY3QuZGVmaW5lUHJvcGVydGllcztcblxuICAvLyBBcmUgcmVnZXhlcyB0eXBlIGZ1bmN0aW9uP1xuICB2YXIgcmVnZXhJc0Z1bmN0aW9uID0gdHlwZW9mIHJlZ2V4cCgpID09PSAnZnVuY3Rpb24nO1xuXG4gIC8vIERvIHN0cmluZ3MgaGF2ZSBubyBrZXlzP1xuICB2YXIgbm9LZXlzSW5TdHJpbmdPYmplY3RzID0gISgnMCcgaW4gbmV3IHN0cmluZygnYScpKTtcblxuICAvLyBUeXBlIGNoZWNrIG1ldGhvZHMgbmVlZCBhIHdheSB0byBiZSBhY2Nlc3NlZCBkeW5hbWljYWxseS5cbiAgdmFyIHR5cGVDaGVja3MgPSB7fTtcblxuICAvLyBDbGFzc2VzIHRoYXQgY2FuIGJlIG1hdGNoZWQgYnkgdmFsdWVcbiAgdmFyIG1hdGNoZWRCeVZhbHVlUmVnID0gL15cXFtvYmplY3QgRGF0ZXxBcnJheXxTdHJpbmd8TnVtYmVyfFJlZ0V4cHxCb29sZWFufEFyZ3VtZW50c1xcXSQvO1xuXG4gIC8vIENsYXNzIGluaXRpYWxpemVycyBhbmQgY2xhc3MgaGVscGVyc1xuICB2YXIgQ2xhc3NOYW1lcyA9ICdCb29sZWFuLE51bWJlcixTdHJpbmcsQXJyYXksRGF0ZSxSZWdFeHAsRnVuY3Rpb24nLnNwbGl0KCcsJyk7XG5cbiAgdmFyIGlzQm9vbGVhbiAgPSBidWlsZFByaW1pdGl2ZUNsYXNzQ2hlY2soJ2Jvb2xlYW4nLCBDbGFzc05hbWVzWzBdKTtcbiAgdmFyIGlzTnVtYmVyICAgPSBidWlsZFByaW1pdGl2ZUNsYXNzQ2hlY2soJ251bWJlcicsICBDbGFzc05hbWVzWzFdKTtcbiAgdmFyIGlzU3RyaW5nICAgPSBidWlsZFByaW1pdGl2ZUNsYXNzQ2hlY2soJ3N0cmluZycsICBDbGFzc05hbWVzWzJdKTtcblxuICB2YXIgaXNBcnJheSAgICA9IGJ1aWxkQ2xhc3NDaGVjayhDbGFzc05hbWVzWzNdKTtcbiAgdmFyIGlzRGF0ZSAgICAgPSBidWlsZENsYXNzQ2hlY2soQ2xhc3NOYW1lc1s0XSk7XG4gIHZhciBpc1JlZ0V4cCAgID0gYnVpbGRDbGFzc0NoZWNrKENsYXNzTmFtZXNbNV0pO1xuXG5cbiAgLy8gV2FudGVkIHRvIGVuaGFuY2UgcGVyZm9ybWFuY2UgaGVyZSBieSB1c2luZyBzaW1wbHkgXCJ0eXBlb2ZcIlxuICAvLyBidXQgRmlyZWZveCBoYXMgdHdvIG1ham9yIGlzc3VlcyB0aGF0IG1ha2UgdGhpcyBpbXBvc3NpYmxlLFxuICAvLyBvbmUgZml4ZWQsIHRoZSBvdGhlciBub3QuIERlc3BpdGUgYmVpbmcgdHlwZW9mIFwiZnVuY3Rpb25cIlxuICAvLyB0aGUgb2JqZWN0cyBiZWxvdyBzdGlsbCByZXBvcnQgaW4gYXMgW29iamVjdCBGdW5jdGlvbl0sIHNvXG4gIC8vIHdlIG5lZWQgdG8gcGVyZm9ybSBhIGZ1bGwgY2xhc3MgY2hlY2sgaGVyZS5cbiAgLy9cbiAgLy8gMS4gUmVnZXhlcyBjYW4gYmUgdHlwZW9mIFwiZnVuY3Rpb25cIiBpbiBGRiA8IDNcbiAgLy8gICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjE5MTEgKGZpeGVkKVxuICAvL1xuICAvLyAyLiBIVE1MRW1iZWRFbGVtZW50IGFuZCBIVE1MT2JqZWN0RWxlbWVudCBhcmUgYmUgdHlwZW9mIFwiZnVuY3Rpb25cIlxuICAvLyAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yNjg5NDUgKHdvbid0IGZpeClcbiAgLy9cbiAgdmFyIGlzRnVuY3Rpb24gPSBidWlsZENsYXNzQ2hlY2soQ2xhc3NOYW1lc1s2XSk7XG5cbiAgZnVuY3Rpb24gaXNDbGFzcyhvYmosIGtsYXNzLCBjYWNoZWQpIHtcbiAgICB2YXIgayA9IGNhY2hlZCB8fCBjbGFzc05hbWUob2JqKTtcbiAgICByZXR1cm4gayA9PT0gJ1tvYmplY3QgJytrbGFzcysnXSc7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENsYXNzQ2hlY2soa2xhc3MpIHtcbiAgICB2YXIgZm4gPSAoa2xhc3MgPT09ICdBcnJheScgJiYgYXJyYXkuaXNBcnJheSkgfHwgZnVuY3Rpb24ob2JqLCBjYWNoZWQpIHtcbiAgICAgIHJldHVybiBpc0NsYXNzKG9iaiwga2xhc3MsIGNhY2hlZCk7XG4gICAgfTtcbiAgICB0eXBlQ2hlY2tzW2tsYXNzXSA9IGZuO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkUHJpbWl0aXZlQ2xhc3NDaGVjayh0eXBlLCBrbGFzcykge1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYoaXNPYmplY3RUeXBlKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGlzQ2xhc3Mob2JqLCBrbGFzcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gdHlwZTtcbiAgICB9XG4gICAgdHlwZUNoZWNrc1trbGFzc10gPSBmbjtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc05hbWUob2JqKSB7XG4gICAgcmV0dXJuIGludGVybmFsVG9TdHJpbmcuY2FsbChvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZUNsYXNzZXMoKSB7XG4gICAgaW5pdGlhbGl6ZUNsYXNzKG9iamVjdCk7XG4gICAgaXRlcmF0ZU92ZXJPYmplY3QoQ2xhc3NOYW1lcywgZnVuY3Rpb24oaSxuYW1lKSB7XG4gICAgICBpbml0aWFsaXplQ2xhc3MoZ2xvYmFsQ29udGV4dFtuYW1lXSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3Moa2xhc3MpIHtcbiAgICBpZihrbGFzc1snU3VnYXJNZXRob2RzJ10pIHJldHVybjtcbiAgICBkZWZpbmVQcm9wZXJ0eShrbGFzcywgJ1N1Z2FyTWV0aG9kcycsIHt9KTtcbiAgICBleHRlbmQoa2xhc3MsIGZhbHNlLCB0cnVlLCB7XG4gICAgICAnZXh0ZW5kJzogZnVuY3Rpb24obWV0aG9kcywgb3ZlcnJpZGUsIGluc3RhbmNlKSB7XG4gICAgICAgIGV4dGVuZChrbGFzcywgaW5zdGFuY2UgIT09IGZhbHNlLCBvdmVycmlkZSwgbWV0aG9kcyk7XG4gICAgICB9LFxuICAgICAgJ3N1Z2FyUmVzdG9yZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmF0Y2hNZXRob2RFeGVjdXRlKHRoaXMsIGtsYXNzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgbSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgbS5tZXRob2QpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAnc3VnYXJSZXZlcnQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJhdGNoTWV0aG9kRXhlY3V0ZSh0aGlzLCBrbGFzcywgYXJndW1lbnRzLCBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIG0pIHtcbiAgICAgICAgICBpZihtWydleGlzdGVkJ10pIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgbVsnb3JpZ2luYWwnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIENsYXNzIGV4dGVuZGluZyBtZXRob2RzXG5cbiAgZnVuY3Rpb24gZXh0ZW5kKGtsYXNzLCBpbnN0YW5jZSwgb3ZlcnJpZGUsIG1ldGhvZHMpIHtcbiAgICB2YXIgZXh0ZW5kZWUgPSBpbnN0YW5jZSA/IGtsYXNzLnByb3RvdHlwZSA6IGtsYXNzO1xuICAgIGluaXRpYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgaXRlcmF0ZU92ZXJPYmplY3QobWV0aG9kcywgZnVuY3Rpb24obmFtZSwgZXh0ZW5kZWRGbikge1xuICAgICAgdmFyIG5hdGl2ZUZuID0gZXh0ZW5kZWVbbmFtZV0sXG4gICAgICAgICAgZXhpc3RlZCAgPSBoYXNPd25Qcm9wZXJ0eShleHRlbmRlZSwgbmFtZSk7XG4gICAgICBpZihpc0Z1bmN0aW9uKG92ZXJyaWRlKSAmJiBuYXRpdmVGbikge1xuICAgICAgICBleHRlbmRlZEZuID0gd3JhcE5hdGl2ZShuYXRpdmVGbiwgZXh0ZW5kZWRGbiwgb3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgaWYob3ZlcnJpZGUgIT09IGZhbHNlIHx8ICFuYXRpdmVGbikge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShleHRlbmRlZSwgbmFtZSwgZXh0ZW5kZWRGbik7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgbWV0aG9kIGlzIGludGVybmFsIHRvIFN1Z2FyLCB0aGVuXG4gICAgICAvLyBzdG9yZSBhIHJlZmVyZW5jZSBzbyBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXIuXG4gICAgICBrbGFzc1snU3VnYXJNZXRob2RzJ11bbmFtZV0gPSB7XG4gICAgICAgICdtZXRob2QnOiAgIGV4dGVuZGVkRm4sXG4gICAgICAgICdleGlzdGVkJzogIGV4aXN0ZWQsXG4gICAgICAgICdvcmlnaW5hbCc6IG5hdGl2ZUZuLFxuICAgICAgICAnaW5zdGFuY2UnOiBpbnN0YW5jZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFNpbWlsYXIoa2xhc3MsIGluc3RhbmNlLCBvdmVycmlkZSwgc2V0LCBmbikge1xuICAgIHZhciBtZXRob2RzID0ge307XG4gICAgc2V0ID0gaXNTdHJpbmcoc2V0KSA/IHNldC5zcGxpdCgnLCcpIDogc2V0O1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICAgIGZuKG1ldGhvZHMsIG5hbWUsIGkpO1xuICAgIH0pO1xuICAgIGV4dGVuZChrbGFzcywgaW5zdGFuY2UsIG92ZXJyaWRlLCBtZXRob2RzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhdGNoTWV0aG9kRXhlY3V0ZSh0YXJnZXQsIGtsYXNzLCBhcmdzLCBmbikge1xuICAgIHZhciBhbGwgPSBhcmdzLmxlbmd0aCA9PT0gMCwgbWV0aG9kcyA9IG11bHRpQXJncyhhcmdzKSwgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGl0ZXJhdGVPdmVyT2JqZWN0KGtsYXNzWydTdWdhck1ldGhvZHMnXSwgZnVuY3Rpb24obmFtZSwgbSkge1xuICAgICAgaWYoYWxsIHx8IG1ldGhvZHMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGZuKG1bJ2luc3RhbmNlJ10gPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0LCBuYW1lLCBtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBOYXRpdmUobmF0aXZlRm4sIGV4dGVuZGVkRm4sIGNvbmRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gY29uZGl0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgP1xuICAgICAgICAgICAgIGV4dGVuZGVkRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6XG4gICAgICAgICAgICAgbmF0aXZlRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIG1ldGhvZCkge1xuICAgIGlmKGRlZmluZVByb3BlcnR5U3VwcG9ydCkge1xuICAgICAgb2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICAndmFsdWUnOiBtZXRob2QsXG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W25hbWVdID0gbWV0aG9kO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gQXJndW1lbnQgaGVscGVyc1xuXG4gIGZ1bmN0aW9uIG11bHRpQXJncyhhcmdzLCBmbiwgZnJvbSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgaSA9IGZyb20gfHwgMCwgbGVuO1xuICAgIGZvcihsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChhcmdzW2ldKTtcbiAgICAgIGlmKGZuKSBmbi5jYWxsKGFyZ3MsIGFyZ3NbaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZmxhdHRlbmVkQXJncyhhcmdzLCBmbiwgZnJvbSkge1xuICAgIHZhciBhcmcgPSBhcmdzW2Zyb20gfHwgMF07XG4gICAgaWYoaXNBcnJheShhcmcpKSB7XG4gICAgICBhcmdzID0gYXJnO1xuICAgICAgZnJvbSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtdWx0aUFyZ3MoYXJncywgZm4sIGZyb20pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDYWxsYmFjayhmbikge1xuICAgIGlmKCFmbiB8fCAhZm4uY2FsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FsbGJhY2sgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBHZW5lcmFsIGhlbHBlcnNcblxuICBmdW5jdGlvbiBpc0RlZmluZWQobykge1xuICAgIHJldHVybiBvICE9PSBVbmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvKSB7XG4gICAgcmV0dXJuIG8gPT09IFVuZGVmaW5lZDtcbiAgfVxuXG5cbiAgLy8gT2JqZWN0IGhlbHBlcnNcblxuICBmdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgICByZXR1cm4gIWlzUHJpbWl0aXZlVHlwZShvYmopICYmIHByb3AgaW4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIGludGVybmFsSGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPYmplY3RUeXBlKG9iaikge1xuICAgIC8vIDEuIENoZWNrIGZvciBudWxsXG4gICAgLy8gMi4gQ2hlY2sgZm9yIHJlZ2V4ZXMgaW4gZW52aXJvbm1lbnRzIHdoZXJlIHRoZXkgYXJlIFwiZnVuY3Rpb25zXCIuXG4gICAgcmV0dXJuICEhb2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCAocmVnZXhJc0Z1bmN0aW9uICYmIGlzUmVnRXhwKG9iaikpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZShvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqLCBrbGFzcykge1xuICAgIGtsYXNzID0ga2xhc3MgfHwgY2xhc3NOYW1lKG9iaik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3RcbiAgICAgIC8vIFRoaXMgY29kZSB3YXMgYm9ycm93ZWQgZnJvbSBqUXVlcnkuaXNQbGFpbk9iamVjdFxuICAgICAgaWYgKG9iaiAmJiBvYmouY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICFoYXNPd25Qcm9wZXJ0eShvYmosICdjb25zdHJ1Y3RvcicpICYmXG4gICAgICAgICAgICAhaGFzT3duUHJvcGVydHkob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyA9PT0gb24gdGhlIGNvbnN0cnVjdG9yIGlzIG5vdCBzYWZlIGFjcm9zcyBpZnJhbWVzXG4gICAgLy8gJ2hhc093blByb3BlcnR5JyBlbnN1cmVzIHRoYXQgdGhlIG9iamVjdCBhbHNvIGluaGVyaXRzXG4gICAgLy8gZnJvbSBPYmplY3QsIHdoaWNoIGlzIGZhbHNlIGZvciBET01FbGVtZW50cyBpbiBJRS5cbiAgICByZXR1cm4gISFvYmogJiYga2xhc3MgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmICdoYXNPd25Qcm9wZXJ0eScgaW4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZU92ZXJPYmplY3Qob2JqLCBmbikge1xuICAgIHZhciBrZXk7XG4gICAgZm9yKGtleSBpbiBvYmopIHtcbiAgICAgIGlmKCFoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkpIGNvbnRpbnVlO1xuICAgICAgaWYoZm4uY2FsbChvYmosIGtleSwgb2JqW2tleV0sIG9iaikgPT09IGZhbHNlKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVSZXBlYXQobiwgZm4pIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBmbihpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGl0ZXJhdGVPdmVyT2JqZWN0KHNvdXJjZSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAgLy8gTWFrZSBwcmltdGl2ZXMgdHlwZXMgbGlrZSBzdHJpbmdzIGludG8gb2JqZWN0cy5cbiAgIGZ1bmN0aW9uIGNvZXJjZVByaW1pdGl2ZVRvT2JqZWN0KG9iaikge1xuICAgICBpZihpc1ByaW1pdGl2ZVR5cGUob2JqKSkge1xuICAgICAgIG9iaiA9IG9iamVjdChvYmopO1xuICAgICB9XG4gICAgIGlmKG5vS2V5c0luU3RyaW5nT2JqZWN0cyAmJiBpc1N0cmluZyhvYmopKSB7XG4gICAgICAgZm9yY2VTdHJpbmdDb2VyY2lvbihvYmopO1xuICAgICB9XG4gICAgIHJldHVybiBvYmo7XG4gICB9XG5cbiAgIC8vIEZvcmNlIHN0cmluZ3MgdG8gaGF2ZSB0aGVpciBpbmRleGVzIHNldCBpblxuICAgLy8gZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5LlxuICAgZnVuY3Rpb24gZm9yY2VTdHJpbmdDb2VyY2lvbihvYmopIHtcbiAgICAgdmFyIGkgPSAwLCBjaHI7XG4gICAgIHdoaWxlKGNociA9IG9iai5jaGFyQXQoaSkpIHtcbiAgICAgICBvYmpbaSsrXSA9IGNocjtcbiAgICAgfVxuICAgfVxuXG4gIC8vIEhhc2ggZGVmaW5pdGlvblxuXG4gIGZ1bmN0aW9uIEhhc2gob2JqKSB7XG4gICAgc2ltcGxlTWVyZ2UodGhpcywgY29lcmNlUHJpbWl0aXZlVG9PYmplY3Qob2JqKSk7XG4gIH07XG5cbiAgSGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvYmplY3Q7XG5cbiAgLy8gTWF0aCBoZWxwZXJzXG5cbiAgdmFyIGFicyAgID0gbWF0aC5hYnM7XG4gIHZhciBwb3cgICA9IG1hdGgucG93O1xuICB2YXIgY2VpbCAgPSBtYXRoLmNlaWw7XG4gIHZhciBmbG9vciA9IG1hdGguZmxvb3I7XG4gIHZhciByb3VuZCA9IG1hdGgucm91bmQ7XG4gIHZhciBtaW4gICA9IG1hdGgubWluO1xuICB2YXIgbWF4ICAgPSBtYXRoLm1heDtcblxuICBmdW5jdGlvbiB3aXRoUHJlY2lzaW9uKHZhbCwgcHJlY2lzaW9uLCBmbikge1xuICAgIHZhciBtdWx0aXBsaWVyID0gcG93KDEwLCBhYnMocHJlY2lzaW9uIHx8IDApKTtcbiAgICBmbiA9IGZuIHx8IHJvdW5kO1xuICAgIGlmKHByZWNpc2lvbiA8IDApIG11bHRpcGxpZXIgPSAxIC8gbXVsdGlwbGllcjtcbiAgICByZXR1cm4gZm4odmFsICogbXVsdGlwbGllcikgLyBtdWx0aXBsaWVyO1xuICB9XG5cbiAgLy8gRnVsbCB3aWR0aCBudW1iZXIgaGVscGVyc1xuXG4gIHZhciBIYWxmV2lkdGhaZXJvQ29kZSA9IDB4MzA7XG4gIHZhciBIYWxmV2lkdGhOaW5lQ29kZSA9IDB4Mzk7XG4gIHZhciBGdWxsV2lkdGhaZXJvQ29kZSA9IDB4ZmYxMDtcbiAgdmFyIEZ1bGxXaWR0aE5pbmVDb2RlID0gMHhmZjE5O1xuXG4gIHZhciBIYWxmV2lkdGhQZXJpb2QgPSAnLic7XG4gIHZhciBGdWxsV2lkdGhQZXJpb2QgPSAn77yOJztcbiAgdmFyIEhhbGZXaWR0aENvbW1hICA9ICcsJztcblxuICAvLyBVc2VkIGhlcmUgYW5kIGxhdGVyIGluIHRoZSBEYXRlIHBhY2thZ2UuXG4gIHZhciBGdWxsV2lkdGhEaWdpdHMgICA9ICcnO1xuXG4gIHZhciBOdW1iZXJOb3JtYWxpemVNYXAgPSB7fTtcbiAgdmFyIE51bWJlck5vcm1hbGl6ZVJlZztcblxuICBmdW5jdGlvbiBjb2RlSXNOdW1lcmFsKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPj0gSGFsZldpZHRoWmVyb0NvZGUgJiYgY29kZSA8PSBIYWxmV2lkdGhOaW5lQ29kZSkgfHxcbiAgICAgICAgICAgKGNvZGUgPj0gRnVsbFdpZHRoWmVyb0NvZGUgJiYgY29kZSA8PSBGdWxsV2lkdGhOaW5lQ29kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZE51bWJlckhlbHBlcnMoKSB7XG4gICAgdmFyIGRpZ2l0LCBpO1xuICAgIGZvcihpID0gMDsgaSA8PSA5OyBpKyspIHtcbiAgICAgIGRpZ2l0ID0gY2hyKGkgKyBGdWxsV2lkdGhaZXJvQ29kZSk7XG4gICAgICBGdWxsV2lkdGhEaWdpdHMgKz0gZGlnaXQ7XG4gICAgICBOdW1iZXJOb3JtYWxpemVNYXBbZGlnaXRdID0gY2hyKGkgKyBIYWxmV2lkdGhaZXJvQ29kZSk7XG4gICAgfVxuICAgIE51bWJlck5vcm1hbGl6ZU1hcFtIYWxmV2lkdGhDb21tYV0gPSAnJztcbiAgICBOdW1iZXJOb3JtYWxpemVNYXBbRnVsbFdpZHRoUGVyaW9kXSA9IEhhbGZXaWR0aFBlcmlvZDtcbiAgICAvLyBNYXBwaW5nIHRoaXMgdG8gaXRzZWxmIHRvIGVhc2lseSBiZSBhYmxlIHRvIGVhc2lseVxuICAgIC8vIGNhcHR1cmUgaXQgaW4gc3RyaW5nVG9OdW1iZXIgdG8gZGV0ZWN0IGRlY2ltYWxzIGxhdGVyLlxuICAgIE51bWJlck5vcm1hbGl6ZU1hcFtIYWxmV2lkdGhQZXJpb2RdID0gSGFsZldpZHRoUGVyaW9kO1xuICAgIE51bWJlck5vcm1hbGl6ZVJlZyA9IHJlZ2V4cCgnWycgKyBGdWxsV2lkdGhEaWdpdHMgKyBGdWxsV2lkdGhQZXJpb2QgKyBIYWxmV2lkdGhDb21tYSArIEhhbGZXaWR0aFBlcmlvZCArICddJywgJ2cnKTtcbiAgfVxuXG4gIC8vIFN0cmluZyBoZWxwZXJzXG5cbiAgZnVuY3Rpb24gY2hyKG51bSkge1xuICAgIHJldHVybiBzdHJpbmcuZnJvbUNoYXJDb2RlKG51bSk7XG4gIH1cblxuICAvLyBXaGl0ZVNwYWNlL0xpbmVUZXJtaW5hdG9yIGFzIGRlZmluZWQgaW4gRVM1LjEgcGx1cyBVbmljb2RlIGNoYXJhY3RlcnMgaW4gdGhlIFNwYWNlLCBTZXBhcmF0b3IgY2F0ZWdvcnkuXG4gIGZ1bmN0aW9uIGdldFRyaW1tYWJsZUNoYXJhY3RlcnMoKSB7XG4gICAgcmV0dXJuICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MjAyOFxcdTIwMjlcXHUzMDAwXFx1RkVGRic7XG4gIH1cblxuICBmdW5jdGlvbiByZXBlYXRTdHJpbmcoc3RyLCBudW0pIHtcbiAgICB2YXIgcmVzdWx0ID0gJycsIHN0ciA9IHN0ci50b1N0cmluZygpO1xuICAgIHdoaWxlIChudW0gPiAwKSB7XG4gICAgICBpZiAobnVtICYgMSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgICAgfVxuICAgICAgaWYgKG51bSA+Pj0gMSkge1xuICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0YWtpbmcgaW50byBhY2NvdW50IGZ1bGwtd2lkdGggY2hhcmFjdGVycywgY29tbWFzLCBhbmQgZGVjaW1hbHMuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvTnVtYmVyKHN0ciwgYmFzZSkge1xuICAgIHZhciBzYW5pdGl6ZWQsIGlzRGVjaW1hbDtcbiAgICBzYW5pdGl6ZWQgPSBzdHIucmVwbGFjZShOdW1iZXJOb3JtYWxpemVSZWcsIGZ1bmN0aW9uKGNocikge1xuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gTnVtYmVyTm9ybWFsaXplTWFwW2Nocl07XG4gICAgICBpZihyZXBsYWNlbWVudCA9PT0gSGFsZldpZHRoUGVyaW9kKSB7XG4gICAgICAgIGlzRGVjaW1hbCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzRGVjaW1hbCA/IHBhcnNlRmxvYXQoc2FuaXRpemVkKSA6IHBhcnNlSW50KHNhbml0aXplZCwgYmFzZSB8fCAxMCk7XG4gIH1cblxuXG4gIC8vIFVzZWQgYnkgTnVtYmVyIGFuZCBEYXRlXG5cbiAgZnVuY3Rpb24gcGFkTnVtYmVyKG51bSwgcGxhY2UsIHNpZ24sIGJhc2UpIHtcbiAgICB2YXIgc3RyID0gYWJzKG51bSkudG9TdHJpbmcoYmFzZSB8fCAxMCk7XG4gICAgc3RyID0gcmVwZWF0U3RyaW5nKCcwJywgcGxhY2UgLSBzdHIucmVwbGFjZSgvXFwuXFxkKy8sICcnKS5sZW5ndGgpICsgc3RyO1xuICAgIGlmKHNpZ24gfHwgbnVtIDwgMCkge1xuICAgICAgc3RyID0gKG51bSA8IDAgPyAnLScgOiAnKycpICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3JkaW5hbGl6ZWRTdWZmaXgobnVtKSB7XG4gICAgaWYobnVtID49IDExICYmIG51bSA8PSAxMykge1xuICAgICAgcmV0dXJuICd0aCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaChudW0gJSAxMCkge1xuICAgICAgICBjYXNlIDE6ICByZXR1cm4gJ3N0JztcbiAgICAgICAgY2FzZSAyOiAgcmV0dXJuICduZCc7XG4gICAgICAgIGNhc2UgMzogIHJldHVybiAncmQnO1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gJ3RoJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8vIFJlZ0V4cCBoZWxwZXJzXG5cbiAgZnVuY3Rpb24gZ2V0UmVnRXhwRmxhZ3MocmVnLCBhZGQpIHtcbiAgICB2YXIgZmxhZ3MgPSAnJztcbiAgICBhZGQgPSBhZGQgfHwgJyc7XG4gICAgZnVuY3Rpb24gY2hlY2tGbGFnKHByb3AsIGZsYWcpIHtcbiAgICAgIGlmKHByb3AgfHwgYWRkLmluZGV4T2YoZmxhZykgPiAtMSkge1xuICAgICAgICBmbGFncyArPSBmbGFnO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ZsYWcocmVnLm11bHRpbGluZSwgJ20nKTtcbiAgICBjaGVja0ZsYWcocmVnLmlnbm9yZUNhc2UsICdpJyk7XG4gICAgY2hlY2tGbGFnKHJlZy5nbG9iYWwsICdnJyk7XG4gICAgY2hlY2tGbGFnKHJlZy5zdGlja3ksICd5Jyk7XG4gICAgcmV0dXJuIGZsYWdzO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIGlmKCFpc1N0cmluZyhzdHIpKSBzdHIgPSBzdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbXFxcXC9cXCcqKz98KClcXFtcXF17fS5eJF0pL2csJ1xcXFwkMScpO1xuICB9XG5cblxuICAvLyBEYXRlIGhlbHBlcnNcblxuICBmdW5jdGlvbiBjYWxsRGF0ZUdldChkLCBtZXRob2QpIHtcbiAgICByZXR1cm4gZFsnZ2V0JyArIChkLl91dGMgPyAnVVRDJyA6ICcnKSArIG1ldGhvZF0oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxEYXRlU2V0KGQsIG1ldGhvZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gZFsnc2V0JyArIChkLl91dGMgJiYgbWV0aG9kICE9ICdJU09XZWVrJyA/ICdVVEMnIDogJycpICsgbWV0aG9kXSh2YWx1ZSk7XG4gIH1cblxuICAvLyBVc2VkIGJ5IEFycmF5I3VuaXF1ZSBhbmQgT2JqZWN0LmVxdWFsXG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KHRoaW5nLCBzdGFjaykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHRoaW5nLFxuICAgICAgICB0aGluZ0lzT2JqZWN0LFxuICAgICAgICB0aGluZ0lzQXJyYXksXG4gICAgICAgIGtsYXNzLCB2YWx1ZSxcbiAgICAgICAgYXJyLCBrZXksIGksIGxlbjtcblxuICAgIC8vIFJldHVybiBxdWlja2x5IGlmIHN0cmluZyB0byBzYXZlIGN5Y2xlc1xuICAgIGlmKHR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gdGhpbmc7XG5cbiAgICBrbGFzcyAgICAgICAgID0gaW50ZXJuYWxUb1N0cmluZy5jYWxsKHRoaW5nKVxuICAgIHRoaW5nSXNPYmplY3QgPSBpc1BsYWluT2JqZWN0KHRoaW5nLCBrbGFzcyk7XG4gICAgdGhpbmdJc0FycmF5ICA9IGlzQXJyYXkodGhpbmcsIGtsYXNzKTtcblxuICAgIGlmKHRoaW5nICE9IG51bGwgJiYgdGhpbmdJc09iamVjdCB8fCB0aGluZ0lzQXJyYXkpIHtcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGZvciBjaGVja2luZyBmb3IgY3ljbGljIHN0cnVjdHVyZXMgd2FzIGVncmVnaW91c2x5IHN0b2xlbiBmcm9tXG4gICAgICAvLyB0aGUgaW5nZW5pb3VzIG1ldGhvZCBieSBAa2l0Y2FtYnJpZGdlIGZyb20gdGhlIFVuZGVyc2NvcmUgc2NyaXB0OlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvY3VtZW50Y2xvdWQvdW5kZXJzY29yZS9pc3N1ZXMvMjQwXG4gICAgICBpZighc3RhY2spIHN0YWNrID0gW107XG4gICAgICAvLyBBbGxvd2luZyBhIHN0ZXAgaW50byB0aGUgc3RydWN0dXJlIGJlZm9yZSB0cmlnZ2VyaW5nIHRoaXNcbiAgICAgIC8vIHNjcmlwdCB0byBzYXZlIGN5Y2xlcyBvbiBzdGFuZGFyZCBKU09OIHN0cnVjdHVyZXMgYW5kIGFsc28gdG9cbiAgICAgIC8vIHRyeSBhcyBoYXJkIGFzIHBvc3NpYmxlIHRvIGNhdGNoIGJhc2ljIHByb3BlcnRpZXMgdGhhdCBtYXkgaGF2ZVxuICAgICAgLy8gYmVlbiBtb2RpZmllZC5cbiAgICAgIGlmKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaSA9IHN0YWNrLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdGhpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ1lDJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2godGhpbmcpO1xuICAgICAgdmFsdWUgPSB0aGluZy52YWx1ZU9mKCkgKyBzdHJpbmcodGhpbmcuY29uc3RydWN0b3IpO1xuICAgICAgYXJyID0gdGhpbmdJc0FycmF5ID8gdGhpbmcgOiBvYmplY3Qua2V5cyh0aGluZykuc29ydCgpO1xuICAgICAgZm9yKGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAga2V5ID0gdGhpbmdJc0FycmF5ID8gaSA6IGFycltpXTtcbiAgICAgICAgdmFsdWUgKz0ga2V5ICsgc3RyaW5naWZ5KHRoaW5nW2tleV0sIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSBpZigxIC8gdGhpbmcgPT09IC1JbmZpbml0eSkge1xuICAgICAgdmFsdWUgPSAnLTAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZyh0aGluZyAmJiB0aGluZy52YWx1ZU9mID8gdGhpbmcudmFsdWVPZigpIDogdGhpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSArIGtsYXNzICsgdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICBpZihhID09PSBiKSB7XG4gICAgICAvLyBSZXR1cm4gcXVpY2tseSB1cCBmcm9udCB3aGVuIG1hdGNoaW5nIGJ5IHJlZmVyZW5jZSxcbiAgICAgIC8vIGJ1dCBiZSBjYXJlZnVsIGFib3V0IDAgIT09IC0wLlxuICAgICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIH0gZWxzZSBpZihvYmplY3RJc01hdGNoZWRCeVZhbHVlKGEpICYmIG9iamVjdElzTWF0Y2hlZEJ5VmFsdWUoYikpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkoYSkgPT09IHN0cmluZ2lmeShiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0SXNNYXRjaGVkQnlWYWx1ZShvYmopIHtcbiAgICAvLyBPbmx5IGtub3duIG9iamVjdHMgYXJlIG1hdGNoZWQgYnkgdmFsdWUuIFRoaXMgaXMgbm90YWJseSBleGNsdWRpbmcgZnVuY3Rpb25zLCBET00gRWxlbWVudHMsIGFuZCBpbnN0YW5jZXMgb2ZcbiAgICAvLyB1c2VyLWNyZWF0ZWQgY2xhc3Nlcy4gVGhlIGxhdHRlciBjYW4gYXJndWFibHkgYmUgbWF0Y2hlZCBieSB2YWx1ZSwgYnV0IGRpc3Rpbmd1aXNoaW5nIGJldHdlZW4gdGhlc2UgYW5kXG4gICAgLy8gaG9zdCBvYmplY3RzIC0tIHdoaWNoIHNob3VsZCBuZXZlciBiZSBjb21wYXJlZCBieSB2YWx1ZSAtLSBpcyB2ZXJ5IHRyaWNreSBzbyBub3QgZGVhbGluZyB3aXRoIGl0IGhlcmUuXG4gICAgdmFyIGtsYXNzID0gY2xhc3NOYW1lKG9iaik7XG4gICAgcmV0dXJuIG1hdGNoZWRCeVZhbHVlUmVnLnRlc3Qoa2xhc3MpIHx8IGlzUGxhaW5PYmplY3Qob2JqLCBrbGFzcyk7XG4gIH1cblxuXG4gIC8vIFVzZWQgYnkgQXJyYXkjYXQgYW5kIFN0cmluZyNhdFxuXG4gIGZ1bmN0aW9uIGdldEVudHJpZXNGb3JJbmRleGVzKG9iaiwgYXJncywgaXNTdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBsZW5ndGggICAgPSBvYmoubGVuZ3RoLFxuICAgICAgICBhcmdzTGVuICAgPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgb3ZlcnNob290ID0gYXJnc1thcmdzTGVuIC0gMV0gIT09IGZhbHNlLFxuICAgICAgICBtdWx0aXBsZSAgPSBhcmdzTGVuID4gKG92ZXJzaG9vdCA/IDEgOiAyKTtcbiAgICBpZighbXVsdGlwbGUpIHtcbiAgICAgIHJldHVybiBlbnRyeUF0SW5kZXgob2JqLCBsZW5ndGgsIGFyZ3NbMF0sIG92ZXJzaG9vdCwgaXNTdHJpbmcpO1xuICAgIH1cbiAgICByZXN1bHQgPSBbXTtcbiAgICBtdWx0aUFyZ3MoYXJncywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmKGlzQm9vbGVhbihpbmRleCkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJlc3VsdC5wdXNoKGVudHJ5QXRJbmRleChvYmosIGxlbmd0aCwgaW5kZXgsIG92ZXJzaG9vdCwgaXNTdHJpbmcpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cnlBdEluZGV4KG9iaiwgbGVuZ3RoLCBpbmRleCwgb3ZlcnNob290LCBpc1N0cmluZykge1xuICAgIGlmKG92ZXJzaG9vdCkge1xuICAgICAgaW5kZXggPSBpbmRleCAlIGxlbmd0aDtcbiAgICAgIGlmKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3RyaW5nID8gb2JqLmNoYXJBdChpbmRleCkgOiBvYmpbaW5kZXhdO1xuICB9XG5cblxuICAvLyBPYmplY3QgY2xhc3MgbWV0aG9kcyBpbXBsZW1lbnRlZCBhcyBpbnN0YW5jZSBtZXRob2RzXG5cbiAgZnVuY3Rpb24gYnVpbGRPYmplY3RJbnN0YW5jZU1ldGhvZHMoc2V0LCB0YXJnZXQpIHtcbiAgICBleHRlbmRTaW1pbGFyKHRhcmdldCwgdHJ1ZSwgZmFsc2UsIHNldCwgZnVuY3Rpb24obWV0aG9kcywgbmFtZSkge1xuICAgICAgbWV0aG9kc1tuYW1lICsgKG5hbWUgPT09ICdlcXVhbCcgPyAncycgOiAnJyldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RbbmFtZV0uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChtdWx0aUFyZ3MoYXJndW1lbnRzKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdGlhbGl6ZUNsYXNzZXMoKTtcbiAgYnVpbGROdW1iZXJIZWxwZXJzKCk7XG5cblxuICAvKioqXG4gICAqIEBwYWNrYWdlIEVTNVxuICAgKiBAZGVzY3JpcHRpb24gU2hpbSBtZXRob2RzIHRoYXQgcHJvdmlkZSBFUzUgY29tcGF0aWJsZSBmdW5jdGlvbmFsaXR5LiBUaGlzIHBhY2thZ2UgY2FuIGJlIGV4Y2x1ZGVkIGlmIHlvdSBkbyBub3QgcmVxdWlyZSBsZWdhY3kgYnJvd3NlciBzdXBwb3J0IChJRTggYW5kIGJlbG93KS5cbiAgICpcbiAgICoqKi9cblxuXG4gIC8qKipcbiAgICogT2JqZWN0IG1vZHVsZVxuICAgKlxuICAgKioqL1xuXG4gIGV4dGVuZChvYmplY3QsIGZhbHNlLCBmYWxzZSwge1xuXG4gICAgJ2tleXMnOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBrZXlzID0gW107XG4gICAgICBpZighaXNPYmplY3RUeXBlKG9iaikgJiYgIWlzUmVnRXhwKG9iaikgJiYgIWlzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgcmVxdWlyZWQnKTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGVPdmVyT2JqZWN0KG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuXG4gIH0pO1xuXG5cbiAgLyoqKlxuICAgKiBBcnJheSBtb2R1bGVcbiAgICpcbiAgICoqKi9cblxuICAvLyBFQ01BNSBtZXRob2RzXG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFyciwgc2VhcmNoLCBmcm9tSW5kZXgsIGluY3JlbWVudCkge1xuICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoLFxuICAgICAgICBmcm9tUmlnaHQgPSBpbmNyZW1lbnQgPT0gLTEsXG4gICAgICAgIHN0YXJ0ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIC0gMSA6IDAsXG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyV2l0aERlZmF1bHQoZnJvbUluZGV4LCBzdGFydCk7XG4gICAgaWYoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIH1cbiAgICBpZigoIWZyb21SaWdodCAmJiBpbmRleCA8IDApIHx8IChmcm9tUmlnaHQgJiYgaW5kZXggPj0gbGVuZ3RoKSkge1xuICAgICAgaW5kZXggPSBzdGFydDtcbiAgICB9XG4gICAgd2hpbGUoKGZyb21SaWdodCAmJiBpbmRleCA+PSAwKSB8fCAoIWZyb21SaWdodCAmJiBpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmKGFycltpbmRleF0gPT09IHNlYXJjaCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpbmNyZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFyciwgZm4sIGluaXRpYWxWYWx1ZSwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsIGNvdW50ID0gMCwgZGVmaW5lZCA9IGlzRGVmaW5lZChpbml0aWFsVmFsdWUpLCByZXN1bHQsIGluZGV4O1xuICAgIGNoZWNrQ2FsbGJhY2soZm4pO1xuICAgIGlmKGxlbmd0aCA9PSAwICYmICFkZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2UgY2FsbGVkIG9uIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH0gZWxzZSBpZihkZWZpbmVkKSB7XG4gICAgICByZXN1bHQgPSBpbml0aWFsVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGFycltmcm9tUmlnaHQgPyBsZW5ndGggLSAxIDogY291bnRdO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgd2hpbGUoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIC0gY291bnQgLSAxIDogY291bnQ7XG4gICAgICBpZihpbmRleCBpbiBhcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gZm4ocmVzdWx0LCBhcnJbaW5kZXhdLCBpbmRleCwgYXJyKTtcbiAgICAgIH1cbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiB0b0ludGVnZXJXaXRoRGVmYXVsdChpLCBkKSB7XG4gICAgaWYoaXNOYU4oaSkpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoaSA+PiAwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZpcnN0QXJndW1lbnRFeGlzdHMoYXJncykge1xuICAgIGlmKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuXG5cblxuICBleHRlbmQoYXJyYXksIGZhbHNlLCBmYWxzZSwge1xuXG4gICAgLyoqKlxuICAgICAqXG4gICAgICogQG1ldGhvZCBBcnJheS5pc0FycmF5KDxvYmo+KVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIDxvYmo+IGlzIGFuIEFycmF5LlxuICAgICAqIEBleHRyYSBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0IGludGVybmFsbHkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgQXJyYXkuaXNBcnJheSgzKSAgICAgICAgLT4gZmFsc2VcbiAgICAgKiAgIEFycmF5LmlzQXJyYXkodHJ1ZSkgICAgIC0+IGZhbHNlXG4gICAgICogICBBcnJheS5pc0FycmF5KCd3YXNhYmknKSAtPiBmYWxzZVxuICAgICAqICAgQXJyYXkuaXNBcnJheShbMSwyLDNdKSAgLT4gdHJ1ZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNBcnJheSc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKTtcbiAgICB9XG5cbiAgfSk7XG5cblxuICBleHRlbmQoYXJyYXksIHRydWUsIGZhbHNlLCB7XG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBldmVyeSg8Zj4sIFtzY29wZV0pXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgYWxsIGVsZW1lbnRzIGluIHRoZSBhcnJheSBtYXRjaCA8Zj4uXG4gICAgICogQGV4dHJhIFtzY29wZV0gaXMgdGhlICV0aGlzJSBvYmplY3QuICVhbGwlIGlzIHByb3ZpZGVkIGFuIGFsaWFzLiBJbiBhZGRpdGlvbiB0byBwcm92aWRpbmcgdGhpcyBtZXRob2QgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdCBuYXRpdmVseSwgdGhpcyBtZXRob2QgYWxzbyBpbXBsZW1lbnRzIEBhcnJheV9tYXRjaGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICsgICBbJ2EnLCdhJywnYSddLmV2ZXJ5KGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG4gPT0gJ2EnO1xuICAgICAqICAgfSk7XG4gICAgICogICBbJ2EnLCdhJywnYSddLmV2ZXJ5KCdhJykgICAtPiB0cnVlXG4gICAgICogICBbe2E6Mn0se2E6Mn1dLmV2ZXJ5KHthOjJ9KSAtPiB0cnVlXG4gICAgICoqKi9cbiAgICAnZXZlcnknOiBmdW5jdGlvbihmbiwgc2NvcGUpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCwgaW5kZXggPSAwO1xuICAgICAgY2hlY2tGaXJzdEFyZ3VtZW50RXhpc3RzKGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZShpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZihpbmRleCBpbiB0aGlzICYmICFmbi5jYWxsKHNjb3BlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2Qgc29tZSg8Zj4sIFtzY29wZV0pXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgYW55IGVsZW1lbnQgaW4gdGhlIGFycmF5IG1hdGNoZXMgPGY+LlxuICAgICAqIEBleHRyYSBbc2NvcGVdIGlzIHRoZSAldGhpcyUgb2JqZWN0LiAlYW55JSBpcyBwcm92aWRlZCBhcyBhbiBhbGlhcy4gSW4gYWRkaXRpb24gdG8gcHJvdmlkaW5nIHRoaXMgbWV0aG9kIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQgbmF0aXZlbHksIHRoaXMgbWV0aG9kIGFsc28gaW1wbGVtZW50cyBAYXJyYXlfbWF0Y2hpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICArICAgWydhJywnYicsJ2MnXS5zb21lKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG4gPT0gJ2EnO1xuICAgICAqICAgfSk7XG4gICAgICsgICBbJ2EnLCdiJywnYyddLnNvbWUoZnVuY3Rpb24obikge1xuICAgICAqICAgICByZXR1cm4gbiA9PSAnZCc7XG4gICAgICogICB9KTtcbiAgICAgKiAgIFsnYScsJ2InLCdjJ10uc29tZSgnYScpICAgLT4gdHJ1ZVxuICAgICAqICAgW3thOjJ9LHtiOjV9XS5zb21lKHthOjJ9KSAtPiB0cnVlXG4gICAgICoqKi9cbiAgICAnc29tZSc6IGZ1bmN0aW9uKGZuLCBzY29wZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoLCBpbmRleCA9IDA7XG4gICAgICBjaGVja0ZpcnN0QXJndW1lbnRFeGlzdHMoYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmKGluZGV4IGluIHRoaXMgJiYgZm4uY2FsbChzY29wZSwgdGhpc1tpbmRleF0sIGluZGV4LCB0aGlzKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIG1hcCg8bWFwPiwgW3Njb3BlXSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBNYXBzIHRoZSBhcnJheSB0byBhbm90aGVyIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgPG1hcD4gb24gZWFjaCBlbGVtZW50LlxuICAgICAqIEBleHRyYSBbc2NvcGVdIGlzIHRoZSAldGhpcyUgb2JqZWN0LiBXaGVuIDxtYXA+IGlzIGEgZnVuY3Rpb24sIGl0IHJlY2VpdmVzIHRocmVlIGFyZ3VtZW50czogdGhlIGN1cnJlbnQgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXgsIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkuIEluIGFkZGl0aW9uIHRvIHByb3ZpZGluZyB0aGlzIG1ldGhvZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0IG5hdGl2ZWx5LCB0aGlzIGVuaGFuY2VkIG1ldGhvZCBhbHNvIGRpcmVjdGx5IGFjY2VwdHMgYSBzdHJpbmcsIHdoaWNoIGlzIGEgc2hvcnRjdXQgZm9yIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoYXQgcHJvcGVydHkgKG9yIGludm9rZXMgYSBmdW5jdGlvbikgb24gZWFjaCBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsM10ubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG4gKiAzO1xuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IFszLDYsOV1cbiAgICAgKiAgIFsnb25lJywndHdvJywndGhyZWUnXS5tYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgICByZXR1cm4gbi5sZW5ndGg7XG4gICAgICogICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4gWzMsMyw1XVxuICAgICAqICAgWydvbmUnLCd0d28nLCd0aHJlZSddLm1hcCgnbGVuZ3RoJykgIC0+IFszLDMsNV1cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ21hcCc6IGZ1bmN0aW9uKGZuLCBzY29wZSkge1xuICAgICAgdmFyIHNjb3BlID0gYXJndW1lbnRzWzFdLCBsZW5ndGggPSB0aGlzLmxlbmd0aCwgaW5kZXggPSAwLCByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGNoZWNrRmlyc3RBcmd1bWVudEV4aXN0cyhhcmd1bWVudHMpO1xuICAgICAgd2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBmbi5jYWxsKHNjb3BlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBmaWx0ZXIoPGY+LCBbc2NvcGVdKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IFJldHVybnMgYW55IGVsZW1lbnRzIGluIHRoZSBhcnJheSB0aGF0IG1hdGNoIDxmPi5cbiAgICAgKiBAZXh0cmEgW3Njb3BlXSBpcyB0aGUgJXRoaXMlIG9iamVjdC4gSW4gYWRkaXRpb24gdG8gcHJvdmlkaW5nIHRoaXMgbWV0aG9kIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQgbmF0aXZlbHksIHRoaXMgbWV0aG9kIGFsc28gaW1wbGVtZW50cyBAYXJyYXlfbWF0Y2hpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICArICAgWzEsMiwzXS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAqICAgICByZXR1cm4gbiA+IDE7XG4gICAgICogICB9KTtcbiAgICAgKiAgIFsxLDIsMiw0XS5maWx0ZXIoMikgLT4gMlxuICAgICAqXG4gICAgICoqKi9cbiAgICAnZmlsdGVyJzogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHZhciBzY29wZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCwgaW5kZXggPSAwLCByZXN1bHQgPSBbXTtcbiAgICAgIGNoZWNrRmlyc3RBcmd1bWVudEV4aXN0cyhhcmd1bWVudHMpO1xuICAgICAgd2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYoaW5kZXggaW4gdGhpcyAmJiBmbi5jYWxsKHNjb3BlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godGhpc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBpbmRleE9mKDxzZWFyY2g+LCBbZnJvbUluZGV4XSlcbiAgICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICAgKiBAc2hvcnQgU2VhcmNoZXMgdGhlIGFycmF5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBpbmRleCB3aGVyZSA8c2VhcmNoPiBvY2N1cnMsIG9yIC0xIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAZXh0cmEgW2Zyb21JbmRleF0gaXMgdGhlIGluZGV4IGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIHNlYXJjaC4gVGhpcyBtZXRob2QgcGVyZm9ybXMgYSBzaW1wbGUgc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb24gb24gPHNlYXJjaD4uIEl0IGRvZXMgbm90IHN1cHBvcnQgZW5oYW5jZWQgZnVuY3Rpb25hbGl0eSBzdWNoIGFzIHNlYXJjaGluZyB0aGUgY29udGVudHMgYWdhaW5zdCBhIHJlZ2V4LCBjYWxsYmFjaywgb3IgZGVlcCBjb21wYXJpc29uIG9mIG9iamVjdHMuIEZvciBzdWNoIGZ1bmN0aW9uYWxpdHksIHVzZSB0aGUgJWZpbmRJbmRleCUgbWV0aG9kIGluc3RlYWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzXS5pbmRleE9mKDMpICAgICAgICAgICAtPiAxXG4gICAgICogICBbMSwyLDNdLmluZGV4T2YoNykgICAgICAgICAgIC0+IC0xXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpbmRleE9mJzogZnVuY3Rpb24oc2VhcmNoKSB7XG4gICAgICB2YXIgZnJvbUluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYoaXNTdHJpbmcodGhpcykpIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoLCBmcm9tSW5kZXgpO1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBzZWFyY2gsIGZyb21JbmRleCwgMSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGxhc3RJbmRleE9mKDxzZWFyY2g+LCBbZnJvbUluZGV4XSlcbiAgICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICAgKiBAc2hvcnQgU2VhcmNoZXMgdGhlIGFycmF5IGFuZCByZXR1cm5zIHRoZSBsYXN0IGluZGV4IHdoZXJlIDxzZWFyY2g+IG9jY3Vycywgb3IgLTEgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGZvdW5kLlxuICAgICAqIEBleHRyYSBbZnJvbUluZGV4XSBpcyB0aGUgaW5kZXggZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBhIHNpbXBsZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbiBvbiA8c2VhcmNoPi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwyLDFdLmxhc3RJbmRleE9mKDEpICAgICAgICAgICAgICAgICAtPiAyXG4gICAgICogICBbMSwyLDFdLmxhc3RJbmRleE9mKDcpICAgICAgICAgICAgICAgICAtPiAtMVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnbGFzdEluZGV4T2YnOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgIHZhciBmcm9tSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICBpZihpc1N0cmluZyh0aGlzKSkgcmV0dXJuIHRoaXMubGFzdEluZGV4T2Yoc2VhcmNoLCBmcm9tSW5kZXgpO1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBzZWFyY2gsIGZyb21JbmRleCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBmb3JFYWNoKFtmbl0sIFtzY29wZV0pXG4gICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAqIEBzaG9ydCBJdGVyYXRlcyBvdmVyIHRoZSBhcnJheSwgY2FsbGluZyBbZm5dIG9uIGVhY2ggbG9vcC5cbiAgICAgKiBAZXh0cmEgVGhpcyBtZXRob2QgaXMgb25seSBwcm92aWRlZCBmb3IgdGhvc2UgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCBuYXRpdmVseS4gW3Njb3BlXSBiZWNvbWVzIHRoZSAldGhpcyUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsnYScsJ2InLCdjJ10uZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICogICAgIC8vIENhbGxlZCAzIHRpbWVzOiAnYScsJ2InLCdjJ1xuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdmb3JFYWNoJzogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCwgaW5kZXggPSAwLCBzY29wZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGNoZWNrQ2FsbGJhY2soZm4pO1xuICAgICAgd2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgIGZuLmNhbGwoc2NvcGUsIHRoaXNbaW5kZXhdLCBpbmRleCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmVkdWNlKDxmbj4sIFtpbml0XSlcbiAgICAgKiBAcmV0dXJucyBNaXhlZFxuICAgICAqIEBzaG9ydCBSZWR1Y2VzIHRoZSBhcnJheSB0byBhIHNpbmdsZSByZXN1bHQuXG4gICAgICogQGV4dHJhIElmIFtpbml0XSBpcyBwYXNzZWQgYXMgYSBzdGFydGluZyB2YWx1ZSwgdGhhdCB2YWx1ZSB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrLiBUaGUgc2Vjb25kIGFyZ3VtZW50IHdpbGwgYmUgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5LiBGcm9tIHRoYXQgcG9pbnQsIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrIHdpbGwgdGhlbiBiZSB1c2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbmV4dCBpdGVyYXRpb24uIFRoaXMgaXMgb2Z0ZW4gcmVmZXJlZCB0byBhcyBcImFjY3VtdWxhdGlvblwiLCBhbmQgW2luaXRdIGlzIG9mdGVuIGNhbGxlZCBhbiBcImFjY3VtdWxhdG9yXCIuIElmIFtpbml0XSBpcyBub3QgcGFzc2VkLCB0aGVuIDxmbj4gd2lsbCBiZSBjYWxsZWQgbiAtIDEgdGltZXMsIHdoZXJlIG4gaXMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIEluIHRoaXMgY2FzZSwgb24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCB0aGUgZmlyc3QgYXJndW1lbnQgd2lsbCBiZSB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXksIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHdpbGwgYmUgdGhlIHNlY29uZC4gQWZ0ZXIgdGhhdCBjYWxsYmFja3Mgd29yayBhcyBub3JtYWwsIHVzaW5nIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzIGNhbGxiYWNrIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbmV4dC4gVGhpcyBtZXRob2QgaXMgb25seSBwcm92aWRlZCBmb3IgdGhvc2UgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCBuYXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKyAgIFsxLDIsMyw0XS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgICByZXR1cm4gYSAtIGI7XG4gICAgICogICB9KTtcbiAgICAgKyAgIFsxLDIsMyw0XS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgICByZXR1cm4gYSAtIGI7XG4gICAgICogICB9LCAxMDApO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAncmVkdWNlJzogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZSh0aGlzLCBmbiwgYXJndW1lbnRzWzFdKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmVkdWNlUmlnaHQoW2ZuXSwgW2luaXRdKVxuICAgICAqIEByZXR1cm5zIE1peGVkXG4gICAgICogQHNob3J0IElkZW50aWNhbCB0byAlQXJyYXkjcmVkdWNlJSwgYnV0IG9wZXJhdGVzIG9uIHRoZSBlbGVtZW50cyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAqIEBleHRyYSBUaGlzIG1ldGhvZCBpcyBvbmx5IHByb3ZpZGVkIGZvciB0aG9zZSBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0IG5hdGl2ZWx5LlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICArICAgWzEsMiwzLDRdLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdyZWR1Y2VSaWdodCc6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UodGhpcywgZm4sIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gICAgfVxuXG5cbiAgfSk7XG5cblxuXG5cbiAgLyoqKlxuICAgKiBTdHJpbmcgbW9kdWxlXG4gICAqXG4gICAqKiovXG5cblxuICBmdW5jdGlvbiBidWlsZFRyaW0oKSB7XG4gICAgdmFyIHN1cHBvcnQgPSBnZXRUcmltbWFibGVDaGFyYWN0ZXJzKCkubWF0Y2goL15cXHMrJC8pO1xuICAgIHRyeSB7IHN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKFsxXSk7IH0gY2F0Y2goZSkgeyBzdXBwb3J0ID0gZmFsc2U7IH1cbiAgICBleHRlbmQoc3RyaW5nLCB0cnVlLCAhc3VwcG9ydCwge1xuXG4gICAgICAvKioqXG4gICAgICAgKiBAbWV0aG9kIHRyaW1bU2lkZV0oKVxuICAgICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICAgKiBAc2hvcnQgUmVtb3ZlcyBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIHN0cmluZy5cbiAgICAgICAqIEBleHRyYSBXaGl0ZXNwYWNlIGlzIGRlZmluZWQgYXMgbGluZSBicmVha3MsIHRhYnMsIGFuZCBhbnkgY2hhcmFjdGVyIGluIHRoZSBcIlNwYWNlLCBTZXBhcmF0b3JcIiBVbmljb2RlIGNhdGVnb3J5LCBjb25mb3JtaW5nIHRvIHRoZSB0aGUgRVM1IHNwZWMuIFRoZSBzdGFuZGFyZCAldHJpbSUgbWV0aG9kIGlzIG9ubHkgYWRkZWQgd2hlbiBub3QgZnVsbHkgc3VwcG9ydGVkIG5hdGl2ZWx5LlxuICAgICAgICpcbiAgICAgICAqIEBzZXRcbiAgICAgICAqICAgdHJpbVxuICAgICAgICogICB0cmltTGVmdFxuICAgICAgICogICB0cmltUmlnaHRcbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqICAgJyAgIHdhc2FiaSAgICcudHJpbSgpICAgICAgLT4gJ3dhc2FiaSdcbiAgICAgICAqICAgJyAgIHdhc2FiaSAgICcudHJpbUxlZnQoKSAgLT4gJ3dhc2FiaSAgICdcbiAgICAgICAqICAgJyAgIHdhc2FiaSAgICcudHJpbVJpZ2h0KCkgLT4gJyAgIHdhc2FiaSdcbiAgICAgICAqXG4gICAgICAgKioqL1xuICAgICAgJ3RyaW0nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS50cmltTGVmdCgpLnRyaW1SaWdodCgpO1xuICAgICAgfSxcblxuICAgICAgJ3RyaW1MZWZ0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UocmVnZXhwKCdeWycrZ2V0VHJpbW1hYmxlQ2hhcmFjdGVycygpKyddKycpLCAnJyk7XG4gICAgICB9LFxuXG4gICAgICAndHJpbVJpZ2h0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UocmVnZXhwKCdbJytnZXRUcmltbWFibGVDaGFyYWN0ZXJzKCkrJ10rJCcpLCAnJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuXG5cbiAgLyoqKlxuICAgKiBGdW5jdGlvbiBtb2R1bGVcbiAgICpcbiAgICoqKi9cblxuXG4gIGV4dGVuZChGdW5jdGlvbiwgdHJ1ZSwgZmFsc2UsIHtcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBiaW5kKDxzY29wZT4sIFthcmcxXSwgLi4uKVxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gICAgICogQHNob3J0IEJpbmRzIDxzY29wZT4gYXMgdGhlICV0aGlzJSBvYmplY3QgZm9yIHRoZSBmdW5jdGlvbiB3aGVuIGl0IGlzIGNhbGxlZC4gQWxzbyBhbGxvd3MgY3VycnlpbmcgYW4gdW5saW1pdGVkIG51bWJlciBvZiBwYXJhbWV0ZXJzLlxuICAgICAqIEBleHRyYSBcImN1cnJ5aW5nXCIgbWVhbnMgc2V0dGluZyBwYXJhbWV0ZXJzIChbYXJnMV0sIFthcmcyXSwgZXRjLikgYWhlYWQgb2YgdGltZSBzbyB0aGF0IHRoZXkgYXJlIHBhc3NlZCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbGF0ZXIuIElmIHlvdSBwYXNzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aGVuIHRoZSBmdW5jdGlvbiBpcyBhY3R1YWxseSBjYWxsZWQsIHRoZXkgd2lsbCBiZSBhZGRlZCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJpZWQgcGFyYW1ldGVycy4gVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdCBpbnRlcm5hbGx5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKyAgIChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRoaXM7XG4gICAgICogICB9KS5iaW5kKCd3b29mJykoKTsgLT4gcmV0dXJucyAnd29vZic7IGZ1bmN0aW9uIGlzIGJvdW5kIHdpdGggJ3dvb2YnIGFzIHRoZSB0aGlzIG9iamVjdC5cbiAgICAgKiAgIChmdW5jdGlvbihhKSB7XG4gICAgICogICAgIHJldHVybiBhO1xuICAgICAqICAgfSkuYmluZCgxLCAyKSgpOyAgIC0+IHJldHVybnMgMjsgZnVuY3Rpb24gaXMgYm91bmQgd2l0aCAxIGFzIHRoZSB0aGlzIG9iamVjdCBhbmQgMiBjdXJyaWVkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAgICAgKiAgIChmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICAgIHJldHVybiBhICsgYjtcbiAgICAgKiAgIH0pLmJpbmQoMSwgMikoMyk7ICAtPiByZXR1cm5zIDU7IGZ1bmN0aW9uIGlzIGJvdW5kIHdpdGggMSBhcyB0aGUgdGhpcyBvYmplY3QsIDIgY3VyaWVkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYW5kIDMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgICAqXG4gICAgICoqKi9cbiAgICAnYmluZCc6IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICB2YXIgZm4gPSB0aGlzLCBhcmdzID0gbXVsdGlBcmdzKGFyZ3VtZW50cywgbnVsbCwgMSksIGJvdW5kO1xuICAgICAgaWYoIWlzRnVuY3Rpb24odGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGEgbm9uLWZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoZm4ucHJvdG90eXBlICYmIHRoaXMgaW5zdGFuY2VvZiBmbiA/IHRoaXMgOiBzY29wZSwgYXJncy5jb25jYXQobXVsdGlBcmdzKGFyZ3VtZW50cykpKTtcbiAgICAgIH1cbiAgICAgIGJvdW5kLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICB9KTtcblxuICAvKioqXG4gICAqIERhdGUgbW9kdWxlXG4gICAqXG4gICAqKiovXG5cbiAgIC8qKipcbiAgICogQG1ldGhvZCB0b0lTT1N0cmluZygpXG4gICAqIEByZXR1cm5zIFN0cmluZ1xuICAgKiBAc2hvcnQgRm9ybWF0cyB0aGUgc3RyaW5nIHRvIElTTzg2MDEgZm9ybWF0LlxuICAgKiBAZXh0cmEgVGhpcyB3aWxsIGFsd2F5cyBmb3JtYXQgYXMgVVRDIHRpbWUuIFByb3ZpZGVkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoaXMgbWV0aG9kLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIERhdGUuY3JlYXRlKCkudG9JU09TdHJpbmcoKSAtPiBleC4gMjAxMS0wNy0wNSAxMjoyNDo1NS41MjhaXG4gICAqXG4gICAqKipcbiAgICogQG1ldGhvZCB0b0pTT04oKVxuICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICogQHNob3J0IFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRlLlxuICAgKiBAZXh0cmEgVGhpcyBpcyBlZmZlY3RpdmVseSBhbiBhbGlhcyBmb3IgJXRvSVNPU3RyaW5nJS4gV2lsbCBhbHdheXMgcmV0dXJuIHRoZSBkYXRlIGluIFVUQyB0aW1lLiBQcm92aWRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGlzIG1ldGhvZC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICBEYXRlLmNyZWF0ZSgpLnRvSlNPTigpIC0+IGV4LiAyMDExLTA3LTA1IDEyOjI0OjU1LjUyOFpcbiAgICpcbiAgICoqKi9cblxuICBleHRlbmQoZGF0ZSwgZmFsc2UsIGZhbHNlLCB7XG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgRGF0ZS5ub3coKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIEphbnVhcnkgMXN0LCAxOTcwIDAwOjAwOjAwIChVVEMgdGltZSkuXG4gICAgICogQGV4dHJhIFByb3ZpZGVkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoaXMgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUubm93KCkgLT4gZXguIDEzMTE5MzgyOTYyMzFcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ25vdyc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBkYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cblxuICB9KTtcblxuICAgZnVuY3Rpb24gYnVpbGRJU09TdHJpbmcoKSB7XG4gICAgdmFyIGQgPSBuZXcgZGF0ZShkYXRlLlVUQygxOTk5LCAxMSwgMzEpKSwgdGFyZ2V0ID0gJzE5OTktMTItMzFUMDA6MDA6MDAuMDAwWic7XG4gICAgdmFyIHN1cHBvcnQgPSBkLnRvSVNPU3RyaW5nICYmIGQudG9JU09TdHJpbmcoKSA9PT0gdGFyZ2V0O1xuICAgIGV4dGVuZFNpbWlsYXIoZGF0ZSwgdHJ1ZSwgIXN1cHBvcnQsICd0b0lTT1N0cmluZyx0b0pTT04nLCBmdW5jdGlvbihtZXRob2RzLCBuYW1lKSB7XG4gICAgICBtZXRob2RzW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYWROdW1iZXIodGhpcy5nZXRVVENGdWxsWWVhcigpLCA0KSArICctJyArXG4gICAgICAgICAgICAgICBwYWROdW1iZXIodGhpcy5nZXRVVENNb250aCgpICsgMSwgMikgKyAnLScgK1xuICAgICAgICAgICAgICAgcGFkTnVtYmVyKHRoaXMuZ2V0VVRDRGF0ZSgpLCAyKSArICdUJyArXG4gICAgICAgICAgICAgICBwYWROdW1iZXIodGhpcy5nZXRVVENIb3VycygpLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICBwYWROdW1iZXIodGhpcy5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICtcbiAgICAgICAgICAgICAgIHBhZE51bWJlcih0aGlzLmdldFVUQ1NlY29uZHMoKSwgMikgKyAnLicgK1xuICAgICAgICAgICAgICAgcGFkTnVtYmVyKHRoaXMuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIDMpICsgJ1onO1xuICAgICAgfVxuICAgIH0pO1xuICAgfVxuXG4gIC8vIEluaXRpYWxpemVcbiAgYnVpbGRUcmltKCk7XG4gIGJ1aWxkSVNPU3RyaW5nKCk7XG5cblxuICAvKioqXG4gICAqIEBwYWNrYWdlIEFycmF5XG4gICAqIEBkZXBlbmRlbmN5IGNvcmVcbiAgICogQGRlc2NyaXB0aW9uIEFycmF5IG1hbmlwdWxhdGlvbiBhbmQgdHJhdmVyc2FsLCBcImZ1enp5IG1hdGNoaW5nXCIgYWdhaW5zdCBlbGVtZW50cywgYWxwaGFudW1lcmljIHNvcnRpbmcgYW5kIGNvbGxhdGlvbiwgZW51bWVyYWJsZSBtZXRob2RzIG9uIE9iamVjdC5cbiAgICpcbiAgICoqKi9cblxuXG4gIGZ1bmN0aW9uIHJlZ2V4TWF0Y2hlcihyZWcpIHtcbiAgICByZWcgPSByZWdleHAocmVnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gcmVnLnRlc3QoZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRhdGVNYXRjaGVyKGQpIHtcbiAgICB2YXIgbXMgPSBkLmdldFRpbWUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gISEoZWwgJiYgZWwuZ2V0VGltZSkgJiYgZWwuZ2V0VGltZSgpID09PSBtcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmdW5jdGlvbk1hdGNoZXIoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCBhcnIpIHtcbiAgICAgIC8vIFJldHVybiB0cnVlIHVwIGZyb250IGlmIG1hdGNoIGJ5IHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGVsID09PSBmbiB8fCBmbi5jYWxsKHRoaXMsIGVsLCBpLCBhcnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydGVkQXJnc0Z1bmN0aW9uTWF0Y2hlcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAvLyBSZXR1cm4gdHJ1ZSB1cCBmcm9udCBpZiBtYXRjaCBieSByZWZlcmVuY2VcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gZm4gfHwgZm4uY2FsbChvYmosIGtleSwgdmFsdWUsIG9iaik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZnV6enlNYXRjaGVyKG9iaiwgaXNPYmplY3QpIHtcbiAgICB2YXIgbWF0Y2hlcnMgPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsLCBpLCBhcnIpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBpZighaXNPYmplY3RUeXBlKGVsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3Ioa2V5IGluIG9iaikge1xuICAgICAgICBtYXRjaGVyc1trZXldID0gbWF0Y2hlcnNba2V5XSB8fCBnZXRNYXRjaGVyKG9ialtrZXldLCBpc09iamVjdCk7XG4gICAgICAgIGlmKG1hdGNoZXJzW2tleV0uY2FsbChhcnIsIGVsW2tleV0sIGksIGFycikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0TWF0Y2hlcihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsID09PSBmIHx8IGlzRXF1YWwoZWwsIGYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoZXIoZiwgaXNPYmplY3QpIHtcbiAgICBpZihpc1ByaW1pdGl2ZVR5cGUoZikpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgYW5kIGZhbGwgdGhyb3VnaCB0byB0aGVcbiAgICAgIC8vIGRlZmF1bHQgbWF0Y2hlciBiZWxvdy5cbiAgICB9IGVsc2UgaWYoaXNSZWdFeHAoZikpIHtcbiAgICAgIC8vIE1hdGNoIGFnYWluc3QgYSByZWdleHBcbiAgICAgIHJldHVybiByZWdleE1hdGNoZXIoZik7XG4gICAgfSBlbHNlIGlmKGlzRGF0ZShmKSkge1xuICAgICAgLy8gTWF0Y2ggYWdhaW5zdCBhIGRhdGUuIGlzRXF1YWwgYmVsb3cgc2hvdWxkIGFsc29cbiAgICAgIC8vIGNhdGNoIHRoaXMgYnV0IG1hdGNoaW5nIGRpcmVjdGx5IHVwIGZyb250IGZvciBzcGVlZC5cbiAgICAgIHJldHVybiBkYXRlTWF0Y2hlcihmKTtcbiAgICB9IGVsc2UgaWYoaXNGdW5jdGlvbihmKSkge1xuICAgICAgLy8gTWF0Y2ggYWdhaW5zdCBhIGZpbHRlcmluZyBmdW5jdGlvblxuICAgICAgaWYoaXNPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGludmVydGVkQXJnc0Z1bmN0aW9uTWF0Y2hlcihmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk1hdGNoZXIoZik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIC8vIE1hdGNoIGFnYWluc3QgYSBmdXp6eSBoYXNoIG9yIGFycmF5LlxuICAgICAgcmV0dXJuIGZ1enp5TWF0Y2hlcihmLCBpc09iamVjdCk7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgaXMgc3RhbmRhcmQgaXNFcXVhbFxuICAgIHJldHVybiBkZWZhdWx0TWF0Y2hlcihmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUFyZ3VtZW50KGVsLCBtYXAsIGNvbnRleHQsIG1hcEFyZ3MpIHtcbiAgICBpZighbWFwKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSBlbHNlIGlmKG1hcC5hcHBseSkge1xuICAgICAgcmV0dXJuIG1hcC5hcHBseShjb250ZXh0LCBtYXBBcmdzIHx8IFtdKTtcbiAgICB9IGVsc2UgaWYoaXNGdW5jdGlvbihlbFttYXBdKSkge1xuICAgICAgcmV0dXJuIGVsW21hcF0uY2FsbChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbFttYXBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhc2ljIGFycmF5IGludGVybmFsIG1ldGhvZHNcblxuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyLCBmbiwgc3RhcnRJbmRleCwgbG9vcCkge1xuICAgIHZhciBpbmRleCwgaSwgbGVuZ3RoID0gK2Fyci5sZW5ndGg7XG4gICAgaWYoc3RhcnRJbmRleCA8IDApIHN0YXJ0SW5kZXggPSBhcnIubGVuZ3RoICsgc3RhcnRJbmRleDtcbiAgICBpID0gaXNOYU4oc3RhcnRJbmRleCkgPyAwIDogc3RhcnRJbmRleDtcbiAgICBpZihsb29wID09PSB0cnVlKSB7XG4gICAgICBsZW5ndGggKz0gaTtcbiAgICB9XG4gICAgd2hpbGUoaSA8IGxlbmd0aCkge1xuICAgICAgaW5kZXggPSBpICUgYXJyLmxlbmd0aDtcbiAgICAgIGlmKCEoaW5kZXggaW4gYXJyKSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZU92ZXJTcGFyc2VBcnJheShhcnIsIGZuLCBpLCBsb29wKTtcbiAgICAgIH0gZWxzZSBpZihmbi5jYWxsKGFyciwgYXJyW2luZGV4XSwgaW5kZXgsIGFycikgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVPdmVyU3BhcnNlQXJyYXkoYXJyLCBmbiwgZnJvbUluZGV4LCBsb29wKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXSwgaTtcbiAgICBmb3IoaSBpbiBhcnIpIHtcbiAgICAgIGlmKGlzQXJyYXlJbmRleChhcnIsIGkpICYmIGkgPj0gZnJvbUluZGV4KSB7XG4gICAgICAgIGluZGV4ZXMucHVzaChwYXJzZUludChpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGluZGV4ZXMuc29ydCgpLmVhY2goZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGFyciwgYXJyW2luZGV4XSwgaW5kZXgsIGFycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJyYXlJbmRleChhcnIsIGkpIHtcbiAgICByZXR1cm4gaSBpbiBhcnIgJiYgdG9VSW50MzIoaSkgPT0gaSAmJiBpICE9IDB4ZmZmZmZmZmY7XG4gIH1cblxuICBmdW5jdGlvbiB0b1VJbnQzMihpKSB7XG4gICAgcmV0dXJuIGkgPj4+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUZpbmQoYXJyLCBmLCBzdGFydEluZGV4LCBsb29wLCByZXR1cm5JbmRleCwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQsIGluZGV4LCBtYXRjaGVyO1xuICAgIGlmKGFyci5sZW5ndGggPiAwKSB7XG4gICAgICBtYXRjaGVyID0gZ2V0TWF0Y2hlcihmKTtcbiAgICAgIGFycmF5RWFjaChhcnIsIGZ1bmN0aW9uKGVsLCBpKSB7XG4gICAgICAgIGlmKG1hdGNoZXIuY2FsbChjb250ZXh0LCBlbCwgaSwgYXJyKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGVsO1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHN0YXJ0SW5kZXgsIGxvb3ApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuSW5kZXggPyBpbmRleCA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5VW5pcXVlKGFyciwgbWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBvID0ge30sIHRyYW5zZm9ybWVkO1xuICAgIGFycmF5RWFjaChhcnIsIGZ1bmN0aW9uKGVsLCBpKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IG1hcCA/IHRyYW5zZm9ybUFyZ3VtZW50KGVsLCBtYXAsIGFyciwgW2VsLCBpLCBhcnJdKSA6IGVsO1xuICAgICAgaWYoIWNoZWNrRm9yRWxlbWVudEluSGFzaEFuZFNldChvLCB0cmFuc2Zvcm1lZCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW50ZXJzZWN0KGFycjEsIGFycjIsIHN1YnRyYWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBvID0ge307XG4gICAgYXJyMi5lYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICBjaGVja0ZvckVsZW1lbnRJbkhhc2hBbmRTZXQobywgZWwpO1xuICAgIH0pO1xuICAgIGFycjEuZWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5KGVsKSxcbiAgICAgICAgICBpc1JlZmVyZW5jZSA9ICFvYmplY3RJc01hdGNoZWRCeVZhbHVlKGVsKTtcbiAgICAgIC8vIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBhcnJheSBpZjpcbiAgICAgIC8vIDEuIFdlJ3JlIHN1YnRyYWN0aW5nIGludGVyc2VjdGlvbnMgb3IgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0IGluIHRoZSByZXN1bHQgYW5kXG4gICAgICAvLyAyLiBJdCBleGlzdHMgaW4gdGhlIGNvbXBhcmVkIGFycmF5IGFuZCB3ZSdyZSBhZGRpbmcsIG9yIGl0IGRvZXNuJ3QgZXhpc3QgYW5kIHdlJ3JlIHJlbW92aW5nLlxuICAgICAgaWYoZWxlbWVudEV4aXN0c0luSGFzaChvLCBzdHJpbmdpZmllZCwgZWwsIGlzUmVmZXJlbmNlKSAhPT0gc3VidHJhY3QpIHtcbiAgICAgICAgZGlzY2FyZEVsZW1lbnRGcm9tSGFzaChvLCBzdHJpbmdpZmllZCwgZWwsIGlzUmVmZXJlbmNlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUZsYXR0ZW4oYXJyLCBsZXZlbCwgY3VycmVudCkge1xuICAgIGxldmVsID0gbGV2ZWwgfHwgSW5maW5pdHk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQgfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgYXJyYXlFYWNoKGFyciwgZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmKGlzQXJyYXkoZWwpICYmIGN1cnJlbnQgPCBsZXZlbCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGFycmF5RmxhdHRlbihlbCwgbGV2ZWwsIGN1cnJlbnQgKyAxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICAgIHJldHVybiBoYXNQcm9wZXJ0eShvYmosICdsZW5ndGgnKSAmJiAhaXNTdHJpbmcob2JqKSAmJiAhaXNQbGFpbk9iamVjdChvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBcmd1bWVudHNPYmplY3Qob2JqKSB7XG4gICAgLy8gLmNhbGxlZSBleGlzdHMgb24gQXJndW1lbnRzIG9iamVjdHMgaW4gPCBJRThcbiAgICByZXR1cm4gaGFzUHJvcGVydHkob2JqLCAnbGVuZ3RoJykgJiYgKGNsYXNzTmFtZShvYmopID09PSAnW29iamVjdCBBcmd1bWVudHNdJyB8fCAhIW9iai5jYWxsZWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxhdEFyZ3VtZW50cyhhcmdzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIG11bHRpQXJncyhhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYXJnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZWxlbWVudEV4aXN0c0luSGFzaChoYXNoLCBrZXksIGVsZW1lbnQsIGlzUmVmZXJlbmNlKSB7XG4gICAgdmFyIGV4aXN0cyA9IGtleSBpbiBoYXNoO1xuICAgIGlmKGlzUmVmZXJlbmNlKSB7XG4gICAgICBpZighaGFzaFtrZXldKSB7XG4gICAgICAgIGhhc2hba2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZXhpc3RzID0gaGFzaFtrZXldLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JFbGVtZW50SW5IYXNoQW5kU2V0KGhhc2gsIGVsZW1lbnQpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnkoZWxlbWVudCksXG4gICAgICAgIGlzUmVmZXJlbmNlID0gIW9iamVjdElzTWF0Y2hlZEJ5VmFsdWUoZWxlbWVudCksXG4gICAgICAgIGV4aXN0cyAgICAgID0gZWxlbWVudEV4aXN0c0luSGFzaChoYXNoLCBzdHJpbmdpZmllZCwgZWxlbWVudCwgaXNSZWZlcmVuY2UpO1xuICAgIGlmKGlzUmVmZXJlbmNlKSB7XG4gICAgICBoYXNoW3N0cmluZ2lmaWVkXS5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNoW3N0cmluZ2lmaWVkXSA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBleGlzdHM7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNjYXJkRWxlbWVudEZyb21IYXNoKGhhc2gsIGtleSwgZWxlbWVudCwgaXNSZWZlcmVuY2UpIHtcbiAgICB2YXIgYXJyLCBpID0gMDtcbiAgICBpZihpc1JlZmVyZW5jZSkge1xuICAgICAgYXJyID0gaGFzaFtrZXldO1xuICAgICAgd2hpbGUoaSA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgaWYoYXJyW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICB9XG4gIH1cblxuICAvLyBTdXBwb3J0IG1ldGhvZHNcblxuICBmdW5jdGlvbiBnZXRNaW5Pck1heChvYmosIG1hcCwgd2hpY2gsIGFsbCkge1xuICAgIHZhciBlbCxcbiAgICAgICAga2V5LFxuICAgICAgICBlZGdlLFxuICAgICAgICB0ZXN0LFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgbWF4ID0gd2hpY2ggPT09ICdtYXgnLFxuICAgICAgICBtaW4gPSB3aGljaCA9PT0gJ21pbicsXG4gICAgICAgIGlzQXJyYXkgPSBhcnJheS5pc0FycmF5KG9iaik7XG4gICAgZm9yKGtleSBpbiBvYmopIHtcbiAgICAgIGlmKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG4gICAgICBlbCAgID0gb2JqW2tleV07XG4gICAgICB0ZXN0ID0gdHJhbnNmb3JtQXJndW1lbnQoZWwsIG1hcCwgb2JqLCBpc0FycmF5ID8gW2VsLCBwYXJzZUludChrZXkpLCBvYmpdIDogW10pO1xuICAgICAgaWYoaXNVbmRlZmluZWQodGVzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbXBhcmUgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmKHRlc3QgPT09IGVkZ2UpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgfSBlbHNlIGlmKGlzVW5kZWZpbmVkKGVkZ2UpIHx8IChtYXggJiYgdGVzdCA+IGVkZ2UpIHx8IChtaW4gJiYgdGVzdCA8IGVkZ2UpKSB7XG4gICAgICAgIHJlc3VsdCA9IFtlbF07XG4gICAgICAgIGVkZ2UgPSB0ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZighaXNBcnJheSkgcmVzdWx0ID0gYXJyYXlGbGF0dGVuKHJlc3VsdCwgMSk7XG4gICAgcmV0dXJuIGFsbCA/IHJlc3VsdCA6IHJlc3VsdFswXTtcbiAgfVxuXG5cbiAgLy8gQWxwaGFudW1lcmljIGNvbGxhdGlvbiBoZWxwZXJzXG5cbiAgZnVuY3Rpb24gY29sbGF0ZVN0cmluZ3MoYSwgYikge1xuICAgIHZhciBhVmFsdWUsIGJWYWx1ZSwgYUNoYXIsIGJDaGFyLCBhRXF1aXYsIGJFcXVpdiwgaW5kZXggPSAwLCB0aWVicmVha2VyID0gMDtcblxuICAgIHZhciBzb3J0SWdub3JlICAgICAgPSBhcnJheVtBbHBoYW51bWVyaWNTb3J0SWdub3JlXTtcbiAgICB2YXIgc29ydElnbm9yZUNhc2UgID0gYXJyYXlbQWxwaGFudW1lcmljU29ydElnbm9yZUNhc2VdO1xuICAgIHZhciBzb3J0RXF1aXZhbGVudHMgPSBhcnJheVtBbHBoYW51bWVyaWNTb3J0RXF1aXZhbGVudHNdO1xuICAgIHZhciBzb3J0T3JkZXIgICAgICAgPSBhcnJheVtBbHBoYW51bWVyaWNTb3J0T3JkZXJdO1xuICAgIHZhciBuYXR1cmFsU29ydCAgICAgPSBhcnJheVtBbHBoYW51bWVyaWNTb3J0TmF0dXJhbF07XG5cbiAgICBhID0gZ2V0Q29sbGF0aW9uUmVhZHlTdHJpbmcoYSwgc29ydElnbm9yZSwgc29ydElnbm9yZUNhc2UpO1xuICAgIGIgPSBnZXRDb2xsYXRpb25SZWFkeVN0cmluZyhiLCBzb3J0SWdub3JlLCBzb3J0SWdub3JlQ2FzZSk7XG5cbiAgICBkbyB7XG5cbiAgICAgIGFDaGFyICA9IGdldENvbGxhdGlvbkNoYXJhY3RlcihhLCBpbmRleCwgc29ydEVxdWl2YWxlbnRzKTtcbiAgICAgIGJDaGFyICA9IGdldENvbGxhdGlvbkNoYXJhY3RlcihiLCBpbmRleCwgc29ydEVxdWl2YWxlbnRzKTtcbiAgICAgIGFWYWx1ZSA9IGdldFNvcnRPcmRlckluZGV4KGFDaGFyLCBzb3J0T3JkZXIpO1xuICAgICAgYlZhbHVlID0gZ2V0U29ydE9yZGVySW5kZXgoYkNoYXIsIHNvcnRPcmRlcik7XG5cbiAgICAgIGlmKGFWYWx1ZSA9PT0gLTEgfHwgYlZhbHVlID09PSAtMSkge1xuICAgICAgICBhVmFsdWUgPSBhLmNoYXJDb2RlQXQoaW5kZXgpIHx8IG51bGw7XG4gICAgICAgIGJWYWx1ZSA9IGIuY2hhckNvZGVBdChpbmRleCkgfHwgbnVsbDtcbiAgICAgICAgaWYobmF0dXJhbFNvcnQgJiYgY29kZUlzTnVtZXJhbChhVmFsdWUpICYmIGNvZGVJc051bWVyYWwoYlZhbHVlKSkge1xuICAgICAgICAgIGFWYWx1ZSA9IHN0cmluZ1RvTnVtYmVyKGEuc2xpY2UoaW5kZXgpKTtcbiAgICAgICAgICBiVmFsdWUgPSBzdHJpbmdUb051bWJlcihiLnNsaWNlKGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFFcXVpdiA9IGFDaGFyICE9PSBhLmNoYXJBdChpbmRleCk7XG4gICAgICAgIGJFcXVpdiA9IGJDaGFyICE9PSBiLmNoYXJBdChpbmRleCk7XG4gICAgICAgIGlmKGFFcXVpdiAhPT0gYkVxdWl2ICYmIHRpZWJyZWFrZXIgPT09IDApIHtcbiAgICAgICAgICB0aWVicmVha2VyID0gYUVxdWl2IC0gYkVxdWl2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmRleCArPSAxO1xuICAgIH0gd2hpbGUoYVZhbHVlICE9IG51bGwgJiYgYlZhbHVlICE9IG51bGwgJiYgYVZhbHVlID09PSBiVmFsdWUpO1xuICAgIGlmKGFWYWx1ZSA9PT0gYlZhbHVlKSByZXR1cm4gdGllYnJlYWtlcjtcbiAgICByZXR1cm4gYVZhbHVlIC0gYlZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29sbGF0aW9uUmVhZHlTdHJpbmcoc3RyLCBzb3J0SWdub3JlLCBzb3J0SWdub3JlQ2FzZSkge1xuICAgIGlmKCFpc1N0cmluZyhzdHIpKSBzdHIgPSBzdHJpbmcoc3RyKTtcbiAgICBpZihzb3J0SWdub3JlQ2FzZSkge1xuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmKHNvcnRJZ25vcmUpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHNvcnRJZ25vcmUsICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbGxhdGlvbkNoYXJhY3RlcihzdHIsIGluZGV4LCBzb3J0RXF1aXZhbGVudHMpIHtcbiAgICB2YXIgY2hyID0gc3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIHNvcnRFcXVpdmFsZW50c1tjaHJdIHx8IGNocjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNvcnRPcmRlckluZGV4KGNociwgc29ydE9yZGVyKSB7XG4gICAgaWYoIWNocikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzb3J0T3JkZXIuaW5kZXhPZihjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBBbHBoYW51bWVyaWNTb3J0ICAgICAgICAgICAgPSAnQWxwaGFudW1lcmljU29ydCc7XG4gIHZhciBBbHBoYW51bWVyaWNTb3J0T3JkZXIgICAgICAgPSAnQWxwaGFudW1lcmljU29ydE9yZGVyJztcbiAgdmFyIEFscGhhbnVtZXJpY1NvcnRJZ25vcmUgICAgICA9ICdBbHBoYW51bWVyaWNTb3J0SWdub3JlJztcbiAgdmFyIEFscGhhbnVtZXJpY1NvcnRJZ25vcmVDYXNlICA9ICdBbHBoYW51bWVyaWNTb3J0SWdub3JlQ2FzZSc7XG4gIHZhciBBbHBoYW51bWVyaWNTb3J0RXF1aXZhbGVudHMgPSAnQWxwaGFudW1lcmljU29ydEVxdWl2YWxlbnRzJztcbiAgdmFyIEFscGhhbnVtZXJpY1NvcnROYXR1cmFsICAgICA9ICdBbHBoYW51bWVyaWNTb3J0TmF0dXJhbCc7XG5cblxuXG4gIGZ1bmN0aW9uIGJ1aWxkRW5oYW5jZW1lbnRzKCkge1xuICAgIHZhciBuYXRpdmVNYXAgPSBhcnJheS5wcm90b3R5cGUubWFwO1xuICAgIHZhciBjYWxsYmFja0NoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IDAgJiYgIWlzRnVuY3Rpb24oYXJnc1swXSk7XG4gICAgfTtcbiAgICBleHRlbmRTaW1pbGFyKGFycmF5LCB0cnVlLCBjYWxsYmFja0NoZWNrLCAnZXZlcnksYWxsLHNvbWUsZmlsdGVyLGFueSxub25lLGZpbmQsZmluZEluZGV4JywgZnVuY3Rpb24obWV0aG9kcywgbmFtZSkge1xuICAgICAgdmFyIG5hdGl2ZUZuID0gYXJyYXkucHJvdG90eXBlW25hbWVdXG4gICAgICBtZXRob2RzW25hbWVdID0gZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IGdldE1hdGNoZXIoZik7XG4gICAgICAgIHJldHVybiBuYXRpdmVGbi5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVyKGVsLCBpbmRleCwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV4dGVuZChhcnJheSwgdHJ1ZSwgY2FsbGJhY2tDaGVjaywge1xuICAgICAgJ21hcCc6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1hcC5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Bcmd1bWVudChlbCwgZiwgdGhpcywgW2VsLCBpbmRleCwgdGhpc10pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQWxwaGFudW1lcmljU29ydCgpIHtcbiAgICB2YXIgb3JkZXIgPSAnQcOBw4DDgsODxIRCQ8SGxIzDh0TEjsOQRcOJw4jEmsOKw4vEmEZHxJ5IxLFJw43DjMSww47Dj0pLTMWBTU7Fg8WHw5FPw5PDksOUUFFSxZhTxZrFoMWeVMWkVcOaw5nFrsObw5xWV1hZw51axbnFu8W9w57DhsWSw5jDlcOFw4TDlic7XG4gICAgdmFyIGVxdWl2ID0gJ0HDgcOAw4LDg8OELEPDhyxFw4nDiMOKw4ssScONw4zEsMOOw48sT8OTw5LDlMOVw5YsU8OfLFXDmsOZw5vDnCc7XG4gICAgYXJyYXlbQWxwaGFudW1lcmljU29ydE9yZGVyXSA9IG9yZGVyLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyICsgc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSkuam9pbignJyk7XG4gICAgdmFyIGVxdWl2YWxlbnRzID0ge307XG4gICAgYXJyYXlFYWNoKGVxdWl2LnNwbGl0KCcsJyksIGZ1bmN0aW9uKHNldCkge1xuICAgICAgdmFyIGVxdWl2YWxlbnQgPSBzZXQuY2hhckF0KDApO1xuICAgICAgYXJyYXlFYWNoKHNldC5zbGljZSgxKS5zcGxpdCgnJyksIGZ1bmN0aW9uKGNocikge1xuICAgICAgICBlcXVpdmFsZW50c1tjaHJdID0gZXF1aXZhbGVudDtcbiAgICAgICAgZXF1aXZhbGVudHNbY2hyLnRvTG93ZXJDYXNlKCldID0gZXF1aXZhbGVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYXJyYXlbQWxwaGFudW1lcmljU29ydE5hdHVyYWxdID0gdHJ1ZTtcbiAgICBhcnJheVtBbHBoYW51bWVyaWNTb3J0SWdub3JlQ2FzZV0gPSB0cnVlO1xuICAgIGFycmF5W0FscGhhbnVtZXJpY1NvcnRFcXVpdmFsZW50c10gPSBlcXVpdmFsZW50cztcbiAgfVxuXG4gIGV4dGVuZChhcnJheSwgZmFsc2UsIHRydWUsIHtcblxuICAgIC8qKipcbiAgICAgKlxuICAgICAqIEBtZXRob2QgQXJyYXkuY3JlYXRlKDxvYmoxPiwgPG9iajI+LCAuLi4pXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgQWx0ZXJuYXRlIGFycmF5IGNvbnN0cnVjdG9yLlxuICAgICAqIEBleHRyYSBUaGlzIG1ldGhvZCB3aWxsIGNyZWF0ZSBhIHNpbmdsZSBhcnJheSBieSBjYWxsaW5nICVjb25jYXQlIG9uIGFsbCBhcmd1bWVudHMgcGFzc2VkLiBJbiBhZGRpdGlvbiB0byBlbnN1cmluZyB0aGF0IGFuIHVua25vd24gdmFyaWFibGUgaXMgaW4gYSBzaW5nbGUsIGZsYXQgYXJyYXkgKHRoZSBzdGFuZGFyZCBjb25zdHJ1Y3RvciB3aWxsIGNyZWF0ZSBuZXN0ZWQgYXJyYXlzLCB0aGlzIG9uZSB3aWxsIG5vdCksIGl0IGlzIGFsc28gYSB1c2VmdWwgc2hvcnRoYW5kIHRvIGNvbnZlcnQgYSBmdW5jdGlvbidzIGFyZ3VtZW50cyBvYmplY3QgaW50byBhIHN0YW5kYXJkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIEFycmF5LmNyZWF0ZSgnb25lJywgdHJ1ZSwgMykgICAtPiBbJ29uZScsIHRydWUsIDNdXG4gICAgICogICBBcnJheS5jcmVhdGUoWydvbmUnLCB0cnVlLCAzXSkgLT4gWydvbmUnLCB0cnVlLCAzXVxuICAgICArICAgQXJyYXkuY3JlYXRlKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICAgKiAgIH0oJ2hvd2R5JywgJ2Rvb2R5JykpO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnY3JlYXRlJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBtdWx0aUFyZ3MoYXJndW1lbnRzLCBmdW5jdGlvbihhKSB7XG4gICAgICAgIGlmKGlzQXJndW1lbnRzT2JqZWN0KGEpIHx8IGlzQXJyYXlMaWtlKGEpKSB7XG4gICAgICAgICAgYSA9IGFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGV4dGVuZChhcnJheSwgdHJ1ZSwgZmFsc2UsIHtcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGZpbmQoPGY+LCBbY29udGV4dF0gPSB1bmRlZmluZWQpXG4gICAgICogQHJldHVybnMgTWl4ZWRcbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgPGY+LlxuICAgICAqIEBleHRyYSBbY29udGV4dF0gaXMgdGhlICV0aGlzJSBvYmplY3QgaWYgcGFzc2VkLiBXaGVuIDxmPiBpcyBhIGZ1bmN0aW9uLCB3aWxsIHVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gaWYgaXQgZXhpc3RzLiA8Zj4gd2lsbCBhbHNvIG1hdGNoIGEgc3RyaW5nLCBudW1iZXIsIGFycmF5LCBvYmplY3QsIG9yIGFsdGVybmF0ZWx5IHRlc3QgYWdhaW5zdCBhIGZ1bmN0aW9uIG9yIHJlZ2V4LiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIEBhcnJheV9tYXRjaGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICsgICBbe2E6MSxiOjJ9LHthOjEsYjozfSx7YToxLGI6NH1dLmZpbmQoZnVuY3Rpb24obikge1xuICAgICAqICAgICByZXR1cm4gblsnYSddID09IDE7XG4gICAgICogICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4ge2E6MSxiOjN9XG4gICAgICogICBbJ2N1YmEnLCdqYXBhbicsJ2NhbmFkYSddLmZpbmQoL15jLykgLT4gJ2N1YmEnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdmaW5kJzogZnVuY3Rpb24oZiwgY29udGV4dCkge1xuICAgICAgY2hlY2tDYWxsYmFjayhmKTtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodGhpcywgZiwgMCwgZmFsc2UsIGZhbHNlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgZmluZEluZGV4KDxmPiwgW2NvbnRleHRdID0gdW5kZWZpbmVkKVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgPGY+IG9yIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBAZXh0cmEgW2NvbnRleHRdIGlzIHRoZSAldGhpcyUgb2JqZWN0IGlmIHBhc3NlZC4gV2hlbiA8Zj4gaXMgYSBmdW5jdGlvbiwgd2lsbCB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIGl0IGV4aXN0cy4gPGY+IHdpbGwgYWxzbyBtYXRjaCBhIHN0cmluZywgbnVtYmVyLCBhcnJheSwgb2JqZWN0LCBvciBhbHRlcm5hdGVseSB0ZXN0IGFnYWluc3QgYSBmdW5jdGlvbiBvciByZWdleC4gVGhpcyBtZXRob2QgaW1wbGVtZW50cyBAYXJyYXlfbWF0Y2hpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICsgICBbMSwyLDMsNF0uZmluZEluZGV4KGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogICB9KTsgLT4gMVxuICAgICArICAgWzEsMiwzLDRdLmZpbmRJbmRleCgzKTsgICAgICAgICAgICAgICAtPiAyXG4gICAgICsgICBbJ29uZScsJ3R3bycsJ3RocmVlJ10uZmluZEluZGV4KC90Lyk7IC0+IDFcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2ZpbmRJbmRleCc6IGZ1bmN0aW9uKGYsIGNvbnRleHQpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIGNoZWNrQ2FsbGJhY2soZik7XG4gICAgICBpbmRleCA9IGFycmF5RmluZCh0aGlzLCBmLCAwLCBmYWxzZSwgdHJ1ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoaW5kZXgpID8gLTEgOiBpbmRleDtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZXh0ZW5kKGFycmF5LCB0cnVlLCB0cnVlLCB7XG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBmaW5kRnJvbSg8Zj4sIFtpbmRleF0gPSAwLCBbbG9vcF0gPSBmYWxzZSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGFueSBlbGVtZW50IHRoYXQgbWF0Y2hlcyA8Zj4sIGJlZ2lubmluZyBmcm9tIFtpbmRleF0uXG4gICAgICogQGV4dHJhIDxmPiB3aWxsIG1hdGNoIGEgc3RyaW5nLCBudW1iZXIsIGFycmF5LCBvYmplY3QsIG9yIGFsdGVybmF0ZWx5IHRlc3QgYWdhaW5zdCBhIGZ1bmN0aW9uIG9yIHJlZ2V4LiBXaWxsIGNvbnRpbnVlIGZyb20gaW5kZXggPSAwIGlmIFtsb29wXSBpcyB0cnVlLiBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIEBhcnJheV9tYXRjaGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbJ2N1YmEnLCdqYXBhbicsJ2NhbmFkYSddLmZpbmRGcm9tKC9eYy8sIDIpIC0+ICdjYW5hZGEnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdmaW5kRnJvbSc6IGZ1bmN0aW9uKGYsIGluZGV4LCBsb29wKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHRoaXMsIGYsIGluZGV4LCBsb29wKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgZmluZEluZGV4RnJvbSg8Zj4sIFtpbmRleF0gPSAwLCBbbG9vcF0gPSBmYWxzZSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBpbmRleCBvZiBhbnkgZWxlbWVudCB0aGF0IG1hdGNoZXMgPGY+LCBiZWdpbm5pbmcgZnJvbSBbaW5kZXhdLlxuICAgICAqIEBleHRyYSA8Zj4gd2lsbCBtYXRjaCBhIHN0cmluZywgbnVtYmVyLCBhcnJheSwgb2JqZWN0LCBvciBhbHRlcm5hdGVseSB0ZXN0IGFnYWluc3QgYSBmdW5jdGlvbiBvciByZWdleC4gV2lsbCBjb250aW51ZSBmcm9tIGluZGV4ID0gMCBpZiBbbG9vcF0gaXMgdHJ1ZS4gVGhpcyBtZXRob2QgaW1wbGVtZW50cyBAYXJyYXlfbWF0Y2hpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWydjdWJhJywnamFwYW4nLCdjYW5hZGEnXS5maW5kSW5kZXhGcm9tKC9eYy8sIDIpIC0+IDJcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2ZpbmRJbmRleEZyb20nOiBmdW5jdGlvbihmLCBpbmRleCwgbG9vcCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kKHRoaXMsIGYsIGluZGV4LCBsb29wLCB0cnVlKTtcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChpbmRleCkgPyAtMSA6IGluZGV4O1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBmaW5kQWxsKDxmPiwgW2luZGV4XSA9IDAsIFtsb29wXSA9IGZhbHNlKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IFJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgbWF0Y2ggPGY+LlxuICAgICAqIEBleHRyYSA8Zj4gd2lsbCBtYXRjaCBhIHN0cmluZywgbnVtYmVyLCBhcnJheSwgb2JqZWN0LCBvciBhbHRlcm5hdGVseSB0ZXN0IGFnYWluc3QgYSBmdW5jdGlvbiBvciByZWdleC4gU3RhcnRzIGF0IFtpbmRleF0sIGFuZCB3aWxsIGNvbnRpbnVlIG9uY2UgZnJvbSBpbmRleCA9IDAgaWYgW2xvb3BdIGlzIHRydWUuIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgQGFycmF5X21hdGNoaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKyAgIFt7YToxLGI6Mn0se2E6MSxiOjN9LHthOjIsYjo0fV0uZmluZEFsbChmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuWydhJ10gPT0gMTtcbiAgICAgKiAgIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBbe2E6MSxiOjN9LHthOjEsYjo0fV1cbiAgICAgKiAgIFsnY3ViYScsJ2phcGFuJywnY2FuYWRhJ10uZmluZEFsbCgvXmMvKSAgICAtPiAnY3ViYScsJ2NhbmFkYSdcbiAgICAgKiAgIFsnY3ViYScsJ2phcGFuJywnY2FuYWRhJ10uZmluZEFsbCgvXmMvLCAyKSAtPiAnY2FuYWRhJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnZmluZEFsbCc6IGZ1bmN0aW9uKGYsIGluZGV4LCBsb29wKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIG1hdGNoZXI7XG4gICAgICBpZih0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWF0Y2hlciA9IGdldE1hdGNoZXIoZik7XG4gICAgICAgIGFycmF5RWFjaCh0aGlzLCBmdW5jdGlvbihlbCwgaSwgYXJyKSB7XG4gICAgICAgICAgaWYobWF0Y2hlcihlbCwgaSwgYXJyKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgaW5kZXgsIGxvb3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgY291bnQoPGY+KVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBDb3VudHMgYWxsIGVsZW1lbnRzIGluIHRoZSBhcnJheSB0aGF0IG1hdGNoIDxmPi5cbiAgICAgKiBAZXh0cmEgPGY+IHdpbGwgbWF0Y2ggYSBzdHJpbmcsIG51bWJlciwgYXJyYXksIG9iamVjdCwgb3IgYWx0ZXJuYXRlbHkgdGVzdCBhZ2FpbnN0IGEgZnVuY3Rpb24gb3IgcmVnZXguIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgQGFycmF5X21hdGNoaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsMywxXS5jb3VudCgxKSAgICAgICAtPiAyXG4gICAgICogICBbJ2EnLCdiJywnYyddLmNvdW50KC9iLykgLT4gMVxuICAgICArICAgW3thOjF9LHtiOjJ9XS5jb3VudChmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuWydhJ10gPiAxO1xuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgIC0+IDBcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2NvdW50JzogZnVuY3Rpb24oZikge1xuICAgICAgaWYoaXNVbmRlZmluZWQoZikpIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRBbGwoZikubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCByZW1vdmVBdCg8c3RhcnQ+LCBbZW5kXSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZW1vdmVzIGVsZW1lbnQgYXQgPHN0YXJ0Pi4gSWYgW2VuZF0gaXMgc3BlY2lmaWVkLCByZW1vdmVzIHRoZSByYW5nZSBiZXR3ZWVuIDxzdGFydD4gYW5kIFtlbmRdLiBUaGlzIG1ldGhvZCB3aWxsIGNoYW5nZSB0aGUgYXJyYXkhIElmIHlvdSBkb24ndCBpbnRlbmQgdGhlIGFycmF5IHRvIGJlIGNoYW5nZWQgdXNlICVjbG9uZSUgZmlyc3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWydhJywnYicsJ2MnXS5yZW1vdmVBdCgwKSAtPiBbJ2InLCdjJ11cbiAgICAgKiAgIFsxLDIsMyw0XS5yZW1vdmVBdCgxLCAzKSAgLT4gWzFdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdyZW1vdmVBdCc6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmKGlzVW5kZWZpbmVkKHN0YXJ0KSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZihpc1VuZGVmaW5lZChlbmQpKSAgIGVuZCA9IHN0YXJ0O1xuICAgICAgdGhpcy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgaW5jbHVkZSg8ZWw+LCBbaW5kZXhdKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IEFkZHMgPGVsPiB0byB0aGUgYXJyYXkuXG4gICAgICogQGV4dHJhIFRoaXMgaXMgYSBub24tZGVzdHJ1Y3RpdmUgYWxpYXMgZm9yICVhZGQlLiBJdCB3aWxsIG5vdCBjaGFuZ2UgdGhlIG9yaWdpbmFsIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsMyw0XS5pbmNsdWRlKDUpICAgICAgIC0+IFsxLDIsMyw0LDVdXG4gICAgICogICBbMSwyLDMsNF0uaW5jbHVkZSg4LCAxKSAgICAtPiBbMSw4LDIsMyw0XVxuICAgICAqICAgWzEsMiwzLDRdLmluY2x1ZGUoWzUsNiw3XSkgLT4gWzEsMiwzLDQsNSw2LDddXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpbmNsdWRlJzogZnVuY3Rpb24oZWwsIGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmFkZChlbCwgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBleGNsdWRlKFtmMV0sIFtmMl0sIC4uLilcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZW1vdmVzIGFueSBlbGVtZW50IGluIHRoZSBhcnJheSB0aGF0IG1hdGNoZXMgW2YxXSwgW2YyXSwgZXRjLlxuICAgICAqIEBleHRyYSBUaGlzIGlzIGEgbm9uLWRlc3RydWN0aXZlIGFsaWFzIGZvciAlcmVtb3ZlJS4gSXQgd2lsbCBub3QgY2hhbmdlIHRoZSBvcmlnaW5hbCBhcnJheS4gVGhpcyBtZXRob2QgaW1wbGVtZW50cyBAYXJyYXlfbWF0Y2hpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzXS5leGNsdWRlKDMpICAgICAgICAgLT4gWzEsMl1cbiAgICAgKiAgIFsnYScsJ2InLCdjJ10uZXhjbHVkZSgvYi8pIC0+IFsnYScsJ2MnXVxuICAgICArICAgW3thOjF9LHtiOjJ9XS5leGNsdWRlKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG5bJ2EnXSA9PSAxO1xuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAtPiBbe2I6Mn1dXG4gICAgICpcbiAgICAgKioqL1xuICAgICdleGNsdWRlJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJyYXkucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLmNsb25lKCksIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNsb25lKClcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsM10uY2xvbmUoKSAtPiBbMSwyLDNdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdjbG9uZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNpbXBsZU1lcmdlKFtdLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgdW5pcXVlKFttYXBdID0gbnVsbClcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZW1vdmVzIGFsbCBkdXBsaWNhdGUgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxuICAgICAqIEBleHRyYSBbbWFwXSBtYXkgYmUgYSBmdW5jdGlvbiBtYXBwaW5nIHRoZSB2YWx1ZSB0byBiZSB1bmlxdWVkIG9uIG9yIGEgc3RyaW5nIGFjdGluZyBhcyBhIHNob3J0Y3V0LiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCB3aGVuIHlvdSBoYXZlIGEga2V5IHRoYXQgZW5zdXJlcyB0aGUgb2JqZWN0J3MgdW5pcXVlbmVzcywgYW5kIGRvbid0IG5lZWQgdG8gY2hlY2sgYWxsIGZpZWxkcy4gVGhpcyBtZXRob2Qgd2lsbCBhbHNvIGNvcnJlY3RseSBvcGVyYXRlIG9uIGFycmF5cyBvZiBvYmplY3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsMiwzXS51bmlxdWUoKSAgICAgICAgICAgICAgICAgLT4gWzEsMiwzXVxuICAgICAqICAgW3tmb286J2Jhcid9LHtmb286J2Jhcid9XS51bmlxdWUoKSAtPiBbe2ZvbzonYmFyJ31dXG4gICAgICsgICBbe2ZvbzonYmFyJ30se2ZvbzonYmFyJ31dLnVuaXF1ZShmdW5jdGlvbihvYmope1xuICAgICAqICAgICByZXR1cm4gb2JqLmZvbztcbiAgICAgKiAgIH0pOyAtPiBbe2ZvbzonYmFyJ31dXG4gICAgICogICBbe2ZvbzonYmFyJ30se2ZvbzonYmFyJ31dLnVuaXF1ZSgnZm9vJykgLT4gW3tmb286J2Jhcid9XVxuICAgICAqXG4gICAgICoqKi9cbiAgICAndW5pcXVlJzogZnVuY3Rpb24obWFwKSB7XG4gICAgICByZXR1cm4gYXJyYXlVbmlxdWUodGhpcywgbWFwKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgZmxhdHRlbihbbGltaXRdID0gSW5maW5pdHkpXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhIGZsYXR0ZW5lZCwgb25lLWRpbWVuc2lvbmFsIGNvcHkgb2YgdGhlIGFycmF5LlxuICAgICAqIEBleHRyYSBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSBhIFtsaW1pdF0sIHdoaWNoIHdpbGwgb25seSBmbGF0dGVuIHRoYXQgZGVwdGguXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgW1sxXSwgMiwgWzNdXS5mbGF0dGVuKCkgICAgICAtPiBbMSwyLDNdXG4gICAgICogICBbWydhJ10sW10sJ2InLCdjJ10uZmxhdHRlbigpIC0+IFsnYScsJ2InLCdjJ11cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2ZsYXR0ZW4nOiBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgcmV0dXJuIGFycmF5RmxhdHRlbih0aGlzLCBsaW1pdCk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHVuaW9uKFthMV0sIFthMl0sIC4uLilcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIGluIGFsbCBhcnJheXMgd2l0aCBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gICAgICogQGV4dHJhIFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBjb3JyZWN0bHkgb3BlcmF0ZSBvbiBhcnJheXMgb2Ygb2JqZWN0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwzLDVdLnVuaW9uKFs1LDcsOV0pICAgICAtPiBbMSwzLDUsNyw5XVxuICAgICAqICAgWydhJywnYiddLnVuaW9uKFsnYicsJ2MnXSkgLT4gWydhJywnYicsJ2MnXVxuICAgICAqXG4gICAgICoqKi9cbiAgICAndW5pb24nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcnJheVVuaXF1ZSh0aGlzLmNvbmNhdChmbGF0QXJndW1lbnRzKGFyZ3VtZW50cykpKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgaW50ZXJzZWN0KFthMV0sIFthMl0sIC4uLilcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnRzIGFsbCBhcnJheXMgaGF2ZSBpbiBjb21tb24uXG4gICAgICogQGV4dHJhIFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBjb3JyZWN0bHkgb3BlcmF0ZSBvbiBhcnJheXMgb2Ygb2JqZWN0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwzLDVdLmludGVyc2VjdChbNSw3LDldKSAgIC0+IFs1XVxuICAgICAqICAgWydhJywnYiddLmludGVyc2VjdCgnYicsJ2MnKSAtPiBbJ2InXVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaW50ZXJzZWN0JzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbnRlcnNlY3QodGhpcywgZmxhdEFyZ3VtZW50cyhhcmd1bWVudHMpLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHN1YnRyYWN0KFthMV0sIFthMl0sIC4uLilcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBTdWJ0cmFjdHMgZnJvbSB0aGUgYXJyYXkgYWxsIGVsZW1lbnRzIGluIFthMV0sIFthMl0sIGV0Yy5cbiAgICAgKiBAZXh0cmEgVGhpcyBtZXRob2Qgd2lsbCBhbHNvIGNvcnJlY3RseSBvcGVyYXRlIG9uIGFycmF5cyBvZiBvYmplY3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDMsNV0uc3VidHJhY3QoWzUsNyw5XSkgICAtPiBbMSwzXVxuICAgICAqICAgWzEsMyw1XS5zdWJ0cmFjdChbM10sWzVdKSAgIC0+IFsxXVxuICAgICAqICAgWydhJywnYiddLnN1YnRyYWN0KCdiJywnYycpIC0+IFsnYSddXG4gICAgICpcbiAgICAgKioqL1xuICAgICdzdWJ0cmFjdCc6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhcnJheUludGVyc2VjdCh0aGlzLCBmbGF0QXJndW1lbnRzKGFyZ3VtZW50cyksIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBhdCg8aW5kZXg+LCBbbG9vcF0gPSB0cnVlKVxuICAgICAqIEByZXR1cm5zIE1peGVkXG4gICAgICogQHNob3J0IEdldHMgdGhlIGVsZW1lbnQocykgYXQgYSBnaXZlbiBpbmRleC5cbiAgICAgKiBAZXh0cmEgV2hlbiBbbG9vcF0gaXMgdHJ1ZSwgb3ZlcnNob290aW5nIHRoZSBlbmQgb2YgdGhlIGFycmF5IChvciB0aGUgYmVnaW5uaW5nKSB3aWxsIGJlZ2luIGNvdW50aW5nIGZyb20gdGhlIG90aGVyIGVuZC4gQXMgYW4gYWx0ZXJuYXRlIHN5bnRheCwgcGFzc2luZyBtdWx0aXBsZSBpbmRleGVzIHdpbGwgZ2V0IHRoZSBlbGVtZW50cyBhdCB0aG9zZSBpbmRleGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsM10uYXQoMCkgICAgICAgIC0+IDFcbiAgICAgKiAgIFsxLDIsM10uYXQoMikgICAgICAgIC0+IDNcbiAgICAgKiAgIFsxLDIsM10uYXQoNCkgICAgICAgIC0+IDJcbiAgICAgKiAgIFsxLDIsM10uYXQoNCwgZmFsc2UpIC0+IG51bGxcbiAgICAgKiAgIFsxLDIsM10uYXQoLTEpICAgICAgIC0+IDNcbiAgICAgKiAgIFsxLDIsM10uYXQoMCwxKSAgICAgIC0+IFsxLDJdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdhdCc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldEVudHJpZXNGb3JJbmRleGVzKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGZpcnN0KFtudW1dID0gMSlcbiAgICAgKiBAcmV0dXJucyBNaXhlZFxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50KHMpIGluIHRoZSBhcnJheS5cbiAgICAgKiBAZXh0cmEgV2hlbiA8bnVtPiBpcyBwYXNzZWQsIHJldHVybnMgdGhlIGZpcnN0IDxudW0+IGVsZW1lbnRzIGluIHRoZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwyLDNdLmZpcnN0KCkgICAgICAgIC0+IDFcbiAgICAgKiAgIFsxLDIsM10uZmlyc3QoMikgICAgICAgLT4gWzEsMl1cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2ZpcnN0JzogZnVuY3Rpb24obnVtKSB7XG4gICAgICBpZihpc1VuZGVmaW5lZChudW0pKSByZXR1cm4gdGhpc1swXTtcbiAgICAgIGlmKG51bSA8IDApIG51bSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBudW0pO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBsYXN0KFtudW1dID0gMSlcbiAgICAgKiBAcmV0dXJucyBNaXhlZFxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgaW4gdGhlIGFycmF5LlxuICAgICAqIEBleHRyYSBXaGVuIDxudW0+IGlzIHBhc3NlZCwgcmV0dXJucyB0aGUgbGFzdCA8bnVtPiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzXS5sYXN0KCkgICAgICAgIC0+IDNcbiAgICAgKiAgIFsxLDIsM10ubGFzdCgyKSAgICAgICAtPiBbMiwzXVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnbGFzdCc6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgaWYoaXNVbmRlZmluZWQobnVtKSkgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMubGVuZ3RoIC0gbnVtIDwgMCA/IDAgOiB0aGlzLmxlbmd0aCAtIG51bTtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0KTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgZnJvbSg8aW5kZXg+KVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IFJldHVybnMgYSBzbGljZSBvZiB0aGUgYXJyYXkgZnJvbSA8aW5kZXg+LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsM10uZnJvbSgxKSAgLT4gWzIsM11cbiAgICAgKiAgIFsxLDIsM10uZnJvbSgyKSAgLT4gWzNdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdmcm9tJzogZnVuY3Rpb24obnVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZShudW0pO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCB0byg8aW5kZXg+KVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IFJldHVybnMgYSBzbGljZSBvZiB0aGUgYXJyYXkgdXAgdG8gPGluZGV4Pi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwyLDNdLnRvKDEpICAtPiBbMV1cbiAgICAgKiAgIFsxLDIsM10udG8oMikgIC0+IFsxLDJdXG4gICAgICpcbiAgICAgKioqL1xuICAgICd0byc6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgaWYoaXNVbmRlZmluZWQobnVtKSkgbnVtID0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBudW0pO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBtaW4oW21hcF0sIFthbGxdID0gZmFsc2UpXG4gICAgICogQHJldHVybnMgTWl4ZWRcbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgZWxlbWVudCBpbiB0aGUgYXJyYXkgd2l0aCB0aGUgbG93ZXN0IHZhbHVlLlxuICAgICAqIEBleHRyYSBbbWFwXSBtYXkgYmUgYSBmdW5jdGlvbiBtYXBwaW5nIHRoZSB2YWx1ZSB0byBiZSBjaGVja2VkIG9yIGEgc3RyaW5nIGFjdGluZyBhcyBhIHNob3J0Y3V0LiBJZiBbYWxsXSBpcyB0cnVlLCB3aWxsIHJldHVybiBhbGwgbWluIHZhbHVlcyBpbiBhbiBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwyLDNdLm1pbigpICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAxXG4gICAgICogICBbJ2ZlZScsJ2ZvJywnZnVtJ10ubWluKCdsZW5ndGgnKSAgICAgICAtPiAnZm8nXG4gICAgICogICBbJ2ZlZScsJ2ZvJywnZnVtJ10ubWluKCdsZW5ndGgnLCB0cnVlKSAtPiBbJ2ZvJ11cbiAgICAgKyAgIFsnZmVlJywnZm8nLCdmdW0nXS5taW4oZnVuY3Rpb24obikge1xuICAgICAqICAgICByZXR1cm4gbi5sZW5ndGg7XG4gICAgICogICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBbJ2ZvJ11cbiAgICAgKyAgIFt7YTozLGE6Mn1dLm1pbihmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuWydhJ107XG4gICAgICogICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBbe2E6Mn1dXG4gICAgICpcbiAgICAgKioqL1xuICAgICdtaW4nOiBmdW5jdGlvbihtYXAsIGFsbCkge1xuICAgICAgcmV0dXJuIGdldE1pbk9yTWF4KHRoaXMsIG1hcCwgJ21pbicsIGFsbCk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIG1heChbbWFwXSwgW2FsbF0gPSBmYWxzZSlcbiAgICAgKiBAcmV0dXJucyBNaXhlZFxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBlbGVtZW50IGluIHRoZSBhcnJheSB3aXRoIHRoZSBncmVhdGVzdCB2YWx1ZS5cbiAgICAgKiBAZXh0cmEgW21hcF0gbWF5IGJlIGEgZnVuY3Rpb24gbWFwcGluZyB0aGUgdmFsdWUgdG8gYmUgY2hlY2tlZCBvciBhIHN0cmluZyBhY3RpbmcgYXMgYSBzaG9ydGN1dC4gSWYgW2FsbF0gaXMgdHJ1ZSwgd2lsbCByZXR1cm4gYWxsIG1heCB2YWx1ZXMgaW4gYW4gYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzXS5tYXgoKSAgICAgICAgICAgICAgICAgICAgICAgICAgLT4gM1xuICAgICAqICAgWydmZWUnLCdmbycsJ2Z1bSddLm1heCgnbGVuZ3RoJykgICAgICAgLT4gJ2ZlZSdcbiAgICAgKiAgIFsnZmVlJywnZm8nLCdmdW0nXS5tYXgoJ2xlbmd0aCcsIHRydWUpIC0+IFsnZmVlJ11cbiAgICAgKyAgIFt7YTozLGE6Mn1dLm1heChmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuWydhJ107XG4gICAgICogICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiB7YTozfVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnbWF4JzogZnVuY3Rpb24obWFwLCBhbGwpIHtcbiAgICAgIHJldHVybiBnZXRNaW5Pck1heCh0aGlzLCBtYXAsICdtYXgnLCBhbGwpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBsZWFzdChbbWFwXSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBlbGVtZW50cyBpbiB0aGUgYXJyYXkgd2l0aCB0aGUgbGVhc3QgY29tbW9ubHkgb2NjdXJpbmcgdmFsdWUuXG4gICAgICogQGV4dHJhIFttYXBdIG1heSBiZSBhIGZ1bmN0aW9uIG1hcHBpbmcgdGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQgb3IgYSBzdHJpbmcgYWN0aW5nIGFzIGEgc2hvcnRjdXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzMsMiwyXS5sZWFzdCgpICAgICAgICAgICAgICAgICAgIC0+IFszXVxuICAgICAqICAgWydmZScsJ2ZvJywnZnVtJ10ubGVhc3QoJ2xlbmd0aCcpIC0+IFsnZnVtJ11cbiAgICAgKyAgIFt7YWdlOjM1LG5hbWU6J2tlbid9LHthZ2U6MTIsbmFtZTonYm9iJ30se2FnZToxMixuYW1lOid0ZWQnfV0ubGVhc3QoZnVuY3Rpb24obikge1xuICAgICAqICAgICByZXR1cm4gbi5hZ2U7XG4gICAgICogICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4gW3thZ2U6MzUsbmFtZTona2VuJ31dXG4gICAgICpcbiAgICAgKioqL1xuICAgICdsZWFzdCc6IGZ1bmN0aW9uKG1hcCwgYWxsKSB7XG4gICAgICByZXR1cm4gZ2V0TWluT3JNYXgodGhpcy5ncm91cEJ5LmFwcGx5KHRoaXMsIFttYXBdKSwgJ2xlbmd0aCcsICdtaW4nLCBhbGwpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBtb3N0KFttYXBdKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IFJldHVybnMgdGhlIGVsZW1lbnRzIGluIHRoZSBhcnJheSB3aXRoIHRoZSBtb3N0IGNvbW1vbmx5IG9jY3VyaW5nIHZhbHVlLlxuICAgICAqIEBleHRyYSBbbWFwXSBtYXkgYmUgYSBmdW5jdGlvbiBtYXBwaW5nIHRoZSB2YWx1ZSB0byBiZSBjaGVja2VkIG9yIGEgc3RyaW5nIGFjdGluZyBhcyBhIHNob3J0Y3V0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFszLDIsMl0ubW9zdCgpICAgICAgICAgICAgICAgICAgIC0+IFsyXVxuICAgICAqICAgWydmZScsJ2ZvJywnZnVtJ10ubW9zdCgnbGVuZ3RoJykgLT4gWydmZScsJ2ZvJ11cbiAgICAgKyAgIFt7YWdlOjM1LG5hbWU6J2tlbid9LHthZ2U6MTIsbmFtZTonYm9iJ30se2FnZToxMixuYW1lOid0ZWQnfV0ubW9zdChmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuLmFnZTtcbiAgICAgKiAgIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IFt7YWdlOjEyLG5hbWU6J2JvYid9LHthZ2U6MTIsbmFtZTondGVkJ31dXG4gICAgICpcbiAgICAgKioqL1xuICAgICdtb3N0JzogZnVuY3Rpb24obWFwLCBhbGwpIHtcbiAgICAgIHJldHVybiBnZXRNaW5Pck1heCh0aGlzLmdyb3VwQnkuYXBwbHkodGhpcywgW21hcF0pLCAnbGVuZ3RoJywgJ21heCcsIGFsbCk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHN1bShbbWFwXSlcbiAgICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICAgKiBAc2hvcnQgU3VtcyBhbGwgdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgICAgKiBAZXh0cmEgW21hcF0gbWF5IGJlIGEgZnVuY3Rpb24gbWFwcGluZyB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkIG9yIGEgc3RyaW5nIGFjdGluZyBhcyBhIHNob3J0Y3V0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsMl0uc3VtKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiA1XG4gICAgICsgICBbe2FnZTozNX0se2FnZToxMn0se2FnZToxMn1dLnN1bShmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuLmFnZTtcbiAgICAgKiAgIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiA1OVxuICAgICAqICAgW3thZ2U6MzV9LHthZ2U6MTJ9LHthZ2U6MTJ9XS5zdW0oJ2FnZScpIC0+IDU5XG4gICAgICpcbiAgICAgKioqL1xuICAgICdzdW0nOiBmdW5jdGlvbihtYXApIHtcbiAgICAgIHZhciBhcnIgPSBtYXAgPyB0aGlzLm1hcChtYXApIDogdGhpcztcbiAgICAgIHJldHVybiBhcnIubGVuZ3RoID4gMCA/IGFyci5yZWR1Y2UoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhICsgYjsgfSkgOiAwO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBhdmVyYWdlKFttYXBdKVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBHZXRzIHRoZSBtZWFuIGF2ZXJhZ2UgZm9yIGFsbCB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICAgICAqIEBleHRyYSBbbWFwXSBtYXkgYmUgYSBmdW5jdGlvbiBtYXBwaW5nIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZCBvciBhIHN0cmluZyBhY3RpbmcgYXMgYSBzaG9ydGN1dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwyLDNdLmF2ZXJhZ2UoKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IDJcbiAgICAgKyAgIFt7YWdlOjM1fSx7YWdlOjExfSx7YWdlOjExfV0uYXZlcmFnZShmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuLmFnZTtcbiAgICAgKiAgIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLT4gMTlcbiAgICAgKiAgIFt7YWdlOjM1fSx7YWdlOjExfSx7YWdlOjExfV0uYXZlcmFnZSgnYWdlJykgLT4gMTlcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2F2ZXJhZ2UnOiBmdW5jdGlvbihtYXApIHtcbiAgICAgIHZhciBhcnIgPSBtYXAgPyB0aGlzLm1hcChtYXApIDogdGhpcztcbiAgICAgIHJldHVybiBhcnIubGVuZ3RoID4gMCA/IGFyci5zdW0oKSAvIGFyci5sZW5ndGggOiAwO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBpbkdyb3Vwcyg8bnVtPiwgW3BhZGRpbmddKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IEdyb3VwcyB0aGUgYXJyYXkgaW50byA8bnVtPiBhcnJheXMuXG4gICAgICogQGV4dHJhIFtwYWRkaW5nXSBzcGVjaWZpZXMgYSB2YWx1ZSB3aXRoIHdoaWNoIHRvIHBhZCB0aGUgbGFzdCBhcnJheSBzbyB0aGF0IHRoZXkgYXJlIGFsbCBlcXVhbCBsZW5ndGguXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzLDQsNSw2LDddLmluR3JvdXBzKDMpICAgICAgICAgLT4gWyBbMSwyLDNdLCBbNCw1LDZdLCBbN10gXVxuICAgICAqICAgWzEsMiwzLDQsNSw2LDddLmluR3JvdXBzKDMsICdub25lJykgLT4gWyBbMSwyLDNdLCBbNCw1LDZdLCBbNywnbm9uZScsJ25vbmUnXSBdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpbkdyb3Vwcyc6IGZ1bmN0aW9uKG51bSwgcGFkZGluZykge1xuICAgICAgdmFyIHBhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxO1xuICAgICAgdmFyIGFyciA9IHRoaXM7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgZGl2aXNvciA9IGNlaWwodGhpcy5sZW5ndGggLyBudW0pO1xuICAgICAgc2ltcGxlUmVwZWF0KG51bSwgZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpICogZGl2aXNvcjtcbiAgICAgICAgdmFyIGdyb3VwID0gYXJyLnNsaWNlKGluZGV4LCBpbmRleCArIGRpdmlzb3IpO1xuICAgICAgICBpZihwYWQgJiYgZ3JvdXAubGVuZ3RoIDwgZGl2aXNvcikge1xuICAgICAgICAgIHNpbXBsZVJlcGVhdChkaXZpc29yIC0gZ3JvdXAubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGdyb3VwID0gZ3JvdXAuYWRkKHBhZGRpbmcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGdyb3VwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgaW5Hcm91cHNPZig8bnVtPiwgW3BhZGRpbmddID0gbnVsbClcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBHcm91cHMgdGhlIGFycmF5IGludG8gYXJyYXlzIG9mIDxudW0+IGVsZW1lbnRzIGVhY2guXG4gICAgICogQGV4dHJhIFtwYWRkaW5nXSBzcGVjaWZpZXMgYSB2YWx1ZSB3aXRoIHdoaWNoIHRvIHBhZCB0aGUgbGFzdCBhcnJheSBzbyB0aGF0IHRoZXkgYXJlIGFsbCBlcXVhbCBsZW5ndGguXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzLDQsNSw2LDddLmluR3JvdXBzT2YoNCkgICAgICAgICAtPiBbIFsxLDIsMyw0XSwgWzUsNiw3XSBdXG4gICAgICogICBbMSwyLDMsNCw1LDYsN10uaW5Hcm91cHNPZig0LCAnbm9uZScpIC0+IFsgWzEsMiwzLDRdLCBbNSw2LDcsJ25vbmUnXSBdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpbkdyb3Vwc09mJzogZnVuY3Rpb24obnVtLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGxlbiA9IHRoaXMubGVuZ3RoLCBhcnIgPSB0aGlzLCBncm91cDtcbiAgICAgIGlmKGxlbiA9PT0gMCB8fCBudW0gPT09IDApIHJldHVybiBhcnI7XG4gICAgICBpZihpc1VuZGVmaW5lZChudW0pKSBudW0gPSAxO1xuICAgICAgaWYoaXNVbmRlZmluZWQocGFkZGluZykpIHBhZGRpbmcgPSBudWxsO1xuICAgICAgc2ltcGxlUmVwZWF0KGNlaWwobGVuIC8gbnVtKSwgZnVuY3Rpb24oaSkge1xuICAgICAgICBncm91cCA9IGFyci5zbGljZShudW0gKiBpLCBudW0gKiBpICsgbnVtKTtcbiAgICAgICAgd2hpbGUoZ3JvdXAubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChncm91cCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGlzRW1wdHkoKVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBhcnJheSBpcyBlbXB0eS5cbiAgICAgKiBAZXh0cmEgVGhpcyBpcyB0cnVlIGlmIHRoZSBhcnJheSBoYXMgYSBsZW5ndGggb2YgemVybywgb3IgY29udGFpbnMgb25seSAldW5kZWZpbmVkJSwgJW51bGwlLCBvciAlTmFOJS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbXS5pc0VtcHR5KCkgICAgICAgICAgICAgICAtPiB0cnVlXG4gICAgICogICBbbnVsbCx1bmRlZmluZWRdLmlzRW1wdHkoKSAtPiB0cnVlXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpc0VtcHR5JzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYWN0KCkubGVuZ3RoID09IDA7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHNvcnRCeSg8bWFwPiwgW2Rlc2NdID0gZmFsc2UpXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgU29ydHMgdGhlIGFycmF5IGJ5IDxtYXA+LlxuICAgICAqIEBleHRyYSA8bWFwPiBtYXkgYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcgYWN0aW5nIGFzIGEgc2hvcnRjdXQsIG9yIGJsYW5rIChkaXJlY3QgY29tcGFyaXNvbiBvZiBhcnJheSB2YWx1ZXMpLiBbZGVzY10gd2lsbCBzb3J0IHRoZSBhcnJheSBpbiBkZXNjZW5kaW5nIG9yZGVyLiBXaGVuIHRoZSBmaWVsZCBiZWluZyBzb3J0ZWQgb24gaXMgYSBzdHJpbmcsIHRoZSByZXN1bHRpbmcgb3JkZXIgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IGFuIGludGVybmFsIGNvbGxhdGlvbiBhbGdvcml0aG0gdGhhdCBpcyBvcHRpbWl6ZWQgZm9yIG1ham9yIFdlc3Rlcm4gbGFuZ3VhZ2VzLCBidXQgY2FuIGJlIGN1c3RvbWl6ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBAYXJyYXlfc29ydGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbJ3dvcmxkJywnYScsJ25ldyddLnNvcnRCeSgnbGVuZ3RoJykgICAgICAgLT4gWydhJywnbmV3Jywnd29ybGQnXVxuICAgICAqICAgWyd3b3JsZCcsJ2EnLCduZXcnXS5zb3J0QnkoJ2xlbmd0aCcsIHRydWUpIC0+IFsnd29ybGQnLCduZXcnLCdhJ11cbiAgICAgKyAgIFt7YWdlOjcyfSx7YWdlOjEzfSx7YWdlOjE4fV0uc29ydEJ5KGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG4uYWdlO1xuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IFt7YWdlOjEzfSx7YWdlOjE4fSx7YWdlOjcyfV1cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3NvcnRCeSc6IGZ1bmN0aW9uKG1hcCwgZGVzYykge1xuICAgICAgdmFyIGFyciA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGFyci5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgdmFyIGFQcm9wZXJ0eSwgYlByb3BlcnR5LCBjb21wO1xuICAgICAgICBhUHJvcGVydHkgPSB0cmFuc2Zvcm1Bcmd1bWVudChhLCBtYXAsIGFyciwgW2FdKTtcbiAgICAgICAgYlByb3BlcnR5ID0gdHJhbnNmb3JtQXJndW1lbnQoYiwgbWFwLCBhcnIsIFtiXSk7XG4gICAgICAgIGlmKGlzU3RyaW5nKGFQcm9wZXJ0eSkgJiYgaXNTdHJpbmcoYlByb3BlcnR5KSkge1xuICAgICAgICAgIGNvbXAgPSBjb2xsYXRlU3RyaW5ncyhhUHJvcGVydHksIGJQcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSBpZihhUHJvcGVydHkgPCBiUHJvcGVydHkpIHtcbiAgICAgICAgICBjb21wID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZihhUHJvcGVydHkgPiBiUHJvcGVydHkpIHtcbiAgICAgICAgICBjb21wID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcCAqIChkZXNjID8gLTEgOiAxKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmFuZG9taXplKClcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGEgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgcmFuZG9taXplZC5cbiAgICAgKiBAZXh0cmEgVXNlcyBGaXNoZXItWWF0ZXMgYWxnb3JpdGhtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsMyw0XS5yYW5kb21pemUoKSAgLT4gWz8sPyw/LD9dXG4gICAgICpcbiAgICAgKioqL1xuICAgICdyYW5kb21pemUnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcnIgPSB0aGlzLmNvbmNhdCgpLCBpID0gYXJyLmxlbmd0aCwgaiwgeDtcbiAgICAgIHdoaWxlKGkpIHtcbiAgICAgICAgaiA9IChtYXRoLnJhbmRvbSgpICogaSkgfCAwO1xuICAgICAgICB4ID0gYXJyWy0taV07XG4gICAgICAgIGFycltpXSA9IGFycltqXTtcbiAgICAgICAgYXJyW2pdID0geDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHppcChbYXJyMV0sIFthcnIyXSwgLi4uKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IE1lcmdlcyBtdWx0aXBsZSBhcnJheXMgdG9nZXRoZXIuXG4gICAgICogQGV4dHJhIFRoaXMgbWV0aG9kIFwiemlwcyB1cFwiIHNtYWxsZXIgYXJyYXlzIGludG8gb25lIGxhcmdlIHdob3NlIGVsZW1lbnRzIGFyZSBcImFsbCBlbGVtZW50cyBhdCBpbmRleCAwXCIsIFwiYWxsIGVsZW1lbnRzIGF0IGluZGV4IDFcIiwgZXRjLiBVc2VmdWwgd2hlbiB5b3UgaGF2ZSBhc3NvY2lhdGVkIGRhdGEgdGhhdCBpcyBzcGxpdCBvdmVyIHNlcGFyYXRlZCBhcnJheXMuIElmIHRoZSBhcnJheXMgcGFzc2VkIGhhdmUgbW9yZSBlbGVtZW50cyB0aGFuIHRoZSBvcmlnaW5hbCBhcnJheSwgdGhleSB3aWxsIGJlIGRpc2NhcmRlZC4gSWYgdGhleSBoYXZlIGZld2VyIGVsZW1lbnRzLCB0aGUgbWlzc2luZyBlbGVtZW50cyB3aWxsIGZpbGxlZCB3aXRoICVudWxsJS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwyLDNdLnppcChbNCw1LDZdKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IFtbMSwyXSwgWzMsNF0sIFs1LDZdXVxuICAgICAqICAgWydNYXJ0aW4nLCdKb2huJ10uemlwKFsnTHV0aGVyJywnRi4nXSwgWydLaW5nJywnS2VubmVkeSddKSAtPiBbWydNYXJ0aW4nLCdMdXRoZXInLCdLaW5nJ10sIFsnSm9obicsJ0YuJywnS2VubmVkeSddXVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnemlwJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IG11bHRpQXJncyhhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKGVsLCBpKSB7XG4gICAgICAgIHJldHVybiBbZWxdLmNvbmNhdChhcmdzLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgcmV0dXJuIChpIGluIGspID8ga1tpXSA6IG51bGw7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBzYW1wbGUoW251bV0pXG4gICAgICogQHJldHVybnMgTWl4ZWRcbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhIHJhbmRvbSBlbGVtZW50IGZyb20gdGhlIGFycmF5LlxuICAgICAqIEBleHRyYSBJZiBbbnVtXSBpcyBwYXNzZWQsIHdpbGwgcmV0dXJuIFtudW1dIHNhbXBsZXMgZnJvbSB0aGUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzLDQsNV0uc2FtcGxlKCkgIC0+IC8vIFJhbmRvbSBlbGVtZW50XG4gICAgICogICBbMSwyLDMsNCw1XS5zYW1wbGUoMykgLT4gLy8gQXJyYXkgb2YgMyByYW5kb20gZWxlbWVudHNcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3NhbXBsZSc6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgdmFyIGFyciA9IHRoaXMucmFuZG9taXplKCk7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcnIuc2xpY2UoMCwgbnVtKSA6IGFyclswXTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgZWFjaCg8Zm4+LCBbaW5kZXhdID0gMCwgW2xvb3BdID0gZmFsc2UpXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgUnVucyA8Zm4+IGFnYWluc3QgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS4gRW5oYW5jZWQgdmVyc2lvbiBvZiAlQXJyYXkjZm9yRWFjaCUuXG4gICAgICogQGV4dHJhIFBhcmFtZXRlcnMgcGFzc2VkIHRvIDxmbj4gYXJlIGlkZW50aWNhbCB0byAlZm9yRWFjaCUsIGllLiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSBjdXJyZW50IGVsZW1lbnQsIHNlY29uZCBwYXJhbWV0ZXIgaXMgdGhlIGN1cnJlbnQgaW5kZXgsIGFuZCB0aGlyZCBwYXJhbWV0ZXIgaXMgdGhlIGFycmF5IGl0c2VsZi4gSWYgPGZuPiByZXR1cm5zICVmYWxzZSUgYXQgYW55IHRpbWUgaXQgd2lsbCBicmVhayBvdXQgb2YgdGhlIGxvb3AuIE9uY2UgJWVhY2glIGZpbmlzaGVzLCBpdCB3aWxsIHJldHVybiB0aGUgYXJyYXkuIElmIFtpbmRleF0gaXMgcGFzc2VkLCA8Zm4+IHdpbGwgYmVnaW4gYXQgdGhhdCBpbmRleCBhbmQgd29yayBpdHMgd2F5IHRvIHRoZSBlbmQuIElmIFtsb29wXSBpcyB0cnVlLCBpdCB3aWxsIHRoZW4gc3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFuZCBjb250aW51ZSB1bnRpbCBpdCByZWFjaGVzIFtpbmRleF0gLSAxLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsxLDIsMyw0XS5lYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgLy8gQ2FsbGVkIDQgdGltZXM6IDEsIDIsIDMsIDRcbiAgICAgKiAgIH0pO1xuICAgICAqICAgWzEsMiwzLDRdLmVhY2goZnVuY3Rpb24obikge1xuICAgICAqICAgICAvLyBDYWxsZWQgNCB0aW1lczogMywgNCwgMSwgMlxuICAgICAqICAgfSwgMiwgdHJ1ZSk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdlYWNoJzogZnVuY3Rpb24oZm4sIGluZGV4LCBsb29wKSB7XG4gICAgICBhcnJheUVhY2godGhpcywgZm4sIGluZGV4LCBsb29wKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBhZGQoPGVsPiwgW2luZGV4XSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBBZGRzIDxlbD4gdG8gdGhlIGFycmF5LlxuICAgICAqIEBleHRyYSBJZiBbaW5kZXhdIGlzIHNwZWNpZmllZCwgaXQgd2lsbCBhZGQgYXQgW2luZGV4XSwgb3RoZXJ3aXNlIGFkZHMgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuICVhZGQlIGJlaGF2ZXMgbGlrZSAlY29uY2F0JSBpbiB0aGF0IGlmIDxlbD4gaXMgYW4gYXJyYXkgaXQgd2lsbCBiZSBqb2luZWQsIG5vdCBpbnNlcnRlZC4gVGhpcyBtZXRob2Qgd2lsbCBjaGFuZ2UgdGhlIGFycmF5ISBVc2UgJWluY2x1ZGUlIGZvciBhIG5vbi1kZXN0cnVjdGl2ZSBhbGlhcy4gQWxzbywgJWluc2VydCUgaXMgcHJvdmlkZWQgYXMgYW4gYWxpYXMgdGhhdCByZWFkcyBiZXR0ZXIgd2hlbiB1c2luZyBhbiBpbmRleC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSwyLDMsNF0uYWRkKDUpICAgICAgIC0+IFsxLDIsMyw0LDVdXG4gICAgICogICBbMSwyLDMsNF0uYWRkKFs1LDYsN10pIC0+IFsxLDIsMyw0LDUsNiw3XVxuICAgICAqICAgWzEsMiwzLDRdLmluc2VydCg4LCAxKSAtPiBbMSw4LDIsMyw0XVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnYWRkJzogZnVuY3Rpb24oZWwsIGluZGV4KSB7XG4gICAgICBpZighaXNOdW1iZXIobnVtYmVyKGluZGV4KSkgfHwgaXNOYU4oaW5kZXgpKSBpbmRleCA9IHRoaXMubGVuZ3RoO1xuICAgICAgYXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseSh0aGlzLCBbaW5kZXgsIDBdLmNvbmNhdChlbCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHJlbW92ZShbZjFdLCBbZjJdLCAuLi4pXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgUmVtb3ZlcyBhbnkgZWxlbWVudCBpbiB0aGUgYXJyYXkgdGhhdCBtYXRjaGVzIFtmMV0sIFtmMl0sIGV0Yy5cbiAgICAgKiBAZXh0cmEgV2lsbCBtYXRjaCBhIHN0cmluZywgbnVtYmVyLCBhcnJheSwgb2JqZWN0LCBvciBhbHRlcm5hdGVseSB0ZXN0IGFnYWluc3QgYSBmdW5jdGlvbiBvciByZWdleC4gVGhpcyBtZXRob2Qgd2lsbCBjaGFuZ2UgdGhlIGFycmF5ISBVc2UgJWV4Y2x1ZGUlIGZvciBhIG5vbi1kZXN0cnVjdGl2ZSBhbGlhcy4gVGhpcyBtZXRob2QgaW1wbGVtZW50cyBAYXJyYXlfbWF0Y2hpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzXS5yZW1vdmUoMykgICAgICAgICAtPiBbMSwyXVxuICAgICAqICAgWydhJywnYicsJ2MnXS5yZW1vdmUoL2IvKSAtPiBbJ2EnLCdjJ11cbiAgICAgKyAgIFt7YToxfSx7YjoyfV0ucmVtb3ZlKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG5bJ2EnXSA9PSAxO1xuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAtPiBbe2I6Mn1dXG4gICAgICpcbiAgICAgKioqL1xuICAgICdyZW1vdmUnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcnIgPSB0aGlzO1xuICAgICAgbXVsdGlBcmdzKGFyZ3VtZW50cywgZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgaSA9IDAsIG1hdGNoZXIgPSBnZXRNYXRjaGVyKGYpO1xuICAgICAgICB3aGlsZShpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgIGlmKG1hdGNoZXIoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNvbXBhY3QoW2FsbF0gPSBmYWxzZSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZW1vdmVzIGFsbCBpbnN0YW5jZXMgb2YgJXVuZGVmaW5lZCUsICVudWxsJSwgYW5kICVOYU4lIGZyb20gdGhlIGFycmF5LlxuICAgICAqIEBleHRyYSBJZiBbYWxsXSBpcyAldHJ1ZSUsIGFsbCBcImZhbHN5XCIgZWxlbWVudHMgd2lsbCBiZSByZW1vdmVkLiBUaGlzIGluY2x1ZGVzIGVtcHR5IHN0cmluZ3MsIDAsIGFuZCBmYWxzZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBbMSxudWxsLDIsdW5kZWZpbmVkLDNdLmNvbXBhY3QoKSAtPiBbMSwyLDNdXG4gICAgICogICBbMSwnJywyLGZhbHNlLDNdLmNvbXBhY3QoKSAgICAgICAtPiBbMSwnJywyLGZhbHNlLDNdXG4gICAgICogICBbMSwnJywyLGZhbHNlLDNdLmNvbXBhY3QodHJ1ZSkgICAtPiBbMSwyLDNdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdjb21wYWN0JzogZnVuY3Rpb24oYWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBhcnJheUVhY2godGhpcywgZnVuY3Rpb24oZWwsIGkpIHtcbiAgICAgICAgaWYoaXNBcnJheShlbCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbC5jb21wYWN0KCkpO1xuICAgICAgICB9IGVsc2UgaWYoYWxsICYmIGVsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgICB9IGVsc2UgaWYoIWFsbCAmJiBlbCAhPSBudWxsICYmIGVsLnZhbHVlT2YoKSA9PT0gZWwudmFsdWVPZigpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGdyb3VwQnkoPG1hcD4sIFtmbl0pXG4gICAgICogQHJldHVybnMgT2JqZWN0XG4gICAgICogQHNob3J0IEdyb3VwcyB0aGUgYXJyYXkgYnkgPG1hcD4uXG4gICAgICogQGV4dHJhIFdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGtleXMgZXF1YWwgdG8gdGhlIGdyb3VwZWQgdmFsdWVzLiA8bWFwPiBtYXkgYmUgYSBtYXBwaW5nIGZ1bmN0aW9uLCBvciBhIHN0cmluZyBhY3RpbmcgYXMgYSBzaG9ydGN1dC4gT3B0aW9uYWxseSBjYWxscyBbZm5dIGZvciBlYWNoIGdyb3VwLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIFsnZmVlJywnZmknLCdmdW0nXS5ncm91cEJ5KCdsZW5ndGgnKSAtPiB7IDI6IFsnZmknXSwgMzogWydmZWUnLCdmdW0nXSB9XG4gICAgICsgICBbe2FnZTozNSxuYW1lOidrZW4nfSx7YWdlOjE1LG5hbWU6J2JvYid9XS5ncm91cEJ5KGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgICAgcmV0dXJuIG4uYWdlO1xuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IHsgMzU6IFt7YWdlOjM1LG5hbWU6J2tlbid9XSwgMTU6IFt7YWdlOjE1LG5hbWU6J2JvYid9XSB9XG4gICAgICpcbiAgICAgKioqL1xuICAgICdncm91cEJ5JzogZnVuY3Rpb24obWFwLCBmbikge1xuICAgICAgdmFyIGFyciA9IHRoaXMsIHJlc3VsdCA9IHt9LCBrZXk7XG4gICAgICBhcnJheUVhY2goYXJyLCBmdW5jdGlvbihlbCwgaW5kZXgpIHtcbiAgICAgICAga2V5ID0gdHJhbnNmb3JtQXJndW1lbnQoZWwsIG1hcCwgYXJyLCBbZWwsIGluZGV4LCBhcnJdKTtcbiAgICAgICAgaWYoIXJlc3VsdFtrZXldKSByZXN1bHRba2V5XSA9IFtdO1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKGVsKTtcbiAgICAgIH0pO1xuICAgICAgaWYoZm4pIHtcbiAgICAgICAgaXRlcmF0ZU92ZXJPYmplY3QocmVzdWx0LCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBub25lKDxmPilcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiBub25lIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgYXJyYXkgbWF0Y2ggPGY+LlxuICAgICAqIEBleHRyYSA8Zj4gd2lsbCBtYXRjaCBhIHN0cmluZywgbnVtYmVyLCBhcnJheSwgb2JqZWN0LCBvciBhbHRlcm5hdGVseSB0ZXN0IGFnYWluc3QgYSBmdW5jdGlvbiBvciByZWdleC4gVGhpcyBtZXRob2QgaW1wbGVtZW50cyBAYXJyYXlfbWF0Y2hpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgWzEsMiwzXS5ub25lKDUpICAgICAgICAgLT4gdHJ1ZVxuICAgICAqICAgWydhJywnYicsJ2MnXS5ub25lKC9iLykgLT4gZmFsc2VcbiAgICAgKyAgIFt7YToxfSx7YjoyfV0ubm9uZShmdW5jdGlvbihuKSB7XG4gICAgICogICAgIHJldHVybiBuWydhJ10gPiAxO1xuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgLT4gdHJ1ZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnbm9uZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmFueS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuXG4gIH0pO1xuXG5cbiAgLy8gQWxpYXNlc1xuXG4gIGV4dGVuZChhcnJheSwgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgYWxsKClcbiAgICAgKiBAYWxpYXMgZXZlcnlcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2FsbCc6IGFycmF5LnByb3RvdHlwZS5ldmVyeSxcblxuICAgIC8qKiogQG1ldGhvZCBhbnkoKVxuICAgICAqIEBhbGlhcyBzb21lXG4gICAgICpcbiAgICAgKioqL1xuICAgICdhbnknOiBhcnJheS5wcm90b3R5cGUuc29tZSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGluc2VydCgpXG4gICAgICogQGFsaWFzIGFkZFxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaW5zZXJ0JzogYXJyYXkucHJvdG90eXBlLmFkZFxuXG4gIH0pO1xuXG5cbiAgLyoqKlxuICAgKiBPYmplY3QgbW9kdWxlXG4gICAqIEVudW1lcmFibGUgbWV0aG9kcyBvbiBvYmplY3RzXG4gICAqXG4gICAqKiovXG5cbiAgIGZ1bmN0aW9uIGtleXNXaXRoT2JqZWN0Q29lcmNpb24ob2JqKSB7XG4gICAgIHJldHVybiBvYmplY3Qua2V5cyhjb2VyY2VQcmltaXRpdmVUb09iamVjdChvYmopKTtcbiAgIH1cblxuICAvKioqXG4gICAqIEBtZXRob2QgW2VudW1lcmFibGVdKDxvYmo+KVxuICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAqIEBzaG9ydCBFbnVtZXJhYmxlIG1ldGhvZHMgaW4gdGhlIEFycmF5IHBhY2thZ2UgYXJlIGFsc28gYXZhaWxhYmxlIHRvIHRoZSBPYmplY3QgY2xhc3MuIFRoZXkgd2lsbCBwZXJmb3JtIHRoZWlyIG5vcm1hbCBvcGVyYXRpb25zIGZvciBldmVyeSBwcm9wZXJ0eSBpbiA8b2JqPi5cbiAgICogQGV4dHJhIEluIGNhc2VzIHdoZXJlIGEgY2FsbGJhY2sgaXMgdXNlZCwgaW5zdGVhZCBvZiAlZWxlbWVudCwgaW5kZXglLCB0aGUgY2FsbGJhY2sgd2lsbCBpbnN0ZWFkIGJlIHBhc3NlZCAla2V5LCB2YWx1ZSUuIEVudW1lcmFibGUgbWV0aG9kcyBhcmUgYWxzbyBhdmFpbGFibGUgdG8gZXh0ZW5kZWQgb2JqZWN0cyBhcyBpbnN0YW5jZSBtZXRob2RzLlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgZWFjaFxuICAgKiAgIG1hcFxuICAgKiAgIGFueVxuICAgKiAgIGFsbFxuICAgKiAgIG5vbmVcbiAgICogICBjb3VudFxuICAgKiAgIGZpbmRcbiAgICogICBmaW5kQWxsXG4gICAqICAgcmVkdWNlXG4gICAqICAgaXNFbXB0eVxuICAgKiAgIHN1bVxuICAgKiAgIGF2ZXJhZ2VcbiAgICogICBtaW5cbiAgICogICBtYXhcbiAgICogICBsZWFzdFxuICAgKiAgIG1vc3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICBPYmplY3QuYW55KHtmb286J2Jhcid9LCAnYmFyJykgICAgICAgICAgICAtPiB0cnVlXG4gICAqICAgT2JqZWN0LmV4dGVuZGVkKHtmb286J2Jhcid9KS5hbnkoJ2JhcicpICAgLT4gdHJ1ZVxuICAgKiAgIE9iamVjdC5pc0VtcHR5KHt9KSAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRydWVcbiAgICsgICBPYmplY3QubWFwKHsgZnJlZDogeyBhZ2U6IDUyIH0gfSwgJ2FnZScpOyAtPiB7IGZyZWQ6IDUyIH1cbiAgICpcbiAgICoqKi9cblxuICBmdW5jdGlvbiBidWlsZEVudW1lcmFibGVNZXRob2RzKG5hbWVzLCBtYXBwaW5nKSB7XG4gICAgZXh0ZW5kU2ltaWxhcihvYmplY3QsIGZhbHNlLCB0cnVlLCBuYW1lcywgZnVuY3Rpb24obWV0aG9kcywgbmFtZSkge1xuICAgICAgbWV0aG9kc1tuYW1lXSA9IGZ1bmN0aW9uKG9iaiwgYXJnMSwgYXJnMikge1xuICAgICAgICB2YXIgcmVzdWx0LCBjb2VyY2VkID0ga2V5c1dpdGhPYmplY3RDb2VyY2lvbihvYmopLCBtYXRjaGVyO1xuICAgICAgICBpZighbWFwcGluZykge1xuICAgICAgICAgIG1hdGNoZXIgPSBnZXRNYXRjaGVyKGFyZzEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGFycmF5LnByb3RvdHlwZVtuYW1lXS5jYWxsKGNvZXJjZWQsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgIGlmKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Bcmd1bWVudCh2YWx1ZSwgYXJnMSwgb2JqLCBba2V5LCB2YWx1ZSwgb2JqXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKHZhbHVlLCBrZXksIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBhcmcyKTtcbiAgICAgICAgaWYoaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgLy8gVGhlIG1ldGhvZCBoYXMgcmV0dXJuZWQgYW4gYXJyYXkgb2Yga2V5cyBzbyB1c2UgdGhpcyBhcnJheVxuICAgICAgICAgIC8vIHRvIGJ1aWxkIHVwIHRoZSByZXN1bHRpbmcgb2JqZWN0IGluIHRoZSBmb3JtIHdlIHdhbnQgaXQgaW4uXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlZHVjZShmdW5jdGlvbihvLCBrZXksIGkpIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGJ1aWxkT2JqZWN0SW5zdGFuY2VNZXRob2RzKG5hbWVzLCBIYXNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cG9ydFNvcnRBbGdvcml0aG0oKSB7XG4gICAgYXJyYXlbQWxwaGFudW1lcmljU29ydF0gPSBjb2xsYXRlU3RyaW5ncztcbiAgfVxuXG4gIGV4dGVuZChvYmplY3QsIGZhbHNlLCB0cnVlLCB7XG5cbiAgICAnbWFwJzogZnVuY3Rpb24ob2JqLCBtYXApIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fSwga2V5LCB2YWx1ZTtcbiAgICAgIGZvcihrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmKCFoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9IHRyYW5zZm9ybUFyZ3VtZW50KHZhbHVlLCBtYXAsIG9iaiwgW2tleSwgdmFsdWUsIG9ial0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgJ3JlZHVjZSc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHZhbHVlcyA9IGtleXNXaXRoT2JqZWN0Q29lcmNpb24ob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UuYXBwbHkodmFsdWVzLCBtdWx0aUFyZ3MoYXJndW1lbnRzLCBudWxsLCAxKSk7XG4gICAgfSxcblxuICAgICdlYWNoJzogZnVuY3Rpb24ob2JqLCBmbikge1xuICAgICAgY2hlY2tDYWxsYmFjayhmbik7XG4gICAgICBpdGVyYXRlT3Zlck9iamVjdChvYmosIGZuKTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHNpemUoPG9iaj4pXG4gICAgICogQHJldHVybnMgTnVtYmVyXG4gICAgICogQHNob3J0IFJldHVybnMgdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzIGluIDxvYmo+LlxuICAgICAqIEBleHRyYSAlc2l6ZSUgaXMgYXZhaWxhYmxlIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBvbiBleHRlbmRlZCBvYmplY3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIE9iamVjdC5zaXplKHsgZm9vOiAnYmFyJyB9KSAtPiAxXG4gICAgICpcbiAgICAgKioqL1xuICAgICdzaXplJzogZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIGtleXNXaXRoT2JqZWN0Q29lcmNpb24ob2JqKS5sZW5ndGg7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHZhciBFbnVtZXJhYmxlRmluZGluZ01ldGhvZHMgPSAnYW55LGFsbCxub25lLGNvdW50LGZpbmQsZmluZEFsbCxpc0VtcHR5Jy5zcGxpdCgnLCcpO1xuICB2YXIgRW51bWVyYWJsZU1hcHBpbmdNZXRob2RzID0gJ3N1bSxhdmVyYWdlLG1pbixtYXgsbGVhc3QsbW9zdCcuc3BsaXQoJywnKTtcbiAgdmFyIEVudW1lcmFibGVPdGhlck1ldGhvZHMgICA9ICdtYXAscmVkdWNlLHNpemUnLnNwbGl0KCcsJyk7XG4gIHZhciBFbnVtZXJhYmxlTWV0aG9kcyAgICAgICAgPSBFbnVtZXJhYmxlRmluZGluZ01ldGhvZHMuY29uY2F0KEVudW1lcmFibGVNYXBwaW5nTWV0aG9kcykuY29uY2F0KEVudW1lcmFibGVPdGhlck1ldGhvZHMpO1xuXG4gIGJ1aWxkRW5oYW5jZW1lbnRzKCk7XG4gIGJ1aWxkQWxwaGFudW1lcmljU29ydCgpO1xuICBidWlsZEVudW1lcmFibGVNZXRob2RzKEVudW1lcmFibGVGaW5kaW5nTWV0aG9kcyk7XG4gIGJ1aWxkRW51bWVyYWJsZU1ldGhvZHMoRW51bWVyYWJsZU1hcHBpbmdNZXRob2RzLCB0cnVlKTtcbiAgYnVpbGRPYmplY3RJbnN0YW5jZU1ldGhvZHMoRW51bWVyYWJsZU90aGVyTWV0aG9kcywgSGFzaCk7XG4gIGV4cG9ydFNvcnRBbGdvcml0aG0oKTtcblxuXG4gIC8qKipcbiAgICogQHBhY2thZ2UgRGF0ZVxuICAgKiBAZGVwZW5kZW5jeSBjb3JlXG4gICAqIEBkZXNjcmlwdGlvbiBEYXRlIHBhcnNpbmcgYW5kIGZvcm1hdHRpbmcsIHJlbGF0aXZlIGZvcm1hdHMgbGlrZSBcIjEgbWludXRlIGFnb1wiLCBOdW1iZXIgbWV0aG9kcyBsaWtlIFwiZGF5c0Fnb1wiLCBsb2NhbGl6YXRpb24gc3VwcG9ydCB3aXRoIGRlZmF1bHQgRW5nbGlzaCBsb2NhbGUgZGVmaW5pdGlvbi5cbiAgICpcbiAgICoqKi9cblxuICB2YXIgRW5nbGlzaDtcbiAgdmFyIEN1cnJlbnRMb2NhbGl6YXRpb247XG5cbiAgdmFyIFRpbWVGb3JtYXQgPSBbJ2FtcG0nLCdob3VyJywnbWludXRlJywnc2Vjb25kJywnYW1wbScsJ3V0YycsJ29mZnNldF9zaWduJywnb2Zmc2V0X2hvdXJzJywnb2Zmc2V0X21pbnV0ZXMnLCdhbXBtJ11cbiAgdmFyIERlY2ltYWxSZWcgPSAnKD86WywuXVxcXFxkKyk/JztcbiAgdmFyIEhvdXJzUmVnICAgPSAnXFxcXGR7MSwyfScgKyBEZWNpbWFsUmVnO1xuICB2YXIgU2l4dHlSZWcgICA9ICdbMC01XVxcXFxkJyArIERlY2ltYWxSZWc7XG4gIHZhciBSZXF1aXJlZFRpbWUgPSAnKHt0fSk/XFxcXHMqKCcrSG91cnNSZWcrJykoPzp7aH0oJytTaXh0eVJlZysnKT97bX0oPzo6PygnK1NpeHR5UmVnKycpe3N9KT9cXFxccyooPzooe3R9KXwoWil8KD86KFsrLV0pKFxcXFxkezIsMn0pKD86Oj8oXFxcXGR7MiwyfSkpPyk/KT98XFxcXHMqKHt0fSkpJztcblxuICB2YXIgS2FuamlEaWdpdHMgPSAn44CH5LiA5LqM5LiJ5Zub5LqU5YWt5LiD5YWr5Lmd5Y2B55m+5Y2D5LiHJztcbiAgdmFyIEFzaWFuRGlnaXRNYXAgPSB7fTtcbiAgdmFyIEFzaWFuRGlnaXRSZWc7XG5cbiAgdmFyIERhdGVBcmd1bWVudFVuaXRzO1xuICB2YXIgRGF0ZVVuaXRzUmV2ZXJzZWQ7XG4gIHZhciBDb3JlRGF0ZUZvcm1hdHMgPSBbXTtcbiAgdmFyIENvbXBpbGVkT3V0cHV0Rm9ybWF0cyA9IHt9O1xuXG4gIHZhciBEYXRlRm9ybWF0VG9rZW5zID0ge1xuXG4gICAgJ3l5eXknOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gY2FsbERhdGVHZXQoZCwgJ0Z1bGxZZWFyJyk7XG4gICAgfSxcblxuICAgICd5eSc6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBjYWxsRGF0ZUdldChkLCAnRnVsbFllYXInKSAlIDEwMDtcbiAgICB9LFxuXG4gICAgJ29yZCc6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBkYXRlID0gY2FsbERhdGVHZXQoZCwgJ0RhdGUnKTtcbiAgICAgIHJldHVybiBkYXRlICsgZ2V0T3JkaW5hbGl6ZWRTdWZmaXgoZGF0ZSk7XG4gICAgfSxcblxuICAgICd0eic6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBkLmdldFVUQ09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAnaXNvdHonOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gZC5nZXRVVENPZmZzZXQodHJ1ZSk7XG4gICAgfSxcblxuICAgICdaJzogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGQuZ2V0VVRDT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgICdaWic6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBkLmdldFVUQ09mZnNldCgpLnJlcGxhY2UoLyhcXGR7Mn0pJC8sICc6JDEnKTtcbiAgICB9XG5cbiAgfTtcblxuICB2YXIgRGF0ZVVuaXRzID0gW1xuICAgIHtcbiAgICAgIG5hbWU6ICd5ZWFyJyxcbiAgICAgIG1ldGhvZDogJ0Z1bGxZZWFyJyxcbiAgICAgIGFtYmlndW91czogdHJ1ZSxcbiAgICAgIG11bHRpcGxpZXI6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGFkanVzdCA9IGQgPyAoZC5pc0xlYXBZZWFyKCkgPyAxIDogMCkgOiAwLjI1O1xuICAgICAgICByZXR1cm4gKDM2NSArIGFkanVzdCkgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vbnRoJyxcbiAgICAgIGVycm9yOiAwLjkxOSwgLy8gRmViIDEtMjggb3ZlciAxIG1vbnRoXG4gICAgICBtZXRob2Q6ICdNb250aCcsXG4gICAgICBhbWJpZ3VvdXM6IHRydWUsXG4gICAgICBtdWx0aXBsaWVyOiBmdW5jdGlvbihkLCBtcykge1xuICAgICAgICB2YXIgZGF5cyA9IDMwLjQzNzUsIGluTW9udGg7XG4gICAgICAgIGlmKGQpIHtcbiAgICAgICAgICBpbk1vbnRoID0gZC5kYXlzSW5Nb250aCgpO1xuICAgICAgICAgIGlmKG1zIDw9IGluTW9udGguZGF5cygpKSB7XG4gICAgICAgICAgICBkYXlzID0gaW5Nb250aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3dlZWsnLFxuICAgICAgbWV0aG9kOiAnSVNPV2VlaycsXG4gICAgICBtdWx0aXBsaWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2RheScsXG4gICAgICBlcnJvcjogMC45NTgsIC8vIERTVCB0cmF2ZXJzYWwgb3ZlciAxIGRheVxuICAgICAgbWV0aG9kOiAnRGF0ZScsXG4gICAgICBhbWJpZ3VvdXM6IHRydWUsXG4gICAgICBtdWx0aXBsaWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDI0ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnaG91cicsXG4gICAgICBtZXRob2Q6ICdIb3VycycsXG4gICAgICBtdWx0aXBsaWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDYwICogNjAgKiAxMDAwO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21pbnV0ZScsXG4gICAgICBtZXRob2Q6ICdNaW51dGVzJyxcbiAgICAgIG11bHRpcGxpZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gNjAgKiAxMDAwO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3NlY29uZCcsXG4gICAgICBtZXRob2Q6ICdTZWNvbmRzJyxcbiAgICAgIG11bHRpcGxpZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMTAwMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdtaWxsaXNlY29uZCcsXG4gICAgICBtZXRob2Q6ICdNaWxsaXNlY29uZHMnLFxuICAgICAgbXVsdGlwbGllcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgXTtcblxuXG5cblxuICAvLyBEYXRlIExvY2FsaXphdGlvblxuXG4gIHZhciBMb2NhbGl6YXRpb25zID0ge307XG5cbiAgLy8gTG9jYWxpemF0aW9uIG9iamVjdFxuXG4gIGZ1bmN0aW9uIExvY2FsaXphdGlvbihsKSB7XG4gICAgc2ltcGxlTWVyZ2UodGhpcywgbCk7XG4gICAgdGhpcy5jb21waWxlZEZvcm1hdHMgPSBDb3JlRGF0ZUZvcm1hdHMuY29uY2F0KCk7XG4gIH1cblxuICBMb2NhbGl6YXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgZ2V0TW9udGg6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmKGlzTnVtYmVyKG4pKSB7XG4gICAgICAgIHJldHVybiBuIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzWydtb250aHMnXS5pbmRleE9mKG4pICUgMTI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFdlZWtkYXk6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB0aGlzWyd3ZWVrZGF5cyddLmluZGV4T2YobikgJSA3O1xuICAgIH0sXG5cbiAgICBnZXROdW1iZXI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYoaXNOdW1iZXIobikpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9IGVsc2UgaWYobiAmJiAoaSA9IHRoaXNbJ251bWJlcnMnXS5pbmRleE9mKG4pKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIChpICsgMSkgJSAxMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXROdW1lcmljRGF0ZTogZnVuY3Rpb24obikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIG4ucmVwbGFjZShyZWdleHAodGhpc1snbnVtJ10sICdnJyksIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIG51bSA9IHNlbGYuZ2V0TnVtYmVyKGQpO1xuICAgICAgICByZXR1cm4gbnVtIHx8ICcnO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldFVuaXRJbmRleDogZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHRoaXNbJ3VuaXRzJ10uaW5kZXhPZihuKSAlIDg7XG4gICAgfSxcblxuICAgIGdldFJlbGF0aXZlRm9ybWF0OiBmdW5jdGlvbihhZHUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRBZGp1c3RlZFRvRm9ybWF0KGFkdSwgYWR1WzJdID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnKTtcbiAgICB9LFxuXG4gICAgZ2V0RHVyYXRpb246IGZ1bmN0aW9uKG1zKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QWRqdXN0ZWRUb0Zvcm1hdChnZXRBZGp1c3RlZFVuaXQobXMpLCAnZHVyYXRpb24nKTtcbiAgICB9LFxuXG4gICAgaGFzVmFyaWFudDogZnVuY3Rpb24oY29kZSkge1xuICAgICAgY29kZSA9IGNvZGUgfHwgdGhpcy5jb2RlO1xuICAgICAgcmV0dXJuIGNvZGUgPT09ICdlbicgfHwgY29kZSA9PT0gJ2VuLVVTJyA/IHRydWUgOiB0aGlzWyd2YXJpYW50J107XG4gICAgfSxcblxuICAgIG1hdGNoQU06IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ciA9PT0gdGhpc1snYW1wbSddWzBdO1xuICAgIH0sXG5cbiAgICBtYXRjaFBNOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIgJiYgc3RyID09PSB0aGlzWydhbXBtJ11bMV07XG4gICAgfSxcblxuICAgIGNvbnZlcnRBZGp1c3RlZFRvRm9ybWF0OiBmdW5jdGlvbihhZHUsIG1vZGUpIHtcbiAgICAgIHZhciBzaWduLCB1bml0LCBtdWx0LFxuICAgICAgICAgIG51bSAgICA9IGFkdVswXSxcbiAgICAgICAgICB1ICAgICAgPSBhZHVbMV0sXG4gICAgICAgICAgbXMgICAgID0gYWR1WzJdLFxuICAgICAgICAgIGZvcm1hdCA9IHRoaXNbbW9kZV0gfHwgdGhpc1sncmVsYXRpdmUnXTtcbiAgICAgIGlmKGlzRnVuY3Rpb24oZm9ybWF0KSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0LmNhbGwodGhpcywgbnVtLCB1LCBtcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBtdWx0ID0gdGhpc1sncGx1cmFsJ10gJiYgbnVtID4gMSA/IDEgOiAwO1xuICAgICAgdW5pdCA9IHRoaXNbJ3VuaXRzJ11bbXVsdCAqIDggKyB1XSB8fCB0aGlzWyd1bml0cyddW3VdO1xuICAgICAgaWYodGhpc1snY2FwaXRhbGl6ZVVuaXQnXSkgdW5pdCA9IHNpbXBsZUNhcGl0YWxpemUodW5pdCk7XG4gICAgICBzaWduID0gdGhpc1snbW9kaWZpZXJzJ10uZmlsdGVyKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0ubmFtZSA9PSAnc2lnbicgJiYgbS52YWx1ZSA9PSAobXMgPiAwID8gMSA6IC0xKTsgfSlbMF07XG4gICAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoL1xceyguKj8pXFx9L2csIGZ1bmN0aW9uKGZ1bGwsIG1hdGNoKSB7XG4gICAgICAgIHN3aXRjaChtYXRjaCkge1xuICAgICAgICAgIGNhc2UgJ251bSc6IHJldHVybiBudW07XG4gICAgICAgICAgY2FzZSAndW5pdCc6IHJldHVybiB1bml0O1xuICAgICAgICAgIGNhc2UgJ3NpZ24nOiByZXR1cm4gc2lnbi5zcmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRGb3JtYXRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlZEZvcm1hdCA/IFt0aGlzLmNhY2hlZEZvcm1hdF0uY29uY2F0KHRoaXMuY29tcGlsZWRGb3JtYXRzKSA6IHRoaXMuY29tcGlsZWRGb3JtYXRzO1xuICAgIH0sXG5cbiAgICBhZGRGb3JtYXQ6IGZ1bmN0aW9uKHNyYywgYWxsb3dzVGltZSwgbWF0Y2gsIHZhcmlhbnQsIGlzbykge1xuICAgICAgdmFyIHRvID0gbWF0Y2ggfHwgW10sIGxvYyA9IHRoaXMsIHRpbWUsIHRpbWVNYXJrZXJzLCBsYXN0SXNOdW1lcmFsO1xuXG4gICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFxzKy9nLCAnWywuIF0qJyk7XG4gICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFx7KFteLF0rPylcXH0vZywgZnVuY3Rpb24oYWxsLCBrKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgYXJyLCByZXN1bHQsXG4gICAgICAgICAgICBvcHQgICA9IGsubWF0Y2goL1xcPyQvKSxcbiAgICAgICAgICAgIG5jICAgID0gay5tYXRjaCgvXihcXGQrKVxcPz8kLyksXG4gICAgICAgICAgICBzbGljZSA9IGsubWF0Y2goLyhcXGQpKD86LShcXGQpKT8vKSxcbiAgICAgICAgICAgIGtleSAgID0gay5yZXBsYWNlKC9bXmEtel0rJC8sICcnKTtcbiAgICAgICAgaWYobmMpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxvY1sndG9rZW5zJ11bbmNbMV1dO1xuICAgICAgICB9IGVsc2UgaWYobG9jW2tleV0pIHtcbiAgICAgICAgICB2YWx1ZSA9IGxvY1trZXldO1xuICAgICAgICB9IGVsc2UgaWYobG9jW2tleSArICdzJ10pIHtcbiAgICAgICAgICB2YWx1ZSA9IGxvY1trZXkgKyAncyddO1xuICAgICAgICAgIGlmKHNsaWNlKSB7XG4gICAgICAgICAgICAvLyBDYW4ndCB1c2UgZmlsdGVyIGhlcmUgYXMgUHJvdG90eXBlIGhpamFja3MgdGhlIG1ldGhvZCBhbmQgZG9lc24ndFxuICAgICAgICAgICAgLy8gcGFzcyBhbiBpbmRleCwgc28gdXNlIGEgc2ltcGxlIGxvb3AgaW5zdGVhZCFcbiAgICAgICAgICAgIGFyciA9IFtdO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihtLCBpKSB7XG4gICAgICAgICAgICAgIHZhciBtb2QgPSBpICUgKGxvY1sndW5pdHMnXSA/IDggOiB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICBpZihtb2QgPj0gc2xpY2VbMV0gJiYgbW9kIDw9IChzbGljZVsyXSB8fCBzbGljZVsxXSkpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGFycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBhcnJheVRvQWx0ZXJuYXRlcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYobmMpIHtcbiAgICAgICAgICByZXN1bHQgPSAnKD86JyArIHZhbHVlICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCFtYXRjaCkge1xuICAgICAgICAgICAgdG8ucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSAnKCcgKyB2YWx1ZSArICcpJztcbiAgICAgICAgfVxuICAgICAgICBpZihvcHQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJz8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIGlmKGFsbG93c1RpbWUpIHtcbiAgICAgICAgdGltZSA9IHByZXBhcmVUaW1lKFJlcXVpcmVkVGltZSwgbG9jLCBpc28pO1xuICAgICAgICB0aW1lTWFya2VycyA9IFsndCcsJ1tcXFxcc1xcXFx1MzAwMF0nXS5jb25jYXQobG9jWyd0aW1lTWFya2VyJ10pO1xuICAgICAgICBsYXN0SXNOdW1lcmFsID0gc3JjLm1hdGNoKC9cXFxcZFxce1xcZCxcXGRcXH1cXCkrXFw/PyQvKTtcbiAgICAgICAgYWRkRGF0ZUlucHV0Rm9ybWF0KGxvYywgJyg/OicgKyB0aW1lICsgJylbLFxcXFxzXFxcXHUzMDAwXSs/JyArIHNyYywgVGltZUZvcm1hdC5jb25jYXQodG8pLCB2YXJpYW50KTtcbiAgICAgICAgYWRkRGF0ZUlucHV0Rm9ybWF0KGxvYywgc3JjICsgJyg/OlssXFxcXHNdKig/OicgKyB0aW1lTWFya2Vycy5qb2luKCd8JykgKyAobGFzdElzTnVtZXJhbCA/ICcrJyA6ICcqJykgKycpJyArIHRpbWUgKyAnKT8nLCB0by5jb25jYXQoVGltZUZvcm1hdCksIHZhcmlhbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkRGF0ZUlucHV0Rm9ybWF0KGxvYywgc3JjLCB0bywgdmFyaWFudCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cblxuICAvLyBMb2NhbGl6YXRpb24gaGVscGVyc1xuXG4gIGZ1bmN0aW9uIGdldExvY2FsaXphdGlvbihsb2NhbGVDb2RlLCBmYWxsYmFjaykge1xuICAgIHZhciBsb2M7XG4gICAgaWYoIWlzU3RyaW5nKGxvY2FsZUNvZGUpKSBsb2NhbGVDb2RlID0gJyc7XG4gICAgbG9jID0gTG9jYWxpemF0aW9uc1tsb2NhbGVDb2RlXSB8fCBMb2NhbGl6YXRpb25zW2xvY2FsZUNvZGUuc2xpY2UoMCwyKV07XG4gICAgaWYoZmFsbGJhY2sgPT09IGZhbHNlICYmICFsb2MpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbG9jYWxlLicpO1xuICAgIH1cbiAgICByZXR1cm4gbG9jIHx8IEN1cnJlbnRMb2NhbGl6YXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMb2NhbGl6YXRpb24obG9jYWxlQ29kZSwgc2V0KSB7XG4gICAgdmFyIGxvYywgY2FuQWJicmV2aWF0ZTtcblxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVGaWVsZChuYW1lKSB7XG4gICAgICB2YXIgdmFsID0gbG9jW25hbWVdO1xuICAgICAgaWYoaXNTdHJpbmcodmFsKSkge1xuICAgICAgICBsb2NbbmFtZV0gPSB2YWwuc3BsaXQoJywnKTtcbiAgICAgIH0gZWxzZSBpZighdmFsKSB7XG4gICAgICAgIGxvY1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2hBbHRlcm5hdGUoc3RyLCBmbikge1xuICAgICAgc3RyID0gc3RyLnNwbGl0KCcrJykubWFwKGZ1bmN0aW9uKHNwbGl0KSB7XG4gICAgICAgIHJldHVybiBzcGxpdC5yZXBsYWNlKC8oLispOiguKykkLywgZnVuY3Rpb24oZnVsbCwgYmFzZSwgc3VmZml4ZXMpIHtcbiAgICAgICAgICByZXR1cm4gc3VmZml4ZXMuc3BsaXQoJ3wnKS5tYXAoZnVuY3Rpb24oc3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZSArIHN1ZmZpeDtcbiAgICAgICAgICB9KS5qb2luKCd8Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkuam9pbignfCcpO1xuICAgICAgcmV0dXJuIHN0ci5zcGxpdCgnfCcpLmZvckVhY2goZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEFycmF5KG5hbWUsIGFiYnJldmlhdGUsIG11bHRpcGxlKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBsb2NbbmFtZV0uZm9yRWFjaChmdW5jdGlvbihmdWxsLCBpKSB7XG4gICAgICAgIGlmKGFiYnJldmlhdGUpIHtcbiAgICAgICAgICBmdWxsICs9ICcrJyArIGZ1bGwuc2xpY2UoMCwzKTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoQWx0ZXJuYXRlKGZ1bGwsIGZ1bmN0aW9uKGRheSwgaikge1xuICAgICAgICAgIGFycltqICogbXVsdGlwbGUgKyBpXSA9IGRheS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgbG9jW25hbWVdID0gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERpZ2l0KHN0YXJ0LCBzdG9wLCBhbGxvd051bWJlcnMpIHtcbiAgICAgIHZhciBzdHIgPSAnXFxcXGR7JyArIHN0YXJ0ICsgJywnICsgc3RvcCArICd9JztcbiAgICAgIGlmKGFsbG93TnVtYmVycykgc3RyICs9ICd8KD86JyArIGFycmF5VG9BbHRlcm5hdGVzKGxvY1snbnVtYmVycyddKSArICcpKyc7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE51bSgpIHtcbiAgICAgIHZhciBhcnIgPSBbJy0/XFxcXGQrJ10uY29uY2F0KGxvY1snYXJ0aWNsZXMnXSk7XG4gICAgICBpZihsb2NbJ251bWJlcnMnXSkgYXJyID0gYXJyLmNvbmNhdChsb2NbJ251bWJlcnMnXSk7XG4gICAgICByZXR1cm4gYXJyYXlUb0FsdGVybmF0ZXMoYXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXREZWZhdWx0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBsb2NbbmFtZV0gPSBsb2NbbmFtZV0gfHwgdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TW9kaWZpZXJzKCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgbG9jLm1vZGlmaWVyc0J5TmFtZSA9IHt9O1xuICAgICAgbG9jWydtb2RpZmllcnMnXS5wdXNoKHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICd5ZXN0ZXJkYXknLCAndmFsdWUnOiAtMSB9KTtcbiAgICAgIGxvY1snbW9kaWZpZXJzJ10ucHVzaCh7ICduYW1lJzogJ2RheScsICdzcmMnOiAndG9kYXknLCAndmFsdWUnOiAwIH0pO1xuICAgICAgbG9jWydtb2RpZmllcnMnXS5wdXNoKHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICd0b21vcnJvdycsICd2YWx1ZSc6IDEgfSk7XG4gICAgICBsb2NbJ21vZGlmaWVycyddLmZvckVhY2goZnVuY3Rpb24obW9kaWZpZXIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBtb2RpZmllci5uYW1lO1xuICAgICAgICBlYWNoQWx0ZXJuYXRlKG1vZGlmaWVyLnNyYywgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHZhciBsb2NFbnRyeSA9IGxvY1tuYW1lXTtcbiAgICAgICAgICBsb2MubW9kaWZpZXJzQnlOYW1lW3RdID0gbW9kaWZpZXI7XG4gICAgICAgICAgYXJyLnB1c2goeyBuYW1lOiBuYW1lLCBzcmM6IHQsIHZhbHVlOiBtb2RpZmllci52YWx1ZSB9KTtcbiAgICAgICAgICBsb2NbbmFtZV0gPSBsb2NFbnRyeSA/IGxvY0VudHJ5ICsgJ3wnICsgdCA6IHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBsb2NbJ2RheSddICs9ICd8JyArIGFycmF5VG9BbHRlcm5hdGVzKGxvY1snd2Vla2RheXMnXSk7XG4gICAgICBsb2NbJ21vZGlmaWVycyddID0gYXJyO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGxvY2FsZVxuICAgIGxvYyA9IG5ldyBMb2NhbGl6YXRpb24oc2V0KTtcbiAgICBpbml0aWFsaXplRmllbGQoJ21vZGlmaWVycycpO1xuICAgICdtb250aHMsd2Vla2RheXMsdW5pdHMsbnVtYmVycyxhcnRpY2xlcyx0b2tlbnMsdGltZU1hcmtlcixhbXBtLHRpbWVTdWZmaXhlcyxkYXRlUGFyc2UsdGltZVBhcnNlJy5zcGxpdCgnLCcpLmZvckVhY2goaW5pdGlhbGl6ZUZpZWxkKTtcblxuICAgIGNhbkFiYnJldmlhdGUgPSAhbG9jWydtb250aFN1ZmZpeCddO1xuXG4gICAgc2V0QXJyYXkoJ21vbnRocycsICAgY2FuQWJicmV2aWF0ZSwgMTIpO1xuICAgIHNldEFycmF5KCd3ZWVrZGF5cycsIGNhbkFiYnJldmlhdGUsIDcpO1xuICAgIHNldEFycmF5KCd1bml0cycsIGZhbHNlLCA4KTtcbiAgICBzZXRBcnJheSgnbnVtYmVycycsIGZhbHNlLCAxMCk7XG5cbiAgICBzZXREZWZhdWx0KCdjb2RlJywgbG9jYWxlQ29kZSk7XG4gICAgc2V0RGVmYXVsdCgnZGF0ZScsIGdldERpZ2l0KDEsMiwgbG9jWydkaWdpdERhdGUnXSkpO1xuICAgIHNldERlZmF1bHQoJ3llYXInLCBcIidcXFxcZHsyfXxcIiArIGdldERpZ2l0KDQsNCkpO1xuICAgIHNldERlZmF1bHQoJ251bScsIGdldE51bSgpKTtcblxuICAgIHNldE1vZGlmaWVycygpO1xuXG4gICAgaWYobG9jWydtb250aFN1ZmZpeCddKSB7XG4gICAgICBsb2NbJ21vbnRoJ10gPSBnZXREaWdpdCgxLDIpO1xuICAgICAgbG9jWydtb250aHMnXSA9ICcxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMicuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbiArIGxvY1snbW9udGhTdWZmaXgnXTsgfSk7XG4gICAgfVxuICAgIGxvY1snZnVsbF9tb250aCddID0gZ2V0RGlnaXQoMSwyKSArICd8JyArIGFycmF5VG9BbHRlcm5hdGVzKGxvY1snbW9udGhzJ10pO1xuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHRoZXNlIGZvcm1hdHMgaXMgdmVyeSBpbXBvcnRhbnQuIE9yZGVyIGlzIHJldmVyc2VkIHNvIGZvcm1hdHMgdGhhdCBjb21lXG4gICAgLy8gbGF0ZXIgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBmb3JtYXRzIHRoYXQgY29tZSBiZWZvcmUuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXRcbiAgICAvLyBtb3JlIHNwZWNpZmljIGZvcm1hdHMgc2hvdWxkIGNvbWUgbGF0ZXIsIGhvd2V2ZXIsIHRoZSB7eWVhcn0gZm9ybWF0IHNob3VsZCBjb21lIGJlZm9yZVxuICAgIC8vIHtkYXl9LCBhcyAyMDExIG5lZWRzIHRvIGJlIHBhcnNlZCBhcyBhIHllYXIgKDIwMTEpIGFuZCBub3QgZGF0ZSAoMjApICsgaG91cnMgKDExKVxuXG4gICAgLy8gSWYgdGhlIGxvY2FsZSBoYXMgdGltZSBzdWZmaXhlcyB0aGVuIGFkZCBhIHRpbWUgb25seSBmb3JtYXQgZm9yIHRoYXQgbG9jYWxlXG4gICAgLy8gdGhhdCBpcyBzZXBhcmF0ZSBmcm9tIHRoZSBjb3JlIEVuZ2xpc2gtYmFzZWQgb25lLlxuICAgIGlmKGxvY1sndGltZVN1ZmZpeGVzJ10ubGVuZ3RoID4gMCkge1xuICAgICAgbG9jLmFkZEZvcm1hdChwcmVwYXJlVGltZShSZXF1aXJlZFRpbWUsIGxvYyksIGZhbHNlLCBUaW1lRm9ybWF0KVxuICAgIH1cblxuICAgIGxvYy5hZGRGb3JtYXQoJ3tkYXl9JywgdHJ1ZSk7XG4gICAgbG9jLmFkZEZvcm1hdCgne21vbnRofScgKyAobG9jWydtb250aFN1ZmZpeCddIHx8ICcnKSk7XG4gICAgbG9jLmFkZEZvcm1hdCgne3llYXJ9JyArIChsb2NbJ3llYXJTdWZmaXgnXSB8fCAnJykpO1xuXG4gICAgbG9jWyd0aW1lUGFyc2UnXS5mb3JFYWNoKGZ1bmN0aW9uKHNyYykge1xuICAgICAgbG9jLmFkZEZvcm1hdChzcmMsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgbG9jWydkYXRlUGFyc2UnXS5mb3JFYWNoKGZ1bmN0aW9uKHNyYykge1xuICAgICAgbG9jLmFkZEZvcm1hdChzcmMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIExvY2FsaXphdGlvbnNbbG9jYWxlQ29kZV0gPSBsb2M7XG4gIH1cblxuXG4gIC8vIEdlbmVyYWwgaGVscGVyc1xuXG4gIGZ1bmN0aW9uIGFkZERhdGVJbnB1dEZvcm1hdChsb2NhbGUsIGZvcm1hdCwgbWF0Y2gsIHZhcmlhbnQpIHtcbiAgICBsb2NhbGUuY29tcGlsZWRGb3JtYXRzLnVuc2hpZnQoe1xuICAgICAgdmFyaWFudDogdmFyaWFudCxcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgcmVnOiByZWdleHAoJ14nICsgZm9ybWF0ICsgJyQnLCAnaScpLFxuICAgICAgdG86IG1hdGNoXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaW1wbGVDYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMCwxKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlUb0FsdGVybmF0ZXMoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAhIWVsO1xuICAgIH0pLmpvaW4oJ3wnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5ld0RhdGUoKSB7XG4gICAgdmFyIGZuID0gZGF0ZS5TdWdhck5ld0RhdGU7XG4gICAgcmV0dXJuIGZuID8gZm4oKSA6IG5ldyBkYXRlO1xuICB9XG5cbiAgLy8gRGF0ZSBhcmd1bWVudCBoZWxwZXJzXG5cbiAgZnVuY3Rpb24gY29sbGVjdERhdGVBcmd1bWVudHMoYXJncywgYWxsb3dEdXJhdGlvbikge1xuICAgIHZhciBvYmo7XG4gICAgaWYoaXNPYmplY3RUeXBlKGFyZ3NbMF0pKSB7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGFyZ3NbMF0pICYmICFpc051bWJlcihhcmdzWzFdKSkge1xuICAgICAgcmV0dXJuIFthcmdzWzBdXTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGFyZ3NbMF0pICYmIGFsbG93RHVyYXRpb24pIHtcbiAgICAgIHJldHVybiBbZ2V0RGF0ZVBhcmFtc0Zyb21TdHJpbmcoYXJnc1swXSksIGFyZ3NbMV1dO1xuICAgIH1cbiAgICBvYmogPSB7fTtcbiAgICBEYXRlQXJndW1lbnRVbml0cy5mb3JFYWNoKGZ1bmN0aW9uKHUsaSkge1xuICAgICAgb2JqW3UubmFtZV0gPSBhcmdzW2ldO1xuICAgIH0pO1xuICAgIHJldHVybiBbb2JqXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGVQYXJhbXNGcm9tU3RyaW5nKHN0ciwgbnVtKSB7XG4gICAgdmFyIG1hdGNoLCBwYXJhbXMgPSB7fTtcbiAgICBtYXRjaCA9IHN0ci5tYXRjaCgvXihcXGQrKT9cXHM/KFxcdys/KXM/JC9pKTtcbiAgICBpZihtYXRjaCkge1xuICAgICAgaWYoaXNVbmRlZmluZWQobnVtKSkge1xuICAgICAgICBudW0gPSBwYXJzZUludChtYXRjaFsxXSkgfHwgMTtcbiAgICAgIH1cbiAgICAgIHBhcmFtc1ttYXRjaFsyXS50b0xvd2VyQ2FzZSgpXSA9IG51bTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8vIERhdGUgaXRlcmF0aW9uIGhlbHBlcnNcblxuICBmdW5jdGlvbiBpdGVyYXRlT3ZlckRhdGVVbml0cyhmbiwgZnJvbSwgdG8pIHtcbiAgICB2YXIgaSwgdW5pdDtcbiAgICBpZihpc1VuZGVmaW5lZCh0bykpIHRvID0gRGF0ZVVuaXRzUmV2ZXJzZWQubGVuZ3RoO1xuICAgIGZvcihpID0gZnJvbSB8fCAwOyBpIDwgdG87IGkrKykge1xuICAgICAgdW5pdCA9IERhdGVVbml0c1JldmVyc2VkW2ldO1xuICAgICAgaWYoZm4odW5pdC5uYW1lLCB1bml0LCBpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGF0ZSBwYXJzaW5nIGhlbHBlcnNcblxuICBmdW5jdGlvbiBnZXRGb3JtYXRNYXRjaChtYXRjaCwgYXJyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB2YWx1ZSwgbnVtO1xuICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgaSkge1xuICAgICAgdmFsdWUgPSBtYXRjaFtpICsgMV07XG4gICAgICBpZihpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnKSByZXR1cm47XG4gICAgICBpZihrZXkgPT09ICd5ZWFyJykge1xuICAgICAgICBvYmoueWVhckFzU3RyaW5nID0gdmFsdWUucmVwbGFjZSgvJy8sICcnKTtcbiAgICAgIH1cbiAgICAgIG51bSA9IHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZSgvJy8sICcnKS5yZXBsYWNlKC8sLywgJy4nKSk7XG4gICAgICBvYmpba2V5XSA9ICFpc05hTihudW0pID8gbnVtIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5EYXRlSW5wdXQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9eanVzdCAoPz1ub3cpfFxcLiskL2ksICcnKTtcbiAgICByZXR1cm4gY29udmVydEFzaWFuRGlnaXRzKHN0cik7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0QXNpYW5EaWdpdHMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEFzaWFuRGlnaXRSZWcsIGZ1bmN0aW9uKGZ1bGwsIGRpc2FsbG93ZWQsIG1hdGNoKSB7XG4gICAgICB2YXIgc3VtID0gMCwgcGxhY2UgPSAxLCBsYXN0V2FzSG9sZGVyLCBsYXN0SG9sZGVyO1xuICAgICAgaWYoZGlzYWxsb3dlZCkgcmV0dXJuIGZ1bGw7XG4gICAgICBtYXRjaC5zcGxpdCgnJykucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24obGV0dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEFzaWFuRGlnaXRNYXBbbGV0dGVyXSwgaG9sZGVyID0gdmFsdWUgPiA5O1xuICAgICAgICBpZihob2xkZXIpIHtcbiAgICAgICAgICBpZihsYXN0V2FzSG9sZGVyKSBzdW0gKz0gcGxhY2U7XG4gICAgICAgICAgcGxhY2UgKj0gdmFsdWUgLyAobGFzdEhvbGRlciB8fCAxKTtcbiAgICAgICAgICBsYXN0SG9sZGVyID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYobGFzdFdhc0hvbGRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHBsYWNlICo9IDEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdW0gKz0gcGxhY2UgKiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0V2FzSG9sZGVyID0gaG9sZGVyO1xuICAgICAgfSk7XG4gICAgICBpZihsYXN0V2FzSG9sZGVyKSBzdW0gKz0gcGxhY2U7XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWREYXRlKGYsIGxvY2FsZUNvZGUsIHByZWZlciwgZm9yY2VVVEMpIHtcbiAgICB2YXIgZCwgcmVsYXRpdmUsIGJhc2VMb2NhbGl6YXRpb24sIGFmdGVyQ2FsbGJhY2tzLCBsb2MsIHNldCwgdW5pdCwgdW5pdEluZGV4LCB3ZWVrZGF5LCBudW0sIHRtcDtcblxuICAgIGQgPSBnZXROZXdEYXRlKCk7XG4gICAgYWZ0ZXJDYWxsYmFja3MgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGFmdGVyRGF0ZVNldChmbikge1xuICAgICAgYWZ0ZXJDYWxsYmFja3MucHVzaChmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyZUNhbGxiYWNrcygpIHtcbiAgICAgIGFmdGVyQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgZm4uY2FsbCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla2RheU9mTW9udGgoKSB7XG4gICAgICB2YXIgdyA9IGQuZ2V0V2Vla2RheSgpO1xuICAgICAgZC5zZXRXZWVrZGF5KCg3ICogKHNldFsnbnVtJ10gLSAxKSkgKyAodyA+IHdlZWtkYXkgPyB3ZWVrZGF5ICsgNyA6IHdlZWtkYXkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRVbml0RWRnZSgpIHtcbiAgICAgIHZhciBtb2RpZmllciA9IGxvYy5tb2RpZmllcnNCeU5hbWVbc2V0WydlZGdlJ11dO1xuICAgICAgaXRlcmF0ZU92ZXJEYXRlVW5pdHMoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZihpc0RlZmluZWQoc2V0W25hbWVdKSkge1xuICAgICAgICAgIHVuaXQgPSBuYW1lO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgNCk7XG4gICAgICBpZih1bml0ID09PSAneWVhcicpIHNldC5zcGVjaWZpY2l0eSA9ICdtb250aCc7XG4gICAgICBlbHNlIGlmKHVuaXQgPT09ICdtb250aCcgfHwgdW5pdCA9PT0gJ3dlZWsnKSBzZXQuc3BlY2lmaWNpdHkgPSAnZGF5JztcbiAgICAgIGRbKG1vZGlmaWVyLnZhbHVlIDwgMCA/ICdlbmRPZicgOiAnYmVnaW5uaW5nT2YnKSArIHNpbXBsZUNhcGl0YWxpemUodW5pdCldKCk7XG4gICAgICAvLyBUaGlzIHZhbHVlIG9mIC0yIGlzIGFyYml0cmFyeSBidXQgaXQncyBhIG5pY2UgY2xlYW4gd2F5IHRvIGhvb2sgaW50byB0aGlzIHN5c3RlbS5cbiAgICAgIGlmKG1vZGlmaWVyLnZhbHVlID09PSAtMikgZC5yZXNldCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlcGFyYXRlQWJzb2x1dGVVbml0cygpIHtcbiAgICAgIHZhciBwYXJhbXM7XG4gICAgICBpdGVyYXRlT3ZlckRhdGVVbml0cyhmdW5jdGlvbihuYW1lLCB1LCBpKSB7XG4gICAgICAgIGlmKG5hbWUgPT09ICdkYXknKSBuYW1lID0gJ2RhdGUnO1xuICAgICAgICBpZihpc0RlZmluZWQoc2V0W25hbWVdKSkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdGltZSB1bml0IHNldCB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdGhhblxuICAgICAgICAgIC8vIHRoZSBtYXRjaGVkIHVuaXQgd2UgaGF2ZSBhIHN0cmluZyBsaWtlIFwiNTozMGFtIGluIDIgbWludXRlc1wiLFxuICAgICAgICAgIC8vIHdoaWNoIGlzIG1lYW5pbmdsZXNzLCBzbyBpbnZhbGlkYXRlIHRoZSBkYXRlLi4uXG4gICAgICAgICAgaWYoaSA+PSB1bml0SW5kZXgpIHtcbiAgICAgICAgICAgIGludmFsaWRhdGVEYXRlKGQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyAuLi5vdGhlcndpc2Ugc2V0IHRoZSBwYXJhbXMgdG8gc2V0IHRoZSBhYnNvbHV0ZSBkYXRlXG4gICAgICAgICAgLy8gYXMgYSBjYWxsYmFjayBhZnRlciB0aGUgcmVsYXRpdmUgZGF0ZSBoYXMgYmVlbiBzZXQuXG4gICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IHNldFtuYW1lXTtcbiAgICAgICAgICBkZWxldGUgc2V0W25hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmKHBhcmFtcykge1xuICAgICAgICBhZnRlckRhdGVTZXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZC5zZXQocGFyYW1zLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZC51dGMoZm9yY2VVVEMpO1xuXG4gICAgaWYoaXNEYXRlKGYpKSB7XG4gICAgICAvLyBJZiB0aGUgc291cmNlIGhlcmUgaXMgYWxyZWFkeSBhIGRhdGUgb2JqZWN0LCB0aGVuIHRoZSBvcGVyYXRpb25cbiAgICAgIC8vIGlzIHRoZSBzYW1lIGFzIGNsb25pbmcgdGhlIGRhdGUsIHdoaWNoIHByZXNlcnZlcyB0aGUgVVRDIGZsYWcuXG4gICAgICBkLnV0YyhmLmlzVVRDKCkpLnNldFRpbWUoZi5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZihpc051bWJlcihmKSkge1xuICAgICAgZC5zZXRUaW1lKGYpO1xuICAgIH0gZWxzZSBpZihpc09iamVjdFR5cGUoZikpIHtcbiAgICAgIGQuc2V0KGYsIHRydWUpO1xuICAgICAgc2V0ID0gZjtcbiAgICB9IGVsc2UgaWYoaXNTdHJpbmcoZikpIHtcblxuICAgICAgLy8gVGhlIGFjdCBvZiBnZXR0aW5nIHRoZSBsb2NhbGl6YXRpb24gd2lsbCBwcmUtaW5pdGlhbGl6ZVxuICAgICAgLy8gaWYgaXQgaXMgbWlzc2luZyBhbmQgYWRkIHRoZSByZXF1aXJlZCBmb3JtYXRzLlxuICAgICAgYmFzZUxvY2FsaXphdGlvbiA9IGdldExvY2FsaXphdGlvbihsb2NhbGVDb2RlKTtcblxuICAgICAgLy8gQ2xlYW4gdGhlIGlucHV0IGFuZCBjb252ZXJ0IEthbmppIGJhc2VkIG51bWVyYWxzIGlmIHRoZXkgZXhpc3QuXG4gICAgICBmID0gY2xlYW5EYXRlSW5wdXQoZik7XG5cbiAgICAgIGlmKGJhc2VMb2NhbGl6YXRpb24pIHtcbiAgICAgICAgaXRlcmF0ZU92ZXJPYmplY3QoYmFzZUxvY2FsaXphdGlvbi5nZXRGb3JtYXRzKCksIGZ1bmN0aW9uKGksIGRpZikge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGYubWF0Y2goZGlmLnJlZyk7XG4gICAgICAgICAgaWYobWF0Y2gpIHtcblxuICAgICAgICAgICAgbG9jID0gZGlmLmxvY2FsZTtcbiAgICAgICAgICAgIHNldCA9IGdldEZvcm1hdE1hdGNoKG1hdGNoLCBkaWYudG8sIGxvYyk7XG4gICAgICAgICAgICBsb2MuY2FjaGVkRm9ybWF0ID0gZGlmO1xuXG5cbiAgICAgICAgICAgIGlmKHNldFsndXRjJ10pIHtcbiAgICAgICAgICAgICAgZC51dGMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc2V0LnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICBzZXQgPSBzZXQudGltZXN0YW1wO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSB2YXJpYW50IChjcmF6eSBFbmRpYW4gQW1lcmljYW4gZm9ybWF0KSwgc3dhcCB0aGUgbW9udGggYW5kIGRheS5cbiAgICAgICAgICAgIGlmKGRpZi52YXJpYW50ICYmICFpc1N0cmluZyhzZXRbJ21vbnRoJ10pICYmIChpc1N0cmluZyhzZXRbJ2RhdGUnXSkgfHwgYmFzZUxvY2FsaXphdGlvbi5oYXNWYXJpYW50KGxvY2FsZUNvZGUpKSkge1xuICAgICAgICAgICAgICB0bXAgPSBzZXRbJ21vbnRoJ107XG4gICAgICAgICAgICAgIHNldFsnbW9udGgnXSA9IHNldFsnZGF0ZSddO1xuICAgICAgICAgICAgICBzZXRbJ2RhdGUnXSAgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB5ZWFyIGlzIDIgZGlnaXRzIHRoZW4gZ2V0IHRoZSBpbXBsaWVkIGNlbnR1cnkuXG4gICAgICAgICAgICBpZihzZXRbJ3llYXInXSAmJiBzZXQueWVhckFzU3RyaW5nLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICBzZXRbJ3llYXInXSA9IGdldFllYXJGcm9tQWJicmV2aWF0aW9uKHNldFsneWVhciddKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBtb250aCB3aGljaCBtYXkgYmUgbG9jYWxpemVkLlxuICAgICAgICAgICAgaWYoc2V0Wydtb250aCddKSB7XG4gICAgICAgICAgICAgIHNldFsnbW9udGgnXSA9IGxvYy5nZXRNb250aChzZXRbJ21vbnRoJ10pO1xuICAgICAgICAgICAgICBpZihzZXRbJ3NoaWZ0J10gJiYgIXNldFsndW5pdCddKSBzZXRbJ3VuaXQnXSA9IGxvY1sndW5pdHMnXVs3XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYm90aCBhIHdlZWtkYXkgYW5kIGEgZGF0ZSwgdGhlIGRhdGUgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgICAgICAgIGlmKHNldFsnd2Vla2RheSddICYmIHNldFsnZGF0ZSddKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzZXRbJ3dlZWtkYXknXTtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZXQgYSBsb2NhbGl6ZWQgd2Vla2RheS5cbiAgICAgICAgICAgIH0gZWxzZSBpZihzZXRbJ3dlZWtkYXknXSkge1xuICAgICAgICAgICAgICBzZXRbJ3dlZWtkYXknXSA9IGxvYy5nZXRXZWVrZGF5KHNldFsnd2Vla2RheSddKTtcbiAgICAgICAgICAgICAgaWYoc2V0WydzaGlmdCddICYmICFzZXRbJ3VuaXQnXSkgc2V0Wyd1bml0J10gPSBsb2NbJ3VuaXRzJ11bNV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbGF0aXZlIGRheSBsb2NhbGl6YXRpb25zIHN1Y2ggYXMgXCJ0b2RheVwiIGFuZCBcInRvbW9ycm93XCIuXG4gICAgICAgICAgICBpZihzZXRbJ2RheSddICYmICh0bXAgPSBsb2MubW9kaWZpZXJzQnlOYW1lW3NldFsnZGF5J11dKSkge1xuICAgICAgICAgICAgICBzZXRbJ2RheSddID0gdG1wLnZhbHVlO1xuICAgICAgICAgICAgICBkLnJlc2V0KCk7XG4gICAgICAgICAgICAgIHJlbGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkYXkgaXMgYSB3ZWVrZGF5LCB0aGVuIHNldCB0aGF0IGluc3RlYWQuXG4gICAgICAgICAgICB9IGVsc2UgaWYoc2V0WydkYXknXSAmJiAod2Vla2RheSA9IGxvYy5nZXRXZWVrZGF5KHNldFsnZGF5J10pKSA+IC0xKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzZXRbJ2RheSddO1xuICAgICAgICAgICAgICBpZihzZXRbJ251bSddICYmIHNldFsnbW9udGgnXSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgXCJ0aGUgMm5kIHR1ZXNkYXkgb2YgSnVuZVwiLCBzZXQgdGhlIGRheSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtb250aCwgdGhlblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgd2Vla2RheSBhZnRlciBhbGwgb3RoZXIgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0LiBUaGUgd2Vla2RheSBuZWVkcyB0byBiZSBzZXRcbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgYWN0dWFsIHNldCBiZWNhdXNlIGl0IHJlcXVpcmVzIG92ZXJyaWRpbmcgdGhlIFwicHJlZmVyXCIgYXJndW1lbnQgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCB1bmludGVudGlvbmFsbHkgc2VuZCB0aGUgeWVhciBpbnRvIHRoZSBmdXR1cmUsIHBhc3QsIGV0Yy5cbiAgICAgICAgICAgICAgICBhZnRlckRhdGVTZXQoc2V0V2Vla2RheU9mTW9udGgpO1xuICAgICAgICAgICAgICAgIHNldFsnZGF5J10gPSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFsnd2Vla2RheSddID0gd2Vla2RheTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzZXRbJ2RhdGUnXSAmJiAhaXNOdW1iZXIoc2V0WydkYXRlJ10pKSB7XG4gICAgICAgICAgICAgIHNldFsnZGF0ZSddID0gbG9jLmdldE51bWVyaWNEYXRlKHNldFsnZGF0ZSddKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbWUgaXMgMXBtLTExcG0gYWR2YW5jZSB0aGUgdGltZSBieSAxMiBob3Vycy5cbiAgICAgICAgICAgIGlmKGxvYy5tYXRjaFBNKHNldFsnYW1wbSddKSAmJiBzZXRbJ2hvdXInXSA8IDEyKSB7XG4gICAgICAgICAgICAgIHNldFsnaG91ciddICs9IDEyO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGxvYy5tYXRjaEFNKHNldFsnYW1wbSddKSAmJiBzZXRbJ2hvdXInXSA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgc2V0Wydob3VyJ10gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGp1c3QgZm9yIHRpbWV6b25lIG9mZnNldFxuICAgICAgICAgICAgaWYoJ29mZnNldF9ob3VycycgaW4gc2V0IHx8ICdvZmZzZXRfbWludXRlcycgaW4gc2V0KSB7XG4gICAgICAgICAgICAgIGQudXRjKCk7XG4gICAgICAgICAgICAgIHNldFsnb2Zmc2V0X21pbnV0ZXMnXSA9IHNldFsnb2Zmc2V0X21pbnV0ZXMnXSB8fCAwO1xuICAgICAgICAgICAgICBzZXRbJ29mZnNldF9taW51dGVzJ10gKz0gc2V0WydvZmZzZXRfaG91cnMnXSAqIDYwO1xuICAgICAgICAgICAgICBpZihzZXRbJ29mZnNldF9zaWduJ10gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHNldFsnb2Zmc2V0X21pbnV0ZXMnXSAqPSAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRbJ21pbnV0ZSddIC09IHNldFsnb2Zmc2V0X21pbnV0ZXMnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGF0ZSBoYXMgYSB1bml0IGxpa2UgXCJkYXlzXCIsIFwibW9udGhzXCIsIGV0Yy4gYXJlIGFsbCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBkYXRlLlxuICAgICAgICAgICAgaWYoc2V0Wyd1bml0J10pIHtcbiAgICAgICAgICAgICAgcmVsYXRpdmUgID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbnVtICAgICAgID0gbG9jLmdldE51bWJlcihzZXRbJ251bSddKTtcbiAgICAgICAgICAgICAgdW5pdEluZGV4ID0gbG9jLmdldFVuaXRJbmRleChzZXRbJ3VuaXQnXSk7XG4gICAgICAgICAgICAgIHVuaXQgICAgICA9IEVuZ2xpc2hbJ3VuaXRzJ11bdW5pdEluZGV4XTtcblxuICAgICAgICAgICAgICAvLyBGb3JtYXRzIGxpa2UgXCJ0aGUgMTV0aCBvZiBsYXN0IG1vbnRoXCIgb3IgXCI2OjMwcG0gb2YgbmV4dCB3ZWVrXCJcbiAgICAgICAgICAgICAgLy8gY29udGFpbiBhYnNvbHV0ZSB1bml0cyBpbiBhZGRpdGlvbiB0byByZWxhdGl2ZSBvbmVzLCBzbyBzZXBhcmF0ZVxuICAgICAgICAgICAgICAvLyB0aGVtIGhlcmUsIHJlbW92ZSB0aGVtIGZyb20gdGhlIHBhcmFtcywgYW5kIHNldCB1cCBhIGNhbGxiYWNrIHRvXG4gICAgICAgICAgICAgIC8vIHNldCB0aGVtIGFmdGVyIHRoZSByZWxhdGl2ZSBvbmVzIGhhdmUgYmVlbiBzZXQuXG4gICAgICAgICAgICAgIHNlcGFyYXRlQWJzb2x1dGVVbml0cygpO1xuXG4gICAgICAgICAgICAgIC8vIFNoaWZ0IGFuZCB1bml0LCBpZSBcIm5leHQgbW9udGhcIiwgXCJsYXN0IHdlZWtcIiwgZXRjLlxuICAgICAgICAgICAgICBpZihzZXRbJ3NoaWZ0J10pIHtcbiAgICAgICAgICAgICAgICBudW0gKj0gKHRtcCA9IGxvYy5tb2RpZmllcnNCeU5hbWVbc2V0WydzaGlmdCddXSkgPyB0bXAudmFsdWUgOiAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVW5pdCBhbmQgc2lnbiwgaWUgXCJtb250aHMgYWdvXCIsIFwid2Vla3MgZnJvbSBub3dcIiwgZXRjLlxuICAgICAgICAgICAgICBpZihzZXRbJ3NpZ24nXSAmJiAodG1wID0gbG9jLm1vZGlmaWVyc0J5TmFtZVtzZXRbJ3NpZ24nXV0pKSB7XG4gICAgICAgICAgICAgICAgbnVtICo9IHRtcC52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFVuaXRzIGNhbiBiZSB3aXRoIG5vbi1yZWxhdGl2ZSBkYXRlcywgc2V0IGhlcmUuIGllIFwidGhlIGRheSBhZnRlciBtb25kYXlcIlxuICAgICAgICAgICAgICBpZihpc0RlZmluZWQoc2V0Wyd3ZWVrZGF5J10pKSB7XG4gICAgICAgICAgICAgICAgZC5zZXQoeyd3ZWVrZGF5Jzogc2V0Wyd3ZWVrZGF5J10gfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNldFsnd2Vla2RheSddO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmluYWxseSBzaGlmdCB0aGUgdW5pdC5cbiAgICAgICAgICAgICAgc2V0W3VuaXRdID0gKHNldFt1bml0XSB8fCAwKSArIG51bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gXCJlZGdlXCIgaXQgbmVlZHMgdG8gYmUgc2V0IGFmdGVyIHRoZVxuICAgICAgICAgICAgLy8gb3RoZXIgZmllbGRzIGFyZSBzZXQuIGllIFwidGhlIGVuZCBvZiBGZWJydWFyeVwiXG4gICAgICAgICAgICBpZihzZXRbJ2VkZ2UnXSkge1xuICAgICAgICAgICAgICBhZnRlckRhdGVTZXQoc2V0VW5pdEVkZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzZXRbJ3llYXJfc2lnbiddID09PSAnLScpIHtcbiAgICAgICAgICAgICAgc2V0Wyd5ZWFyJ10gKj0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZXJhdGVPdmVyRGF0ZVVuaXRzKGZ1bmN0aW9uKG5hbWUsIHVuaXQsIGkpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2V0W25hbWVdLCBmcmFjdGlvbiA9IHZhbHVlICUgMTtcbiAgICAgICAgICAgICAgaWYoZnJhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZXRbRGF0ZVVuaXRzUmV2ZXJzZWRbaSAtIDFdLm5hbWVdID0gcm91bmQoZnJhY3Rpb24gKiAobmFtZSA9PT0gJ3NlY29uZCcgPyAxMDAwIDogNjApKTtcbiAgICAgICAgICAgICAgICBzZXRbbmFtZV0gPSBmbG9vcih2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEsIDQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZighc2V0KSB7XG4gICAgICAgIC8vIFRoZSBEYXRlIGNvbnN0cnVjdG9yIGRvZXMgc29tZXRoaW5nIHRyaWNreSBsaWtlIGNoZWNraW5nIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgYXJndW1lbnRzIHNvIHNpbXBseSBwYXNzaW5nIGluIHVuZGVmaW5lZCB3b24ndCB3b3JrLlxuICAgICAgICBpZihmICE9PSAnbm93Jykge1xuICAgICAgICAgIGQgPSBuZXcgZGF0ZShmKTtcbiAgICAgICAgfVxuICAgICAgICBpZihmb3JjZVVUQykge1xuICAgICAgICAgIC8vIEZhbGxpbmcgYmFjayB0byBzeXN0ZW0gZGF0ZSBoZXJlIHdoaWNoIGNhbm5vdCBiZSBwYXJzZWQgYXMgVVRDLFxuICAgICAgICAgIC8vIHNvIGlmIHdlJ3JlIGZvcmNpbmcgVVRDIHRoZW4gc2ltcGx5IGFkZCB0aGUgb2Zmc2V0LlxuICAgICAgICAgIGQuYWRkTWludXRlcygtZC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHJlbGF0aXZlKSB7XG4gICAgICAgIGQuYWR2YW5jZShzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZC5fdXRjKSB7XG4gICAgICAgICAgLy8gVVRDIHRpbWVzIGNhbiB0cmF2ZXJzZSBpbnRvIG90aGVyIGRheXMgb3IgZXZlbiBtb250aHMsXG4gICAgICAgICAgLy8gc28gcHJlZW10aXZlbHkgcmVzZXQgdGhlIHRpbWUgaGVyZSB0byBwcmV2ZW50IHRoaXMuXG4gICAgICAgICAgZC5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZURhdGUoZCwgc2V0LCB0cnVlLCBmYWxzZSwgcHJlZmVyKTtcbiAgICAgIH1cbiAgICAgIGZpcmVDYWxsYmFja3MoKTtcbiAgICAgIC8vIEEgZGF0ZSBjcmVhdGVkIGJ5IHBhcnNpbmcgYSBzdHJpbmcgcHJlc3VtZXMgdGhhdCB0aGUgZm9ybWF0ICppdHNlbGYqIGlzIFVUQywgYnV0XG4gICAgICAvLyBub3QgdGhhdCB0aGUgZGF0ZSwgb25jZSBjcmVhdGVkLCBzaG91bGQgYmUgbWFuaXB1bGF0ZWQgYXMgc3VjaC4gSW4gb3RoZXIgd29yZHMsXG4gICAgICAvLyBpZiB5b3UgYXJlIGNyZWF0aW5nIGEgZGF0ZSBvYmplY3QgZnJvbSBhIHNlcnZlciB0aW1lIFwiMjAxMi0xMS0xNVQxMjowMDowMFpcIixcbiAgICAgIC8vIGluIHRoZSBtYWpvcml0eSBvZiBjYXNlcyB5b3UgYXJlIHVzaW5nIGl0IHRvIGNyZWF0ZSBhIGRhdGUgdGhhdCB3aWxsLCBhZnRlciBjcmVhdGlvbixcbiAgICAgIC8vIGJlIG1hbmlwdWxhdGVkIGFzIGxvY2FsLCBzbyByZXNldCB0aGUgdXRjIGZsYWcgaGVyZS5cbiAgICAgIGQudXRjKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGU6IGQsXG4gICAgICBzZXQ6IHNldFxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSB5ZWFyIGlzIHR3byBkaWdpdHMsIGFkZCB0aGUgbW9zdCBhcHByb3ByaWF0ZSBjZW50dXJ5IHByZWZpeC5cbiAgZnVuY3Rpb24gZ2V0WWVhckZyb21BYmJyZXZpYXRpb24oeWVhcikge1xuICAgIHJldHVybiByb3VuZChjYWxsRGF0ZUdldChnZXROZXdEYXRlKCksICdGdWxsWWVhcicpIC8gMTAwKSAqIDEwMCAtIHJvdW5kKHllYXIgLyAxMDApICogMTAwICsgeWVhcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNob3J0SG91cihkKSB7XG4gICAgdmFyIGhvdXJzID0gY2FsbERhdGVHZXQoZCwgJ0hvdXJzJyk7XG4gICAgcmV0dXJuIGhvdXJzID09PSAwID8gMTIgOiBob3VycyAtIChmbG9vcihob3VycyAvIDEzKSAqIDEyKTtcbiAgfVxuXG4gIC8vIHdlZWtzU2luY2Ugd29uJ3Qgd29yayBoZXJlIGFzIHRoZSByZXN1bHQgbmVlZHMgdG8gYmUgZmxvb3JlZCwgbm90IHJvdW5kZWQuXG4gIGZ1bmN0aW9uIGdldFdlZWtOdW1iZXIoZGF0ZSkge1xuICAgIGRhdGUgPSBkYXRlLmNsb25lKCk7XG4gICAgdmFyIGRvdyA9IGNhbGxEYXRlR2V0KGRhdGUsICdEYXknKSB8fCA3O1xuICAgIGRhdGUuYWRkRGF5cyg0IC0gZG93KS5yZXNldCgpO1xuICAgIHJldHVybiAxICsgZmxvb3IoZGF0ZS5kYXlzU2luY2UoZGF0ZS5jbG9uZSgpLmJlZ2lubmluZ09mWWVhcigpKSAvIDcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWRqdXN0ZWRVbml0KG1zKSB7XG4gICAgdmFyIG5leHQsIGFtcyA9IGFicyhtcyksIHZhbHVlID0gYW1zLCB1bml0SW5kZXggPSAwO1xuICAgIGl0ZXJhdGVPdmVyRGF0ZVVuaXRzKGZ1bmN0aW9uKG5hbWUsIHVuaXQsIGkpIHtcbiAgICAgIG5leHQgPSBmbG9vcih3aXRoUHJlY2lzaW9uKGFtcyAvIHVuaXQubXVsdGlwbGllcigpLCAxKSk7XG4gICAgICBpZihuZXh0ID49IDEpIHtcbiAgICAgICAgdmFsdWUgPSBuZXh0O1xuICAgICAgICB1bml0SW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0sIDEpO1xuICAgIHJldHVybiBbdmFsdWUsIHVuaXRJbmRleCwgbXNdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVsYXRpdmVXaXRoTW9udGhGYWxsYmFjayhkYXRlKSB7XG4gICAgdmFyIGFkdSA9IGdldEFkanVzdGVkVW5pdChkYXRlLm1pbGxpc2Vjb25kc0Zyb21Ob3coKSk7XG4gICAgaWYoYWxsb3dNb250aEZhbGxiYWNrKGRhdGUsIGFkdSkpIHtcbiAgICAgIC8vIElmIHRoZSBhZGp1c3RlZCB1bml0IGlzIGluIG1vbnRocywgdGhlbiBiZXR0ZXIgdG8gdXNlXG4gICAgICAvLyB0aGUgXCJtb250aHNmcm9tTm93XCIgd2hpY2ggYXBwbGllcyBhIHNwZWNpYWwgZXJyb3IgbWFyZ2luXG4gICAgICAvLyBmb3IgZWRnZSBjYXNlcyBzdWNoIGFzIEphbi0wOSAtIE1hci0wOSBiZWluZyBsZXNzIHRoYW5cbiAgICAgIC8vIDIgbW9udGhzIGFwYXJ0ICh3aGVuIHVzaW5nIGEgc3RyaWN0IG51bWVyaWMgZGVmaW5pdGlvbikuXG4gICAgICAvLyBUaGUgdGhpcmQgXCJtc1wiIGVsZW1lbnQgaW4gdGhlIGFycmF5IHdpbGwgaGFuZGxlIHRoZSBzaWduXG4gICAgICAvLyAocGFzdCBvciBmdXR1cmUpLCBzbyBzaW1wbHkgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWUgaGVyZS5cbiAgICAgIGFkdVswXSA9IGFicyhkYXRlLm1vbnRoc0Zyb21Ob3coKSk7XG4gICAgICBhZHVbMV0gPSA2O1xuICAgIH1cbiAgICByZXR1cm4gYWR1O1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsb3dNb250aEZhbGxiYWNrKGRhdGUsIGFkdSkge1xuICAgIC8vIEFsbG93IGZhbGxpbmcgYmFjayB0byBtb250aHNGcm9tTm93IGlmIHRoZSB1bml0IGlzIGluIG1vbnRocy4uLlxuICAgIHJldHVybiBhZHVbMV0gPT09IDYgfHxcbiAgICAvLyAuLi5vciBpZiBpdCdzID09PSA0IHdlZWtzIGFuZCB0aGVyZSBhcmUgbW9yZSBkYXlzIHRoYW4gaW4gdGhlIGdpdmVuIG1vbnRoXG4gICAgKGFkdVsxXSA9PT0gNSAmJiBhZHVbMF0gPT09IDQgJiYgZGF0ZS5kYXlzRnJvbU5vdygpID49IGdldE5ld0RhdGUoKS5kYXlzSW5Nb250aCgpKTtcbiAgfVxuXG5cbiAgLy8gRGF0ZSBmb3JtYXQgdG9rZW4gaGVscGVyc1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lcmlkaWFuVG9rZW5zKHNsaWNlLCBjYXBzKSB7XG4gICAgdmFyIGZuID0gZnVuY3Rpb24oZCwgbG9jYWxlQ29kZSkge1xuICAgICAgdmFyIGhvdXJzID0gY2FsbERhdGVHZXQoZCwgJ0hvdXJzJyk7XG4gICAgICByZXR1cm4gZ2V0TG9jYWxpemF0aW9uKGxvY2FsZUNvZGUpWydhbXBtJ11bZmxvb3IoaG91cnMgLyAxMildIHx8ICcnO1xuICAgIH1cbiAgICBjcmVhdGVGb3JtYXRUb2tlbigndCcsIGZuLCAxKTtcbiAgICBjcmVhdGVGb3JtYXRUb2tlbigndHQnLCBmbik7XG4gICAgY3JlYXRlRm9ybWF0VG9rZW4oJ1QnLCBmbiwgMSwgMSk7XG4gICAgY3JlYXRlRm9ybWF0VG9rZW4oJ1RUJywgZm4sIG51bGwsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2Vla2RheVRva2VucyhzbGljZSwgY2Fwcykge1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uKGQsIGxvY2FsZUNvZGUpIHtcbiAgICAgIHZhciBkb3cgPSBjYWxsRGF0ZUdldChkLCAnRGF5Jyk7XG4gICAgICByZXR1cm4gZ2V0TG9jYWxpemF0aW9uKGxvY2FsZUNvZGUpWyd3ZWVrZGF5cyddW2Rvd107XG4gICAgfVxuICAgIGNyZWF0ZUZvcm1hdFRva2VuKCdkb3cnLCBmbiwgMyk7XG4gICAgY3JlYXRlRm9ybWF0VG9rZW4oJ0RvdycsIGZuLCAzLCAxKTtcbiAgICBjcmVhdGVGb3JtYXRUb2tlbignd2Vla2RheScsIGZuKTtcbiAgICBjcmVhdGVGb3JtYXRUb2tlbignV2Vla2RheScsIGZuLCBudWxsLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1vbnRoVG9rZW5zKHNsaWNlLCBjYXBzKSB7XG4gICAgY3JlYXRlTW9udGhUb2tlbignbW9uJywgMCwgMyk7XG4gICAgY3JlYXRlTW9udGhUb2tlbignbW9udGgnLCAwKTtcblxuICAgIC8vIEZvciBpbmZsZWN0ZWQgbW9udGggZm9ybXMsIG5hbWVseSBSdXNzaWFuLlxuICAgIGNyZWF0ZU1vbnRoVG9rZW4oJ21vbnRoMicsIDEpO1xuICAgIGNyZWF0ZU1vbnRoVG9rZW4oJ21vbnRoMycsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTW9udGhUb2tlbih0b2tlbiwgbXVsdGlwbGllciwgc2xpY2UpIHtcbiAgICB2YXIgZm4gPSBmdW5jdGlvbihkLCBsb2NhbGVDb2RlKSB7XG4gICAgICB2YXIgbW9udGggPSBjYWxsRGF0ZUdldChkLCAnTW9udGgnKTtcbiAgICAgIHJldHVybiBnZXRMb2NhbGl6YXRpb24obG9jYWxlQ29kZSlbJ21vbnRocyddW21vbnRoICsgKG11bHRpcGxpZXIgKiAxMildO1xuICAgIH07XG4gICAgY3JlYXRlRm9ybWF0VG9rZW4odG9rZW4sIGZuLCBzbGljZSk7XG4gICAgY3JlYXRlRm9ybWF0VG9rZW4oc2ltcGxlQ2FwaXRhbGl6ZSh0b2tlbiksIGZuLCBzbGljZSwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGb3JtYXRUb2tlbih0LCBmbiwgc2xpY2UsIGNhcHMpIHtcbiAgICBEYXRlRm9ybWF0VG9rZW5zW3RdID0gZnVuY3Rpb24oZCwgbG9jYWxlQ29kZSkge1xuICAgICAgdmFyIHN0ciA9IGZuKGQsIGxvY2FsZUNvZGUpO1xuICAgICAgaWYoc2xpY2UpIHN0ciA9IHN0ci5zbGljZSgwLCBzbGljZSk7XG4gICAgICBpZihjYXBzKSAgc3RyID0gc3RyLnNsaWNlKDAsIGNhcHMpLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoY2Fwcyk7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhZGRlZFRva2VuKHQsIGZuLCBtcykge1xuICAgIERhdGVGb3JtYXRUb2tlbnNbdF0gPSBmbjtcbiAgICBEYXRlRm9ybWF0VG9rZW5zW3QgKyB0XSA9IGZ1bmN0aW9uIChkLCBsb2NhbGVDb2RlKSB7XG4gICAgICByZXR1cm4gcGFkTnVtYmVyKGZuKGQsIGxvY2FsZUNvZGUpLCAyKTtcbiAgICB9O1xuICAgIGlmKG1zKSB7XG4gICAgICBEYXRlRm9ybWF0VG9rZW5zW3QgKyB0ICsgdF0gPSBmdW5jdGlvbiAoZCwgbG9jYWxlQ29kZSkge1xuICAgICAgICByZXR1cm4gcGFkTnVtYmVyKGZuKGQsIGxvY2FsZUNvZGUpLCAzKTtcbiAgICAgIH07XG4gICAgICBEYXRlRm9ybWF0VG9rZW5zW3QgKyB0ICsgdCArIHRdID0gZnVuY3Rpb24gKGQsIGxvY2FsZUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHBhZE51bWJlcihmbihkLCBsb2NhbGVDb2RlKSwgNCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gRGF0ZSBmb3JtYXR0aW5nIGhlbHBlcnNcblxuICBmdW5jdGlvbiBidWlsZENvbXBpbGVkT3V0cHV0Rm9ybWF0KGZvcm1hdCkge1xuICAgIHZhciBtYXRjaCA9IGZvcm1hdC5tYXRjaCgvKFxce1xcdytcXH0pfFtee31dKy9nKTtcbiAgICBDb21waWxlZE91dHB1dEZvcm1hdHNbZm9ybWF0XSA9IG1hdGNoLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICBwLnJlcGxhY2UoL1xceyhcXHcrKVxcfS8sIGZ1bmN0aW9uKGZ1bGwsIHRva2VuKSB7XG4gICAgICAgIHAgPSBEYXRlRm9ybWF0VG9rZW5zW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4ZWN1dGVDb21waWxlZE91dHB1dEZvcm1hdChkYXRlLCBmb3JtYXQsIGxvY2FsZUNvZGUpIHtcbiAgICB2YXIgY29tcGlsZWRGb3JtYXQsIGxlbmd0aCwgaSwgdCwgcmVzdWx0ID0gJyc7XG4gICAgY29tcGlsZWRGb3JtYXQgPSBDb21waWxlZE91dHB1dEZvcm1hdHNbZm9ybWF0XTtcbiAgICBmb3IoaSA9IDAsIGxlbmd0aCA9IGNvbXBpbGVkRm9ybWF0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0ID0gY29tcGlsZWRGb3JtYXRbaV07XG4gICAgICByZXN1bHQgKz0gaXNGdW5jdGlvbih0KSA/IHQoZGF0ZSwgbG9jYWxlQ29kZSkgOiB0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHJlbGF0aXZlLCBsb2NhbGVDb2RlKSB7XG4gICAgdmFyIGFkdTtcbiAgICBpZighZGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiAnSW52YWxpZCBEYXRlJztcbiAgICB9IGVsc2UgaWYoRGF0ZVtmb3JtYXRdKSB7XG4gICAgICBmb3JtYXQgPSBEYXRlW2Zvcm1hdF07XG4gICAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oZm9ybWF0KSkge1xuICAgICAgYWR1ID0gZ2V0UmVsYXRpdmVXaXRoTW9udGhGYWxsYmFjayhkYXRlKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5hcHBseShkYXRlLCBhZHUuY29uY2F0KGdldExvY2FsaXphdGlvbihsb2NhbGVDb2RlKSkpO1xuICAgIH1cbiAgICBpZighZm9ybWF0ICYmIHJlbGF0aXZlKSB7XG4gICAgICBhZHUgPSBhZHUgfHwgZ2V0UmVsYXRpdmVXaXRoTW9udGhGYWxsYmFjayhkYXRlKTtcbiAgICAgIC8vIEFkanVzdCB1cCBpZiB0aW1lIGlzIGluIG1zLCBhcyB0aGlzIGRvZXNuJ3RcbiAgICAgIC8vIGxvb2sgdmVyeSBnb29kIGZvciBhIHN0YW5kYXJkIHJlbGF0aXZlIGRhdGUuXG4gICAgICBpZihhZHVbMV0gPT09IDApIHtcbiAgICAgICAgYWR1WzFdID0gMTtcbiAgICAgICAgYWR1WzBdID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRMb2NhbGl6YXRpb24obG9jYWxlQ29kZSkuZ2V0UmVsYXRpdmVGb3JtYXQoYWR1KTtcbiAgICB9XG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICdsb25nJztcbiAgICBpZihmb3JtYXQgPT09ICdzaG9ydCcgfHwgZm9ybWF0ID09PSAnbG9uZycgfHwgZm9ybWF0ID09PSAnZnVsbCcpIHtcbiAgICAgIGZvcm1hdCA9IGdldExvY2FsaXphdGlvbihsb2NhbGVDb2RlKVtmb3JtYXRdO1xuICAgIH1cblxuICAgIGlmKCFDb21waWxlZE91dHB1dEZvcm1hdHNbZm9ybWF0XSkge1xuICAgICAgYnVpbGRDb21waWxlZE91dHB1dEZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBleGVjdXRlQ29tcGlsZWRPdXRwdXRGb3JtYXQoZGF0ZSwgZm9ybWF0LCBsb2NhbGVDb2RlKTtcbiAgfVxuXG4gIC8vIERhdGUgY29tcGFyaXNvbiBoZWxwZXJzXG5cbiAgZnVuY3Rpb24gY29tcGFyZURhdGUoZCwgZmluZCwgbG9jYWxlQ29kZSwgYnVmZmVyLCBmb3JjZVVUQykge1xuICAgIHZhciBwLCB0LCBtaW4sIG1heCwgb3ZlcnJpZGUsIGNhcGl0YWxpemVkLCBhY2N1cmFjeSA9IDAsIGxvQnVmZmVyID0gMCwgaGlCdWZmZXIgPSAwO1xuICAgIHAgPSBnZXRFeHRlbmRlZERhdGUoZmluZCwgbG9jYWxlQ29kZSwgbnVsbCwgZm9yY2VVVEMpO1xuICAgIGlmKGJ1ZmZlciA+IDApIHtcbiAgICAgIGxvQnVmZmVyID0gaGlCdWZmZXIgPSBidWZmZXI7XG4gICAgICBvdmVycmlkZSA9IHRydWU7XG4gICAgfVxuICAgIGlmKCFwLmRhdGUuaXNWYWxpZCgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYocC5zZXQgJiYgcC5zZXQuc3BlY2lmaWNpdHkpIHtcbiAgICAgIERhdGVVbml0cy5mb3JFYWNoKGZ1bmN0aW9uKHUsIGkpIHtcbiAgICAgICAgaWYodS5uYW1lID09PSBwLnNldC5zcGVjaWZpY2l0eSkge1xuICAgICAgICAgIGFjY3VyYWN5ID0gdS5tdWx0aXBsaWVyKHAuZGF0ZSwgZCAtIHAuZGF0ZSkgLSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNhcGl0YWxpemVkID0gc2ltcGxlQ2FwaXRhbGl6ZShwLnNldC5zcGVjaWZpY2l0eSk7XG4gICAgICBpZihwLnNldFsnZWRnZSddIHx8IHAuc2V0WydzaGlmdCddKSB7XG4gICAgICAgIHAuZGF0ZVsnYmVnaW5uaW5nT2YnICsgY2FwaXRhbGl6ZWRdKCk7XG4gICAgICB9XG4gICAgICBpZihwLnNldC5zcGVjaWZpY2l0eSA9PT0gJ21vbnRoJykge1xuICAgICAgICBtYXggPSBwLmRhdGUuY2xvbmUoKVsnZW5kT2YnICsgY2FwaXRhbGl6ZWRdKCkuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgICAgaWYoIW92ZXJyaWRlICYmIHAuc2V0WydzaWduJ10gJiYgcC5zZXQuc3BlY2lmaWNpdHkgIT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAvLyBJZiB0aGUgdGltZSBpcyByZWxhdGl2ZSwgdGhlcmUgY2FuIG9jY2FzaW9uYWxseSBiZSBhbiBkaXNwYXJpdHkgYmV0d2VlbiB0aGUgcmVsYXRpdmUgZGF0ZVxuICAgICAgICAvLyBhbmQgXCJub3dcIiwgd2hpY2ggaXQgaXMgYmVpbmcgY29tcGFyZWQgdG8sIHNvIHNldCBhbiBleHRyYSBidWZmZXIgdG8gYWNjb3VudCBmb3IgdGhpcy5cbiAgICAgICAgbG9CdWZmZXIgPSA1MDtcbiAgICAgICAgaGlCdWZmZXIgPSAtNTA7XG4gICAgICB9XG4gICAgfVxuICAgIHQgICA9IGQuZ2V0VGltZSgpO1xuICAgIG1pbiA9IHAuZGF0ZS5nZXRUaW1lKCk7XG4gICAgbWF4ID0gbWF4IHx8IChtaW4gKyBhY2N1cmFjeSk7XG4gICAgbWF4ID0gY29tcGVuc2F0ZUZvclRpbWV6b25lVHJhdmVyc2FsKGQsIG1pbiwgbWF4KTtcbiAgICByZXR1cm4gdCA+PSAobWluIC0gbG9CdWZmZXIpICYmIHQgPD0gKG1heCArIGhpQnVmZmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBlbnNhdGVGb3JUaW1lem9uZVRyYXZlcnNhbChkLCBtaW4sIG1heCkge1xuICAgIHZhciBkTWluLCBkTWF4LCBtaW5PZmZzZXQsIG1heE9mZnNldDtcbiAgICBkTWluID0gbmV3IGRhdGUobWluKTtcbiAgICBkTWF4ID0gbmV3IGRhdGUobWF4KS51dGMoZC5pc1VUQygpKTtcbiAgICBpZihjYWxsRGF0ZUdldChkTWF4LCAnSG91cnMnKSAhPT0gMjMpIHtcbiAgICAgIG1pbk9mZnNldCA9IGRNaW4uZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIG1heE9mZnNldCA9IGRNYXguZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIGlmKG1pbk9mZnNldCAhPT0gbWF4T2Zmc2V0KSB7XG4gICAgICAgIG1heCArPSAobWF4T2Zmc2V0IC0gbWluT2Zmc2V0KS5taW51dGVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEYXRlKGQsIHBhcmFtcywgcmVzZXQsIGFkdmFuY2UsIHByZWZlcikge1xuICAgIHZhciB3ZWVrZGF5LCBzcGVjaWZpY2l0eUluZGV4O1xuXG4gICAgZnVuY3Rpb24gZ2V0UGFyYW0oa2V5KSB7XG4gICAgICByZXR1cm4gaXNEZWZpbmVkKHBhcmFtc1trZXldKSA/IHBhcmFtc1trZXldIDogcGFyYW1zW2tleSArICdzJ107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyYW1FeGlzdHMoa2V5KSB7XG4gICAgICByZXR1cm4gaXNEZWZpbmVkKGdldFBhcmFtKGtleSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXF1ZVBhcmFtRXhpc3RzKGtleSwgaXNEYXkpIHtcbiAgICAgIHJldHVybiBwYXJhbUV4aXN0cyhrZXkpIHx8IChpc0RheSAmJiBwYXJhbUV4aXN0cygnd2Vla2RheScpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5EaXNhbWJpZ3VhdGUoKSB7XG4gICAgICBzd2l0Y2gocHJlZmVyKSB7XG4gICAgICAgIGNhc2UgLTE6IHJldHVybiBkID4gZ2V0TmV3RGF0ZSgpO1xuICAgICAgICBjYXNlICAxOiByZXR1cm4gZCA8IGdldE5ld0RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihpc051bWJlcihwYXJhbXMpICYmIGFkdmFuY2UpIHtcbiAgICAgIC8vIElmIHBhcmFtIGlzIGEgbnVtYmVyIGFuZCB3ZSdyZSBhZHZhbmNpbmcsIHRoZSBudW1iZXIgaXMgcHJlc3VtZWQgdG8gYmUgbWlsbGlzZWNvbmRzLlxuICAgICAgcGFyYW1zID0geyAnbWlsbGlzZWNvbmRzJzogcGFyYW1zIH07XG4gICAgfSBlbHNlIGlmKGlzTnVtYmVyKHBhcmFtcykpIHtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHNldCB0aGUgdGltZXN0YW1wIGFuZCByZXR1cm4uXG4gICAgICBkLnNldFRpbWUocGFyYW1zKTtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIC8vIFwiZGF0ZVwiIGNhbiBhbHNvIGJlIHBhc3NlZCBmb3IgdGhlIGRheVxuICAgIGlmKGlzRGVmaW5lZChwYXJhbXNbJ2RhdGUnXSkpIHtcbiAgICAgIHBhcmFtc1snZGF5J10gPSBwYXJhbXNbJ2RhdGUnXTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBhbnkgdW5pdCBsb3dlciB0aGFuIHRoZSBsZWFzdCBzcGVjaWZpYyB1bml0IHNldC4gRG8gbm90IGRvIHRoaXMgZm9yIHdlZWtzXG4gICAgLy8gb3IgZm9yIHllYXJzLiBUaGlzIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCBiZWZvcmUgdGhlIGFjdXRhbCBzZXR0aW5nIG9mIHRoZSBkYXRlXG4gICAgLy8gYmVjYXVzZSB0aGUgb3JkZXIgbmVlZHMgdG8gYmUgcmV2ZXJzZWQgaW4gb3JkZXIgdG8gZ2V0IHRoZSBsb3dlc3Qgc3BlY2lmaWNpdHksXG4gICAgLy8gYWxzbyBiZWNhdXNlIGhpZ2hlciBvcmRlciB1bml0cyBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgbG93ZXIgb3JkZXIgdW5pdHMsIHN1Y2hcbiAgICAvLyBhcyBzZXR0aW5nIGhvdXI6IDMsIG1pbnV0ZTogMzQ1LCBldGMuXG4gICAgaXRlcmF0ZU92ZXJEYXRlVW5pdHMoZnVuY3Rpb24obmFtZSwgdW5pdCwgaSkge1xuICAgICAgdmFyIGlzRGF5ID0gbmFtZSA9PT0gJ2RheSc7XG4gICAgICBpZih1bmlxdWVQYXJhbUV4aXN0cyhuYW1lLCBpc0RheSkpIHtcbiAgICAgICAgcGFyYW1zLnNwZWNpZmljaXR5ID0gbmFtZTtcbiAgICAgICAgc3BlY2lmaWNpdHlJbmRleCA9ICtpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYocmVzZXQgJiYgbmFtZSAhPT0gJ3dlZWsnICYmICghaXNEYXkgfHwgIXBhcmFtRXhpc3RzKCd3ZWVrJykpKSB7XG4gICAgICAgIC8vIERheXMgYXJlIHJlbGF0aXZlIHRvIG1vbnRocywgbm90IHdlZWtzLCBzbyBkb24ndCByZXNldCBpZiBhIHdlZWsgZXhpc3RzLlxuICAgICAgICBjYWxsRGF0ZVNldChkLCB1bml0Lm1ldGhvZCwgKGlzRGF5ID8gMSA6IDApKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE5vdyBhY3R1YWxseSBzZXQgb3IgYWR2YW5jZSB0aGUgZGF0ZSBpbiBvcmRlciwgaGlnaGVyIHVuaXRzIGZpcnN0LlxuICAgIERhdGVVbml0cy5mb3JFYWNoKGZ1bmN0aW9uKHUsIGkpIHtcbiAgICAgIHZhciBuYW1lID0gdS5uYW1lLCBtZXRob2QgPSB1Lm1ldGhvZCwgaGlnaGVyVW5pdCA9IERhdGVVbml0c1tpIC0gMV0sIHZhbHVlO1xuICAgICAgdmFsdWUgPSBnZXRQYXJhbShuYW1lKVxuICAgICAgaWYoaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG4gICAgICBpZihhZHZhbmNlKSB7XG4gICAgICAgIGlmKG5hbWUgPT09ICd3ZWVrJykge1xuICAgICAgICAgIHZhbHVlICA9IChwYXJhbXNbJ2RheSddIHx8IDApICsgKHZhbHVlICogNyk7XG4gICAgICAgICAgbWV0aG9kID0gJ0RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gKHZhbHVlICogYWR2YW5jZSkgKyBjYWxsRGF0ZUdldChkLCBtZXRob2QpO1xuICAgICAgfSBlbHNlIGlmKG5hbWUgPT09ICdtb250aCcgJiYgcGFyYW1FeGlzdHMoJ2RheScpKSB7XG4gICAgICAgIC8vIFdoZW4gc2V0dGluZyB0aGUgbW9udGgsIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2Ugd2lsbCB0cmF2ZXJzZSBpbnRvIGEgbmV3IG1vbnRoLlxuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gRFNUIHNoaWZ0cywgZm9yIGV4YW1wbGUgSnVuZSAxc3QgRFNUIGp1bXBpbmcgdG8gSmFudWFyeSAxc3RcbiAgICAgICAgLy8gKG5vbi1EU1QpIHdpbGwgaGF2ZSBhIHNoaWZ0IG9mIC0xOjAwIHdoaWNoIHdpbGwgdHJhdmVyc2UgaW50byB0aGUgcHJldmlvdXMgeWVhci5cbiAgICAgICAgLy8gUHJldmVudCB0aGlzIGJ5IHByb2FjdGl2ZWx5IHNldHRpbmcgdGhlIGRheSB3aGVuIHdlIGtub3cgaXQgd2lsbCBiZSBzZXQgYWdhaW4gYW55d2F5LlxuICAgICAgICAvLyBJdCBjYW4gYWxzbyBoYXBwZW4gd2hlbiB0aGVyZSBhcmUgbm90IGVub3VnaCBkYXlzIGluIHRoZSB0YXJnZXQgbW9udGguIFRoaXMgc2Vjb25kXG4gICAgICAgIC8vIHNpdHVhdGlvbiBpcyBpZGVudGljYWwgdG8gY2hlY2tNb250aFRyYXZlcnNhbCBiZWxvdywgaG93ZXZlciB3aGVuIHdlIGFyZSBhZHZhbmNpbmdcbiAgICAgICAgLy8gd2Ugd2FudCB0byByZXNldCB0aGUgZGF0ZSB0byBcInRoZSBsYXN0IGRhdGUgaW4gdGhlIHRhcmdldCBtb250aFwiLiBJbiB0aGUgY2FzZSBvZlxuICAgICAgICAvLyBEU1Qgc2hpZnRzLCBob3dldmVyLCB3ZSB3YW50IHRvIGF2b2lkIHRoZSBcImVkZ2VzXCIgb2YgbW9udGhzIGFzIHRoYXQgaXMgd2hlcmUgdGhpc1xuICAgICAgICAvLyB1bmludGVuZGVkIHRyYXZlcnNhbCBjYW4gaGFwcGVuLiBUaGlzIGlzIHRoZSByZWFzb24gZm9yIHRoZSBkaWZmZXJlbnQgaGFuZGxpbmcgb2ZcbiAgICAgICAgLy8gdHdvIHNpbWlsYXIgYnV0IHNsaWdodGx5IGRpZmZlcmVudCBzaXR1YXRpb25zLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUTDtEUiBUaGlzIG1ldGhvZCBhdm9pZHMgdGhlIGVkZ2VzIG9mIGEgbW9udGggSUYgbm90IGFkdmFuY2luZyBhbmQgdGhlIGRhdGUgaXMgZ29pbmdcbiAgICAgICAgLy8gdG8gYmUgc2V0IGFueXdheSwgd2hpbGUgY2hlY2tNb250aFRyYXZlcnNhbCByZXNldHMgdGhlIGRhdGUgdG8gdGhlIGxhc3QgZGF5IGlmIGFkdmFuY2luZy5cbiAgICAgICAgLy9cbiAgICAgICAgY2FsbERhdGVTZXQoZCwgJ0RhdGUnLCAxNSk7XG4gICAgICB9XG4gICAgICBjYWxsRGF0ZVNldChkLCBtZXRob2QsIHZhbHVlKTtcbiAgICAgIGlmKGFkdmFuY2UgJiYgbmFtZSA9PT0gJ21vbnRoJykge1xuICAgICAgICBjaGVja01vbnRoVHJhdmVyc2FsKGQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gSWYgYSB3ZWVrZGF5IGlzIGluY2x1ZGVkIGluIHRoZSBwYXJhbXMsIHNldCBpdCBhaGVhZCBvZiB0aW1lIGFuZCBzZXQgdGhlIHBhcmFtc1xuICAgIC8vIHRvIHJlZmxlY3QgdGhlIHVwZGF0ZWQgZGF0ZSBzbyB0aGF0IHJlc2V0dGluZyB3b3JrcyBwcm9wZXJseS5cbiAgICBpZighYWR2YW5jZSAmJiAhcGFyYW1FeGlzdHMoJ2RheScpICYmIHBhcmFtRXhpc3RzKCd3ZWVrZGF5JykpIHtcbiAgICAgIHZhciB3ZWVrZGF5ID0gZ2V0UGFyYW0oJ3dlZWtkYXknKSwgaXNBaGVhZCwgZnV0dXJlUHJlZmVycmVkO1xuICAgICAgZC5zZXRXZWVrZGF5KHdlZWtkYXkpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3Qgb3IgZnV0dXJlIGlzIHByZWZlcnJlZCwgdGhlbiB0aGUgcHJvY2VzcyBvZiBcImRpc2FtYmlndWF0aW9uXCIgd2lsbCBlbnN1cmUgdGhhdCBhblxuICAgIC8vIGFtYmlndW91cyB0aW1lL2RhdGUgKFwiNHBtXCIsIFwidGh1cnNkYXlcIiwgXCJKdW5lXCIsIGV0Yy4pIHdpbGwgYmUgaW4gdGhlIHBhc3Qgb3IgZnV0dXJlLlxuICAgIGlmKGNhbkRpc2FtYmlndWF0ZSgpKSB7XG4gICAgICBpdGVyYXRlT3ZlckRhdGVVbml0cyhmdW5jdGlvbihuYW1lLCB1bml0KSB7XG4gICAgICAgIHZhciBhbWJpZ3VvdXMgPSB1bml0LmFtYmlndW91cyB8fCAobmFtZSA9PT0gJ3dlZWsnICYmIHBhcmFtRXhpc3RzKCd3ZWVrZGF5JykpO1xuICAgICAgICBpZihhbWJpZ3VvdXMgJiYgIXVuaXF1ZVBhcmFtRXhpc3RzKG5hbWUsIG5hbWUgPT09ICdkYXknKSkge1xuICAgICAgICAgIGRbdW5pdC5hZGRNZXRob2RdKHByZWZlcik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCBzcGVjaWZpY2l0eUluZGV4ICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9XG5cbiAgLy8gVGhlIElTTyBmb3JtYXQgYWxsb3dzIHRpbWVzIHN0cnVuZyB0b2dldGhlciB3aXRob3V0IGEgZGVtYXJjYXRpbmcgXCI6XCIsIHNvIG1ha2Ugc3VyZVxuICAvLyB0aGF0IHRoZXNlIG1hcmtlcnMgYXJlIG5vdyBvcHRpb25hbC5cbiAgZnVuY3Rpb24gcHJlcGFyZVRpbWUoZm9ybWF0LCBsb2MsIGlzbykge1xuICAgIHZhciB0aW1lU3VmZml4TWFwcGluZyA9IHsnaCc6MCwnbSc6MSwncyc6Mn0sIGFkZDtcbiAgICBsb2MgPSBsb2MgfHwgRW5nbGlzaDtcbiAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoL3soW2Etel0pfS9nLCBmdW5jdGlvbihmdWxsLCB0b2tlbikge1xuICAgICAgdmFyIHNlcGFyYXRvcnMgPSBbXSxcbiAgICAgICAgICBpc0hvdXJzID0gdG9rZW4gPT09ICdoJyxcbiAgICAgICAgICB0b2tlbklzUmVxdWlyZWQgPSBpc0hvdXJzICYmICFpc287XG4gICAgICBpZih0b2tlbiA9PT0gJ3QnKSB7XG4gICAgICAgIHJldHVybiBsb2NbJ2FtcG0nXS5qb2luKCd8Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZihpc0hvdXJzKSB7XG4gICAgICAgICAgc2VwYXJhdG9ycy5wdXNoKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWRkID0gbG9jWyd0aW1lU3VmZml4ZXMnXVt0aW1lU3VmZml4TWFwcGluZ1t0b2tlbl1dKSB7XG4gICAgICAgICAgc2VwYXJhdG9ycy5wdXNoKGFkZCArICdcXFxccyonKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VwYXJhdG9ycy5sZW5ndGggPT09IDAgPyAnJyA6ICcoPzonICsgc2VwYXJhdG9ycy5qb2luKCd8JykgKyAnKScgKyAodG9rZW5Jc1JlcXVpcmVkID8gJycgOiAnPycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cblxuICAvLyBJZiB0aGUgbW9udGggaXMgYmVpbmcgc2V0LCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gYWNjaWRlbnRhbGx5XG4gIC8vIHRyYXZlcnNlIGludG8gYSBuZXcgbW9udGgganVzdCBiZWNhdXNlIHRoZSB0YXJnZXQgbW9udGggZG9lc24ndCBoYXZlIGVub3VnaFxuICAvLyBkYXlzLiBJbiBvdGhlciB3b3JkcywgXCI1IG1vbnRocyBhZ29cIiBmcm9tIEp1bHkgMzB0aCBpcyBzdGlsbCBGZWJydWFyeSwgZXZlblxuICAvLyB0aG91Z2ggdGhlcmUgaXMgbm8gRmVicnVhcnkgMzB0aCwgc28gaXQgd2lsbCBvZiBuZWNlc3NpdHkgYmUgRmVicnVhcnkgMjh0aFxuICAvLyAob3IgMjl0aCBpbiB0aGUgY2FzZSBvZiBhIGxlYXAgeWVhcikuXG5cbiAgZnVuY3Rpb24gY2hlY2tNb250aFRyYXZlcnNhbChkYXRlLCB0YXJnZXRNb250aCkge1xuICAgIGlmKHRhcmdldE1vbnRoIDwgMCkge1xuICAgICAgdGFyZ2V0TW9udGggPSB0YXJnZXRNb250aCAlIDEyICsgMTI7XG4gICAgfVxuICAgIGlmKHRhcmdldE1vbnRoICUgMTIgIT0gY2FsbERhdGVHZXQoZGF0ZSwgJ01vbnRoJykpIHtcbiAgICAgIGNhbGxEYXRlU2V0KGRhdGUsICdEYXRlJywgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRGF0ZShhcmdzLCBwcmVmZXIsIGZvcmNlVVRDKSB7XG4gICAgdmFyIGYsIGxvY2FsZUNvZGU7XG4gICAgaWYoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgIC8vIElmIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBudW1iZXIsIHRoZW4gd2UgaGF2ZSBhbiBlbnVtZXJhdGVkIGNvbnN0cnVjdG9yIHR5cGUgYXMgaW4gXCJuZXcgRGF0ZSgyMDAzLCAyLCAxMik7XCJcbiAgICAgIGYgPSBjb2xsZWN0RGF0ZUFyZ3VtZW50cyhhcmdzKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZiAgICAgICAgICA9IGFyZ3NbMF07XG4gICAgICBsb2NhbGVDb2RlID0gYXJnc1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEV4dGVuZGVkRGF0ZShmLCBsb2NhbGVDb2RlLCBwcmVmZXIsIGZvcmNlVVRDKS5kYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZURhdGUoZCkge1xuICAgIGQuc2V0VGltZShOYU4pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGREYXRlVW5pdHMoKSB7XG4gICAgRGF0ZVVuaXRzUmV2ZXJzZWQgPSBEYXRlVW5pdHMuY29uY2F0KCkucmV2ZXJzZSgpO1xuICAgIERhdGVBcmd1bWVudFVuaXRzID0gRGF0ZVVuaXRzLmNvbmNhdCgpO1xuICAgIERhdGVBcmd1bWVudFVuaXRzLnNwbGljZSgyLDEpO1xuICB9XG5cblxuICAvKioqXG4gICAqIEBtZXRob2QgW3VuaXRzXVNpbmNlKFtkXSwgW2xvY2FsZV0gPSBjdXJyZW50TG9jYWxlKVxuICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICogQHNob3J0IFJldHVybnMgdGhlIHRpbWUgc2luY2UgW2RdIGluIHRoZSBhcHByb3ByaWF0ZSB1bml0LlxuICAgKiBAZXh0cmEgW2RdIHdpbGwgYWNjZXB0IGEgZGF0ZSBvYmplY3QsIHRpbWVzdGFtcCwgb3IgdGV4dCBmb3JtYXQuIElmIG5vdCBzcGVjaWZpZWQsIFtkXSBpcyBhc3N1bWVkIHRvIGJlIG5vdy4gW2xvY2FsZV0gY2FuIGJlIHBhc3NlZCB0byBzcGVjaWZ5IHRoZSBsb2NhbGUgdGhhdCB0aGUgZGF0ZSBpcyBpbi4gJVt1bml0XUFnbyUgaXMgcHJvdmlkZWQgYXMgYW4gYWxpYXMgdG8gbWFrZSB0aGlzIG1vcmUgcmVhZGFibGUgd2hlbiBbZF0gaXMgYXNzdW1lZCB0byBiZSB0aGUgY3VycmVudCBkYXRlLiBGb3IgbW9yZSBzZWUgQGRhdGVfZm9ybWF0LlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgbWlsbGlzZWNvbmRzU2luY2VcbiAgICogICBzZWNvbmRzU2luY2VcbiAgICogICBtaW51dGVzU2luY2VcbiAgICogICBob3Vyc1NpbmNlXG4gICAqICAgZGF5c1NpbmNlXG4gICAqICAgd2Vla3NTaW5jZVxuICAgKiAgIG1vbnRoc1NpbmNlXG4gICAqICAgeWVhcnNTaW5jZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIERhdGUuY3JlYXRlKCkubWlsbGlzZWNvbmRzU2luY2UoJzEgaG91ciBhZ28nKSAtPiAzLDYwMCwwMDBcbiAgICogICBEYXRlLmNyZWF0ZSgpLmRheXNTaW5jZSgnMSB3ZWVrIGFnbycpICAgICAgICAgLT4gN1xuICAgKiAgIERhdGUuY3JlYXRlKCkueWVhcnNTaW5jZSgnMTUgeWVhcnMgYWdvJykgICAgICAtPiAxNVxuICAgKiAgIERhdGUuY3JlYXRlKCcxNSB5ZWFycyBhZ28nKS55ZWFyc0FnbygpICAgICAgICAtPiAxNVxuICAgKlxuICAgKioqXG4gICAqIEBtZXRob2QgW3VuaXRzXUFnbygpXG4gICAqIEByZXR1cm5zIE51bWJlclxuICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgdGltZSBhZ28gaW4gdGhlIGFwcHJvcHJpYXRlIHVuaXQuXG4gICAqXG4gICAqIEBzZXRcbiAgICogICBtaWxsaXNlY29uZHNBZ29cbiAgICogICBzZWNvbmRzQWdvXG4gICAqICAgbWludXRlc0Fnb1xuICAgKiAgIGhvdXJzQWdvXG4gICAqICAgZGF5c0Fnb1xuICAgKiAgIHdlZWtzQWdvXG4gICAqICAgbW9udGhzQWdvXG4gICAqICAgeWVhcnNBZ29cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICBEYXRlLmNyZWF0ZSgnbGFzdCB5ZWFyJykubWlsbGlzZWNvbmRzQWdvKCkgLT4gMyw2MDAsMDAwXG4gICAqICAgRGF0ZS5jcmVhdGUoJ2xhc3QgeWVhcicpLmRheXNBZ28oKSAgICAgICAgIC0+IDdcbiAgICogICBEYXRlLmNyZWF0ZSgnbGFzdCB5ZWFyJykueWVhcnNBZ28oKSAgICAgICAgLT4gMTVcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIFt1bml0c11VbnRpbChbZF0sIFtsb2NhbGVdID0gY3VycmVudExvY2FsZSlcbiAgICogQHJldHVybnMgTnVtYmVyXG4gICAqIEBzaG9ydCBSZXR1cm5zIHRoZSB0aW1lIHVudGlsIFtkXSBpbiB0aGUgYXBwcm9wcmlhdGUgdW5pdC5cbiAgICogQGV4dHJhIFtkXSB3aWxsIGFjY2VwdCBhIGRhdGUgb2JqZWN0LCB0aW1lc3RhbXAsIG9yIHRleHQgZm9ybWF0LiBJZiBub3Qgc3BlY2lmaWVkLCBbZF0gaXMgYXNzdW1lZCB0byBiZSBub3cuIFtsb2NhbGVdIGNhbiBiZSBwYXNzZWQgdG8gc3BlY2lmeSB0aGUgbG9jYWxlIHRoYXQgdGhlIGRhdGUgaXMgaW4uICVbdW5pdF1Gcm9tTm93JSBpcyBwcm92aWRlZCBhcyBhbiBhbGlhcyB0byBtYWtlIHRoaXMgbW9yZSByZWFkYWJsZSB3aGVuIFtkXSBpcyBhc3N1bWVkIHRvIGJlIHRoZSBjdXJyZW50IGRhdGUuIEZvciBtb3JlIHNlZSBAZGF0ZV9mb3JtYXQuXG4gICAqXG4gICAqIEBzZXRcbiAgICogICBtaWxsaXNlY29uZHNVbnRpbFxuICAgKiAgIHNlY29uZHNVbnRpbFxuICAgKiAgIG1pbnV0ZXNVbnRpbFxuICAgKiAgIGhvdXJzVW50aWxcbiAgICogICBkYXlzVW50aWxcbiAgICogICB3ZWVrc1VudGlsXG4gICAqICAgbW9udGhzVW50aWxcbiAgICogICB5ZWFyc1VudGlsXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5taWxsaXNlY29uZHNVbnRpbCgnMSBob3VyIGZyb20gbm93JykgLT4gMyw2MDAsMDAwXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5kYXlzVW50aWwoJzEgd2VlayBmcm9tIG5vdycpICAgICAgICAgLT4gN1xuICAgKiAgIERhdGUuY3JlYXRlKCkueWVhcnNVbnRpbCgnMTUgeWVhcnMgZnJvbSBub3cnKSAgICAgIC0+IDE1XG4gICAqICAgRGF0ZS5jcmVhdGUoJzE1IHllYXJzIGZyb20gbm93JykueWVhcnNGcm9tTm93KCkgICAgLT4gMTVcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIFt1bml0c11Gcm9tTm93KClcbiAgICogQHJldHVybnMgTnVtYmVyXG4gICAqIEBzaG9ydCBSZXR1cm5zIHRoZSB0aW1lIGZyb20gbm93IGluIHRoZSBhcHByb3ByaWF0ZSB1bml0LlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgbWlsbGlzZWNvbmRzRnJvbU5vd1xuICAgKiAgIHNlY29uZHNGcm9tTm93XG4gICAqICAgbWludXRlc0Zyb21Ob3dcbiAgICogICBob3Vyc0Zyb21Ob3dcbiAgICogICBkYXlzRnJvbU5vd1xuICAgKiAgIHdlZWtzRnJvbU5vd1xuICAgKiAgIG1vbnRoc0Zyb21Ob3dcbiAgICogICB5ZWFyc0Zyb21Ob3dcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICBEYXRlLmNyZWF0ZSgnbmV4dCB5ZWFyJykubWlsbGlzZWNvbmRzRnJvbU5vdygpIC0+IDMsNjAwLDAwMFxuICAgKiAgIERhdGUuY3JlYXRlKCduZXh0IHllYXInKS5kYXlzRnJvbU5vdygpICAgICAgICAgLT4gN1xuICAgKiAgIERhdGUuY3JlYXRlKCduZXh0IHllYXInKS55ZWFyc0Zyb21Ob3coKSAgICAgICAgLT4gMTVcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIGFkZFtVbml0c10oPG51bT4sIFtyZXNldF0gPSBmYWxzZSlcbiAgICogQHJldHVybnMgRGF0ZVxuICAgKiBAc2hvcnQgQWRkcyA8bnVtPiBvZiB0aGUgdW5pdCB0byB0aGUgZGF0ZS4gSWYgW3Jlc2V0XSBpcyB0cnVlLCBhbGwgbG93ZXIgdW5pdHMgd2lsbCBiZSByZXNldC5cbiAgICogQGV4dHJhIE5vdGUgdGhhdCBcIm1vbnRoc1wiIGlzIGFtYmlndW91cyBhcyBhIHVuaXQgb2YgdGltZS4gSWYgdGhlIHRhcmdldCBkYXRlIGZhbGxzIG9uIGEgZGF5IHRoYXQgZG9lcyBub3QgZXhpc3QgKGllLiBBdWd1c3QgMzEgLT4gRmVicnVhcnkgMzEpLCB0aGUgZGF0ZSB3aWxsIGJlIHNoaWZ0ZWQgdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBtb250aC4gRG9uJ3QgdXNlICVhZGRNb250aHMlIGlmIHlvdSBuZWVkIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIGFkZE1pbGxpc2Vjb25kc1xuICAgKiAgIGFkZFNlY29uZHNcbiAgICogICBhZGRNaW51dGVzXG4gICAqICAgYWRkSG91cnNcbiAgICogICBhZGREYXlzXG4gICAqICAgYWRkV2Vla3NcbiAgICogICBhZGRNb250aHNcbiAgICogICBhZGRZZWFyc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIERhdGUuY3JlYXRlKCkuYWRkTWlsbGlzZWNvbmRzKDUpIC0+IGN1cnJlbnQgdGltZSArIDUgbWlsbGlzZWNvbmRzXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5hZGREYXlzKDUpICAgICAgICAgLT4gY3VycmVudCB0aW1lICsgNSBkYXlzXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5hZGRZZWFycyg1KSAgICAgICAgLT4gY3VycmVudCB0aW1lICsgNSB5ZWFyc1xuICAgKlxuICAgKioqXG4gICAqIEBtZXRob2QgaXNMYXN0W1VuaXRdKClcbiAgICogQHJldHVybnMgQm9vbGVhblxuICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRlIGlzIGxhc3Qgd2Vlay9tb250aC95ZWFyLlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgaXNMYXN0V2Vla1xuICAgKiAgIGlzTGFzdE1vbnRoXG4gICAqICAgaXNMYXN0WWVhclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIERhdGUuY3JlYXRlKCd5ZXN0ZXJkYXknKS5pc0xhc3RXZWVrKCkgIC0+IHRydWUgb3IgZmFsc2U/XG4gICAqICAgRGF0ZS5jcmVhdGUoJ3llc3RlcmRheScpLmlzTGFzdE1vbnRoKCkgLT4gcHJvYmFibHkgbm90Li4uXG4gICAqICAgRGF0ZS5jcmVhdGUoJ3llc3RlcmRheScpLmlzTGFzdFllYXIoKSAgLT4gZXZlbiBsZXNzIGxpa2VseS4uLlxuICAgKlxuICAgKioqXG4gICAqIEBtZXRob2QgaXNUaGlzW1VuaXRdKClcbiAgICogQHJldHVybnMgQm9vbGVhblxuICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRlIGlzIHRoaXMgd2Vlay9tb250aC95ZWFyLlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgaXNUaGlzV2Vla1xuICAgKiAgIGlzVGhpc01vbnRoXG4gICAqICAgaXNUaGlzWWVhclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIERhdGUuY3JlYXRlKCd0b21vcnJvdycpLmlzVGhpc1dlZWsoKSAgLT4gdHJ1ZSBvciBmYWxzZT9cbiAgICogICBEYXRlLmNyZWF0ZSgndG9tb3Jyb3cnKS5pc1RoaXNNb250aCgpIC0+IHByb2JhYmx5Li4uXG4gICAqICAgRGF0ZS5jcmVhdGUoJ3RvbW9ycm93JykuaXNUaGlzWWVhcigpICAtPiBzaWducyBwb2ludCB0byB5ZXMuLi5cbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIGlzTmV4dFtVbml0XSgpXG4gICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF0ZSBpcyBuZXh0IHdlZWsvbW9udGgveWVhci5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIGlzTmV4dFdlZWtcbiAgICogICBpc05leHRNb250aFxuICAgKiAgIGlzTmV4dFllYXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICBEYXRlLmNyZWF0ZSgndG9tb3Jyb3cnKS5pc05leHRXZWVrKCkgIC0+IHRydWUgb3IgZmFsc2U/XG4gICAqICAgRGF0ZS5jcmVhdGUoJ3RvbW9ycm93JykuaXNOZXh0TW9udGgoKSAtPiBwcm9iYWJseSBub3QuLi5cbiAgICogICBEYXRlLmNyZWF0ZSgndG9tb3Jyb3cnKS5pc05leHRZZWFyKCkgIC0+IGV2ZW4gbGVzcyBsaWtlbHkuLi5cbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIGJlZ2lubmluZ09mW1VuaXRdKClcbiAgICogQHJldHVybnMgRGF0ZVxuICAgKiBAc2hvcnQgU2V0cyB0aGUgZGF0ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcHByb3ByaWF0ZSB1bml0LlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgYmVnaW5uaW5nT2ZEYXlcbiAgICogICBiZWdpbm5pbmdPZldlZWtcbiAgICogICBiZWdpbm5pbmdPZk1vbnRoXG4gICAqICAgYmVnaW5uaW5nT2ZZZWFyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5iZWdpbm5pbmdPZkRheSgpICAgLT4gdGhlIGJlZ2lubmluZyBvZiB0b2RheSAocmVzZXRzIHRoZSB0aW1lKVxuICAgKiAgIERhdGUuY3JlYXRlKCkuYmVnaW5uaW5nT2ZXZWVrKCkgIC0+IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHdlZWtcbiAgICogICBEYXRlLmNyZWF0ZSgpLmJlZ2lubmluZ09mTW9udGgoKSAtPiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtb250aFxuICAgKiAgIERhdGUuY3JlYXRlKCkuYmVnaW5uaW5nT2ZZZWFyKCkgIC0+IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHllYXJcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIGVuZE9mW1VuaXRdKClcbiAgICogQHJldHVybnMgRGF0ZVxuICAgKiBAc2hvcnQgU2V0cyB0aGUgZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBhcHByb3ByaWF0ZSB1bml0LlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgZW5kT2ZEYXlcbiAgICogICBlbmRPZldlZWtcbiAgICogICBlbmRPZk1vbnRoXG4gICAqICAgZW5kT2ZZZWFyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5lbmRPZkRheSgpICAgLT4gdGhlIGVuZCBvZiB0b2RheSAoc2V0cyB0aGUgdGltZSB0byAyMzo1OTo1OS45OTkpXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5lbmRPZldlZWsoKSAgLT4gdGhlIGVuZCBvZiB0aGUgd2Vla1xuICAgKiAgIERhdGUuY3JlYXRlKCkuZW5kT2ZNb250aCgpIC0+IHRoZSBlbmQgb2YgdGhlIG1vbnRoXG4gICAqICAgRGF0ZS5jcmVhdGUoKS5lbmRPZlllYXIoKSAgLT4gdGhlIGVuZCBvZiB0aGUgeWVhclxuICAgKlxuICAgKioqL1xuXG4gIGZ1bmN0aW9uIGJ1aWxkRGF0ZU1ldGhvZHMoKSB7XG4gICAgZXh0ZW5kU2ltaWxhcihkYXRlLCB0cnVlLCB0cnVlLCBEYXRlVW5pdHMsIGZ1bmN0aW9uKG1ldGhvZHMsIHUsIGkpIHtcbiAgICAgIHZhciBuYW1lID0gdS5uYW1lLCBjYXBzID0gc2ltcGxlQ2FwaXRhbGl6ZShuYW1lKSwgbXVsdGlwbGllciA9IHUubXVsdGlwbGllcigpLCBzaW5jZSwgdW50aWw7XG4gICAgICB1LmFkZE1ldGhvZCA9ICdhZGQnICsgY2FwcyArICdzJztcbiAgICAgIC8vIFwic2luY2UvdW50aWwgbm93XCIgb25seSBjb3VudCBcInBhc3RcIiBhbiBpbnRlZ2VyLCBpLmUuIFwiMiBkYXlzIGFnb1wiIGlzXG4gICAgICAvLyBhbnl0aGluZyBiZXR3ZWVuIDIgLSAyLjk5OSBkYXlzLiBUaGUgZGVmYXVsdCBtYXJnaW4gb2YgZXJyb3IgaXMgMC45OTksXG4gICAgICAvLyBidXQgXCJtb250aHNcIiBoYXZlIGFuIGluaGVyZW50bHkgbGFyZ2VyIG1hcmdpbiwgYXMgdGhlIG51bWJlciBvZiBkYXlzXG4gICAgICAvLyBpbiBhIGdpdmVuIG1vbnRoIG1heSBiZSBzaWduaWZpY2FudGx5IGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRheXMgaW5cbiAgICAgIC8vIHRoZSBhdmVyYWdlIG1vbnRoLCBzbyBmb3IgZXhhbXBsZSBcIjMwIGRheXNcIiBiZWZvcmUgTWFyY2ggMTUgbWF5IGluIGZhY3RcbiAgICAgIC8vIGJlIDEgbW9udGggYWdvLiBZZWFycyBhbHNvIGhhdmUgYSBtYXJnaW4gb2YgZXJyb3IgZHVlIHRvIGxlYXAgeWVhcnMsXG4gICAgICAvLyBidXQgdGhpcyBpcyByb3VnaGx5IDAuOTk5IGFueXdheSAoMzY1IC8gMzY1LjI1KS4gT3RoZXIgdW5pdHMgZG8gbm90XG4gICAgICAvLyB0ZWNobmljYWxseSBuZWVkIHRoZSBlcnJvciBtYXJnaW4gYXBwbGllZCB0byB0aGVtIGJ1dCB0aGlzIGFjY291bnRzXG4gICAgICAvLyBmb3IgZGlzY3JlcGFuY2llcyBsaWtlICgxNSkuaG91cnNBZ28oKSB3aGljaCB0ZWNobmljYWxseSBjcmVhdGVzIHRoZVxuICAgICAgLy8gY3VycmVudCBkYXRlIGZpcnN0LCB0aGVuIGNyZWF0ZXMgYSBkYXRlIDE1IGhvdXJzIGJlZm9yZSBhbmQgY29tcGFyZXNcbiAgICAgIC8vIHRoZW0sIHRoZSBkaXNjcmVwYW5jeSBiZXR3ZWVuIHRoZSBjcmVhdGlvbiBvZiB0aGUgMiBkYXRlcyBtZWFucyB0aGF0XG4gICAgICAvLyB0aGV5IG1heSBhY3R1YWxseSBiZSAxNS4wMDAxIGhvdXJzIGFwYXJ0LiBNaWxsaXNlY29uZHMgZG9uJ3QgaGF2ZVxuICAgICAgLy8gZnJhY3Rpb25zLCBzbyB0aGV5IHdvbid0IGJlIHN1YmplY3QgdG8gdGhpcyBlcnJvciBtYXJnaW4uXG4gICAgICBmdW5jdGlvbiBhcHBseUVycm9yTWFyZ2luKG1zKSB7XG4gICAgICAgIHZhciBudW0gICAgICA9IG1zIC8gbXVsdGlwbGllcixcbiAgICAgICAgICAgIGZyYWN0aW9uID0gbnVtICUgMSxcbiAgICAgICAgICAgIGVycm9yICAgID0gdS5lcnJvciB8fCAwLjk5OTtcbiAgICAgICAgaWYoZnJhY3Rpb24gJiYgYWJzKGZyYWN0aW9uICUgMSkgPiBlcnJvcikge1xuICAgICAgICAgIG51bSA9IHJvdW5kKG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bSA8IDAgPyBjZWlsKG51bSkgOiBmbG9vcihudW0pO1xuICAgICAgfVxuICAgICAgc2luY2UgPSBmdW5jdGlvbihmLCBsb2NhbGVDb2RlKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVycm9yTWFyZ2luKHRoaXMuZ2V0VGltZSgpIC0gZGF0ZS5jcmVhdGUoZiwgbG9jYWxlQ29kZSkuZ2V0VGltZSgpKTtcbiAgICAgIH07XG4gICAgICB1bnRpbCA9IGZ1bmN0aW9uKGYsIGxvY2FsZUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RXJyb3JNYXJnaW4oZGF0ZS5jcmVhdGUoZiwgbG9jYWxlQ29kZSkuZ2V0VGltZSgpIC0gdGhpcy5nZXRUaW1lKCkpO1xuICAgICAgfTtcbiAgICAgIG1ldGhvZHNbbmFtZSsnc0FnbyddICAgICA9IHVudGlsO1xuICAgICAgbWV0aG9kc1tuYW1lKydzVW50aWwnXSAgID0gdW50aWw7XG4gICAgICBtZXRob2RzW25hbWUrJ3NTaW5jZSddICAgPSBzaW5jZTtcbiAgICAgIG1ldGhvZHNbbmFtZSsnc0Zyb21Ob3cnXSA9IHNpbmNlO1xuICAgICAgbWV0aG9kc1t1LmFkZE1ldGhvZF0gPSBmdW5jdGlvbihudW0sIHJlc2V0KSB7XG4gICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgc2V0W25hbWVdID0gbnVtO1xuICAgICAgICByZXR1cm4gdGhpcy5hZHZhbmNlKHNldCwgcmVzZXQpO1xuICAgICAgfTtcbiAgICAgIGJ1aWxkTnVtYmVyVG9EYXRlQWxpYXModSwgbXVsdGlwbGllcik7XG4gICAgICBpZihpIDwgMykge1xuICAgICAgICBbJ0xhc3QnLCdUaGlzJywnTmV4dCddLmZvckVhY2goZnVuY3Rpb24oc2hpZnQpIHtcbiAgICAgICAgICBtZXRob2RzWydpcycgKyBzaGlmdCArIGNhcHNdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZURhdGUodGhpcywgc2hpZnQgKyAnICcgKyBuYW1lLCAnZW4nKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKGkgPCA0KSB7XG4gICAgICAgIG1ldGhvZHNbJ2JlZ2lubmluZ09mJyArIGNhcHNdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICAgIHN3aXRjaChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzogIHNldFsneWVhciddICAgID0gY2FsbERhdGVHZXQodGhpcywgJ0Z1bGxZZWFyJyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOiBzZXRbJ21vbnRoJ10gICA9IGNhbGxEYXRlR2V0KHRoaXMsICdNb250aCcpOyAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6ICAgc2V0WydkYXknXSAgICAgPSBjYWxsRGF0ZUdldCh0aGlzLCAnRGF0ZScpOyAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzogIHNldFsnd2Vla2RheSddID0gMDsgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnNldChzZXQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBtZXRob2RzWydlbmRPZicgKyBjYXBzXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzZXQgPSB7ICdob3Vycyc6IDIzLCAnbWludXRlcyc6IDU5LCAnc2Vjb25kcyc6IDU5LCAnbWlsbGlzZWNvbmRzJzogOTk5IH07XG4gICAgICAgICAgc3dpdGNoKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOiAgc2V0Wydtb250aCddICAgPSAxMTsgc2V0WydkYXknXSA9IDMxOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogc2V0WydkYXknXSAgICAgPSB0aGlzLmRheXNJbk1vbnRoKCk7ICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiAgc2V0Wyd3ZWVrZGF5J10gPSA2OyAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHNldCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZENvcmVJbnB1dEZvcm1hdHMoKSB7XG4gICAgRW5nbGlzaC5hZGRGb3JtYXQoJyhbKy1dKT8oXFxcXGR7NCw0fSlbLS5dP3tmdWxsX21vbnRofVstLl0/KFxcXFxkezEsMn0pPycsIHRydWUsIFsneWVhcl9zaWduJywneWVhcicsJ21vbnRoJywnZGF0ZSddLCBmYWxzZSwgdHJ1ZSk7XG4gICAgRW5nbGlzaC5hZGRGb3JtYXQoJyhcXFxcZHsxLDJ9KVstLlxcXFwvXXtmdWxsX21vbnRofSg/OlstLlxcXFwvXShcXFxcZHsyLDR9KSk/JywgdHJ1ZSwgWydkYXRlJywnbW9udGgnLCd5ZWFyJ10sIHRydWUpO1xuICAgIEVuZ2xpc2guYWRkRm9ybWF0KCd7ZnVsbF9tb250aH1bLS5dKFxcXFxkezQsNH0pJywgZmFsc2UsIFsnbW9udGgnLCd5ZWFyJ10pO1xuICAgIEVuZ2xpc2guYWRkRm9ybWF0KCdcXFxcL0RhdGVcXFxcKChcXFxcZCsoPzpbKy1dXFxcXGR7NCw0fSk/KVxcXFwpXFxcXC8nLCBmYWxzZSwgWyd0aW1lc3RhbXAnXSlcbiAgICBFbmdsaXNoLmFkZEZvcm1hdChwcmVwYXJlVGltZShSZXF1aXJlZFRpbWUsIEVuZ2xpc2gpLCBmYWxzZSwgVGltZUZvcm1hdClcblxuICAgIC8vIFdoZW4gYSBuZXcgbG9jYWxlIGlzIGluaXRpYWxpemVkIGl0IHdpbGwgaGF2ZSB0aGUgQ29yZURhdGVGb3JtYXRzIGluaXRpYWxpemVkIGJ5IGRlZmF1bHQuXG4gICAgLy8gRnJvbSB0aGVyZSwgYWRkaW5nIG5ldyBmb3JtYXRzIHdpbGwgcHVzaCB0aGVtIGluIGZyb250IG9mIHRoZSBwcmV2aW91cyBvbmVzLCBzbyB0aGUgY29yZVxuICAgIC8vIGZvcm1hdHMgd2lsbCBiZSB0aGUgbGFzdCB0byBiZSByZWFjaGVkLiBIb3dldmVyLCB0aGUgY29yZSBmb3JtYXRzIHRoZW1zZWx2ZXMgaGF2ZSBFbmdsaXNoXG4gICAgLy8gbW9udGhzIGluIHRoZW0sIHdoaWNoIG1lYW5zIHRoYXQgRW5nbGlzaCBuZWVkcyB0byBmaXJzdCBiZSBpbml0aWFsaXplZCBhbmQgY3JlYXRlcyBhIHJhY2VcbiAgICAvLyBjb25kaXRpb24uIEknbSBnZXR0aW5nIGFyb3VuZCB0aGlzIGhlcmUgYnkgYWRkaW5nIHRoZXNlIGdlbmVyYWxpemVkIGZvcm1hdHMgaW4gdGhlIG9yZGVyXG4gICAgLy8gc3BlY2lmaWMgLT4gZ2VuZXJhbCwgd2hpY2ggd2lsbCBtZWFuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgRW5nbGlzaCBsb2NhbGl6YXRpb24gaW5cbiAgICAvLyBnZW5lcmFsIC0+IHNwZWNpZmljIG9yZGVyLCB0aGVuIGNob3BwaW5nIHRoZW0gb2ZmIHRoZSBmcm9udCBhbmQgcmV2ZXJzaW5nIHRvIGdldCB0aGUgY29ycmVjdFxuICAgIC8vIG9yZGVyLiBOb3RlIHRoYXQgdGhlcmUgYXJlIDcgZm9ybWF0cyBhcyAyIGhhdmUgdGltZXMgd2hpY2ggYWRkcyBhIGZyb250IGFuZCBhIGJhY2sgZm9ybWF0LlxuICAgIENvcmVEYXRlRm9ybWF0cyA9IEVuZ2xpc2guY29tcGlsZWRGb3JtYXRzLnNsaWNlKDAsNykucmV2ZXJzZSgpO1xuICAgIEVuZ2xpc2guY29tcGlsZWRGb3JtYXRzID0gRW5nbGlzaC5jb21waWxlZEZvcm1hdHMuc2xpY2UoNykuY29uY2F0KENvcmVEYXRlRm9ybWF0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEZvcm1hdFRva2VucygpIHtcblxuICAgIGNyZWF0ZVBhZGRlZFRva2VuKCdmJywgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGNhbGxEYXRlR2V0KGQsICdNaWxsaXNlY29uZHMnKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIGNyZWF0ZVBhZGRlZFRva2VuKCdzJywgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGNhbGxEYXRlR2V0KGQsICdTZWNvbmRzJyk7XG4gICAgfSk7XG5cbiAgICBjcmVhdGVQYWRkZWRUb2tlbignbScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBjYWxsRGF0ZUdldChkLCAnTWludXRlcycpO1xuICAgIH0pO1xuXG4gICAgY3JlYXRlUGFkZGVkVG9rZW4oJ2gnLCBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gY2FsbERhdGVHZXQoZCwgJ0hvdXJzJykgJSAxMiB8fCAxMjtcbiAgICB9KTtcblxuICAgIGNyZWF0ZVBhZGRlZFRva2VuKCdIJywgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGNhbGxEYXRlR2V0KGQsICdIb3VycycpO1xuICAgIH0pO1xuXG4gICAgY3JlYXRlUGFkZGVkVG9rZW4oJ2QnLCBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gY2FsbERhdGVHZXQoZCwgJ0RhdGUnKTtcbiAgICB9KTtcblxuICAgIGNyZWF0ZVBhZGRlZFRva2VuKCdNJywgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGNhbGxEYXRlR2V0KGQsICdNb250aCcpICsgMTtcbiAgICB9KTtcblxuICAgIGNyZWF0ZU1lcmlkaWFuVG9rZW5zKCk7XG4gICAgY3JlYXRlV2Vla2RheVRva2VucygpO1xuICAgIGNyZWF0ZU1vbnRoVG9rZW5zKCk7XG5cbiAgICAvLyBBbGlhc2VzXG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snbXMnXSAgICAgICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydmJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snbWlsbGlzZWNvbmRzJ10gPSBEYXRlRm9ybWF0VG9rZW5zWydmJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snc2Vjb25kcyddICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydzJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snbWludXRlcyddICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydtJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snaG91cnMnXSAgICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydoJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snMjRociddICAgICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydIJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snMTJociddICAgICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydoJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snZGF0ZSddICAgICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydkJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1snZGF5J10gICAgICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWydkJ107XG4gICAgRGF0ZUZvcm1hdFRva2Vuc1sneWVhciddICAgICAgICAgPSBEYXRlRm9ybWF0VG9rZW5zWyd5eXl5J107XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkRm9ybWF0U2hvcnRjdXRzKCkge1xuICAgIGV4dGVuZFNpbWlsYXIoZGF0ZSwgdHJ1ZSwgdHJ1ZSwgJ3Nob3J0LGxvbmcsZnVsbCcsIGZ1bmN0aW9uKG1ldGhvZHMsIG5hbWUpIHtcbiAgICAgIG1ldGhvZHNbbmFtZV0gPSBmdW5jdGlvbihsb2NhbGVDb2RlKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlKHRoaXMsIG5hbWUsIGZhbHNlLCBsb2NhbGVDb2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQXNpYW5EaWdpdHMoKSB7XG4gICAgS2FuamlEaWdpdHMuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oZGlnaXQsIHZhbHVlKSB7XG4gICAgICB2YXIgaG9sZGVyO1xuICAgICAgaWYodmFsdWUgPiA5KSB7XG4gICAgICAgIHZhbHVlID0gcG93KDEwLCB2YWx1ZSAtIDkpO1xuICAgICAgfVxuICAgICAgQXNpYW5EaWdpdE1hcFtkaWdpdF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICBzaW1wbGVNZXJnZShBc2lhbkRpZ2l0TWFwLCBOdW1iZXJOb3JtYWxpemVNYXApO1xuICAgIC8vIEthbmppIG51bWVyYWxzIG1heSBhbHNvIGJlIGluY2x1ZGVkIGluIHBocmFzZXMgd2hpY2ggYXJlIHRleHQtYmFzZWQgcmF0aGVyXG4gICAgLy8gdGhhbiBhY3R1YWwgbnVtYmVycyBzdWNoIGFzIENoaW5lc2Ugd2Vla2RheXMgKOS4iuWRqOS4iSksIGFuZCBcInRoZSBkYXkgYmVmb3JlXG4gICAgLy8geWVzdGVyZGF5XCIgKOS4gOaYqOaXpSkgaW4gSmFwYW5lc2UsIHNvIGRvbid0IG1hdGNoIHRoZXNlLlxuICAgIEFzaWFuRGlnaXRSZWcgPSByZWdleHAoJyhb5pyf6YCx5ZGoXSk/KFsnICsgS2FuamlEaWdpdHMgKyBGdWxsV2lkdGhEaWdpdHMgKyAnXSspKD8h5pioKScsICdnJyk7XG4gIH1cblxuICAgLyoqKlxuICAgKiBAbWV0aG9kIGlzW0RheV0oKVxuICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIGRhdGUgZmFsbHMgb24gdGhhdCBkYXkuXG4gICAqIEBleHRyYSBBbHNvIGF2YWlsYWJsZTogJWlzWWVzdGVyZGF5JSwgJWlzVG9kYXklLCAlaXNUb21vcnJvdyUsICVpc1dlZWtkYXklLCBhbmQgJWlzV2Vla2VuZCUuXG4gICAqXG4gICAqIEBzZXRcbiAgICogICBpc1RvZGF5XG4gICAqICAgaXNZZXN0ZXJkYXlcbiAgICogICBpc1RvbW9ycm93XG4gICAqICAgaXNXZWVrZGF5XG4gICAqICAgaXNXZWVrZW5kXG4gICAqICAgaXNTdW5kYXlcbiAgICogICBpc01vbmRheVxuICAgKiAgIGlzVHVlc2RheVxuICAgKiAgIGlzV2VkbmVzZGF5XG4gICAqICAgaXNUaHVyc2RheVxuICAgKiAgIGlzRnJpZGF5XG4gICAqICAgaXNTYXR1cmRheVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIERhdGUuY3JlYXRlKCd0b21vcnJvdycpLmlzVG9kYXkoKSAtPiBmYWxzZVxuICAgKiAgIERhdGUuY3JlYXRlKCd0aHVyc2RheScpLmlzVG9tb3Jyb3coKSAtPiA/XG4gICAqICAgRGF0ZS5jcmVhdGUoJ3llc3RlcmRheScpLmlzV2VkbmVzZGF5KCkgLT4gP1xuICAgKiAgIERhdGUuY3JlYXRlKCd0b2RheScpLmlzV2Vla2VuZCgpIC0+ID9cbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIGlzRnV0dXJlKClcbiAgICogQHJldHVybnMgQm9vbGVhblxuICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRlIGlzIGluIHRoZSBmdXR1cmUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgRGF0ZS5jcmVhdGUoJ25leHQgd2VlaycpLmlzRnV0dXJlKCkgLT4gdHJ1ZVxuICAgKiAgIERhdGUuY3JlYXRlKCdsYXN0IHdlZWsnKS5pc0Z1dHVyZSgpIC0+IGZhbHNlXG4gICAqXG4gICAqKipcbiAgICogQG1ldGhvZCBpc1Bhc3QoKVxuICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIGRhdGUgaXMgaW4gdGhlIHBhc3QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgRGF0ZS5jcmVhdGUoJ2xhc3Qgd2VlaycpLmlzUGFzdCgpIC0+IHRydWVcbiAgICogICBEYXRlLmNyZWF0ZSgnbmV4dCB3ZWVrJykuaXNQYXN0KCkgLT4gZmFsc2VcbiAgICpcbiAgICoqKi9cbiAgZnVuY3Rpb24gYnVpbGRSZWxhdGl2ZUFsaWFzZXMoKSB7XG4gICAgdmFyIHNwZWNpYWwgID0gJ3RvZGF5LHllc3RlcmRheSx0b21vcnJvdyx3ZWVrZGF5LHdlZWtlbmQsZnV0dXJlLHBhc3QnLnNwbGl0KCcsJyk7XG4gICAgdmFyIHdlZWtkYXlzID0gRW5nbGlzaFsnd2Vla2RheXMnXS5zbGljZSgwLDcpO1xuICAgIHZhciBtb250aHMgICA9IEVuZ2xpc2hbJ21vbnRocyddLnNsaWNlKDAsMTIpO1xuICAgIGV4dGVuZFNpbWlsYXIoZGF0ZSwgdHJ1ZSwgdHJ1ZSwgc3BlY2lhbC5jb25jYXQod2Vla2RheXMpLmNvbmNhdChtb250aHMpLCBmdW5jdGlvbihtZXRob2RzLCBuYW1lKSB7XG4gICAgICBtZXRob2RzWydpcycrIHNpbXBsZUNhcGl0YWxpemUobmFtZSldID0gZnVuY3Rpb24odXRjKSB7XG4gICAgICAgcmV0dXJuIHRoaXMuaXMobmFtZSwgMCwgdXRjKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZFVUQ0FsaWFzZXMoKSB7XG4gICAgLy8gRG9uJ3Qgd2FudCB0byB1c2UgZXh0ZW5kIGhlcmUgYXMgaXQgd2lsbCBvdmVycmlkZVxuICAgIC8vIHRoZSBhY3R1YWwgXCJ1dGNcIiBtZXRob2Qgb24gdGhlIHByb3RvdHlwZS5cbiAgICBpZihkYXRlWyd1dGMnXSkgcmV0dXJuO1xuICAgIGRhdGVbJ3V0YyddID0ge1xuXG4gICAgICAgICdjcmVhdGUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRGF0ZShhcmd1bWVudHMsIDAsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdwYXN0JzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGUoYXJndW1lbnRzLCAtMSwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2Z1dHVyZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVEYXRlKGFyZ3VtZW50cywgMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgZXh0ZW5kKGRhdGUsIGZhbHNlICwgdHJ1ZSwge1xuICAgICAgJ1JGQzExMjMnOiAne0Rvd30sIHtkZH0ge01vbn0ge3l5eXl9IHtISH06e21tfTp7c3N9IHt0en0nLFxuICAgICAgJ1JGQzEwMzYnOiAne1dlZWtkYXl9LCB7ZGR9LXtNb259LXt5eX0ge0hIfTp7bW19Ontzc30ge3R6fScsXG4gICAgICAnSVNPODYwMV9EQVRFJzogJ3t5eXl5fS17TU19LXtkZH0nLFxuICAgICAgJ0lTTzg2MDFfREFURVRJTUUnOiAne3l5eXl9LXtNTX0te2RkfVR7SEh9OnttbX06e3NzfS57ZmZmfXtpc290en0nXG4gICAgfSk7XG4gIH1cblxuXG4gIGV4dGVuZChkYXRlLCBmYWxzZSwgdHJ1ZSwge1xuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIERhdGUuY3JlYXRlKDxkPiwgW2xvY2FsZV0gPSBjdXJyZW50TG9jYWxlKVxuICAgICAqIEByZXR1cm5zIERhdGVcbiAgICAgKiBAc2hvcnQgQWx0ZXJuYXRlIERhdGUgY29uc3RydWN0b3Igd2hpY2ggdW5kZXJzdGFuZHMgbWFueSBkaWZmZXJlbnQgdGV4dCBmb3JtYXRzLCBhIHRpbWVzdGFtcCwgb3IgYW5vdGhlciBkYXRlLlxuICAgICAqIEBleHRyYSBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgZGF0ZSBpcyBhc3N1bWVkIHRvIGJlIG5vdy4gJURhdGUuY3JlYXRlJSBhZGRpdGlvbmFsbHkgY2FuIGFjY2VwdCBlbnVtZXJhdGVkIHBhcmFtZXRlcnMgYXMgd2l0aCB0aGUgc3RhbmRhcmQgZGF0ZSBjb25zdHJ1Y3Rvci4gW2xvY2FsZV0gY2FuIGJlIHBhc3NlZCB0byBzcGVjaWZ5IHRoZSBsb2NhbGUgdGhhdCB0aGUgZGF0ZSBpcyBpbi4gV2hlbiB1bnNwZWNpZmllZCwgdGhlIGN1cnJlbnQgbG9jYWxlIChkZWZhdWx0IGlzIEVuZ2xpc2gpIGlzIGFzc3VtZWQuIFVUQy1iYXNlZCBkYXRlcyBjYW4gYmUgY3JlYXRlZCB0aHJvdWdoIHRoZSAldXRjJSBvYmplY3QuIEZvciBtb3JlIHNlZSBAZGF0ZV9mb3JtYXQuXG4gICAgICogQHNldFxuICAgICAqICAgRGF0ZS51dGMuY3JlYXRlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBEYXRlLmNyZWF0ZSgnSnVseScpICAgICAgICAgIC0+IEp1bHkgb2YgdGhpcyB5ZWFyXG4gICAgICogICBEYXRlLmNyZWF0ZSgnMTc3NicpICAgICAgICAgIC0+IDE3NzZcbiAgICAgKiAgIERhdGUuY3JlYXRlKCd0b2RheScpICAgICAgICAgLT4gdG9kYXlcbiAgICAgKiAgIERhdGUuY3JlYXRlKCd3ZWRuZXNkYXknKSAgICAgLT4gVGhpcyB3ZWRuZXNkYXlcbiAgICAgKiAgIERhdGUuY3JlYXRlKCduZXh0IGZyaWRheScpICAgLT4gTmV4dCBmcmlkYXlcbiAgICAgKiAgIERhdGUuY3JlYXRlKCdKdWx5IDQsIDE3NzYnKSAgLT4gSnVseSA0LCAxNzc2XG4gICAgICogICBEYXRlLmNyZWF0ZSgtNDQ2ODA2ODAwMDAwKSAgIC0+IE5vdmVtYmVyIDUsIDE5NTVcbiAgICAgKiAgIERhdGUuY3JlYXRlKDE3NzYsIDYsIDQpICAgICAgLT4gSnVseSA0LCAxNzc2XG4gICAgICogICBEYXRlLmNyZWF0ZSgnMTc3NuW5tDA35pyIMDTml6UnLCAnamEnKSAtPiBKdWx5IDQsIDE3NzZcbiAgICAgKiAgIERhdGUudXRjLmNyZWF0ZSgnSnVseSA0LCAxNzc2JywgJ2VuJykgIC0+IEp1bHkgNCwgMTc3NlxuICAgICAqXG4gICAgICoqKi9cbiAgICAnY3JlYXRlJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGF0ZShhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgRGF0ZS5wYXN0KDxkPiwgW2xvY2FsZV0gPSBjdXJyZW50TG9jYWxlKVxuICAgICAqIEByZXR1cm5zIERhdGVcbiAgICAgKiBAc2hvcnQgQWx0ZXJuYXRlIGZvcm0gb2YgJURhdGUuY3JlYXRlJSB3aXRoIGFueSBhbWJpZ3VpdHkgYXNzdW1lZCB0byBiZSB0aGUgcGFzdC5cbiAgICAgKiBAZXh0cmEgRm9yIGV4YW1wbGUgJVwiU3VuZGF5XCIlIGNhbiBiZSBlaXRoZXIgXCJ0aGUgU3VuZGF5IGNvbWluZyB1cFwiIG9yIFwidGhlIFN1bmRheSBsYXN0XCIgZGVwZW5kaW5nIG9uIGNvbnRleHQuIE5vdGUgdGhhdCBkYXRlcyBleHBsaWNpdGx5IGluIHRoZSBmdXR1cmUgKFwibmV4dCBTdW5kYXlcIikgd2lsbCByZW1haW4gaW4gdGhlIGZ1dHVyZS4gVGhpcyBtZXRob2Qgc2ltcGx5IHByb3ZpZGVzIGEgaGludCB3aGVuIGFtYmlndWl0eSBleGlzdHMuIFVUQy1iYXNlZCBkYXRlcyBjYW4gYmUgY3JlYXRlZCB0aHJvdWdoIHRoZSAldXRjJSBvYmplY3QuIEZvciBtb3JlLCBzZWUgQGRhdGVfZm9ybWF0LlxuICAgICAqIEBzZXRcbiAgICAgKiAgIERhdGUudXRjLnBhc3RcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUucGFzdCgnSnVseScpICAgICAgICAgIC0+IEp1bHkgb2YgdGhpcyB5ZWFyIG9yIGxhc3QgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IG1vbnRoXG4gICAgICogICBEYXRlLnBhc3QoJ1dlZG5lc2RheScpICAgICAtPiBUaGlzIHdlZG5lc2RheSBvciBsYXN0IGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCB3ZWVrZGF5XG4gICAgICpcbiAgICAgKioqL1xuICAgICdwYXN0JzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGF0ZShhcmd1bWVudHMsIC0xKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIERhdGUuZnV0dXJlKDxkPiwgW2xvY2FsZV0gPSBjdXJyZW50TG9jYWxlKVxuICAgICAqIEByZXR1cm5zIERhdGVcbiAgICAgKiBAc2hvcnQgQWx0ZXJuYXRlIGZvcm0gb2YgJURhdGUuY3JlYXRlJSB3aXRoIGFueSBhbWJpZ3VpdHkgYXNzdW1lZCB0byBiZSB0aGUgZnV0dXJlLlxuICAgICAqIEBleHRyYSBGb3IgZXhhbXBsZSAlXCJTdW5kYXlcIiUgY2FuIGJlIGVpdGhlciBcInRoZSBTdW5kYXkgY29taW5nIHVwXCIgb3IgXCJ0aGUgU3VuZGF5IGxhc3RcIiBkZXBlbmRpbmcgb24gY29udGV4dC4gTm90ZSB0aGF0IGRhdGVzIGV4cGxpY2l0bHkgaW4gdGhlIHBhc3QgKFwibGFzdCBTdW5kYXlcIikgd2lsbCByZW1haW4gaW4gdGhlIHBhc3QuIFRoaXMgbWV0aG9kIHNpbXBseSBwcm92aWRlcyBhIGhpbnQgd2hlbiBhbWJpZ3VpdHkgZXhpc3RzLiBVVEMtYmFzZWQgZGF0ZXMgY2FuIGJlIGNyZWF0ZWQgdGhyb3VnaCB0aGUgJXV0YyUgb2JqZWN0LiBGb3IgbW9yZSwgc2VlIEBkYXRlX2Zvcm1hdC5cbiAgICAgKiBAc2V0XG4gICAgICogICBEYXRlLnV0Yy5mdXR1cmVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUuZnV0dXJlKCdKdWx5JykgICAgICAgICAgLT4gSnVseSBvZiB0aGlzIHllYXIgb3IgbmV4dCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgbW9udGhcbiAgICAgKiAgIERhdGUuZnV0dXJlKCdXZWRuZXNkYXknKSAgICAgLT4gVGhpcyB3ZWRuZXNkYXkgb3IgbmV4dCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgd2Vla2RheVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnZnV0dXJlJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGF0ZShhcmd1bWVudHMsIDEpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgRGF0ZS5hZGRMb2NhbGUoPGNvZGU+LCA8c2V0PilcbiAgICAgKiBAcmV0dXJucyBMb2NhbGVcbiAgICAgKiBAc2hvcnQgQWRkcyBhIGxvY2FsZSA8c2V0PiB0byB0aGUgbG9jYWxlcyB1bmRlcnN0b29kIGJ5IFN1Z2FyLlxuICAgICAqIEBleHRyYSBGb3IgbW9yZSBzZWUgQGRhdGVfZm9ybWF0LlxuICAgICAqXG4gICAgICoqKi9cbiAgICAnYWRkTG9jYWxlJzogZnVuY3Rpb24obG9jYWxlQ29kZSwgc2V0KSB7XG4gICAgICByZXR1cm4gc2V0TG9jYWxpemF0aW9uKGxvY2FsZUNvZGUsIHNldCk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBEYXRlLnNldExvY2FsZSg8Y29kZT4pXG4gICAgICogQHJldHVybnMgTG9jYWxlXG4gICAgICogQHNob3J0IFNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIHRvIGJlIHVzZWQgd2l0aCBkYXRlcy5cbiAgICAgKiBAZXh0cmEgU3VnYXIgaGFzIHN1cHBvcnQgZm9yIDEzIGxvY2FsZXMgdGhhdCBhcmUgYXZhaWxhYmxlIHRocm91Z2ggdGhlIFwiRGF0ZSBMb2NhbGVzXCIgcGFja2FnZS4gSW4gYWRkaXRpb24geW91IGNhbiBkZWZpbmUgYSBuZXcgbG9jYWxlIHdpdGggJURhdGUuYWRkTG9jYWxlJS4gRm9yIG1vcmUgc2VlIEBkYXRlX2Zvcm1hdC5cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3NldExvY2FsZSc6IGZ1bmN0aW9uKGxvY2FsZUNvZGUsIHNldCkge1xuICAgICAgdmFyIGxvYyA9IGdldExvY2FsaXphdGlvbihsb2NhbGVDb2RlLCBmYWxzZSk7XG4gICAgICBDdXJyZW50TG9jYWxpemF0aW9uID0gbG9jO1xuICAgICAgLy8gVGhlIGNvZGUgaXMgYWxsb3dlZCB0byBiZSBtb3JlIHNwZWNpZmljIHRoYW4gdGhlIGNvZGVzIHdoaWNoIGFyZSByZXF1aXJlZDpcbiAgICAgIC8vIGkuZS4gemgtQ04gb3IgZW4tVVMuIEN1cnJlbnRseSB0aGlzIG9ubHkgYWZmZWN0cyBVUyBkYXRlIHZhcmlhbnRzIHN1Y2ggYXMgOC8xMC8yMDAwLlxuICAgICAgaWYobG9jYWxlQ29kZSAmJiBsb2NhbGVDb2RlICE9IGxvY1snY29kZSddKSB7XG4gICAgICAgIGxvY1snY29kZSddID0gbG9jYWxlQ29kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2M7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBEYXRlLmdldExvY2FsZShbY29kZV0gPSBjdXJyZW50KVxuICAgICAqIEByZXR1cm5zIExvY2FsZVxuICAgICAqIEBzaG9ydCBHZXRzIHRoZSBsb2NhbGUgZm9yIHRoZSBnaXZlbiBjb2RlLCBvciB0aGUgY3VycmVudCBsb2NhbGUuXG4gICAgICogQGV4dHJhIFRoZSByZXN1bHRpbmcgbG9jYWxlIG9iamVjdCBjYW4gYmUgbWFuaXB1bGF0ZWQgdG8gcHJvdmlkZSBtb3JlIGNvbnRyb2wgb3ZlciBkYXRlIGxvY2FsaXphdGlvbnMuIEZvciBtb3JlIGFib3V0IGxvY2FsZXMsIHNlZSBAZGF0ZV9mb3JtYXQuXG4gICAgICpcbiAgICAgKioqL1xuICAgICdnZXRMb2NhbGUnOiBmdW5jdGlvbihsb2NhbGVDb2RlKSB7XG4gICAgICByZXR1cm4gIWxvY2FsZUNvZGUgPyBDdXJyZW50TG9jYWxpemF0aW9uIDogZ2V0TG9jYWxpemF0aW9uKGxvY2FsZUNvZGUsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgIC8qKlxuICAgICAqIEBtZXRob2QgRGF0ZS5hZGRGb3JtYXQoPGZvcm1hdD4sIDxtYXRjaD4sIFtjb2RlXSA9IG51bGwpXG4gICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAqIEBzaG9ydCBNYW51YWxseSBhZGRzIGEgbmV3IGRhdGUgaW5wdXQgZm9ybWF0LlxuICAgICAqIEBleHRyYSBUaGlzIG1ldGhvZCBhbGxvd3MgZmluZSBncmFpbmVkIGNvbnRyb2wgZm9yIGFsdGVybmF0ZSBmb3JtYXRzLiA8Zm9ybWF0PiBpcyBhIHN0cmluZyB0aGF0IGNhbiBoYXZlIHJlZ2V4IHRva2VucyBpbnNpZGUuIDxtYXRjaD4gaXMgYW4gYXJyYXkgb2YgdGhlIHRva2VucyB0aGF0IGVhY2ggcmVnZXggY2FwdHVyaW5nIGdyb3VwIHdpbGwgbWFwIHRvLCBmb3IgZXhhbXBsZSAleWVhciUsICVkYXRlJSwgZXRjLiBGb3IgbW9yZSwgc2VlIEBkYXRlX2Zvcm1hdC5cbiAgICAgKlxuICAgICAqKi9cbiAgICAnYWRkRm9ybWF0JzogZnVuY3Rpb24oZm9ybWF0LCBtYXRjaCwgbG9jYWxlQ29kZSkge1xuICAgICAgYWRkRGF0ZUlucHV0Rm9ybWF0KGdldExvY2FsaXphdGlvbihsb2NhbGVDb2RlKSwgZm9ybWF0LCBtYXRjaCk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGV4dGVuZChkYXRlLCB0cnVlLCB0cnVlLCB7XG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2Qgc2V0KDxzZXQ+LCBbcmVzZXRdID0gZmFsc2UpXG4gICAgICogQHJldHVybnMgRGF0ZVxuICAgICAqIEBzaG9ydCBTZXRzIHRoZSBkYXRlIG9iamVjdC5cbiAgICAgKiBAZXh0cmEgVGhpcyBtZXRob2QgY2FuIGFjY2VwdCBtdWx0aXBsZSBmb3JtYXRzIGluY2x1ZGluZyBhIHNpbmdsZSBudW1iZXIgYXMgYSB0aW1lc3RhbXAsIGFuIG9iamVjdCwgb3IgZW51bWVyYXRlZCBwYXJhbWV0ZXJzIChhcyB3aXRoIHRoZSBEYXRlIGNvbnN0cnVjdG9yKS4gSWYgW3Jlc2V0XSBpcyAldHJ1ZSUsIGFueSB1bml0cyBtb3JlIHNwZWNpZmljIHRoYW4gdGhvc2UgcGFzc2VkIHdpbGwgYmUgcmVzZXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBuZXcgRGF0ZSgpLnNldCh7IHllYXI6IDIwMTEsIG1vbnRoOiAxMSwgZGF5OiAzMSB9KSAtPiBEZWNlbWJlciAzMSwgMjAxMVxuICAgICAqICAgbmV3IERhdGUoKS5zZXQoMjAxMSwgMTEsIDMxKSAgICAgICAgICAgICAgICAgICAgICAgLT4gRGVjZW1iZXIgMzEsIDIwMTFcbiAgICAgKiAgIG5ldyBEYXRlKCkuc2V0KDg2NDAwMDAwKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IDEgZGF5IGFmdGVyIEphbiAxLCAxOTcwXG4gICAgICogICBuZXcgRGF0ZSgpLnNldCh7IHllYXI6IDIwMDQsIG1vbnRoOiA2IH0sIHRydWUpICAgICAtPiBKdW5lIDEsIDIwMDQsIDAwOjAwOjAwLjAwMFxuICAgICAqXG4gICAgICoqKi9cbiAgICAnc2V0JzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGNvbGxlY3REYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdXBkYXRlRGF0ZSh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKVxuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2Qgc2V0V2Vla2RheSgpXG4gICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAqIEBzaG9ydCBTZXRzIHRoZSB3ZWVrZGF5IG9mIHRoZSBkYXRlLlxuICAgICAqIEBleHRyYSBJbiBvcmRlciB0byBtYWludGFpbiBhIHBhcmFsbGVsIHdpdGggJWdldFdlZWtkYXklICh3aGljaCBpdHNlbGYgaXMgYW4gYWxpYXMgZm9yIEphdmFzY3JpcHQgbmF0aXZlICVnZXREYXklKSwgU3VuZGF5IGlzIGNvbnNpZGVyZWQgZGF5ICUwJS4gVGhpcyBjb250cmFzdHMgd2l0aCBJU08tODYwMSBzdGFuZGFyZCAodXNlZCBpbiAlZ2V0SVNPV2VlayUgYW5kICVzZXRJU09XZWVrJSkgd2hpY2ggcGxhY2VzIFN1bmRheSBhdCB0aGUgZW5kIG9mIHRoZSB3ZWVrIChkYXkgNykuIFRoaXMgZWZmZWN0aXZlbHkgbWVhbnMgdGhhdCBwYXNzaW5nICUwJSB0byB0aGlzIG1ldGhvZCB3aGlsZSBpbiB0aGUgbWlkZGxlIG9mIGEgd2VlayB3aWxsIHJld2luZCB0aGUgZGF0ZSwgd2hlcmUgcGFzc2luZyAlNyUgd2lsbCBhZHZhbmNlIGl0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgZCA9IG5ldyBEYXRlKCk7IGQuc2V0V2Vla2RheSgxKTsgZDsgLT4gTW9uZGF5IG9mIHRoaXMgd2Vla1xuICAgICAqICAgZCA9IG5ldyBEYXRlKCk7IGQuc2V0V2Vla2RheSg2KTsgZDsgLT4gU2F0dXJkYXkgb2YgdGhpcyB3ZWVrXG4gICAgICpcbiAgICAgKioqL1xuICAgICdzZXRXZWVrZGF5JzogZnVuY3Rpb24oZG93KSB7XG4gICAgICBpZihpc1VuZGVmaW5lZChkb3cpKSByZXR1cm47XG4gICAgICByZXR1cm4gY2FsbERhdGVTZXQodGhpcywgJ0RhdGUnLCBjYWxsRGF0ZUdldCh0aGlzLCAnRGF0ZScpICsgZG93IC0gY2FsbERhdGVHZXQodGhpcywgJ0RheScpKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHNldElTT1dlZWsoKVxuICAgICAqIEByZXR1cm5zIE5vdGhpbmdcbiAgICAgKiBAc2hvcnQgU2V0cyB0aGUgd2VlayAob2YgdGhlIHllYXIpIGFzIGRlZmluZWQgYnkgdGhlIElTTy04NjAxIHN0YW5kYXJkLlxuICAgICAqIEBleHRyYSBOb3RlIHRoYXQgdGhpcyBzdGFuZGFyZCBwbGFjZXMgU3VuZGF5IGF0IHRoZSBlbmQgb2YgdGhlIHdlZWsgKGRheSA3KS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIGQgPSBuZXcgRGF0ZSgpOyBkLnNldElTT1dlZWsoMTUpOyBkOyAtPiAxNXRoIHdlZWsgb2YgdGhlIHllYXJcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3NldElTT1dlZWsnOiBmdW5jdGlvbih3ZWVrKSB7XG4gICAgICB2YXIgd2Vla2RheSA9IGNhbGxEYXRlR2V0KHRoaXMsICdEYXknKSB8fCA3O1xuICAgICAgaWYoaXNVbmRlZmluZWQod2VlaykpIHJldHVybjtcbiAgICAgIHRoaXMuc2V0KHsgJ21vbnRoJzogMCwgJ2RhdGUnOiA0IH0pO1xuICAgICAgdGhpcy5zZXQoeyAnd2Vla2RheSc6IDEgfSk7XG4gICAgICBpZih3ZWVrID4gMSkge1xuICAgICAgICB0aGlzLmFkZFdlZWtzKHdlZWsgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmKHdlZWtkYXkgIT09IDEpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKHsgJ2RheXMnOiB3ZWVrZGF5IC0gMSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldFRpbWUoKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGdldElTT1dlZWsoKVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBHZXRzIHRoZSBkYXRlJ3Mgd2VlayAob2YgdGhlIHllYXIpIGFzIGRlZmluZWQgYnkgdGhlIElTTy04NjAxIHN0YW5kYXJkLlxuICAgICAqIEBleHRyYSBOb3RlIHRoYXQgdGhpcyBzdGFuZGFyZCBwbGFjZXMgU3VuZGF5IGF0IHRoZSBlbmQgb2YgdGhlIHdlZWsgKGRheSA3KS4gSWYgJXV0YyUgaXMgc2V0IG9uIHRoZSBkYXRlLCB0aGUgd2VlayB3aWxsIGJlIGFjY29yZGluZyB0byBVVEMgdGltZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIG5ldyBEYXRlKCkuZ2V0SVNPV2VlaygpICAgIC0+IHRvZGF5J3Mgd2VlayBvZiB0aGUgeWVhclxuICAgICAqXG4gICAgICoqKi9cbiAgICAnZ2V0SVNPV2Vlayc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldFdlZWtOdW1iZXIodGhpcyk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBiZWdpbm5pbmdPZklTT1dlZWsoKVxuICAgICAqIEByZXR1cm5zIERhdGVcbiAgICAgKiBAc2hvcnQgU2V0IHRoZSBkYXRlIHRvIHRoZSBiZWdpbm5pbmcgb2Ygd2VlayBhcyBkZWZpbmVkIGJ5IHRoaXMgSVNPLTg2MDEgc3RhbmRhcmQuXG4gICAgICogQGV4dHJhIE5vdGUgdGhhdCB0aGlzIHN0YW5kYXJkIHBsYWNlcyBNb25kYXkgYXQgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuYmVnaW5uaW5nT2ZJU09XZWVrKCkgLT4gTW9uZGF5XG4gICAgICpcbiAgICAgKioqL1xuICAgICdiZWdpbm5pbmdPZklTT1dlZWsnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXkgPSB0aGlzLmdldERheSgpO1xuICAgICAgaWYoZGF5ID09PSAwKSB7XG4gICAgICAgIGRheSA9IC02O1xuICAgICAgfSBlbHNlIGlmKGRheSAhPT0gMSkge1xuICAgICAgICBkYXkgPSAxO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRXZWVrZGF5KGRheSk7XG4gICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgZW5kT2ZJU09XZWVrKClcbiAgICAgKiBAcmV0dXJucyBEYXRlXG4gICAgICogQHNob3J0IFNldCB0aGUgZGF0ZSB0byB0aGUgZW5kIG9mIHdlZWsgYXMgZGVmaW5lZCBieSB0aGlzIElTTy04NjAxIHN0YW5kYXJkLlxuICAgICAqIEBleHRyYSBOb3RlIHRoYXQgdGhpcyBzdGFuZGFyZCBwbGFjZXMgU3VuZGF5IGF0IHRoZSBlbmQgb2YgdGhlIHdlZWsuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgRGF0ZS5jcmVhdGUoKS5lbmRPZklTT1dlZWsoKSAtPiBTdW5kYXlcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2VuZE9mSVNPV2Vlayc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5nZXREYXkoKSAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldFdlZWtkYXkoNyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbmRPZkRheSgpXG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBnZXRVVENPZmZzZXQoW2lzb10pXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9mZnNldCBmcm9tIFVUQyB0aW1lLiBJZiBbaXNvXSBpcyB0cnVlIHRoZSBvZmZzZXQgd2lsbCBiZSBpbiBJU084NjAxIGZvcm1hdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBuZXcgRGF0ZSgpLmdldFVUQ09mZnNldCgpICAgICAtPiBcIiswOTAwXCJcbiAgICAgKiAgIG5ldyBEYXRlKCkuZ2V0VVRDT2Zmc2V0KHRydWUpIC0+IFwiKzA5OjAwXCJcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2dldFVUQ09mZnNldCc6IGZ1bmN0aW9uKGlzbykge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX3V0YyA/IDAgOiB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgY29sb24gID0gaXNvID09PSB0cnVlID8gJzonIDogJyc7XG4gICAgICBpZighb2Zmc2V0ICYmIGlzbykgcmV0dXJuICdaJztcbiAgICAgIHJldHVybiBwYWROdW1iZXIoZmxvb3IoLW9mZnNldCAvIDYwKSwgMiwgdHJ1ZSkgKyBjb2xvbiArIHBhZE51bWJlcihhYnMob2Zmc2V0ICUgNjApLCAyKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHV0Yyhbb25dID0gdHJ1ZSlcbiAgICAgKiBAcmV0dXJucyBEYXRlXG4gICAgICogQHNob3J0IFNldHMgdGhlIGludGVybmFsIHV0YyBmbGFnIGZvciB0aGUgZGF0ZS4gV2hlbiBvbiwgVVRDLWJhc2VkIG1ldGhvZHMgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseS5cbiAgICAgKiBAZXh0cmEgRm9yIG1vcmUgc2VlIEBkYXRlX2Zvcm1hdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBuZXcgRGF0ZSgpLnV0Yyh0cnVlKVxuICAgICAqICAgbmV3IERhdGUoKS51dGMoZmFsc2UpXG4gICAgICpcbiAgICAgKioqL1xuICAgICd1dGMnOiBmdW5jdGlvbihzZXQpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdfdXRjJywgc2V0ID09PSB0cnVlIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBpc1VUQygpXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIGRhdGUgaGFzIG5vIHRpbWV6b25lIG9mZnNldC5cbiAgICAgKiBAZXh0cmEgVGhpcyB3aWxsIGFsc28gcmV0dXJuIHRydWUgZm9yIHV0Yy1iYXNlZCBkYXRlcyAoZGF0ZXMgdGhhdCBoYXZlIHRoZSAldXRjJSBtZXRob2Qgc2V0IHRydWUpLiBOb3RlIHRoYXQgZXZlbiBpZiB0aGUgdXRjIGZsYWcgaXMgc2V0LCAlZ2V0VGltZXpvbmVPZmZzZXQlIHdpbGwgYWx3YXlzIHJlcG9ydCB0aGUgc2FtZSB0aGluZyBhcyBKYXZhc2NyaXB0IGFsd2F5cyByZXBvcnRzIHRoYXQgYmFzZWQgb24gdGhlIGVudmlyb25tZW50J3MgbG9jYWxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIG5ldyBEYXRlKCkuaXNVVEMoKSAgICAgICAgICAgLT4gdHJ1ZSBvciBmYWxzZT9cbiAgICAgKiAgIG5ldyBEYXRlKCkudXRjKHRydWUpLmlzVVRDKCkgLT4gdHJ1ZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNVVEMnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX3V0YyB8fCB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCkgPT09IDA7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBhZHZhbmNlKDxzZXQ+LCBbcmVzZXRdID0gZmFsc2UpXG4gICAgICogQHJldHVybnMgRGF0ZVxuICAgICAqIEBzaG9ydCBTZXRzIHRoZSBkYXRlIGZvcndhcmQuXG4gICAgICogQGV4dHJhIFRoaXMgbWV0aG9kIGNhbiBhY2NlcHQgbXVsdGlwbGUgZm9ybWF0cyBpbmNsdWRpbmcgYW4gb2JqZWN0LCBhIHN0cmluZyBpbiB0aGUgZm9ybWF0ICUzIGRheXMlLCBhIHNpbmdsZSBudW1iZXIgYXMgbWlsbGlzZWNvbmRzLCBvciBlbnVtZXJhdGVkIHBhcmFtZXRlcnMgKGFzIHdpdGggdGhlIERhdGUgY29uc3RydWN0b3IpLiBJZiBbcmVzZXRdIGlzICV0cnVlJSwgYW55IHVuaXRzIG1vcmUgc3BlY2lmaWMgdGhhbiB0aG9zZSBwYXNzZWQgd2lsbCBiZSByZXNldC4gRm9yIG1vcmUgc2VlIEBkYXRlX2Zvcm1hdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBuZXcgRGF0ZSgpLmFkdmFuY2UoeyB5ZWFyOiAyIH0pIC0+IDIgeWVhcnMgaW4gdGhlIGZ1dHVyZVxuICAgICAqICAgbmV3IERhdGUoKS5hZHZhbmNlKCcyIGRheXMnKSAgICAtPiAyIGRheXMgaW4gdGhlIGZ1dHVyZVxuICAgICAqICAgbmV3IERhdGUoKS5hZHZhbmNlKDAsIDIsIDMpICAgICAtPiAyIG1vbnRocyAzIGRheXMgaW4gdGhlIGZ1dHVyZVxuICAgICAqICAgbmV3IERhdGUoKS5hZHZhbmNlKDg2NDAwMDAwKSAgICAtPiAxIGRheSBpbiB0aGUgZnV0dXJlXG4gICAgICpcbiAgICAgKioqL1xuICAgICdhZHZhbmNlJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGNvbGxlY3REYXRlQXJndW1lbnRzKGFyZ3VtZW50cywgdHJ1ZSk7XG4gICAgICByZXR1cm4gdXBkYXRlRGF0ZSh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCAxKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHJld2luZCg8c2V0PiwgW3Jlc2V0XSA9IGZhbHNlKVxuICAgICAqIEByZXR1cm5zIERhdGVcbiAgICAgKiBAc2hvcnQgU2V0cyB0aGUgZGF0ZSBiYWNrLlxuICAgICAqIEBleHRyYSBUaGlzIG1ldGhvZCBjYW4gYWNjZXB0IG11bHRpcGxlIGZvcm1hdHMgaW5jbHVkaW5nIGEgc2luZ2xlIG51bWJlciBhcyBhIHRpbWVzdGFtcCwgYW4gb2JqZWN0LCBvciBlbnVtZXJhdGVkIHBhcmFtZXRlcnMgKGFzIHdpdGggdGhlIERhdGUgY29uc3RydWN0b3IpLiBJZiBbcmVzZXRdIGlzICV0cnVlJSwgYW55IHVuaXRzIG1vcmUgc3BlY2lmaWMgdGhhbiB0aG9zZSBwYXNzZWQgd2lsbCBiZSByZXNldC4gRm9yIG1vcmUgc2VlIEBkYXRlX2Zvcm1hdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBuZXcgRGF0ZSgpLnJld2luZCh7IHllYXI6IDIgfSkgLT4gMiB5ZWFycyBpbiB0aGUgcGFzdFxuICAgICAqICAgbmV3IERhdGUoKS5yZXdpbmQoMCwgMiwgMykgICAgIC0+IDIgbW9udGhzIDMgZGF5cyBpbiB0aGUgcGFzdFxuICAgICAqICAgbmV3IERhdGUoKS5yZXdpbmQoODY0MDAwMDApICAgIC0+IDEgZGF5IGluIHRoZSBwYXN0XG4gICAgICpcbiAgICAgKioqL1xuICAgICdyZXdpbmQnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gY29sbGVjdERhdGVBcmd1bWVudHMoYXJndW1lbnRzLCB0cnVlKTtcbiAgICAgIHJldHVybiB1cGRhdGVEYXRlKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIC0xKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGlzVmFsaWQoKVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRlIGlzIHZhbGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIG5ldyBEYXRlKCkuaXNWYWxpZCgpICAgICAgICAgLT4gdHJ1ZVxuICAgICAqICAgbmV3IERhdGUoJ2ZsZXhvcicpLmlzVmFsaWQoKSAtPiBmYWxzZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNWYWxpZCc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFpc05hTih0aGlzLmdldFRpbWUoKSk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBpc0FmdGVyKDxkPiwgW21hcmdpbl0gPSAwKVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRlIGlzIGFmdGVyIHRoZSA8ZD4uXG4gICAgICogQGV4dHJhIFttYXJnaW5dIGlzIHRvIGFsbG93IGV4dHJhIG1hcmdpbiBvZiBlcnJvciAoaW4gbXMpLiA8ZD4gd2lsbCBhY2NlcHQgYSBkYXRlIG9iamVjdCwgdGltZXN0YW1wLCBvciB0ZXh0IGZvcm1hdC4gSWYgbm90IHNwZWNpZmllZCwgPGQ+IGlzIGFzc3VtZWQgdG8gYmUgbm93LiBTZWUgQGRhdGVfZm9ybWF0IGZvciBtb3JlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIG5ldyBEYXRlKCkuaXNBZnRlcigndG9tb3Jyb3cnKSAgLT4gZmFsc2VcbiAgICAgKiAgIG5ldyBEYXRlKCkuaXNBZnRlcigneWVzdGVyZGF5JykgLT4gdHJ1ZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNBZnRlcic6IGZ1bmN0aW9uKGQsIG1hcmdpbiwgdXRjKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaW1lKCkgPiBkYXRlLmNyZWF0ZShkKS5nZXRUaW1lKCkgLSAobWFyZ2luIHx8IDApO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgaXNCZWZvcmUoPGQ+LCBbbWFyZ2luXSA9IDApXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIGRhdGUgaXMgYmVmb3JlIDxkPi5cbiAgICAgKiBAZXh0cmEgW21hcmdpbl0gaXMgdG8gYWxsb3cgZXh0cmEgbWFyZ2luIG9mIGVycm9yIChpbiBtcykuIDxkPiB3aWxsIGFjY2VwdCBhIGRhdGUgb2JqZWN0LCB0aW1lc3RhbXAsIG9yIHRleHQgZm9ybWF0LiBJZiBub3Qgc3BlY2lmaWVkLCA8ZD4gaXMgYXNzdW1lZCB0byBiZSBub3cuIFNlZSBAZGF0ZV9mb3JtYXQgZm9yIG1vcmUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgbmV3IERhdGUoKS5pc0JlZm9yZSgndG9tb3Jyb3cnKSAgLT4gdHJ1ZVxuICAgICAqICAgbmV3IERhdGUoKS5pc0JlZm9yZSgneWVzdGVyZGF5JykgLT4gZmFsc2VcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2lzQmVmb3JlJzogZnVuY3Rpb24oZCwgbWFyZ2luKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaW1lKCkgPCBkYXRlLmNyZWF0ZShkKS5nZXRUaW1lKCkgKyAobWFyZ2luIHx8IDApO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgaXNCZXR3ZWVuKDxkMT4sIDxkMj4sIFttYXJnaW5dID0gMClcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF0ZSBmYWxscyBiZXR3ZWVuIDxkMT4gYW5kIDxkMj4uXG4gICAgICogQGV4dHJhIFttYXJnaW5dIGlzIHRvIGFsbG93IGV4dHJhIG1hcmdpbiBvZiBlcnJvciAoaW4gbXMpLiA8ZDE+IGFuZCA8ZDI+IHdpbGwgYWNjZXB0IGEgZGF0ZSBvYmplY3QsIHRpbWVzdGFtcCwgb3IgdGV4dCBmb3JtYXQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgbm93LiBTZWUgQGRhdGVfZm9ybWF0IGZvciBtb3JlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIG5ldyBEYXRlKCkuaXNCZXR3ZWVuKCd5ZXN0ZXJkYXknLCAndG9tb3Jyb3cnKSAgICAtPiB0cnVlXG4gICAgICogICBuZXcgRGF0ZSgpLmlzQmV0d2VlbignbGFzdCB5ZWFyJywgJzIgeWVhcnMgYWdvJykgLT4gZmFsc2VcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2lzQmV0d2Vlbic6IGZ1bmN0aW9uKGQxLCBkMiwgbWFyZ2luKSB7XG4gICAgICB2YXIgdCAgPSB0aGlzLmdldFRpbWUoKTtcbiAgICAgIHZhciB0MSA9IGRhdGUuY3JlYXRlKGQxKS5nZXRUaW1lKCk7XG4gICAgICB2YXIgdDIgPSBkYXRlLmNyZWF0ZShkMikuZ2V0VGltZSgpO1xuICAgICAgdmFyIGxvID0gbWluKHQxLCB0Mik7XG4gICAgICB2YXIgaGkgPSBtYXgodDEsIHQyKTtcbiAgICAgIG1hcmdpbiA9IG1hcmdpbiB8fCAwO1xuICAgICAgcmV0dXJuIChsbyAtIG1hcmdpbiA8IHQpICYmIChoaSArIG1hcmdpbiA+IHQpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgaXNMZWFwWWVhcigpXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIGRhdGUgaXMgYSBsZWFwIHllYXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgRGF0ZS5jcmVhdGUoJzIwMDAnKS5pc0xlYXBZZWFyKCkgLT4gdHJ1ZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNMZWFwWWVhcic6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHllYXIgPSBjYWxsRGF0ZUdldCh0aGlzLCAnRnVsbFllYXInKTtcbiAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgKHllYXIgJSA0MDAgPT09IDApO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgZGF5c0luTW9udGgoKVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgZGF0ZSdzIG1vbnRoLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUuY3JlYXRlKCdNYXknKS5kYXlzSW5Nb250aCgpICAgICAgICAgICAgLT4gMzFcbiAgICAgKiAgIERhdGUuY3JlYXRlKCdGZWJydWFyeSwgMjAwMCcpLmRheXNJbk1vbnRoKCkgLT4gMjlcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2RheXNJbk1vbnRoJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMzIgLSBjYWxsRGF0ZUdldChuZXcgZGF0ZShjYWxsRGF0ZUdldCh0aGlzLCAnRnVsbFllYXInKSwgY2FsbERhdGVHZXQodGhpcywgJ01vbnRoJyksIDMyKSwgJ0RhdGUnKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGZvcm1hdCg8Zm9ybWF0PiwgW2xvY2FsZV0gPSBjdXJyZW50TG9jYWxlKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBGb3JtYXRzIGFuZCBvdXRwdXRzIHRoZSBkYXRlLlxuICAgICAqIEBleHRyYSA8Zm9ybWF0PiBjYW4gYmUgYSBudW1iZXIgb2YgcHJlLWRldGVybWluZWQgZm9ybWF0cyBvciBhIHN0cmluZyBvZiB0b2tlbnMuIExvY2FsZS1zcGVjaWZpYyBmb3JtYXRzIGFyZSAlc2hvcnQlLCAlbG9uZyUsIGFuZCAlZnVsbCUgd2hpY2ggaGF2ZSB0aGVpciBvd24gYWxpYXNlcyBhbmQgY2FuIGJlIGNhbGxlZCB3aXRoICVkYXRlLnNob3J0KCklLCBldGMuIElmIDxmb3JtYXQ+IGlzIG5vdCBzcGVjaWZpZWQgdGhlICVsb25nJSBmb3JtYXQgaXMgYXNzdW1lZC4gW2xvY2FsZV0gc3BlY2lmaWVzIGEgbG9jYWxlIGNvZGUgdG8gdXNlIChpZiBub3Qgc3BlY2lmaWVkIHRoZSBjdXJyZW50IGxvY2FsZSBpcyB1c2VkKS4gU2VlIEBkYXRlX2Zvcm1hdCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHNldFxuICAgICAqICAgc2hvcnRcbiAgICAgKiAgIGxvbmdcbiAgICAgKiAgIGZ1bGxcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuZm9ybWF0KCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IGV4LiBKdWx5IDQsIDIwMDNcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuZm9ybWF0KCd7V2Vla2RheX0ge2R9IHtNb250aH0sIHt5eXl5fScpICAgIC0+IGV4LiBNb25kYXkgSnVseSA0LCAyMDAzXG4gICAgICogICBEYXRlLmNyZWF0ZSgpLmZvcm1hdCgne2hofTp7bW19JykgICAgICAgICAgICAgICAgICAgICAgICAtPiBleC4gMTU6NTdcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuZm9ybWF0KCd7MTJocn06e21tfXt0dH0nKSAgICAgICAgICAgICAgICAgIC0+IGV4LiAzOjU3cG1cbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuZm9ybWF0KERhdGUuSVNPODYwMV9EQVRFVElNRSkgICAgICAgICAgICAgIC0+IGV4LiAyMDExLTA3LTA1IDEyOjI0OjU1LjUyOFpcbiAgICAgKiAgIERhdGUuY3JlYXRlKCdsYXN0IHdlZWsnKS5mb3JtYXQoJ3Nob3J0JywgJ2phJykgICAgICAgICAgICAgICAgLT4gZXguIOWFiOmAsVxuICAgICAqICAgRGF0ZS5jcmVhdGUoJ3llc3RlcmRheScpLmZvcm1hdChmdW5jdGlvbih2YWx1ZSx1bml0LG1zLGxvYykge1xuICAgICAqICAgICAvLyB2YWx1ZSA9IDEsIHVuaXQgPSAzLCBtcyA9IC04NjQwMDAwMCwgbG9jID0gW2N1cnJlbnQgbG9jYWxlIG9iamVjdF1cbiAgICAgKiAgIH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IGV4LiAxIGRheSBhZ29cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2Zvcm1hdCc6IGZ1bmN0aW9uKGYsIGxvY2FsZUNvZGUpIHtcbiAgICAgIHJldHVybiBmb3JtYXREYXRlKHRoaXMsIGYsIGZhbHNlLCBsb2NhbGVDb2RlKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHJlbGF0aXZlKFtmbl0sIFtsb2NhbGVdID0gY3VycmVudExvY2FsZSlcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhIHJlbGF0aXZlIGRhdGUgc3RyaW5nIG9mZnNldCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqIEBleHRyYSBbZm5dIGNhbiBiZSBwYXNzZWQgdG8gcHJvdmlkZSBmb3IgbW9yZSBncmFudWxhciBjb250cm9sIG92ZXIgdGhlIHJlc3VsdGluZyBzdHJpbmcuIFtmbl0gaXMgcGFzc2VkIDQgYXJndW1lbnRzOiB0aGUgYWRqdXN0ZWQgdmFsdWUsIHVuaXQsIG9mZnNldCBpbiBtaWxsaXNlY29uZHMsIGFuZCBhIGxvY2FsaXphdGlvbiBvYmplY3QuIEFzIGFuIGFsdGVybmF0ZSBzeW50YXgsIFtsb2NhbGVdIGNhbiBhbHNvIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgKGFuZCBvbmx5KSBwYXJhbWV0ZXIuIEZvciBtb3JlLCBzZWUgQGRhdGVfZm9ybWF0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUuY3JlYXRlKCc5MCBzZWNvbmRzIGFnbycpLnJlbGF0aXZlKCkgLT4gMSBtaW51dGUgYWdvXG4gICAgICogICBEYXRlLmNyZWF0ZSgnSmFudWFyeScpLnJlbGF0aXZlKCkgICAgICAgIC0+IGV4LiA1IG1vbnRocyBhZ29cbiAgICAgKiAgIERhdGUuY3JlYXRlKCdKYW51YXJ5JykucmVsYXRpdmUoJ2phJykgICAgLT4gM+ODtuaciOWJjVxuICAgICAqICAgRGF0ZS5jcmVhdGUoJzEyMCBtaW51dGVzIGFnbycpLnJlbGF0aXZlKGZ1bmN0aW9uKHZhbCx1bml0LG1zLGxvYykge1xuICAgICAqICAgICAvLyB2YWx1ZSA9IDIsIHVuaXQgPSAzLCBtcyA9IC03MjAwLCBsb2MgPSBbY3VycmVudCBsb2NhbGUgb2JqZWN0XVxuICAgICAqICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBleC4gNSBtb250aHMgYWdvXG4gICAgICpcbiAgICAgKioqL1xuICAgICdyZWxhdGl2ZSc6IGZ1bmN0aW9uKGZuLCBsb2NhbGVDb2RlKSB7XG4gICAgICBpZihpc1N0cmluZyhmbikpIHtcbiAgICAgICAgbG9jYWxlQ29kZSA9IGZuO1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZSh0aGlzLCBmbiwgdHJ1ZSwgbG9jYWxlQ29kZSk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBpcyg8ZD4sIFttYXJnaW5dID0gMClcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF0ZSBpcyA8ZD4uXG4gICAgICogQGV4dHJhIDxkPiB3aWxsIGFjY2VwdCBhIGRhdGUgb2JqZWN0LCB0aW1lc3RhbXAsIG9yIHRleHQgZm9ybWF0LiAlaXMlIGFkZGl0aW9uYWxseSB1bmRlcnN0YW5kcyBtb3JlIGdlbmVyYWxpemVkIGV4cHJlc3Npb25zIGxpa2UgbW9udGgvd2Vla2RheSBuYW1lcywgJ3RvZGF5JywgZXRjLCBhbmQgY29tcGFyZXMgdG8gdGhlIHByZWNpc2lvbiBpbXBsaWVkIGluIDxkPi4gW21hcmdpbl0gYWxsb3dzIGFuIGV4dHJhIG1hcmdpbiBvZiBlcnJvciBpbiBtaWxsaXNlY29uZHMuICBGb3IgbW9yZSwgc2VlIEBkYXRlX2Zvcm1hdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBEYXRlLmNyZWF0ZSgpLmlzKCdKdWx5JykgICAgICAgICAgICAgICAtPiB0cnVlIG9yIGZhbHNlP1xuICAgICAqICAgRGF0ZS5jcmVhdGUoKS5pcygnMTc3NicpICAgICAgICAgICAgICAgLT4gZmFsc2VcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuaXMoJ3RvZGF5JykgICAgICAgICAgICAgIC0+IHRydWVcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuaXMoJ3dlZWtkYXknKSAgICAgICAgICAgIC0+IHRydWUgb3IgZmFsc2U/XG4gICAgICogICBEYXRlLmNyZWF0ZSgpLmlzKCdKdWx5IDQsIDE3NzYnKSAgICAgICAtPiBmYWxzZVxuICAgICAqICAgRGF0ZS5jcmVhdGUoKS5pcygtNjEwNjA5MzIwMDAwMCkgICAgICAgLT4gZmFsc2VcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkuaXMobmV3IERhdGUoMTc3NiwgNiwgNCkpIC0+IGZhbHNlXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpcyc6IGZ1bmN0aW9uKGQsIG1hcmdpbiwgdXRjKSB7XG4gICAgICB2YXIgdG1wLCBjb21wO1xuICAgICAgaWYoIXRoaXMuaXNWYWxpZCgpKSByZXR1cm47XG4gICAgICBpZihpc1N0cmluZyhkKSkge1xuICAgICAgICBkID0gZC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29tcCA9IHRoaXMuY2xvbmUoKS51dGModXRjKTtcbiAgICAgICAgc3dpdGNoKHRydWUpIHtcbiAgICAgICAgICBjYXNlIGQgPT09ICdmdXR1cmUnOiAgcmV0dXJuIHRoaXMuZ2V0VGltZSgpID4gZ2V0TmV3RGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICBjYXNlIGQgPT09ICdwYXN0JzogICAgcmV0dXJuIHRoaXMuZ2V0VGltZSgpIDwgZ2V0TmV3RGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICBjYXNlIGQgPT09ICd3ZWVrZGF5JzogcmV0dXJuIGNhbGxEYXRlR2V0KGNvbXAsICdEYXknKSA+IDAgJiYgY2FsbERhdGVHZXQoY29tcCwgJ0RheScpIDwgNjtcbiAgICAgICAgICBjYXNlIGQgPT09ICd3ZWVrZW5kJzogcmV0dXJuIGNhbGxEYXRlR2V0KGNvbXAsICdEYXknKSA9PT0gMCB8fCBjYWxsRGF0ZUdldChjb21wLCAnRGF5JykgPT09IDY7XG4gICAgICAgICAgY2FzZSAodG1wID0gRW5nbGlzaFsnd2Vla2RheXMnXS5pbmRleE9mKGQpICUgNykgPiAtMTogcmV0dXJuIGNhbGxEYXRlR2V0KGNvbXAsICdEYXknKSA9PT0gdG1wO1xuICAgICAgICAgIGNhc2UgKHRtcCA9IEVuZ2xpc2hbJ21vbnRocyddLmluZGV4T2YoZCkgJSAxMikgPiAtMTogIHJldHVybiBjYWxsRGF0ZUdldChjb21wLCAnTW9udGgnKSA9PT0gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGFyZURhdGUodGhpcywgZCwgbnVsbCwgbWFyZ2luLCB1dGMpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmVzZXQoW3VuaXRdID0gJ2hvdXJzJylcbiAgICAgKiBAcmV0dXJucyBEYXRlXG4gICAgICogQHNob3J0IFJlc2V0cyB0aGUgdW5pdCBwYXNzZWQgYW5kIGFsbCBzbWFsbGVyIHVuaXRzLiBEZWZhdWx0IGlzIFwiaG91cnNcIiwgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIHRoZSB0aW1lLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUuY3JlYXRlKCkucmVzZXQoJ2RheScpICAgLT4gQmVnaW5uaW5nIG9mIHRvZGF5XG4gICAgICogICBEYXRlLmNyZWF0ZSgpLnJlc2V0KCdtb250aCcpIC0+IDFzdCBvZiB0aGUgbW9udGhcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3Jlc2V0JzogZnVuY3Rpb24odW5pdCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHt9LCByZWNvZ25pemVkO1xuICAgICAgdW5pdCA9IHVuaXQgfHwgJ2hvdXJzJztcbiAgICAgIGlmKHVuaXQgPT09ICdkYXRlJykgdW5pdCA9ICdkYXlzJztcbiAgICAgIHJlY29nbml6ZWQgPSBEYXRlVW5pdHMuc29tZShmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1bml0ID09PSB1Lm5hbWUgfHwgdW5pdCA9PT0gdS5uYW1lICsgJ3MnO1xuICAgICAgfSk7XG4gICAgICBwYXJhbXNbdW5pdF0gPSB1bml0Lm1hdGNoKC9eZGF5cz8vKSA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlY29nbml6ZWQgPyB0aGlzLnNldChwYXJhbXMsIHRydWUpIDogdGhpcztcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNsb25lKClcbiAgICAgKiBAcmV0dXJucyBEYXRlXG4gICAgICogQHNob3J0IENsb25lcyB0aGUgZGF0ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBEYXRlLmNyZWF0ZSgpLmNsb25lKCkgLT4gQ29weSBvZiBub3dcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2Nsb25lJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IG5ldyBkYXRlKHRoaXMuZ2V0VGltZSgpKTtcbiAgICAgIGQudXRjKCEhdGhpcy5fdXRjKTtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICB9KTtcblxuXG4gIC8vIEluc3RhbmNlIGFsaWFzZXNcbiAgZXh0ZW5kKGRhdGUsIHRydWUsIHRydWUsIHtcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBpc28oKVxuICAgICAqIEBhbGlhcyB0b0lTT1N0cmluZ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNvJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0lTT1N0cmluZygpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgZ2V0V2Vla2RheSgpXG4gICAgICogQHJldHVybnMgTnVtYmVyXG4gICAgICogQHNob3J0IEFsaWFzIGZvciAlZ2V0RGF5JS5cbiAgICAgKiBAc2V0XG4gICAgICogICBnZXRVVENXZWVrZGF5XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICsgICBEYXRlLmNyZWF0ZSgpLmdldFdlZWtkYXkoKTsgICAgLT4gKGV4LikgM1xuICAgICArICAgRGF0ZS5jcmVhdGUoKS5nZXRVVENXZWVrZGF5KCk7ICAgIC0+IChleC4pIDNcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2dldFdlZWtkYXknOiAgICBkYXRlLnByb3RvdHlwZS5nZXREYXksXG4gICAgJ2dldFVUQ1dlZWtkYXknOiAgICBkYXRlLnByb3RvdHlwZS5nZXRVVENEYXlcblxuICB9KTtcblxuXG5cbiAgLyoqKlxuICAgKiBOdW1iZXIgbW9kdWxlXG4gICAqXG4gICAqKiovXG5cbiAgLyoqKlxuICAgKiBAbWV0aG9kIFt1bml0XSgpXG4gICAqIEByZXR1cm5zIE51bWJlclxuICAgKiBAc2hvcnQgVGFrZXMgdGhlIG51bWJlciBhcyBhIGNvcnJlc3BvbmRpbmcgdW5pdCBvZiB0aW1lIGFuZCBjb252ZXJ0cyB0byBtaWxsaXNlY29uZHMuXG4gICAqIEBleHRyYSBNZXRob2QgbmFtZXMgY2FuIGJlIHNpbmd1bGFyIG9yIHBsdXJhbC4gIE5vdGUgdGhhdCBhcyBcImEgbW9udGhcIiBpcyBhbWJpZ3VvdXMgYXMgYSB1bml0IG9mIHRpbWUsICVtb250aHMlIHdpbGwgYmUgZXF1aXZhbGVudCB0byAzMC40Mzc1IGRheXMsIHRoZSBhdmVyYWdlIG51bWJlciBpbiBhIG1vbnRoLiBCZSBjYXJlZnVsIHVzaW5nICVtb250aHMlIGlmIHlvdSBuZWVkIGV4YWN0IHByZWNpc2lvbi5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIG1pbGxpc2Vjb25kXG4gICAqICAgbWlsbGlzZWNvbmRzXG4gICAqICAgc2Vjb25kXG4gICAqICAgc2Vjb25kc1xuICAgKiAgIG1pbnV0ZVxuICAgKiAgIG1pbnV0ZXNcbiAgICogICBob3VyXG4gICAqICAgaG91cnNcbiAgICogICBkYXlcbiAgICogICBkYXlzXG4gICAqICAgd2Vla1xuICAgKiAgIHdlZWtzXG4gICAqICAgbW9udGhcbiAgICogICBtb250aHNcbiAgICogICB5ZWFyXG4gICAqICAgeWVhcnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAoNSkubWlsbGlzZWNvbmRzKCkgLT4gNVxuICAgKiAgICgxMCkuaG91cnMoKSAgICAgICAtPiAzNjAwMDAwMFxuICAgKiAgICgxKS5kYXkoKSAgICAgICAgICAtPiA4NjQwMDAwMFxuICAgKlxuICAgKioqXG4gICAqIEBtZXRob2QgW3VuaXRdQmVmb3JlKFtkXSwgW2xvY2FsZV0gPSBjdXJyZW50TG9jYWxlKVxuICAgKiBAcmV0dXJucyBEYXRlXG4gICAqIEBzaG9ydCBSZXR1cm5zIGEgZGF0ZSB0aGF0IGlzIDxuPiB1bml0cyBiZWZvcmUgW2RdLCB3aGVyZSA8bj4gaXMgdGhlIG51bWJlci5cbiAgICogQGV4dHJhIFtkXSB3aWxsIGFjY2VwdCBhIGRhdGUgb2JqZWN0LCB0aW1lc3RhbXAsIG9yIHRleHQgZm9ybWF0LiBOb3RlIHRoYXQgXCJtb250aHNcIiBpcyBhbWJpZ3VvdXMgYXMgYSB1bml0IG9mIHRpbWUuIElmIHRoZSB0YXJnZXQgZGF0ZSBmYWxscyBvbiBhIGRheSB0aGF0IGRvZXMgbm90IGV4aXN0IChpZS4gQXVndXN0IDMxIC0+IEZlYnJ1YXJ5IDMxKSwgdGhlIGRhdGUgd2lsbCBiZSBzaGlmdGVkIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGguIEJlIGNhcmVmdWwgdXNpbmcgJW1vbnRoc0JlZm9yZSUgaWYgeW91IG5lZWQgZXhhY3QgcHJlY2lzaW9uLiBTZWUgQGRhdGVfZm9ybWF0IGZvciBtb3JlLlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgbWlsbGlzZWNvbmRCZWZvcmVcbiAgICogICBtaWxsaXNlY29uZHNCZWZvcmVcbiAgICogICBzZWNvbmRCZWZvcmVcbiAgICogICBzZWNvbmRzQmVmb3JlXG4gICAqICAgbWludXRlQmVmb3JlXG4gICAqICAgbWludXRlc0JlZm9yZVxuICAgKiAgIGhvdXJCZWZvcmVcbiAgICogICBob3Vyc0JlZm9yZVxuICAgKiAgIGRheUJlZm9yZVxuICAgKiAgIGRheXNCZWZvcmVcbiAgICogICB3ZWVrQmVmb3JlXG4gICAqICAgd2Vla3NCZWZvcmVcbiAgICogICBtb250aEJlZm9yZVxuICAgKiAgIG1vbnRoc0JlZm9yZVxuICAgKiAgIHllYXJCZWZvcmVcbiAgICogICB5ZWFyc0JlZm9yZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICg1KS5kYXlzQmVmb3JlKCd0dWVzZGF5JykgICAgICAgICAgLT4gNSBkYXlzIGJlZm9yZSB0dWVzZGF5IG9mIHRoaXMgd2Vla1xuICAgKiAgICgxKS55ZWFyQmVmb3JlKCdKYW51YXJ5IDIzLCAxOTk3JykgLT4gSmFudWFyeSAyMywgMTk5NlxuICAgKlxuICAgKioqXG4gICAqIEBtZXRob2QgW3VuaXRdQWdvKClcbiAgICogQHJldHVybnMgRGF0ZVxuICAgKiBAc2hvcnQgUmV0dXJucyBhIGRhdGUgdGhhdCBpcyA8bj4gdW5pdHMgYWdvLlxuICAgKiBAZXh0cmEgTm90ZSB0aGF0IFwibW9udGhzXCIgaXMgYW1iaWd1b3VzIGFzIGEgdW5pdCBvZiB0aW1lLiBJZiB0aGUgdGFyZ2V0IGRhdGUgZmFsbHMgb24gYSBkYXkgdGhhdCBkb2VzIG5vdCBleGlzdCAoaWUuIEF1Z3VzdCAzMSAtPiBGZWJydWFyeSAzMSksIHRoZSBkYXRlIHdpbGwgYmUgc2hpZnRlZCB0byB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoLiBCZSBjYXJlZnVsIHVzaW5nICVtb250aHNBZ28lIGlmIHlvdSBuZWVkIGV4YWN0IHByZWNpc2lvbi5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIG1pbGxpc2Vjb25kQWdvXG4gICAqICAgbWlsbGlzZWNvbmRzQWdvXG4gICAqICAgc2Vjb25kQWdvXG4gICAqICAgc2Vjb25kc0Fnb1xuICAgKiAgIG1pbnV0ZUFnb1xuICAgKiAgIG1pbnV0ZXNBZ29cbiAgICogICBob3VyQWdvXG4gICAqICAgaG91cnNBZ29cbiAgICogICBkYXlBZ29cbiAgICogICBkYXlzQWdvXG4gICAqICAgd2Vla0Fnb1xuICAgKiAgIHdlZWtzQWdvXG4gICAqICAgbW9udGhBZ29cbiAgICogICBtb250aHNBZ29cbiAgICogICB5ZWFyQWdvXG4gICAqICAgeWVhcnNBZ29cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAoNSkud2Vla3NBZ28oKSAtPiA1IHdlZWtzIGFnb1xuICAgKiAgICgxKS55ZWFyQWdvKCkgIC0+IEphbnVhcnkgMjMsIDE5OTZcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIFt1bml0XUFmdGVyKFtkXSwgW2xvY2FsZV0gPSBjdXJyZW50TG9jYWxlKVxuICAgKiBAcmV0dXJucyBEYXRlXG4gICAqIEBzaG9ydCBSZXR1cm5zIGEgZGF0ZSA8bj4gdW5pdHMgYWZ0ZXIgW2RdLCB3aGVyZSA8bj4gaXMgdGhlIG51bWJlci5cbiAgICogQGV4dHJhIFtkXSB3aWxsIGFjY2VwdCBhIGRhdGUgb2JqZWN0LCB0aW1lc3RhbXAsIG9yIHRleHQgZm9ybWF0LiBOb3RlIHRoYXQgXCJtb250aHNcIiBpcyBhbWJpZ3VvdXMgYXMgYSB1bml0IG9mIHRpbWUuIElmIHRoZSB0YXJnZXQgZGF0ZSBmYWxscyBvbiBhIGRheSB0aGF0IGRvZXMgbm90IGV4aXN0IChpZS4gQXVndXN0IDMxIC0+IEZlYnJ1YXJ5IDMxKSwgdGhlIGRhdGUgd2lsbCBiZSBzaGlmdGVkIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGguIEJlIGNhcmVmdWwgdXNpbmcgJW1vbnRoc0FmdGVyJSBpZiB5b3UgbmVlZCBleGFjdCBwcmVjaXNpb24uIFNlZSBAZGF0ZV9mb3JtYXQgZm9yIG1vcmUuXG4gICAqXG4gICAqIEBzZXRcbiAgICogICBtaWxsaXNlY29uZEFmdGVyXG4gICAqICAgbWlsbGlzZWNvbmRzQWZ0ZXJcbiAgICogICBzZWNvbmRBZnRlclxuICAgKiAgIHNlY29uZHNBZnRlclxuICAgKiAgIG1pbnV0ZUFmdGVyXG4gICAqICAgbWludXRlc0FmdGVyXG4gICAqICAgaG91ckFmdGVyXG4gICAqICAgaG91cnNBZnRlclxuICAgKiAgIGRheUFmdGVyXG4gICAqICAgZGF5c0FmdGVyXG4gICAqICAgd2Vla0FmdGVyXG4gICAqICAgd2Vla3NBZnRlclxuICAgKiAgIG1vbnRoQWZ0ZXJcbiAgICogICBtb250aHNBZnRlclxuICAgKiAgIHllYXJBZnRlclxuICAgKiAgIHllYXJzQWZ0ZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAoNSkuZGF5c0FmdGVyKCd0dWVzZGF5JykgICAgICAgICAgLT4gNSBkYXlzIGFmdGVyIHR1ZXNkYXkgb2YgdGhpcyB3ZWVrXG4gICAqICAgKDEpLnllYXJBZnRlcignSmFudWFyeSAyMywgMTk5NycpIC0+IEphbnVhcnkgMjMsIDE5OThcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIFt1bml0XUZyb21Ob3coKVxuICAgKiBAcmV0dXJucyBEYXRlXG4gICAqIEBzaG9ydCBSZXR1cm5zIGEgZGF0ZSA8bj4gdW5pdHMgZnJvbSBub3cuXG4gICAqIEBleHRyYSBOb3RlIHRoYXQgXCJtb250aHNcIiBpcyBhbWJpZ3VvdXMgYXMgYSB1bml0IG9mIHRpbWUuIElmIHRoZSB0YXJnZXQgZGF0ZSBmYWxscyBvbiBhIGRheSB0aGF0IGRvZXMgbm90IGV4aXN0IChpZS4gQXVndXN0IDMxIC0+IEZlYnJ1YXJ5IDMxKSwgdGhlIGRhdGUgd2lsbCBiZSBzaGlmdGVkIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGguIEJlIGNhcmVmdWwgdXNpbmcgJW1vbnRoc0Zyb21Ob3clIGlmIHlvdSBuZWVkIGV4YWN0IHByZWNpc2lvbi5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIG1pbGxpc2Vjb25kRnJvbU5vd1xuICAgKiAgIG1pbGxpc2Vjb25kc0Zyb21Ob3dcbiAgICogICBzZWNvbmRGcm9tTm93XG4gICAqICAgc2Vjb25kc0Zyb21Ob3dcbiAgICogICBtaW51dGVGcm9tTm93XG4gICAqICAgbWludXRlc0Zyb21Ob3dcbiAgICogICBob3VyRnJvbU5vd1xuICAgKiAgIGhvdXJzRnJvbU5vd1xuICAgKiAgIGRheUZyb21Ob3dcbiAgICogICBkYXlzRnJvbU5vd1xuICAgKiAgIHdlZWtGcm9tTm93XG4gICAqICAgd2Vla3NGcm9tTm93XG4gICAqICAgbW9udGhGcm9tTm93XG4gICAqICAgbW9udGhzRnJvbU5vd1xuICAgKiAgIHllYXJGcm9tTm93XG4gICAqICAgeWVhcnNGcm9tTm93XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgKDUpLndlZWtzRnJvbU5vdygpIC0+IDUgd2Vla3MgYWdvXG4gICAqICAgKDEpLnllYXJGcm9tTm93KCkgIC0+IEphbnVhcnkgMjMsIDE5OThcbiAgICpcbiAgICoqKi9cbiAgZnVuY3Rpb24gYnVpbGROdW1iZXJUb0RhdGVBbGlhcyh1LCBtdWx0aXBsaWVyKSB7XG4gICAgdmFyIG5hbWUgPSB1Lm5hbWUsIG1ldGhvZHMgPSB7fTtcbiAgICBmdW5jdGlvbiBiYXNlKCkgeyByZXR1cm4gcm91bmQodGhpcyAqIG11bHRpcGxpZXIpOyB9XG4gICAgZnVuY3Rpb24gYWZ0ZXIoKSB7IHJldHVybiBjcmVhdGVEYXRlKGFyZ3VtZW50cylbdS5hZGRNZXRob2RdKHRoaXMpOyAgfVxuICAgIGZ1bmN0aW9uIGJlZm9yZSgpIHsgcmV0dXJuIGNyZWF0ZURhdGUoYXJndW1lbnRzKVt1LmFkZE1ldGhvZF0oLXRoaXMpOyB9XG4gICAgbWV0aG9kc1tuYW1lXSA9IGJhc2U7XG4gICAgbWV0aG9kc1tuYW1lICsgJ3MnXSA9IGJhc2U7XG4gICAgbWV0aG9kc1tuYW1lICsgJ0JlZm9yZSddID0gYmVmb3JlO1xuICAgIG1ldGhvZHNbbmFtZSArICdzQmVmb3JlJ10gPSBiZWZvcmU7XG4gICAgbWV0aG9kc1tuYW1lICsgJ0FnbyddID0gYmVmb3JlO1xuICAgIG1ldGhvZHNbbmFtZSArICdzQWdvJ10gPSBiZWZvcmU7XG4gICAgbWV0aG9kc1tuYW1lICsgJ0FmdGVyJ10gPSBhZnRlcjtcbiAgICBtZXRob2RzW25hbWUgKyAnc0FmdGVyJ10gPSBhZnRlcjtcbiAgICBtZXRob2RzW25hbWUgKyAnRnJvbU5vdyddID0gYWZ0ZXI7XG4gICAgbWV0aG9kc1tuYW1lICsgJ3NGcm9tTm93J10gPSBhZnRlcjtcbiAgICBudW1iZXIuZXh0ZW5kKG1ldGhvZHMpO1xuICB9XG5cbiAgZXh0ZW5kKG51bWJlciwgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGR1cmF0aW9uKFtsb2NhbGVdID0gY3VycmVudExvY2FsZSlcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgVGFrZXMgdGhlIG51bWJlciBhcyBtaWxsaXNlY29uZHMgYW5kIHJldHVybnMgYSB1bml0LWFkanVzdGVkIGxvY2FsaXplZCBzdHJpbmcuXG4gICAgICogQGV4dHJhIFRoaXMgbWV0aG9kIGlzIHRoZSBzYW1lIGFzICVEYXRlI3JlbGF0aXZlJSB3aXRob3V0IHRoZSBsb2NhbGl6ZWQgZXF1aXZhbGVudCBvZiBcImZyb20gbm93XCIgb3IgXCJhZ29cIi4gW2xvY2FsZV0gY2FuIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgKGFuZCBvbmx5KSBwYXJhbWV0ZXIuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBkYXRlcyBwYWNrYWdlIGlzIGluY2x1ZGVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICg1MDApLmR1cmF0aW9uKCkgLT4gJzUwMCBtaWxsaXNlY29uZHMnXG4gICAgICogICAoMTIwMCkuZHVyYXRpb24oKSAtPiAnMSBzZWNvbmQnXG4gICAgICogICAoNzUpLm1pbnV0ZXMoKS5kdXJhdGlvbigpIC0+ICcxIGhvdXInXG4gICAgICogICAoNzUpLm1pbnV0ZXMoKS5kdXJhdGlvbignZXMnKSAtPiAnMSBob3JhJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnZHVyYXRpb24nOiBmdW5jdGlvbihsb2NhbGVDb2RlKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYWxpemF0aW9uKGxvY2FsZUNvZGUpLmdldER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICB9KTtcblxuXG4gIEVuZ2xpc2ggPSBDdXJyZW50TG9jYWxpemF0aW9uID0gZGF0ZS5hZGRMb2NhbGUoJ2VuJywge1xuICAgICdwbHVyYWwnOiAgICAgdHJ1ZSxcbiAgICAndGltZU1hcmtlcic6ICdhdCcsXG4gICAgJ2FtcG0nOiAgICAgICAnYW0scG0nLFxuICAgICdtb250aHMnOiAgICAgJ0phbnVhcnksRmVicnVhcnksTWFyY2gsQXByaWwsTWF5LEp1bmUsSnVseSxBdWd1c3QsU2VwdGVtYmVyLE9jdG9iZXIsTm92ZW1iZXIsRGVjZW1iZXInLFxuICAgICd3ZWVrZGF5cyc6ICAgJ1N1bmRheSxNb25kYXksVHVlc2RheSxXZWRuZXNkYXksVGh1cnNkYXksRnJpZGF5LFNhdHVyZGF5JyxcbiAgICAndW5pdHMnOiAgICAgICdtaWxsaXNlY29uZDp8cyxzZWNvbmQ6fHMsbWludXRlOnxzLGhvdXI6fHMsZGF5OnxzLHdlZWs6fHMsbW9udGg6fHMseWVhcjp8cycsXG4gICAgJ251bWJlcnMnOiAgICAnb25lLHR3byx0aHJlZSxmb3VyLGZpdmUsc2l4LHNldmVuLGVpZ2h0LG5pbmUsdGVuJyxcbiAgICAnYXJ0aWNsZXMnOiAgICdhLGFuLHRoZScsXG4gICAgJ3Rva2Vucyc6ICAgICAndGhlLHN0fG5kfHJkfHRoLG9mJyxcbiAgICAnc2hvcnQnOiAgICAgICd7TW9udGh9IHtkfSwge3l5eXl9JyxcbiAgICAnbG9uZyc6ICAgICAgICd7TW9udGh9IHtkfSwge3l5eXl9IHtofTp7bW19e3R0fScsXG4gICAgJ2Z1bGwnOiAgICAgICAne1dlZWtkYXl9IHtNb250aH0ge2R9LCB7eXl5eX0ge2h9OnttbX06e3NzfXt0dH0nLFxuICAgICdwYXN0JzogICAgICAgJ3tudW19IHt1bml0fSB7c2lnbn0nLFxuICAgICdmdXR1cmUnOiAgICAgJ3tudW19IHt1bml0fSB7c2lnbn0nLFxuICAgICdkdXJhdGlvbic6ICAgJ3tudW19IHt1bml0fScsXG4gICAgJ21vZGlmaWVycyc6IFtcbiAgICAgIHsgJ25hbWUnOiAnc2lnbicsICAnc3JjJzogJ2Fnb3xiZWZvcmUnLCAndmFsdWUnOiAtMSB9LFxuICAgICAgeyAnbmFtZSc6ICdzaWduJywgICdzcmMnOiAnZnJvbSBub3d8YWZ0ZXJ8ZnJvbXxpbnxsYXRlcicsICd2YWx1ZSc6IDEgfSxcbiAgICAgIHsgJ25hbWUnOiAnZWRnZScsICAnc3JjJzogJ2xhc3QgZGF5JywgJ3ZhbHVlJzogLTIgfSxcbiAgICAgIHsgJ25hbWUnOiAnZWRnZScsICAnc3JjJzogJ2VuZCcsICd2YWx1ZSc6IC0xIH0sXG4gICAgICB7ICduYW1lJzogJ2VkZ2UnLCAgJ3NyYyc6ICdmaXJzdCBkYXl8YmVnaW5uaW5nJywgJ3ZhbHVlJzogMSB9LFxuICAgICAgeyAnbmFtZSc6ICdzaGlmdCcsICdzcmMnOiAnbGFzdCcsICd2YWx1ZSc6IC0xIH0sXG4gICAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICd0aGV8dGhpcycsICd2YWx1ZSc6IDAgfSxcbiAgICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ25leHQnLCAndmFsdWUnOiAxIH1cbiAgICBdLFxuICAgICdkYXRlUGFyc2UnOiBbXG4gICAgICAne21vbnRofSB7eWVhcn0nLFxuICAgICAgJ3tzaGlmdH0ge3VuaXQ9NS03fScsXG4gICAgICAnezA/fSB7ZGF0ZX17MX0nLFxuICAgICAgJ3swP30ge2VkZ2V9IG9mIHtzaGlmdD99IHt1bml0PTQtNz99e21vbnRoP317eWVhcj99J1xuICAgIF0sXG4gICAgJ3RpbWVQYXJzZSc6IFtcbiAgICAgICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgICAgICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgICAgICd7MH0ge251bX17MX0ge2RheX0gb2Yge21vbnRofSB7eWVhcj99JyxcbiAgICAgICd7d2Vla2RheT99IHttb250aH0ge2RhdGV9ezE/fSB7eWVhcj99JyxcbiAgICAgICd7ZGF0ZX0ge21vbnRofSB7eWVhcn0nLFxuICAgICAgJ3tkYXRlfSB7bW9udGh9JyxcbiAgICAgICd7c2hpZnR9IHt3ZWVrZGF5fScsXG4gICAgICAne3NoaWZ0fSB3ZWVrIHt3ZWVrZGF5fScsXG4gICAgICAne3dlZWtkYXl9IHsyP30ge3NoaWZ0fSB3ZWVrJyxcbiAgICAgICd7bnVtfSB7dW5pdD00LTV9IHtzaWdufSB7ZGF5fScsXG4gICAgICAnezA/fSB7ZGF0ZX17MX0gb2Yge21vbnRofScsXG4gICAgICAnezA/fXttb250aD99IHtkYXRlP317MT99IG9mIHtzaGlmdH0ge3VuaXQ9Ni03fSdcbiAgICBdXG4gIH0pO1xuXG4gIGJ1aWxkRGF0ZVVuaXRzKCk7XG4gIGJ1aWxkRGF0ZU1ldGhvZHMoKTtcbiAgYnVpbGRDb3JlSW5wdXRGb3JtYXRzKCk7XG4gIGJ1aWxkRm9ybWF0VG9rZW5zKCk7XG4gIGJ1aWxkRm9ybWF0U2hvcnRjdXRzKCk7XG4gIGJ1aWxkQXNpYW5EaWdpdHMoKTtcbiAgYnVpbGRSZWxhdGl2ZUFsaWFzZXMoKTtcbiAgYnVpbGRVVENBbGlhc2VzKCk7XG4gIHNldERhdGVQcm9wZXJ0aWVzKCk7XG5cblxuICAvKioqXG4gICAqIEBwYWNrYWdlIFJhbmdlXG4gICAqIEBkZXBlbmRlbmN5IGNvcmVcbiAgICogQGRlc2NyaXB0aW9uIFJhbmdlcyBhbGxvdyBjcmVhdGluZyBzcGFucyBvZiBudW1iZXJzLCBzdHJpbmdzLCBvciBkYXRlcy4gVGhleSBjYW4gZW51bWVyYXRlIG92ZXIgc3BlY2lmaWMgcG9pbnRzIHdpdGhpbiB0aGF0IHJhbmdlLCBhbmQgYmUgbWFuaXB1bGF0ZWQgYW5kIGNvbXBhcmVkLlxuICAgKlxuICAgKioqL1xuXG4gIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gY2xvbmVSYW5nZU1lbWJlcihzdGFydCk7XG4gICAgdGhpcy5lbmQgICA9IGNsb25lUmFuZ2VNZW1iZXIoZW5kKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRSYW5nZU1lbWJlck51bWVyaWNWYWx1ZShtKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKG0pID8gbS5jaGFyQ29kZUF0KDApIDogbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhbmdlTWVtYmVyUHJpbWl0aXZlVmFsdWUobSkge1xuICAgIGlmKG0gPT0gbnVsbCkgcmV0dXJuIG07XG4gICAgcmV0dXJuIGlzRGF0ZShtKSA/IG0uZ2V0VGltZSgpIDogbS52YWx1ZU9mKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVJhbmdlTWVtYmVyKG0pIHtcbiAgICBpZihpc0RhdGUobSkpIHtcbiAgICAgIHJldHVybiBuZXcgZGF0ZShtLmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRSYW5nZU1lbWJlclByaW1pdGl2ZVZhbHVlKG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRSYW5nZU1lbWJlcihtKSB7XG4gICAgdmFyIHZhbCA9IGdldFJhbmdlTWVtYmVyUHJpbWl0aXZlVmFsdWUobSk7XG4gICAgcmV0dXJuICEhdmFsIHx8IHZhbCA9PT0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldER1cmF0aW9uKGFtdCkge1xuICAgIHZhciBtYXRjaCwgdmFsLCB1bml0O1xuICAgIGlmKGlzTnVtYmVyKGFtdCkpIHtcbiAgICAgIHJldHVybiBhbXQ7XG4gICAgfVxuICAgIG1hdGNoID0gYW10LnRvTG93ZXJDYXNlKCkubWF0Y2goL14oXFxkKyk/XFxzPyhcXHcrPylzPyQvaSk7XG4gICAgdmFsID0gcGFyc2VJbnQobWF0Y2hbMV0pIHx8IDE7XG4gICAgdW5pdCA9IG1hdGNoWzJdLnNsaWNlKDAsMSkudG9VcHBlckNhc2UoKSArIG1hdGNoWzJdLnNsaWNlKDEpO1xuICAgIGlmKHVuaXQubWF0Y2goL2hvdXJ8bWludXRlfHNlY29uZC9pKSkge1xuICAgICAgdW5pdCArPSAncyc7XG4gICAgfSBlbHNlIGlmKHVuaXQgPT09ICdZZWFyJykge1xuICAgICAgdW5pdCA9ICdGdWxsWWVhcic7XG4gICAgfSBlbHNlIGlmKHVuaXQgPT09ICdEYXknKSB7XG4gICAgICB1bml0ID0gJ0RhdGUnO1xuICAgIH1cbiAgICByZXR1cm4gW3ZhbCwgdW5pdF07XG4gIH1cblxuICBmdW5jdGlvbiBpbmNyZW1lbnREYXRlKGN1cnJlbnQsIGFtb3VudCkge1xuICAgIHZhciBudW0sIHVuaXQsIHZhbCwgZDtcbiAgICBpZihpc051bWJlcihhbW91bnQpKSB7XG4gICAgICByZXR1cm4gbmV3IGRhdGUoY3VycmVudC5nZXRUaW1lKCkgKyBhbW91bnQpO1xuICAgIH1cbiAgICBudW0gID0gYW1vdW50WzBdO1xuICAgIHVuaXQgPSBhbW91bnRbMV07XG4gICAgdmFsICA9IGNhbGxEYXRlR2V0KGN1cnJlbnQsIHVuaXQpO1xuICAgIGQgICAgPSBuZXcgZGF0ZShjdXJyZW50LmdldFRpbWUoKSk7XG4gICAgY2FsbERhdGVTZXQoZCwgdW5pdCwgdmFsICsgbnVtKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY3JlbWVudFN0cmluZyhjdXJyZW50LCBhbW91bnQpIHtcbiAgICByZXR1cm4gc3RyaW5nLmZyb21DaGFyQ29kZShjdXJyZW50LmNoYXJDb2RlQXQoMCkgKyBhbW91bnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jcmVtZW50TnVtYmVyKGN1cnJlbnQsIGFtb3VudCkge1xuICAgIHJldHVybiBjdXJyZW50ICsgYW1vdW50O1xuICB9XG5cbiAgLyoqKlxuICAgKiBAbWV0aG9kIHRvU3RyaW5nKClcbiAgICogQHJldHVybnMgU3RyaW5nXG4gICAqIEBzaG9ydCBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByYW5nZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICBOdW1iZXIucmFuZ2UoMSwgNSkudG9TdHJpbmcoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAxLi41XG4gICAqICAgRGF0ZS5yYW5nZShuZXcgRGF0ZSgyMDAzLCAwKSwgbmV3IERhdGUoMjAwNSwgMCkpLnRvU3RyaW5nKCkgLT4gSmFudWFyeSAxLCAyMDAzLi5KYW51YXJ5IDEsIDIwMDVcbiAgICpcbiAgICoqKi9cblxuICAvLyBOb3RlOiAndG9TdHJpbmcnIGRvZXNuJ3QgYXBwZWFyIGluIGEgZm9yLi5pbiBsb29wIGluIElFIGV2ZW4gdGhvdWdoXG4gIC8vIGhhc093blByb3BlcnR5IHJlcG9ydHMgdHJ1ZSwgc28gZXh0ZW5kKCkgY2FuJ3QgYmUgdXNlZCBoZXJlLlxuICAvLyBBbHNvIHRyaWVkIHNpbXBseSBzZXR0aW5nIHRoZSBwcm90b3R5cGUgPSB7fSB1cCBmcm9udCBmb3IgYWxsXG4gIC8vIG1ldGhvZHMgYnV0IEdDQyB2ZXJ5IG9kZGx5IHN0YXJ0ZWQgZHJvcHBpbmcgcHJvcGVydGllcyBpbiB0aGVcbiAgLy8gb2JqZWN0IHJhbmRvbWx5IChtYXliZSBiZWNhdXNlIG9mIHRoZSBnbG9iYWwgc2NvcGU/KSBoZW5jZVxuICAvLyB0aGUgbmVlZCBmb3IgdGhlIHNwbGl0IGxvZ2ljIGhlcmUuXG4gIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuc3RhcnQgKyBcIi4uXCIgKyB0aGlzLmVuZCA6ICdJbnZhbGlkIFJhbmdlJztcbiAgfTtcblxuICBleHRlbmQoUmFuZ2UsIHRydWUsIHRydWUsIHtcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGlzVmFsaWQoKVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSByYW5nZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIERhdGUucmFuZ2UobmV3IERhdGUoMjAwMywgMCksIG5ldyBEYXRlKDIwMDUsIDApKS5pc1ZhbGlkKCkgLT4gdHJ1ZVxuICAgICAqICAgTnVtYmVyLnJhbmdlKE5hTiwgTmFOKS5pc1ZhbGlkKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBmYWxzZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNWYWxpZCc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzVmFsaWRSYW5nZU1lbWJlcih0aGlzLnN0YXJ0KSAmJiBpc1ZhbGlkUmFuZ2VNZW1iZXIodGhpcy5lbmQpICYmIHR5cGVvZiB0aGlzLnN0YXJ0ID09PSB0eXBlb2YgdGhpcy5lbmQ7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHNwYW4oKVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRoZSBzcGFuIG9mIHRoZSByYW5nZS4gSWYgdGhlIHJhbmdlIGlzIGEgZGF0ZSByYW5nZSwgdGhlIHZhbHVlIGlzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAZXh0cmEgVGhlIHNwYW4gaW5jbHVkZXMgYm90aCB0aGUgc3RhcnQgYW5kIHRoZSBlbmQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgTnVtYmVyLnJhbmdlKDUsIDEwKS5zcGFuKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiA2XG4gICAgICogICBEYXRlLnJhbmdlKG5ldyBEYXRlKDIwMDMsIDApLCBuZXcgRGF0ZSgyMDA1LCAwKSkuc3BhbigpIC0+IDk0Njk0NDAwMDAwXG4gICAgICpcbiAgICAgKioqL1xuICAgICdzcGFuJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyBhYnMoXG4gICAgICAgIGdldFJhbmdlTWVtYmVyTnVtZXJpY1ZhbHVlKHRoaXMuZW5kKSAtIGdldFJhbmdlTWVtYmVyTnVtZXJpY1ZhbHVlKHRoaXMuc3RhcnQpXG4gICAgICApICsgMSA6IE5hTjtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgY29udGFpbnMoPG9iaj4pXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgPG9iaj4gaXMgY29udGFpbmVkIGluc2lkZSB0aGUgcmFuZ2UuIDxvYmo+IG1heSBiZSBhIHZhbHVlIG9yIGFub3RoZXIgcmFuZ2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgTnVtYmVyLnJhbmdlKDUsIDEwKS5jb250YWlucyg3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiB0cnVlXG4gICAgICogICBEYXRlLnJhbmdlKG5ldyBEYXRlKDIwMDMsIDApLCBuZXcgRGF0ZSgyMDA1LCAwKSkuY29udGFpbnMobmV3IERhdGUoMjAwNCwgMCkpIC0+IHRydWVcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2NvbnRhaW5zJzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIGFycjtcbiAgICAgIGlmKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZihvYmouc3RhcnQgJiYgb2JqLmVuZCkge1xuICAgICAgICByZXR1cm4gb2JqLnN0YXJ0ID49IHRoaXMuc3RhcnQgJiYgb2JqLnN0YXJ0IDw9IHRoaXMuZW5kICYmXG4gICAgICAgICAgICAgICBvYmouZW5kICAgPj0gdGhpcy5zdGFydCAmJiBvYmouZW5kICAgPD0gdGhpcy5lbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqID49IHRoaXMuc3RhcnQgJiYgb2JqIDw9IHRoaXMuZW5kO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBldmVyeSg8YW1vdW50PiwgW2ZuXSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBJdGVyYXRlcyB0aHJvdWdoIHRoZSByYW5nZSBmb3IgZXZlcnkgPGFtb3VudD4sIGNhbGxpbmcgW2ZuXSBpZiBpdCBpcyBwYXNzZWQuIFJldHVybnMgYW4gYXJyYXkgb2YgZWFjaCBpbmNyZW1lbnQgdmlzaXRlZC5cbiAgICAgKiBAZXh0cmEgSW4gdGhlIGNhc2Ugb2YgZGF0ZSByYW5nZXMsIDxhbW91bnQ+IGNhbiBhbHNvIGJlIGEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgaW5jcmVtZW50IGEgbnVtYmVyIG9mICB1bml0cy4gTm90ZSB0aGF0ICUoMikubW9udGhzKCklIGZpcnN0IHJlc29sdmVzIHRvIGEgbnVtYmVyLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIG1pbGxpc2Vjb25kcyBhbmQgaXMgYW4gYXBwcm94aW1hdGlvbiwgc28gc3RlcHBpbmcgdGhyb3VnaCB0aGUgYWN0dWFsIG1vbnRocyBieSBwYXNzaW5nICVcIjIgbW9udGhzXCIlIGlzIHVzdWFsbHkgcHJlZmVyYWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBOdW1iZXIucmFuZ2UoMiwgOCkuZXZlcnkoMikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBbMiw0LDYsOF1cbiAgICAgKiAgIERhdGUucmFuZ2UobmV3IERhdGUoMjAwMywgMSksIG5ldyBEYXRlKDIwMDMsMykpLmV2ZXJ5KFwiMiBtb250aHNcIikgLT4gWy4uLl1cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2V2ZXJ5JzogZnVuY3Rpb24oYW1vdW50LCBmbikge1xuICAgICAgdmFyIGluY3JlbWVudCxcbiAgICAgICAgICBzdGFydCAgID0gdGhpcy5zdGFydCxcbiAgICAgICAgICBlbmQgICAgID0gdGhpcy5lbmQsXG4gICAgICAgICAgaW52ZXJzZSA9IGVuZCA8IHN0YXJ0LFxuICAgICAgICAgIGN1cnJlbnQgPSBzdGFydCxcbiAgICAgICAgICBpbmRleCAgID0gMCxcbiAgICAgICAgICByZXN1bHQgID0gW107XG5cbiAgICAgIGlmKGlzRnVuY3Rpb24oYW1vdW50KSkge1xuICAgICAgICBmbiA9IGFtb3VudDtcbiAgICAgICAgYW1vdW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGFtb3VudCA9IGFtb3VudCB8fCAxO1xuICAgICAgaWYoaXNOdW1iZXIoc3RhcnQpKSB7XG4gICAgICAgIGluY3JlbWVudCA9IGluY3JlbWVudE51bWJlcjtcbiAgICAgIH0gZWxzZSBpZihpc1N0cmluZyhzdGFydCkpIHtcbiAgICAgICAgaW5jcmVtZW50ID0gaW5jcmVtZW50U3RyaW5nO1xuICAgICAgfSBlbHNlIGlmKGlzRGF0ZShzdGFydCkpIHtcbiAgICAgICAgYW1vdW50ICAgID0gZ2V0RHVyYXRpb24oYW1vdW50KTtcbiAgICAgICAgaW5jcmVtZW50ID0gaW5jcmVtZW50RGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIEF2b2lkaW5nIGluZmluaXRlIGxvb3BzXG4gICAgICBpZihpbnZlcnNlICYmIGFtb3VudCA+IDApIHtcbiAgICAgICAgYW1vdW50ICo9IC0xO1xuICAgICAgfVxuICAgICAgd2hpbGUoaW52ZXJzZSA/IGN1cnJlbnQgPj0gZW5kIDogY3VycmVudCA8PSBlbmQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgIGlmKGZuKSB7XG4gICAgICAgICAgZm4oY3VycmVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBpbmNyZW1lbnQoY3VycmVudCwgYW1vdW50KTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHVuaW9uKDxyYW5nZT4pXG4gICAgICogQHJldHVybnMgUmFuZ2VcbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhIG5ldyByYW5nZSB3aXRoIHRoZSBlYXJsaWVzdCBzdGFydGluZyBwb2ludCBhcyBpdHMgc3RhcnQsIGFuZCB0aGUgbGF0ZXN0IGVuZGluZyBwb2ludCBhcyBpdHMgZW5kLiBJZiB0aGUgdHdvIHJhbmdlcyBkbyBub3QgaW50ZXJzZWN0IHRoaXMgd2lsbCBlZmZlY3RpdmVseSByZW1vdmUgdGhlIFwiZ2FwXCIgYmV0d2VlbiB0aGVtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIE51bWJlci5yYW5nZSgxLCAzKS51bmlvbihOdW1iZXIucmFuZ2UoMiwgNSkpIC0+IDEuLjVcbiAgICAgKiAgIERhdGUucmFuZ2UobmV3IERhdGUoMjAwMywgMSksIG5ldyBEYXRlKDIwMDUsIDEpKS51bmlvbihEYXRlLnJhbmdlKG5ldyBEYXRlKDIwMDQsIDEpLCBuZXcgRGF0ZSgyMDA2LCAxKSkpIC0+IEphbiAxLCAyMDAzLi5KYW4gMSwgMjAwNlxuICAgICAqXG4gICAgICoqKi9cbiAgICAndW5pb24nOiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgICAgdGhpcy5zdGFydCA8IHJhbmdlLnN0YXJ0ID8gdGhpcy5zdGFydCA6IHJhbmdlLnN0YXJ0LFxuICAgICAgICB0aGlzLmVuZCAgID4gcmFuZ2UuZW5kICAgPyB0aGlzLmVuZCAgIDogcmFuZ2UuZW5kXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBpbnRlcnNlY3QoPHJhbmdlPilcbiAgICAgKiBAcmV0dXJucyBSYW5nZVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGEgbmV3IHJhbmdlIHdpdGggdGhlIGxhdGVzdCBzdGFydGluZyBwb2ludCBhcyBpdHMgc3RhcnQsIGFuZCB0aGUgZWFybGllc3QgZW5kaW5nIHBvaW50IGFzIGl0cyBlbmQuIElmIHRoZSB0d28gcmFuZ2VzIGRvIG5vdCBpbnRlcnNlY3QgdGhpcyB3aWxsIGVmZmVjdGl2ZWx5IHByb2R1Y2UgYW4gaW52YWxpZCByYW5nZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBOdW1iZXIucmFuZ2UoMSwgNSkuaW50ZXJzZWN0KE51bWJlci5yYW5nZSg0LCA4KSkgLT4gNC4uNVxuICAgICAqICAgRGF0ZS5yYW5nZShuZXcgRGF0ZSgyMDAzLCAxKSwgbmV3IERhdGUoMjAwNSwgMSkpLmludGVyc2VjdChEYXRlLnJhbmdlKG5ldyBEYXRlKDIwMDQsIDEpLCBuZXcgRGF0ZSgyMDA2LCAxKSkpIC0+IEphbiAxLCAyMDA0Li5KYW4gMSwgMjAwNVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaW50ZXJzZWN0JzogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgIGlmKHJhbmdlLnN0YXJ0ID4gdGhpcy5lbmQgfHwgcmFuZ2UuZW5kIDwgdGhpcy5zdGFydCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKE5hTiwgTmFOKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICAgIHRoaXMuc3RhcnQgPiByYW5nZS5zdGFydCA/IHRoaXMuc3RhcnQgOiByYW5nZS5zdGFydCxcbiAgICAgICAgdGhpcy5lbmQgICA8IHJhbmdlLmVuZCAgID8gdGhpcy5lbmQgICA6IHJhbmdlLmVuZFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgY2xvbmUoKVxuICAgICAqIEByZXR1cm5zIFJhbmdlXG4gICAgICogQHNob3J0IENsb25lcyB0aGUgcmFuZ2UuXG4gICAgICogQGV4dHJhIE1lbWJlcnMgb2YgdGhlIHJhbmdlIHdpbGwgYWxzbyBiZSBjbG9uZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgTnVtYmVyLnJhbmdlKDEsIDUpLmNsb25lKCkgLT4gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHJhbmdlLlxuICAgICAqXG4gICAgICoqKi9cbiAgICAnY2xvbmUnOiBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNsYW1wKDxvYmo+KVxuICAgICAqIEByZXR1cm5zIE1peGVkXG4gICAgICogQHNob3J0IENsYW1wcyA8b2JqPiB0byBiZSB3aXRoaW4gdGhlIHJhbmdlIGlmIGl0IGZhbGxzIG91dHNpZGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgTnVtYmVyLnJhbmdlKDEsIDUpLmNsYW1wKDgpIC0+IDVcbiAgICAgKiAgIERhdGUucmFuZ2UobmV3IERhdGUoMjAxMCwgMCksIG5ldyBEYXRlKDIwMTIsIDApKS5jbGFtcChuZXcgRGF0ZSgyMDEzLCAwKSkgLT4gMjAxMi0wMVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnY2xhbXAnOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBjbGFtcGVkLFxuICAgICAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB0aGlzLmVuZCxcbiAgICAgICAgICBtaW4gPSBlbmQgPCBzdGFydCA/IGVuZCA6IHN0YXJ0LFxuICAgICAgICAgIG1heCA9IHN0YXJ0ID4gZW5kID8gc3RhcnQgOiBlbmQ7XG4gICAgICBpZihvYmogPCBtaW4pIHtcbiAgICAgICAgY2xhbXBlZCA9IG1pbjtcbiAgICAgIH0gZWxzZSBpZihvYmogPiBtYXgpIHtcbiAgICAgICAgY2xhbXBlZCA9IG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYW1wZWQgPSBvYmo7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVSYW5nZU1lbWJlcihjbGFtcGVkKTtcbiAgICB9XG5cbiAgfSk7XG5cblxuICAvKioqXG4gICAqIE51bWJlciBtb2R1bGVcbiAgICoqKlxuICAgKiBAbWV0aG9kIE51bWJlci5yYW5nZShbc3RhcnRdLCBbZW5kXSlcbiAgICogQHJldHVybnMgUmFuZ2VcbiAgICogQHNob3J0IENyZWF0ZXMgYSBuZXcgcmFuZ2UgYmV0d2VlbiBbc3RhcnRdIGFuZCBbZW5kXS4gU2VlIEByYW5nZXMgZm9yIG1vcmUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgTnVtYmVyLnJhbmdlKDUsIDEwKVxuICAgKlxuICAgKioqXG4gICAqIFN0cmluZyBtb2R1bGVcbiAgICoqKlxuICAgKiBAbWV0aG9kIFN0cmluZy5yYW5nZShbc3RhcnRdLCBbZW5kXSlcbiAgICogQHJldHVybnMgUmFuZ2VcbiAgICogQHNob3J0IENyZWF0ZXMgYSBuZXcgcmFuZ2UgYmV0d2VlbiBbc3RhcnRdIGFuZCBbZW5kXS4gU2VlIEByYW5nZXMgZm9yIG1vcmUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgU3RyaW5nLnJhbmdlKCdhJywgJ3onKVxuICAgKlxuICAgKioqXG4gICAqIERhdGUgbW9kdWxlXG4gICAqKipcbiAgICogQG1ldGhvZCBEYXRlLnJhbmdlKFtzdGFydF0sIFtlbmRdKVxuICAgKiBAcmV0dXJucyBSYW5nZVxuICAgKiBAc2hvcnQgQ3JlYXRlcyBhIG5ldyByYW5nZSBiZXR3ZWVuIFtzdGFydF0gYW5kIFtlbmRdLlxuICAgKiBAZXh0cmEgSWYgZWl0aGVyIFtzdGFydF0gb3IgW2VuZF0gYXJlIG51bGwsIHRoZXkgd2lsbCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IGRhdGUuIFNlZSBAcmFuZ2VzIGZvciBtb3JlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIERhdGUucmFuZ2UoJ3RvZGF5JywgJ3RvbW9ycm93JylcbiAgICpcbiAgICoqKi9cbiAgW251bWJlciwgc3RyaW5nLCBkYXRlXS5mb3JFYWNoKGZ1bmN0aW9uKGtsYXNzKSB7XG4gICAgIGV4dGVuZChrbGFzcywgZmFsc2UsIHRydWUsIHtcblxuICAgICAgJ3JhbmdlJzogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZihrbGFzcy5jcmVhdGUpIHtcbiAgICAgICAgICBzdGFydCA9IGtsYXNzLmNyZWF0ZShzdGFydCk7XG4gICAgICAgICAgZW5kICAgPSBrbGFzcy5jcmVhdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgLyoqKlxuICAgKiBOdW1iZXIgbW9kdWxlXG4gICAqXG4gICAqKiovXG5cbiAgZXh0ZW5kKG51bWJlciwgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgdXB0byg8bnVtPiwgW2ZuXSwgW3N0ZXBdID0gMSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgbnVtYmVycyBmcm9tIHRoZSBudW1iZXIgdXAgdG8gPG51bT4uXG4gICAgICogQGV4dHJhIE9wdGlvbmFsbHkgY2FsbHMgW2ZuXSBjYWxsYmFjayBmb3IgZWFjaCBudW1iZXIgaW4gdGhhdCBhcnJheS4gW3N0ZXBdIGFsbG93cyBtdWx0aXBsZXMgZ3JlYXRlciB0aGFuIDEuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKDIpLnVwdG8oNikgLT4gWzIsIDMsIDQsIDUsIDZdXG4gICAgICogICAoMikudXB0byg2LCBmdW5jdGlvbihuKSB7XG4gICAgICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIDUgdGltZXMgcmVjZWl2aW5nIG4gYXMgdGhlIHZhbHVlLlxuICAgICAqICAgfSk7XG4gICAgICogICAoMikudXB0byg4LCBudWxsLCAyKSAtPiBbMiwgNCwgNiwgOF1cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3VwdG8nOiBmdW5jdGlvbihudW0sIGZuLCBzdGVwKSB7XG4gICAgICByZXR1cm4gbnVtYmVyLnJhbmdlKHRoaXMsIG51bSkuZXZlcnkoc3RlcCwgZm4pO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgY2xhbXAoW3N0YXJ0XSA9IEluZmluaXR5LCBbZW5kXSA9IEluZmluaXR5KVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBDb25zdHJhaW5zIHRoZSBudW1iZXIgc28gdGhhdCBpdCBpcyBiZXR3ZWVuIFtzdGFydF0gYW5kIFtlbmRdLlxuICAgICAqIEBleHRyYSBUaGlzIHdpbGwgYnVpbGQgYSByYW5nZSBvYmplY3QgdGhhdCBoYXMgYW4gZXF1aXZhbGVudCAlY2xhbXAlIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAoMykuY2xhbXAoNTAsIDEwMCkgIC0+IDUwXG4gICAgICogICAoODUpLmNsYW1wKDUwLCAxMDApIC0+IDg1XG4gICAgICpcbiAgICAgKioqL1xuICAgICdjbGFtcCc6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkuY2xhbXAodGhpcyk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBjYXAoW21heF0gPSBJbmZpbml0eSlcbiAgICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICAgKiBAc2hvcnQgQ29uc3RyYWlucyB0aGUgbnVtYmVyIHNvIHRoYXQgaXQgaXMgbm8gZ3JlYXRlciB0aGFuIFttYXhdLlxuICAgICAqIEBleHRyYSBUaGlzIHdpbGwgYnVpbGQgYSByYW5nZSBvYmplY3QgdGhhdCBoYXMgYW4gZXF1aXZhbGVudCAlY2FwJSBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKDEwMCkuY2FwKDgwKSAtPiA4MFxuICAgICAqXG4gICAgICoqKi9cbiAgICAnY2FwJzogZnVuY3Rpb24obWF4KSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGFtcChVbmRlZmluZWQsIG1heCk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGV4dGVuZChudW1iZXIsIHRydWUsIHRydWUsIHtcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGRvd250byg8bnVtPiwgW2ZuXSwgW3N0ZXBdID0gMSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgbnVtYmVycyBmcm9tIHRoZSBudW1iZXIgZG93biB0byA8bnVtPi5cbiAgICAgKiBAZXh0cmEgT3B0aW9uYWxseSBjYWxscyBbZm5dIGNhbGxiYWNrIGZvciBlYWNoIG51bWJlciBpbiB0aGF0IGFycmF5LiBbc3RlcF0gYWxsb3dzIG11bHRpcGxlcyBncmVhdGVyIHRoYW4gMS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAoOCkuZG93bnRvKDMpIC0+IFs4LCA3LCA2LCA1LCA0LCAzXVxuICAgICAqICAgKDgpLmRvd250bygzLCBmdW5jdGlvbihuKSB7XG4gICAgICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIDYgdGltZXMgcmVjZWl2aW5nIG4gYXMgdGhlIHZhbHVlLlxuICAgICAqICAgfSk7XG4gICAgICogICAoOCkuZG93bnRvKDIsIG51bGwsIDIpIC0+IFs4LCA2LCA0LCAyXVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnZG93bnRvJzogbnVtYmVyLnByb3RvdHlwZS51cHRvXG5cbiAgfSk7XG5cblxuICAvKioqXG4gICAqIEFycmF5IG1vZHVsZVxuICAgKlxuICAgKioqL1xuXG4gIGV4dGVuZChhcnJheSwgZmFsc2UsIGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBSYW5nZTsgfSwge1xuXG4gICAgJ2NyZWF0ZSc6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICByZXR1cm4gcmFuZ2UuZXZlcnkoKTtcbiAgICB9XG5cbiAgfSk7XG5cblxuICAvKioqXG4gICAqIEBwYWNrYWdlIEZ1bmN0aW9uXG4gICAqIEBkZXBlbmRlbmN5IGNvcmVcbiAgICogQGRlc2NyaXB0aW9uIExhenksIHRocm90dGxlZCwgYW5kIG1lbW9pemVkIGZ1bmN0aW9ucywgZGVsYXllZCBmdW5jdGlvbnMgYW5kIGhhbmRsaW5nIG9mIHRpbWVycywgYXJndW1lbnQgY3VycnlpbmcuXG4gICAqXG4gICAqKiovXG5cbiAgZnVuY3Rpb24gc2V0RGVsYXkoZm4sIG1zLCBhZnRlciwgc2NvcGUsIGFyZ3MpIHtcbiAgICAvLyBEZWxheSBvZiBpbmZpbml0eSBpcyBuZXZlciBjYWxsZWQgb2YgY291cnNlLi4uXG4gICAgaWYobXMgPT09IEluZmluaXR5KSByZXR1cm47XG4gICAgaWYoIWZuLnRpbWVycykgZm4udGltZXJzID0gW107XG4gICAgaWYoIWlzTnVtYmVyKG1zKSkgbXMgPSAxO1xuICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciA8PSBJRTgsIHdoaWNoIGFwcGFyZW50bHkgaGFzIHRoZVxuICAgIC8vIGFiaWxpdHkgdG8gY2FsbCB0aW1lb3V0cyBpbiB0aGUgcXVldWUgb24gdGhlIHNhbWUgdGljayAobXM/KVxuICAgIC8vIGV2ZW4gaWYgZnVuY3Rpb25hbGx5IHRoZXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2xlYXJlZC5cbiAgICBmbi5fY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBmbi50aW1lcnMucHVzaChzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZighZm4uX2NhbmNlbGVkKSB7XG4gICAgICAgIGFmdGVyLmFwcGx5KHNjb3BlLCBhcmdzIHx8IFtdKTtcbiAgICAgIH1cbiAgICB9LCBtcykpO1xuICB9XG5cbiAgZXh0ZW5kKEZ1bmN0aW9uLCB0cnVlLCB0cnVlLCB7XG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgbGF6eShbbXNdID0gMSwgW2ltbWVkaWF0ZV0gPSBmYWxzZSwgW2xpbWl0XSA9IEluZmluaXR5KVxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gICAgICogQHNob3J0IENyZWF0ZXMgYSBsYXp5IGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkIHJlcGVhdGVkbHksIHdpbGwgcXVldWUgZXhlY3V0aW9uIGFuZCB3YWl0IFttc10gbWlsbGlzZWNvbmRzIHRvIGV4ZWN1dGUuXG4gICAgICogQGV4dHJhIElmIFtpbW1lZGlhdGVdIGlzICV0cnVlJSwgZmlyc3QgZXhlY3V0aW9uIHdpbGwgaGFwcGVuIGltbWVkaWF0ZWx5LCB0aGVuIGxvY2suIElmIFtsaW1pdF0gaXMgYSBmaW5pbnRlIG51bWJlciwgY2FsbHMgcGFzdCBbbGltaXRdIHdpbGwgYmUgaWdub3JlZCB3aGlsZSBleGVjdXRpb24gaXMgbG9ja2VkLiBDb21wYXJlIHRoaXMgdG8gJXRocm90dGxlJSwgd2hpY2ggd2lsbCBleGVjdXRlIG9ubHkgb25jZSBwZXIgW21zXSBtaWxsaXNlY29uZHMuIE5vdGUgdGhhdCBbbXNdIGNhbiBhbHNvIGJlIGEgZnJhY3Rpb24uIENhbGxpbmcgJWNhbmNlbCUgb24gYSBsYXp5IGZ1bmN0aW9uIHdpbGwgY2xlYXIgdGhlIGVudGlyZSBxdWV1ZS4gRm9yIG1vcmUgc2VlIEBmdW5jdGlvbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAvLyBFeGVjdXRlcyBpbW1lZGlhdGVseS5cbiAgICAgKiAgIH0pLmxhenkoKSgpO1xuICAgICAqICAgKDMpLnRpbWVzKGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAvLyBFeGVjdXRlcyAzIHRpbWVzLCB3aXRoIGVhY2ggZXhlY3V0aW9uIDIwbXMgbGF0ZXIgdGhhbiB0aGUgbGFzdC5cbiAgICAgKiAgIH0ubGF6eSgyMCkpO1xuICAgICAqICAgKDEwMCkudGltZXMoZnVuY3Rpb24oKSB7XG4gICAgICogICAgIC8vIEV4ZWN1dGVzIDUwIHRpbWVzLCB3aXRoIGVhY2ggZXhlY3V0aW9uIDIwbXMgbGF0ZXIgdGhhbiB0aGUgbGFzdC5cbiAgICAgKiAgIH0ubGF6eSgyMCwgZmFsc2UsIDUwKSk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdsYXp5JzogZnVuY3Rpb24obXMsIGltbWVkaWF0ZSwgbGltaXQpIHtcbiAgICAgIHZhciBmbiA9IHRoaXMsIHF1ZXVlID0gW10sIGxvY2tlZCA9IGZhbHNlLCBleGVjdXRlLCByb3VuZGVkLCBwZXJFeGVjdXRpb24sIHJlc3VsdDtcbiAgICAgIG1zID0gbXMgfHwgMTtcbiAgICAgIGxpbWl0ID0gbGltaXQgfHwgSW5maW5pdHk7XG4gICAgICByb3VuZGVkID0gY2VpbChtcyk7XG4gICAgICBwZXJFeGVjdXRpb24gPSByb3VuZChyb3VuZGVkIC8gbXMpIHx8IDE7XG4gICAgICBleGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBxdWV1ZUxlbmd0aCA9IHF1ZXVlLmxlbmd0aCwgbWF4UGVyUm91bmQ7XG4gICAgICAgIGlmKHF1ZXVlTGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgICAgLy8gQWxsb3cgZnJhY3Rpb25zIG9mIGEgbWlsbGlzZWNvbmQgYnkgY2FsbGluZ1xuICAgICAgICAvLyBtdWx0aXBsZSB0aW1lcyBwZXIgYWN0dWFsIHRpbWVvdXQgZXhlY3V0aW9uXG4gICAgICAgIG1heFBlclJvdW5kID0gbWF4KHF1ZXVlTGVuZ3RoIC0gcGVyRXhlY3V0aW9uLCAwKTtcbiAgICAgICAgd2hpbGUocXVldWVMZW5ndGggPiBtYXhQZXJSb3VuZCkge1xuICAgICAgICAgIC8vIEdldHRpbmcgdWJlci1tZXRhIGhlcmUuLi5cbiAgICAgICAgICByZXN1bHQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoZm4sIHF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICAgIHF1ZXVlTGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgICAgc2V0RGVsYXkobGF6eSwgcm91bmRlZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgZXhlY3V0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxhenkoKSB7XG4gICAgICAgIC8vIElmIHRoZSBleGVjdXRpb24gaGFzIGxvY2tlZCBhbmQgaXQncyBpbW1lZGlhdGUsIHRoZW5cbiAgICAgICAgLy8gYWxsb3cgMSBsZXNzIGluIHRoZSBxdWV1ZSBhcyAxIGNhbGwgaGFzIGFscmVhZHkgdGFrZW4gcGxhY2UuXG4gICAgICAgIGlmKHF1ZXVlLmxlbmd0aCA8IGxpbWl0IC0gKGxvY2tlZCAmJiBpbW1lZGlhdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKFt0aGlzLCBhcmd1bWVudHNdKTtcbiAgICAgICAgfVxuICAgICAgICBpZighbG9ja2VkKSB7XG4gICAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICBpZihpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGV4ZWN1dGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0RGVsYXkobGF6eSwgcm91bmRlZCwgZXhlY3V0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgbWVtb2l6ZWQgcmVzdWx0XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGF6eTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHRocm90dGxlKFttc10gPSAxKVxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gICAgICogQHNob3J0IENyZWF0ZXMgYSBcInRocm90dGxlZFwiIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uY2UgcGVyIDxtcz4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBleHRyYSBUaGlzIGlzIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIGNhbGxpbmcgJWxhenklIHdpdGggYSBbbGltaXRdIG9mICUxJSBhbmQgW2ltbWVkaWF0ZV0gYXMgJXRydWUlLiAldGhyb3R0bGUlIGlzIGFwcHJvcHJpYXRlIHdoZW4geW91IHdhbnQgdG8gbWFrZSBzdXJlIGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhdCBtb3N0IG9uY2UgZm9yIGEgZ2l2ZW4gZHVyYXRpb24uIEZvciBtb3JlIHNlZSBAZnVuY3Rpb25zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICgzKS50aW1lcyhmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgLy8gY2FsbGVkIG9ubHkgb25jZS4gd2lsbCB3YWl0IDUwbXMgdW50aWwgaXQgcmVzcG9uZHMgYWdhaW5cbiAgICAgKiAgIH0udGhyb3R0bGUoNTApKTtcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3Rocm90dGxlJzogZnVuY3Rpb24obXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhenkobXMsIHRydWUsIDEpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgZGVib3VuY2UoW21zXSA9IDEpXG4gICAgICogQHJldHVybnMgRnVuY3Rpb25cbiAgICAgKiBAc2hvcnQgQ3JlYXRlcyBhIFwiZGVib3VuY2VkXCIgZnVuY3Rpb24gdGhhdCBwb3N0cG9uZXMgaXRzIGV4ZWN1dGlvbiB1bnRpbCBhZnRlciA8bXM+IG1pbGxpc2Vjb25kcyBoYXZlIHBhc3NlZC5cbiAgICAgKiBAZXh0cmEgVGhpcyBtZXRob2QgaXMgdXNlZnVsIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhZnRlciB0aGluZ3MgaGF2ZSBcInNldHRsZWQgZG93blwiLiBBIGdvb2QgZXhhbXBsZSBvZiB0aGlzIGlzIHdoZW4gYSB1c2VyIHRhYnMgcXVpY2tseSB0aHJvdWdoIGZvcm0gZmllbGRzLCBleGVjdXRpb24gb2YgYSBoZWF2eSBvcGVyYXRpb24gc2hvdWxkIGhhcHBlbiBhZnRlciBhIGZldyBtaWxsaXNlY29uZHMgd2hlbiB0aGV5IGhhdmUgXCJzZXR0bGVkXCIgb24gYSBmaWVsZC4gRm9yIG1vcmUgc2VlIEBmdW5jdGlvbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgdmFyIGZuID0gKGZ1bmN0aW9uKGFyZzEpIHtcbiAgICAgKiAgICAgLy8gY2FsbGVkIG9uY2UgNTBtcyBsYXRlclxuICAgICAqICAgfSkuZGVib3VuY2UoNTApOyBmbigpIGZuKCkgZm4oKTtcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2RlYm91bmNlJzogZnVuY3Rpb24obXMpIHtcbiAgICAgIHZhciBmbiA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIGRlYm91bmNlZC5jYW5jZWwoKTtcbiAgICAgICAgc2V0RGVsYXkoZGVib3VuY2VkLCBtcywgZm4sIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGRlbGF5KFttc10gPSAxLCBbYXJnMV0sIC4uLilcbiAgICAgKiBAcmV0dXJucyBGdW5jdGlvblxuICAgICAqIEBzaG9ydCBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gYWZ0ZXIgPG1zPiBtaWxsaXNlY29uZHMuXG4gICAgICogQGV4dHJhIFJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLiAlZGVsYXklIGlzIGFsc28gYSB3YXkgdG8gZXhlY3V0ZSBub24tYmxvY2tpbmcgb3BlcmF0aW9ucyB0aGF0IHdpbGwgd2FpdCB1bnRpbCB0aGUgQ1BVIGlzIGZyZWUuIERlbGF5ZWQgZnVuY3Rpb25zIGNhbiBiZSBjYW5jZWxlZCB1c2luZyB0aGUgJWNhbmNlbCUgbWV0aG9kLiBDYW4gYWxzbyBjdXJyeSBhcmd1bWVudHMgcGFzc2VkIGluIGFmdGVyIDxtcz4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKGZ1bmN0aW9uKGFyZzEpIHtcbiAgICAgKiAgICAgLy8gY2FsbGVkIDFzIGxhdGVyXG4gICAgICogICB9KS5kZWxheSgxMDAwLCAnYXJnMScpO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnZGVsYXknOiBmdW5jdGlvbihtcykge1xuICAgICAgdmFyIGZuID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gbXVsdGlBcmdzKGFyZ3VtZW50cywgbnVsbCwgMSk7XG4gICAgICBzZXREZWxheShmbiwgbXMsIGZuLCBmbiwgYXJncyk7XG4gICAgICByZXR1cm4gZm47XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBldmVyeShbbXNdID0gMSwgW2FyZzFdLCAuLi4pXG4gICAgICogQHJldHVybnMgRnVuY3Rpb25cbiAgICAgKiBAc2hvcnQgRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIGV2ZXJ5IDxtcz4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBleHRyYSBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi4gUmVwZWF0aW5nIGZ1bmN0aW9ucyB3aXRoICVldmVyeSUgY2FuIGJlIGNhbmNlbGVkIHVzaW5nIHRoZSAlY2FuY2VsJSBtZXRob2QuIENhbiBhbHNvIGN1cnJ5IGFyZ3VtZW50cyBwYXNzZWQgaW4gYWZ0ZXIgPG1zPi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAoZnVuY3Rpb24oYXJnMSkge1xuICAgICAqICAgICAvLyBjYWxsZWQgZXZlcnkgMXNcbiAgICAgKiAgIH0pLmV2ZXJ5KDEwMDAsICdhcmcxJyk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdldmVyeSc6IGZ1bmN0aW9uKG1zKSB7XG4gICAgICB2YXIgZm4gPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgYXJncyA9IGFyZ3MubGVuZ3RoID4gMSA/IG11bHRpQXJncyhhcmdzLCBudWxsLCAxKSA6IFtdO1xuICAgICAgZnVuY3Rpb24gZXhlY3V0ZSAoKSB7XG4gICAgICAgIGZuLmFwcGx5KGZuLCBhcmdzKTtcbiAgICAgICAgc2V0RGVsYXkoZm4sIG1zLCBleGVjdXRlKTtcbiAgICAgIH1cbiAgICAgIHNldERlbGF5KGZuLCBtcywgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gZm47XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBjYW5jZWwoKVxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gICAgICogQHNob3J0IENhbmNlbHMgYSBkZWxheWVkIGZ1bmN0aW9uIHNjaGVkdWxlZCB0byBiZSBydW4uXG4gICAgICogQGV4dHJhICVkZWxheSUsICVsYXp5JSwgJXRocm90dGxlJSwgYW5kICVkZWJvdW5jZSUgY2FuIGFsbCBzZXQgZGVsYXlzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgYWxlcnQoJ2hheScpOyAvLyBOZXZlciBjYWxsZWRcbiAgICAgKiAgIH0pLmRlbGF5KDUwMCkuY2FuY2VsKCk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdjYW5jZWwnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aW1lcnMgPSB0aGlzLnRpbWVycywgdGltZXI7XG4gICAgICBpZihpc0FycmF5KHRpbWVycykpIHtcbiAgICAgICAgd2hpbGUodGltZXIgPSB0aW1lcnMuc2hpZnQoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2QgYWZ0ZXIoW251bV0gPSAxKVxuICAgICAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gICAgICogQHNob3J0IENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBhZnRlciBbbnVtXSBjYWxscy5cbiAgICAgKiBAZXh0cmEgJWFmdGVyJSBpcyB1c2VmdWwgZm9yIHJ1bm5pbmcgYSBmaW5hbCBjYWxsYmFjayBhZnRlciBhIHNlcmllcyBvZiBhc3luY2hyb25vdXMgb3BlcmF0aW9ucywgd2hlbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIG9wZXJhdGlvbnMgd2lsbCBjb21wbGV0ZSBpcyB1bmtub3duLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIHZhciBmbiA9IChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgLy8gV2lsbCBiZSBleGVjdXRlZCBvbmNlIG9ubHlcbiAgICAgKiAgIH0pLmFmdGVyKDMpOyBmbigpOyBmbigpOyBmbigpO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnYWZ0ZXInOiBmdW5jdGlvbihudW0pIHtcbiAgICAgIHZhciBmbiA9IHRoaXMsIGNvdW50ZXIgPSAwLCBzdG9yZWRBcmd1bWVudHMgPSBbXTtcbiAgICAgIGlmKCFpc051bWJlcihudW0pKSB7XG4gICAgICAgIG51bSA9IDE7XG4gICAgICB9IGVsc2UgaWYobnVtID09PSAwKSB7XG4gICAgICAgIGZuLmNhbGwoKTtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBzdG9yZWRBcmd1bWVudHMucHVzaChtdWx0aUFyZ3MoYXJndW1lbnRzKSk7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgaWYoY291bnRlciA9PSBudW0pIHtcbiAgICAgICAgICByZXQgPSBmbi5jYWxsKHRoaXMsIHN0b3JlZEFyZ3VtZW50cyk7XG4gICAgICAgICAgY291bnRlciA9IDA7XG4gICAgICAgICAgc3RvcmVkQXJndW1lbnRzID0gW107XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAqIEBtZXRob2Qgb25jZSgpXG4gICAgICogQHJldHVybnMgRnVuY3Rpb25cbiAgICAgKiBAc2hvcnQgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIG9ubHkgb25jZSBhbmQgc3RvcmUgdGhlIHJlc3VsdC5cbiAgICAgKiBAZXh0cmEgJW9uY2UlIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgZnVuY3Rpb25zIHRoYXQgd2lsbCBjYWNoZSB0aGUgcmVzdWx0IG9mIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gYW5kIHVzZSBpdCBvbiBzdWJzZXF1ZW50IGNhbGxzLiBBbHNvIGl0IGNhbiBiZSB1c2VmdWwgZm9yIGNyZWF0aW5nIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9ucyB0aGF0IG9ubHkgbmVlZCB0byBiZSBydW4gb25jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICB2YXIgZm4gPSAoZnVuY3Rpb24oKSB7XG4gICAgICogICAgIC8vIFdpbGwgYmUgZXhlY3V0ZWQgb25jZSBvbmx5XG4gICAgICogICB9KS5vbmNlKCk7IGZuKCk7IGZuKCk7IGZuKCk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdvbmNlJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50aHJvdHRsZShJbmZpbml0eSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICogQG1ldGhvZCBmaWxsKDxhcmcxPiwgPGFyZzI+LCAuLi4pXG4gICAgICogQHJldHVybnMgRnVuY3Rpb25cbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhIG5ldyB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbiB3aGljaCB3aGVuIGNhbGxlZCB3aWxsIGhhdmUgc29tZSBvZiBpdHMgYXJndW1lbnRzIHByZS1lbXB0aXZlbHkgZmlsbGVkIGluLCBhbHNvIGtub3duIGFzIFwiY3VycnlpbmdcIi5cbiAgICAgKiBAZXh0cmEgQXJndW1lbnRzIHBhc3NlZCB0byBhIFwiZmlsbGVkXCIgZnVuY3Rpb24gYXJlIGdlbmVyYWxseSBhcHBlbmRlZCB0byB0aGUgY3VycmllZCBhcmd1bWVudHMuIEhvd2V2ZXIsIGlmICV1bmRlZmluZWQlIGlzIHBhc3NlZCBhcyBhbnkgb2YgdGhlIGFyZ3VtZW50cyB0byAlZmlsbCUsIGl0IHdpbGwgYmUgcmVwbGFjZWQsIHdoZW4gdGhlIFwiZmlsbGVkXCIgZnVuY3Rpb24gaXMgZXhlY3V0ZWQuIFRoaXMgYWxsb3dzIGN1cnJ5aW5nIG9mIGFyZ3VtZW50cyBldmVuIHdoZW4gdGhleSBvY2N1ciB0b3dhcmQgdGhlIGVuZCBvZiBhbiBhcmd1bWVudCBsaXN0ICh0aGUgZXhhbXBsZSBkZW1vbnN0cmF0ZXMgdGhpcyBtdWNoIG1vcmUgY2xlYXJseSkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgdmFyIGRlbGF5T25lU2Vjb25kID0gc2V0VGltZW91dC5maWxsKHVuZGVmaW5lZCwgMTAwMCk7XG4gICAgICogICBkZWxheU9uZVNlY29uZChmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgLy8gV2lsbCBiZSBleGVjdXRlZCAxcyBsYXRlclxuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdmaWxsJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZm4gPSB0aGlzLCBjdXJyaWVkID0gbXVsdGlBcmdzKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gbXVsdGlBcmdzKGFyZ3VtZW50cyk7XG4gICAgICAgIGN1cnJpZWQuZm9yRWFjaChmdW5jdGlvbihhcmcsIGluZGV4KSB7XG4gICAgICAgICAgaWYoYXJnICE9IG51bGwgfHwgaW5kZXggPj0gYXJncy5sZW5ndGgpIGFyZ3Muc3BsaWNlKGluZGV4LCAwLCBhcmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuXG4gIH0pO1xuXG5cbiAgLyoqKlxuICAgKiBAcGFja2FnZSBOdW1iZXJcbiAgICogQGRlcGVuZGVuY3kgY29yZVxuICAgKiBAZGVzY3JpcHRpb24gTnVtYmVyIGZvcm1hdHRpbmcsIHJvdW5kaW5nICh3aXRoIHByZWNpc2lvbiksIGFuZCByYW5nZXMuIEFsaWFzZXMgdG8gTWF0aCBtZXRob2RzLlxuICAgKlxuICAgKioqL1xuXG5cbiAgZnVuY3Rpb24gYWJicmV2aWF0ZU51bWJlcihudW0sIHJvdW5kVG8sIHN0ciwgbWlkLCBsaW1pdCwgYnl0ZXMpIHtcbiAgICB2YXIgZml4ZWQgICAgICAgID0gbnVtLnRvRml4ZWQoMjApLFxuICAgICAgICBkZWNpbWFsUGxhY2UgPSBmaXhlZC5zZWFyY2goL1xcLi8pLFxuICAgICAgICBudW1lcmFsUGxhY2UgPSBmaXhlZC5zZWFyY2goL1sxLTldLyksXG4gICAgICAgIHNpZ25pZmljYW50ICA9IGRlY2ltYWxQbGFjZSAtIG51bWVyYWxQbGFjZSxcbiAgICAgICAgdW5pdCwgaSwgZGl2aXNvcjtcbiAgICBpZihzaWduaWZpY2FudCA+IDApIHtcbiAgICAgIHNpZ25pZmljYW50IC09IDE7XG4gICAgfVxuICAgIGkgPSBtYXgobWluKGZsb29yKHNpZ25pZmljYW50IC8gMyksIGxpbWl0ID09PSBmYWxzZSA/IHN0ci5sZW5ndGggOiBsaW1pdCksIC1taWQpO1xuICAgIHVuaXQgPSBzdHIuY2hhckF0KGkgKyBtaWQgLSAxKTtcbiAgICBpZihzaWduaWZpY2FudCA8IC05KSB7XG4gICAgICBpID0gLTM7XG4gICAgICByb3VuZFRvID0gYWJzKHNpZ25pZmljYW50KSAtIDk7XG4gICAgICB1bml0ID0gc3RyLnNsaWNlKDAsMSk7XG4gICAgfVxuICAgIGRpdmlzb3IgPSBieXRlcyA/IHBvdygyLCAxMCAqIGkpIDogcG93KDEwLCBpICogMyk7XG4gICAgcmV0dXJuIHdpdGhQcmVjaXNpb24obnVtIC8gZGl2aXNvciwgcm91bmRUbyB8fCAwKS5mb3JtYXQoKSArIHVuaXQudHJpbSgpO1xuICB9XG5cblxuICBleHRlbmQobnVtYmVyLCBmYWxzZSwgdHJ1ZSwge1xuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgTnVtYmVyLnJhbmRvbShbbjFdLCBbbjJdKVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBbbjFdIGFuZCBbbjJdLlxuICAgICAqIEBleHRyYSBJZiBvbmx5IDEgbnVtYmVyIGlzIHBhc3NlZCwgdGhlIG90aGVyIHdpbGwgYmUgMC4gSWYgbm9uZSBhcmUgcGFzc2VkLCB0aGUgbnVtYmVyIHdpbGwgYmUgZWl0aGVyIDAgb3IgMS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBOdW1iZXIucmFuZG9tKDUwLCAxMDApIC0+IGV4LiA4NVxuICAgICAqICAgTnVtYmVyLnJhbmRvbSg1MCkgICAgICAtPiBleC4gMjdcbiAgICAgKiAgIE51bWJlci5yYW5kb20oKSAgICAgICAgLT4gZXguIDBcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3JhbmRvbSc6IGZ1bmN0aW9uKG4xLCBuMikge1xuICAgICAgdmFyIG1pbk51bSwgbWF4TnVtO1xuICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSBuMiA9IG4xLCBuMSA9IDA7XG4gICAgICBtaW5OdW0gPSBtaW4objEgfHwgMCwgaXNVbmRlZmluZWQobjIpID8gMSA6IG4yKTtcbiAgICAgIG1heE51bSA9IG1heChuMSB8fCAwLCBpc1VuZGVmaW5lZChuMikgPyAxIDogbjIpICsgMTtcbiAgICAgIHJldHVybiBmbG9vcigobWF0aC5yYW5kb20oKSAqIChtYXhOdW0gLSBtaW5OdW0pKSArIG1pbk51bSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGV4dGVuZChudW1iZXIsIHRydWUsIHRydWUsIHtcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGxvZyg8YmFzZT4gPSBNYXRoLkUpXG4gICAgICogQHJldHVybnMgTnVtYmVyXG4gICAgICogQHNob3J0IFJldHVybnMgdGhlIGxvZ2FyaXRobSBvZiB0aGUgbnVtYmVyIHdpdGggYmFzZSA8YmFzZT4sIG9yIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSBudW1iZXIgaWYgPGJhc2U+IGlzIHVuZGVmaW5lZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAoNjQpLmxvZygyKSAtPiA2XG4gICAgICogICAoOSkubG9nKDMpICAtPiAyXG4gICAgICogICAoNSkubG9nKCkgICAtPiAxLjYwOTQzNzkxMjQzNDEwMDNcbiAgICAgKlxuICAgICAqKiovXG5cbiAgICAnbG9nJzogZnVuY3Rpb24oYmFzZSkge1xuICAgICAgIHJldHVybiBtYXRoLmxvZyh0aGlzKSAvIChiYXNlID8gbWF0aC5sb2coYmFzZSkgOiAxKTtcbiAgICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGFiYnIoW3ByZWNpc2lvbl0gPSAwKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBSZXR1cm5zIGFuIGFiYnJldmlhdGVkIGZvcm0gb2YgdGhlIG51bWJlci5cbiAgICAgKiBAZXh0cmEgW3ByZWNpc2lvbl0gd2lsbCByb3VuZCB0byB0aGUgZ2l2ZW4gcHJlY2lzaW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICgxMDAwKS5hYmJyKCkgICAgLT4gXCIxa1wiXG4gICAgICogICAoMTAwMDAwMCkuYWJicigpIC0+IFwiMW1cIlxuICAgICAqICAgKDEyODApLmFiYnIoMSkgICAtPiBcIjEuM2tcIlxuICAgICAqXG4gICAgICoqKi9cbiAgICAnYWJicic6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuICAgICAgcmV0dXJuIGFiYnJldmlhdGVOdW1iZXIodGhpcywgcHJlY2lzaW9uLCAna21idCcsIDAsIDQpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBtZXRyaWMoW3ByZWNpc2lvbl0gPSAwLCBbbGltaXRdID0gMSlcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgbnVtYmVyIGFzIGEgc3RyaW5nIGluIG1ldHJpYyBub3RhdGlvbi5cbiAgICAgKiBAZXh0cmEgW3ByZWNpc2lvbl0gd2lsbCByb3VuZCB0byB0aGUgZ2l2ZW4gcHJlY2lzaW9uLiBCb3RoIHZlcnkgbGFyZ2UgbnVtYmVycyBhbmQgdmVyeSBzbWFsbCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQuIFtsaW1pdF0gaXMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgdW5pdHMuIFRoZSBkZWZhdWx0IGlzICUxJSwgd2hpY2ggaXMgXCJraWxvXCIuIElmIFtsaW1pdF0gaXMgJWZhbHNlJSwgdGhlIHVwcGVyIGxpbWl0IHdpbGwgYmUgXCJleGFcIi4gVGhlIGxvd2VyIGxpbWl0IGlzIFwibmFub1wiLCBhbmQgY2Fubm90IGJlIGNoYW5nZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKDEwMDApLm1ldHJpYygpICAgICAgICAgICAgLT4gXCIxa1wiXG4gICAgICogICAoMTAwMDAwMCkubWV0cmljKCkgICAgICAgICAtPiBcIjEsMDAwa1wiXG4gICAgICogICAoMTAwMDAwMCkubWV0cmljKDAsIGZhbHNlKSAtPiBcIjFNXCJcbiAgICAgKiAgICgxMjQ5KS5tZXRyaWMoMikgKyAnZycgICAgIC0+IFwiMS4yNWtnXCJcbiAgICAgKiAgICgwLjAyNSkubWV0cmljKCkgKyAnbScgICAgIC0+IFwiMjVtbVwiXG4gICAgICpcbiAgICAgKioqL1xuICAgICdtZXRyaWMnOiBmdW5jdGlvbihwcmVjaXNpb24sIGxpbWl0KSB7XG4gICAgICByZXR1cm4gYWJicmV2aWF0ZU51bWJlcih0aGlzLCBwcmVjaXNpb24sICduzrxtIGtNR1RQRScsIDQsIGlzVW5kZWZpbmVkKGxpbWl0KSA/IDEgOiBsaW1pdCk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGJ5dGVzKFtwcmVjaXNpb25dID0gMCwgW2xpbWl0XSA9IDQpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IFJldHVybnMgYW4gYWJicmV2aWF0ZWQgZm9ybSBvZiB0aGUgbnVtYmVyLCBjb25zaWRlcmVkIHRvIGJlIFwiQnl0ZXNcIi5cbiAgICAgKiBAZXh0cmEgW3ByZWNpc2lvbl0gd2lsbCByb3VuZCB0byB0aGUgZ2l2ZW4gcHJlY2lzaW9uLiBbbGltaXRdIGlzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIHVuaXRzLiBUaGUgZGVmYXVsdCBpcyAlNCUsIHdoaWNoIGlzIFwidGVyYWJ5dGVzXCIgKFRCKS4gSWYgW2xpbWl0XSBpcyAlZmFsc2UlLCB0aGUgdXBwZXIgbGltaXQgd2lsbCBiZSBcImV4YVwiLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICgxMDAwKS5ieXRlcygpICAgICAgICAgICAgICAgICAtPiBcIjFrQlwiXG4gICAgICogICAoMTAwMCkuYnl0ZXMoMikgICAgICAgICAgICAgICAgLT4gXCIwLjk4a0JcIlxuICAgICAqICAgKCgxMCkucG93KDIwKSkuYnl0ZXMoKSAgICAgICAgIC0+IFwiOTAsOTQ5LDQ3MFRCXCJcbiAgICAgKiAgICgoMTApLnBvdygyMCkpLmJ5dGVzKDAsIGZhbHNlKSAtPiBcIjg3RUJcIlxuICAgICAqXG4gICAgICoqKi9cbiAgICAnYnl0ZXMnOiBmdW5jdGlvbihwcmVjaXNpb24sIGxpbWl0KSB7XG4gICAgICByZXR1cm4gYWJicmV2aWF0ZU51bWJlcih0aGlzLCBwcmVjaXNpb24sICdrTUdUUEUnLCAwLCBpc1VuZGVmaW5lZChsaW1pdCkgPyA0IDogbGltaXQsIHRydWUpICsgJ0InO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBpc0ludGVnZXIoKVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBudW1iZXIgaGFzIG5vIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKDQyMCkuaXNJbnRlZ2VyKCkgLT4gdHJ1ZVxuICAgICAqICAgKDQuNSkuaXNJbnRlZ2VyKCkgLT4gZmFsc2VcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2lzSW50ZWdlcic6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMgJSAxID09IDA7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGlzT2RkKClcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiB0aGUgbnVtYmVyIGlzIG9kZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAoMykuaXNPZGQoKSAgLT4gdHJ1ZVxuICAgICAqICAgKDE4KS5pc09kZCgpIC0+IGZhbHNlXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpc09kZCc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFpc05hTih0aGlzKSAmJiAhdGhpcy5pc011bHRpcGxlT2YoMik7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGlzRXZlbigpXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIG51bWJlciBpcyBldmVuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICg2KS5pc0V2ZW4oKSAgLT4gdHJ1ZVxuICAgICAqICAgKDE3KS5pc0V2ZW4oKSAtPiBmYWxzZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnaXNFdmVuJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc011bHRpcGxlT2YoMik7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGlzTXVsdGlwbGVPZig8bnVtPilcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiB0aGUgbnVtYmVyIGlzIGEgbXVsdGlwbGUgb2YgPG51bT4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKDYpLmlzTXVsdGlwbGVPZigyKSAgLT4gdHJ1ZVxuICAgICAqICAgKDE3KS5pc011bHRpcGxlT2YoMikgLT4gZmFsc2VcbiAgICAgKiAgICgzMikuaXNNdWx0aXBsZU9mKDQpIC0+IHRydWVcbiAgICAgKiAgICgzNCkuaXNNdWx0aXBsZU9mKDQpIC0+IGZhbHNlXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpc011bHRpcGxlT2YnOiBmdW5jdGlvbihudW0pIHtcbiAgICAgIHJldHVybiB0aGlzICUgbnVtID09PSAwO1xuICAgIH0sXG5cblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGZvcm1hdChbcGxhY2VdID0gMCwgW3Rob3VzYW5kc10gPSAnLCcsIFtkZWNpbWFsXSA9ICcuJylcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgRm9ybWF0cyB0aGUgbnVtYmVyIHRvIGEgcmVhZGFibGUgc3RyaW5nLlxuICAgICAqIEBleHRyYSBJZiBbcGxhY2VdIGlzICV1bmRlZmluZWQlLCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIHRoZSBwbGFjZS4gW3Rob3VzYW5kc10gaXMgdGhlIGNoYXJhY3RlciB1c2VkIGZvciB0aGUgdGhvdXNhbmRzIHNlcGFyYXRvci4gW2RlY2ltYWxdIGlzIHRoZSBjaGFyYWN0ZXIgdXNlZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKDU2NzgyKS5mb3JtYXQoKSAgICAgICAgICAgLT4gJzU2LDc4MidcbiAgICAgKiAgICg1Njc4MikuZm9ybWF0KDIpICAgICAgICAgIC0+ICc1Niw3ODIuMDAnXG4gICAgICogICAoNDM4OC40MykuZm9ybWF0KDIsICcgJykgICAgICAtPiAnNCAzODguNDMnXG4gICAgICogICAoNDM4OC40MykuZm9ybWF0KDIsICcuJywgJywnKSAtPiAnNC4zODgsNDMnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdmb3JtYXQnOiBmdW5jdGlvbihwbGFjZSwgdGhvdXNhbmRzLCBkZWNpbWFsKSB7XG4gICAgICB2YXIgaSwgc3RyLCBzcGxpdCwgaW50ZWdlciwgZnJhY3Rpb24sIHJlc3VsdCA9ICcnO1xuICAgICAgaWYoaXNVbmRlZmluZWQodGhvdXNhbmRzKSkge1xuICAgICAgICB0aG91c2FuZHMgPSAnLCc7XG4gICAgICB9XG4gICAgICBpZihpc1VuZGVmaW5lZChkZWNpbWFsKSkge1xuICAgICAgICBkZWNpbWFsID0gJy4nO1xuICAgICAgfVxuICAgICAgc3RyICAgICAgPSAoaXNOdW1iZXIocGxhY2UpID8gd2l0aFByZWNpc2lvbih0aGlzLCBwbGFjZSB8fCAwKS50b0ZpeGVkKG1heChwbGFjZSwgMCkpIDogdGhpcy50b1N0cmluZygpKS5yZXBsYWNlKC9eLS8sICcnKTtcbiAgICAgIHNwbGl0ICAgID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICBpbnRlZ2VyICA9IHNwbGl0WzBdO1xuICAgICAgZnJhY3Rpb24gPSBzcGxpdFsxXTtcbiAgICAgIGZvcihpID0gaW50ZWdlci5sZW5ndGg7IGkgPiAwOyBpIC09IDMpIHtcbiAgICAgICAgaWYoaSA8IGludGVnZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdGhvdXNhbmRzICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGludGVnZXIuc2xpY2UobWF4KDAsIGkgLSAzKSwgaSkgKyByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZihmcmFjdGlvbikge1xuICAgICAgICByZXN1bHQgKz0gZGVjaW1hbCArIHJlcGVhdFN0cmluZygnMCcsIChwbGFjZSB8fCAwKSAtIGZyYWN0aW9uLmxlbmd0aCkgKyBmcmFjdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAodGhpcyA8IDAgPyAnLScgOiAnJykgKyByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGhleChbcGFkXSA9IDEpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IENvbnZlcnRzIHRoZSBudW1iZXIgdG8gaGV4aWRlY2ltYWwuXG4gICAgICogQGV4dHJhIFtwYWRdIHdpbGwgcGFkIHRoZSByZXN1bHRpbmcgc3RyaW5nIHRvIHRoYXQgbWFueSBwbGFjZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgKDI1NSkuaGV4KCkgICAtPiAnZmYnO1xuICAgICAqICAgKDI1NSkuaGV4KDQpICAtPiAnMDBmZic7XG4gICAgICogICAoMjM2NTQpLmhleCgpIC0+ICc1YzY2JztcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2hleCc6IGZ1bmN0aW9uKHBhZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFkKHBhZCB8fCAxLCBmYWxzZSwgMTYpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCB0aW1lcyg8Zm4+KVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBDYWxscyA8Zm4+IGEgbnVtYmVyIG9mIHRpbWVzIGVxdWl2YWxlbnQgdG8gdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAoOCkudGltZXMoZnVuY3Rpb24oaSkge1xuICAgICAqICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCA4IHRpbWVzLlxuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICd0aW1lcyc6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBpZihmbikge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpczsgaSsrKSB7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgY2hyKClcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhIHN0cmluZyBhdCB0aGUgY29kZSBwb2ludCBvZiB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICg2NSkuY2hyKCkgLT4gXCJBXCJcbiAgICAgKiAgICg3NSkuY2hyKCkgLT4gXCJLXCJcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2Nocic6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5mcm9tQ2hhckNvZGUodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHBhZCg8cGxhY2U+ID0gMCwgW3NpZ25dID0gZmFsc2UsIFtiYXNlXSA9IDEwKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBQYWRzIGEgbnVtYmVyIHdpdGggXCIwXCIgdG8gPHBsYWNlPi5cbiAgICAgKiBAZXh0cmEgW3NpZ25dIGFsbG93cyB5b3UgdG8gZm9yY2UgdGhlIHNpZ24gYXMgd2VsbCAoKzA1LCBldGMpLiBbYmFzZV0gY2FuIGNoYW5nZSB0aGUgYmFzZSBmb3IgbnVtZXJhbCBjb252ZXJzaW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICg1KS5wYWQoMikgICAgICAgIC0+ICcwNSdcbiAgICAgKiAgICgtNSkucGFkKDQpICAgICAgIC0+ICctMDAwNSdcbiAgICAgKiAgICg4MikucGFkKDMsIHRydWUpIC0+ICcrMDgyJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAncGFkJzogZnVuY3Rpb24ocGxhY2UsIHNpZ24sIGJhc2UpIHtcbiAgICAgIHJldHVybiBwYWROdW1iZXIodGhpcywgcGxhY2UsIHNpZ24sIGJhc2UpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBvcmRpbmFsaXplKClcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhbiBvcmRpbmFsaXplZCAoRW5nbGlzaCkgc3RyaW5nLCBpLmUuIFwiMXN0XCIsIFwiMm5kXCIsIGV0Yy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAoMSkub3JkaW5hbGl6ZSgpIC0+ICcxc3QnO1xuICAgICAqICAgKDIpLm9yZGluYWxpemUoKSAtPiAnMm5kJztcbiAgICAgKiAgICg4KS5vcmRpbmFsaXplKCkgLT4gJzh0aCc7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdvcmRpbmFsaXplJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3VmZml4LCBudW0gPSBhYnModGhpcyksIGxhc3QgPSBwYXJzZUludChudW0udG9TdHJpbmcoKS5zbGljZSgtMikpO1xuICAgICAgcmV0dXJuIHRoaXMgKyBnZXRPcmRpbmFsaXplZFN1ZmZpeChsYXN0KTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgdG9OdW1iZXIoKVxuICAgICAqIEByZXR1cm5zIE51bWJlclxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGEgbnVtYmVyLiBUaGlzIGlzIG1vc3RseSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICg0MjApLnRvTnVtYmVyKCkgLT4gNDIwXG4gICAgICpcbiAgICAgKioqL1xuICAgICd0b051bWJlcic6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcywgMTApO1xuICAgIH1cblxuICB9KTtcblxuICAvKioqXG4gICAqIEBtZXRob2Qgcm91bmQoPHByZWNpc2lvbj4gPSAwKVxuICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICogQHNob3J0IFNob3J0Y3V0IGZvciAlTWF0aC5yb3VuZCUgdGhhdCBhbHNvIGFsbG93cyBhIDxwcmVjaXNpb24+LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICgzLjI0MSkucm91bmQoKSAgLT4gM1xuICAgKiAgICgtMy44NDEpLnJvdW5kKCkgLT4gLTRcbiAgICogICAoMy4yNDEpLnJvdW5kKDIpIC0+IDMuMjRcbiAgICogICAoMzc0OCkucm91bmQoLTIpIC0+IDM4MDBcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIGNlaWwoPHByZWNpc2lvbj4gPSAwKVxuICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICogQHNob3J0IFNob3J0Y3V0IGZvciAlTWF0aC5jZWlsJSB0aGF0IGFsc28gYWxsb3dzIGEgPHByZWNpc2lvbj4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgKDMuMjQxKS5jZWlsKCkgIC0+IDRcbiAgICogICAoLTMuMjQxKS5jZWlsKCkgLT4gLTNcbiAgICogICAoMy4yNDEpLmNlaWwoMikgLT4gMy4yNVxuICAgKiAgICgzNzQ4KS5jZWlsKC0yKSAtPiAzODAwXG4gICAqXG4gICAqKipcbiAgICogQG1ldGhvZCBmbG9vcig8cHJlY2lzaW9uPiA9IDApXG4gICAqIEByZXR1cm5zIE51bWJlclxuICAgKiBAc2hvcnQgU2hvcnRjdXQgZm9yICVNYXRoLmZsb29yJSB0aGF0IGFsc28gYWxsb3dzIGEgPHByZWNpc2lvbj4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgKDMuMjQxKS5mbG9vcigpICAtPiAzXG4gICAqICAgKC0zLjg0MSkuZmxvb3IoKSAtPiAtNFxuICAgKiAgICgzLjI0MSkuZmxvb3IoMikgLT4gMy4yNFxuICAgKiAgICgzNzQ4KS5mbG9vcigtMikgLT4gMzcwMFxuICAgKlxuICAgKioqXG4gICAqIEBtZXRob2QgW21hdGhdKClcbiAgICogQHJldHVybnMgTnVtYmVyXG4gICAqIEBzaG9ydCBNYXRoIHJlbGF0ZWQgZnVuY3Rpb25zIGFyZSBtYXBwZWQgYXMgc2hvcnRjdXRzIHRvIG51bWJlcnMgYW5kIGFyZSBpZGVudGljYWwuIE5vdGUgdGhhdCAlTnVtYmVyI2xvZyUgcHJvdmlkZXMgc29tZSBzcGVjaWFsIGRlZmF1bHRzLlxuICAgKlxuICAgKiBAc2V0XG4gICAqICAgYWJzXG4gICAqICAgc2luXG4gICAqICAgYXNpblxuICAgKiAgIGNvc1xuICAgKiAgIGFjb3NcbiAgICogICB0YW5cbiAgICogICBhdGFuXG4gICAqICAgc3FydFxuICAgKiAgIGV4cFxuICAgKiAgIHBvd1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICgzKS5wb3coMykgLT4gMjdcbiAgICogICAoLTMpLmFicygpIC0+IDNcbiAgICogICAoMTAyNCkuc3FydCgpIC0+IDMyXG4gICAqXG4gICAqKiovXG5cbiAgZnVuY3Rpb24gYnVpbGROdW1iZXIoKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmRpbmdGdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgICAgICAgcmV0dXJuIHByZWNpc2lvbiA/IHdpdGhQcmVjaXNpb24odGhpcywgcHJlY2lzaW9uLCBmbikgOiBmbih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXh0ZW5kKG51bWJlciwgdHJ1ZSwgdHJ1ZSwge1xuICAgICAgJ2NlaWwnOiAgIGNyZWF0ZVJvdW5kaW5nRnVuY3Rpb24oY2VpbCksXG4gICAgICAncm91bmQnOiAgY3JlYXRlUm91bmRpbmdGdW5jdGlvbihyb3VuZCksXG4gICAgICAnZmxvb3InOiAgY3JlYXRlUm91bmRpbmdGdW5jdGlvbihmbG9vcilcbiAgICB9KTtcbiAgICBleHRlbmRTaW1pbGFyKG51bWJlciwgdHJ1ZSwgdHJ1ZSwgJ2Ficyxwb3csc2luLGFzaW4sY29zLGFjb3MsdGFuLGF0YW4sZXhwLHBvdyxzcXJ0JywgZnVuY3Rpb24obWV0aG9kcywgbmFtZSkge1xuICAgICAgbWV0aG9kc1tuYW1lXSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhbbmFtZV0odGhpcywgYSwgYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBidWlsZE51bWJlcigpO1xuXG5cbiAgLyoqKlxuICAgKiBAcGFja2FnZSBPYmplY3RcbiAgICogQGRlcGVuZGVuY3kgY29yZVxuICAgKiBAZGVzY3JpcHRpb24gT2JqZWN0IG1hbmlwdWxhdGlvbiwgdHlwZSBjaGVja2luZyAoaXNOdW1iZXIsIGlzU3RyaW5nLCAuLi4pLCBleHRlbmRlZCBvYmplY3RzIHdpdGggaGFzaC1saWtlIG1ldGhvZHMgYXZhaWxhYmxlIGFzIGluc3RhbmNlIG1ldGhvZHMuXG4gICAqXG4gICAqIE11Y2ggdGhhbmtzIHRvIGthbmdheCBmb3IgaGlzIGluZm9ybWF0aXZlIGFyaWNsZSBhYm91dCBob3cgcHJvYmxlbXMgd2l0aCBpbnN0YW5jZW9mIGFuZCBjb25zdHJ1Y3RvclxuICAgKiBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cbiAgICpcbiAgICoqKi9cblxuICB2YXIgT2JqZWN0VHlwZU1ldGhvZHMgPSAnaXNPYmplY3QsaXNOYU4nLnNwbGl0KCcsJyk7XG4gIHZhciBPYmplY3RIYXNoTWV0aG9kcyA9ICdrZXlzLHZhbHVlcyxzZWxlY3QscmVqZWN0LGVhY2gsbWVyZ2UsY2xvbmUsZXF1YWwsd2F0Y2gsdGFwLGhhcyx0b1F1ZXJ5U3RyaW5nJy5zcGxpdCgnLCcpO1xuXG4gIGZ1bmN0aW9uIHNldFBhcmFtc09iamVjdChvYmosIHBhcmFtLCB2YWx1ZSwgY2FzdEJvb2xlYW4pIHtcbiAgICB2YXIgcmVnID0gL14oLis/KShcXFsuKlxcXSkkLywgcGFyYW1Jc0FycmF5LCBtYXRjaCwgYWxsS2V5cywga2V5O1xuICAgIGlmKG1hdGNoID0gcGFyYW0ubWF0Y2gocmVnKSkge1xuICAgICAga2V5ID0gbWF0Y2hbMV07XG4gICAgICBhbGxLZXlzID0gbWF0Y2hbMl0ucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKS5zcGxpdCgnXVsnKTtcbiAgICAgIGFsbEtleXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHBhcmFtSXNBcnJheSA9ICFrIHx8IGsubWF0Y2goL15cXGQrJC8pO1xuICAgICAgICBpZigha2V5ICYmIGlzQXJyYXkob2JqKSkga2V5ID0gb2JqLmxlbmd0aDtcbiAgICAgICAgaWYoIWhhc093blByb3BlcnR5KG9iaiwga2V5KSkge1xuICAgICAgICAgIG9ialtrZXldID0gcGFyYW1Jc0FycmF5ID8gW10gOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAga2V5ID0gaztcbiAgICAgIH0pO1xuICAgICAgaWYoIWtleSAmJiBwYXJhbUlzQXJyYXkpIGtleSA9IG9iai5sZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIHNldFBhcmFtc09iamVjdChvYmosIGtleSwgdmFsdWUsIGNhc3RCb29sZWFuKTtcbiAgICB9IGVsc2UgaWYoY2FzdEJvb2xlYW4gJiYgdmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgb2JqW3BhcmFtXSA9IHRydWU7XG4gICAgfSBlbHNlIGlmKGNhc3RCb29sZWFuICYmIHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICBvYmpbcGFyYW1dID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtwYXJhbV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RUb1F1ZXJ5U3RyaW5nKGJhc2UsIG9iaikge1xuICAgIHZhciB0bXA7XG4gICAgLy8gSWYgYSBjdXN0b20gdG9TdHJpbmcgZXhpc3RzIGJhaWwgaGVyZSBhbmQgdXNlIHRoYXQgaW5zdGVhZFxuICAgIGlmKGlzQXJyYXkob2JqKSB8fCAoaXNPYmplY3RUeXBlKG9iaikgJiYgb2JqLnRvU3RyaW5nID09PSBpbnRlcm5hbFRvU3RyaW5nKSkge1xuICAgICAgdG1wID0gW107XG4gICAgICBpdGVyYXRlT3Zlck9iamVjdChvYmosIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYoYmFzZSkge1xuICAgICAgICAgIGtleSA9IGJhc2UgKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgdG1wLnB1c2gob2JqZWN0VG9RdWVyeVN0cmluZyhrZXksIHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0bXAuam9pbignJicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZighYmFzZSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIHNhbml0aXplVVJJQ29tcG9uZW50KGJhc2UpICsgJz0nICsgKGlzRGF0ZShvYmopID8gb2JqLmdldFRpbWUoKSA6IHNhbml0aXplVVJJQ29tcG9uZW50KG9iaikpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbml0aXplVVJJQ29tcG9uZW50KG9iaikge1xuICAgIC8vIHVuZGVmaW5lZCwgbnVsbCwgYW5kIE5hTiBhcmUgcmVwcmVzZW50ZWQgYXMgYSBibGFuayBzdHJpbmcsXG4gICAgLy8gd2hpbGUgZmFsc2UgYW5kIDAgYXJlIHN0cmluZ2lmaWVkLiBcIitcIiBpcyBhbGxvd2VkIGluIHF1ZXJ5IHN0cmluZ1xuICAgIHJldHVybiAhb2JqICYmIG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSAwID8gJycgOiBlbmNvZGVVUklDb21wb25lbnQob2JqKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoSW5PYmplY3QobWF0Y2gsIGtleSwgdmFsdWUpIHtcbiAgICBpZihpc1JlZ0V4cChtYXRjaCkpIHtcbiAgICAgIHJldHVybiBtYXRjaC50ZXN0KGtleSk7XG4gICAgfSBlbHNlIGlmKGlzT2JqZWN0VHlwZShtYXRjaCkpIHtcbiAgICAgIHJldHVybiBtYXRjaFtrZXldID09PSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGtleSA9PT0gc3RyaW5nKG1hdGNoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RGcm9tT2JqZWN0KG9iaiwgYXJncywgc2VsZWN0KSB7XG4gICAgdmFyIG1hdGNoLCByZXN1bHQgPSBvYmogaW5zdGFuY2VvZiBIYXNoID8gbmV3IEhhc2ggOiB7fTtcbiAgICBpdGVyYXRlT3Zlck9iamVjdChvYmosIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICBmbGF0dGVuZWRBcmdzKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZihtYXRjaEluT2JqZWN0KGFyZywga2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDEpO1xuICAgICAgaWYobWF0Y2ggPT09IHNlbGVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8qKipcbiAgICogQG1ldGhvZCBPYmplY3QuaXNbVHlwZV0oPG9iaj4pXG4gICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiA8b2JqPiBpcyBhbiBvYmplY3Qgb2YgdGhhdCB0eXBlLlxuICAgKiBAZXh0cmEgJWlzT2JqZWN0JSB3aWxsIHJldHVybiBmYWxzZSBvbiBhbnl0aGluZyB0aGF0IGlzIG5vdCBhbiBvYmplY3QgbGl0ZXJhbCwgaW5jbHVkaW5nIGluc3RhbmNlcyBvZiBpbmhlcml0ZWQgY2xhc3Nlcy4gTm90ZSBhbHNvIHRoYXQgJWlzTmFOJSB3aWxsIE9OTFkgcmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBJUyAlTmFOJS4gSXQgZG9lcyBub3QgbWVhbiB0aGUgc2FtZSBhcyBicm93c2VyIG5hdGl2ZSAlaXNOYU4lLCB3aGljaCByZXR1cm5zIHRydWUgZm9yIGFueXRoaW5nIHRoYXQgaXMgXCJub3QgYSBudW1iZXJcIi5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIGlzQXJyYXlcbiAgICogICBpc09iamVjdFxuICAgKiAgIGlzQm9vbGVhblxuICAgKiAgIGlzRGF0ZVxuICAgKiAgIGlzRnVuY3Rpb25cbiAgICogICBpc05hTlxuICAgKiAgIGlzTnVtYmVyXG4gICAqICAgaXNTdHJpbmdcbiAgICogICBpc1JlZ0V4cFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgIE9iamVjdC5pc0FycmF5KFsxLDIsM10pICAgICAgICAgICAgLT4gdHJ1ZVxuICAgKiAgIE9iamVjdC5pc0RhdGUoMykgICAgICAgICAgICAgICAgICAgLT4gZmFsc2VcbiAgICogICBPYmplY3QuaXNSZWdFeHAoL3dhc2FiaS8pICAgICAgICAgIC0+IHRydWVcbiAgICogICBPYmplY3QuaXNPYmplY3QoeyBicm9rZW46J3dlYXInIH0pIC0+IHRydWVcbiAgICpcbiAgICoqKi9cbiAgZnVuY3Rpb24gYnVpbGRUeXBlTWV0aG9kcygpIHtcbiAgICBleHRlbmRTaW1pbGFyKG9iamVjdCwgZmFsc2UsIHRydWUsIENsYXNzTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZHMsIG5hbWUpIHtcbiAgICAgIHZhciBtZXRob2QgPSAnaXMnICsgbmFtZTtcbiAgICAgIE9iamVjdFR5cGVNZXRob2RzLnB1c2gobWV0aG9kKTtcbiAgICAgIG1ldGhvZHNbbWV0aG9kXSA9IHR5cGVDaGVja3NbbmFtZV07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZE9iamVjdEV4dGVuZCgpIHtcbiAgICBleHRlbmQob2JqZWN0LCBmYWxzZSwgZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDA7IH0sIHtcbiAgICAgICdleHRlbmQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBPYmplY3RUeXBlTWV0aG9kcy5jb25jYXQoT2JqZWN0SGFzaE1ldGhvZHMpXG4gICAgICAgIGlmKHR5cGVvZiBFbnVtZXJhYmxlTWV0aG9kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBtZXRob2RzID0gbWV0aG9kcy5jb25jYXQoRW51bWVyYWJsZU1ldGhvZHMpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkT2JqZWN0SW5zdGFuY2VNZXRob2RzKG1ldGhvZHMsIG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBleHRlbmQob2JqZWN0LCBmYWxzZSwgdHJ1ZSwge1xuICAgICAgLyoqKlxuICAgICAgICogQG1ldGhvZCB3YXRjaCg8b2JqPiwgPHByb3A+LCA8Zm4+KVxuICAgICAgICogQHJldHVybnMgTm90aGluZ1xuICAgICAgICogQHNob3J0IFdhdGNoZXMgYSBwcm9wZXJ0eSBvZiA8b2JqPiBhbmQgcnVucyA8Zm4+IHdoZW4gaXQgY2hhbmdlcy5cbiAgICAgICAqIEBleHRyYSA8Zm4+IGlzIHBhc3NlZCB0aHJlZSBhcmd1bWVudHM6IHRoZSBwcm9wZXJ0eSA8cHJvcD4sIHRoZSBvbGQgdmFsdWUsIGFuZCB0aGUgbmV3IHZhbHVlLiBUaGUgcmV0dXJuIHZhbHVlIG9mIFtmbl0gd2lsbCBiZSBzZXQgYXMgdGhlIG5ldyB2YWx1ZS4gVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciB0aGluZ3Mgc3VjaCBhcyB2YWxpZGF0aW5nIG9yIGNsZWFuaW5nIHRoZSB2YWx1ZSB3aGVuIGl0IGlzIHNldC4gV2FybmluZzogdGhpcyBtZXRob2QgV0lMTCBOT1Qgd29yayBpbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUgKElFIDggYW5kIGJlbG93KS4gVGhpcyBpcyB0aGUgb25seSBtZXRob2QgaW4gU3VnYXIgdGhhdCBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSB3aXRoIGFsbCBicm93c2Vycy4gJXdhdGNoJSBpcyBhdmFpbGFibGUgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIG9uIGV4dGVuZGVkIG9iamVjdHMuXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqICAgT2JqZWN0LndhdGNoKHsgZm9vOiAnYmFyJyB9LCAnZm9vJywgZnVuY3Rpb24ocHJvcCwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAqICAgICAvLyBXaWxsIGJlIHJ1biB3aGVuIHRoZSBwcm9wZXJ0eSAnZm9vJyBpcyBzZXQgb24gdGhlIG9iamVjdC5cbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIE9iamVjdC5leHRlbmRlZCgpLndhdGNoKHsgZm9vOiAnYmFyJyB9LCAnZm9vJywgZnVuY3Rpb24ocHJvcCwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAqICAgICAvLyBXaWxsIGJlIHJ1biB3aGVuIHRoZSBwcm9wZXJ0eSAnZm9vJyBpcyBzZXQgb24gdGhlIG9iamVjdC5cbiAgICAgICAqICAgfSk7XG4gICAgICAgKlxuICAgICAgICoqKi9cbiAgICAnd2F0Y2gnOiBmdW5jdGlvbihvYmosIHByb3AsIGZuKSB7XG4gICAgICBpZighZGVmaW5lUHJvcGVydHlTdXBwb3J0KSByZXR1cm47XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgICBvYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgICdlbnVtZXJhYmxlJyAgOiB0cnVlLFxuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2dldCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3NldCc6IGZ1bmN0aW9uKHRvKSB7XG4gICAgICAgICAgdmFsdWUgPSBmbi5jYWxsKG9iaiwgcHJvcCwgdmFsdWUsIHRvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBleHRlbmQob2JqZWN0LCBmYWxzZSwgZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMTsgfSwge1xuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2Qga2V5cyg8b2JqPiwgW2ZuXSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGtleXMgaW4gPG9iaj4uIE9wdGlvbmFsbHkgY2FsbHMgW2ZuXSBmb3IgZWFjaCBrZXkuXG4gICAgICogQGV4dHJhIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQgbmF0aXZlbHksIGFuZCBhZGRpdGlvbmFsbHkgaXMgZW5oYW5jZWQgdG8gYWNjZXB0IHRoZSBjYWxsYmFjayBbZm5dLiBSZXR1cm5lZCBrZXlzIGFyZSBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLiAla2V5cyUgaXMgYXZhaWxhYmxlIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBvbiBleHRlbmRlZCBvYmplY3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIE9iamVjdC5rZXlzKHsgYnJva2VuOiAnd2VhcicgfSkgLT4gWydicm9rZW4nXVxuICAgICAqICAgT2JqZWN0LmtleXMoeyBicm9rZW46ICd3ZWFyJyB9LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICogICAgIC8vIENhbGxlZCBvbmNlIGZvciBlYWNoIGtleS5cbiAgICAgKiAgIH0pO1xuICAgICAqICAgT2JqZWN0LmV4dGVuZGVkKHsgYnJva2VuOiAnd2VhcicgfSkua2V5cygpIC0+IFsnYnJva2VuJ11cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2tleXMnOiBmdW5jdGlvbihvYmosIGZuKSB7XG4gICAgICB2YXIga2V5cyA9IG9iamVjdC5rZXlzKG9iaik7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGZuLmNhbGwob2JqLCBrZXksIG9ialtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGV4dGVuZChvYmplY3QsIGZhbHNlLCB0cnVlLCB7XG5cbiAgICAnaXNPYmplY3QnOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KG9iaik7XG4gICAgfSxcblxuICAgICdpc05hTic6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gVGhpcyBpcyBvbmx5IHRydWUgb2YgTmFOXG4gICAgICByZXR1cm4gaXNOdW1iZXIob2JqKSAmJiBvYmoudmFsdWVPZigpICE9PSBvYmoudmFsdWVPZigpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBlcXVhbCg8YT4sIDxiPilcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICogQHNob3J0IFJldHVybnMgdHJ1ZSBpZiA8YT4gYW5kIDxiPiBhcmUgZXF1YWwuXG4gICAgICogQGV4dHJhICVlcXVhbCUgaW4gU3VnYXIgaXMgXCJlZ2FsXCIsIG1lYW5pbmcgdGhlIHZhbHVlcyBhcmUgZXF1YWwgaWYgdGhleSBhcmUgXCJub3Qgb2JzZXJ2YWJseSBkaXN0aW5ndWlzaGFibGVcIi4gTm90ZSB0aGF0IG9uIGV4dGVuZGVkIG9iamVjdHMgdGhlIG5hbWUgaXMgJWVxdWFscyUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIE9iamVjdC5lcXVhbCh7YToyfSwge2E6Mn0pIC0+IHRydWVcbiAgICAgKiAgIE9iamVjdC5lcXVhbCh7YToyfSwge2E6M30pIC0+IGZhbHNlXG4gICAgICogICBPYmplY3QuZXh0ZW5kZWQoe2E6Mn0pLmVxdWFscyh7YTozfSkgLT4gZmFsc2VcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2VxdWFsJzogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGlzRXF1YWwoYSwgYik7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIE9iamVjdC5leHRlbmRlZCg8b2JqPiA9IHt9KVxuICAgICAqIEByZXR1cm5zIEV4dGVuZGVkIG9iamVjdFxuICAgICAqIEBzaG9ydCBDcmVhdGVzIGEgbmV3IG9iamVjdCwgZXF1aXZhbGVudCB0byAlbmV3IE9iamVjdCgpJSBvciAle30lLCBidXQgd2l0aCBleHRlbmRlZCBtZXRob2RzLlxuICAgICAqIEBleHRyYSBTZWUgZXh0ZW5kZWQgb2JqZWN0cyBmb3IgbW9yZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBPYmplY3QuZXh0ZW5kZWQoKVxuICAgICAqICAgT2JqZWN0LmV4dGVuZGVkKHsgaGFwcHk6dHJ1ZSwgcGFwcHk6ZmFsc2UgfSkua2V5cygpIC0+IFsnaGFwcHknLCdwYXBweSddXG4gICAgICogICBPYmplY3QuZXh0ZW5kZWQoeyBoYXBweTp0cnVlLCBwYXBweTpmYWxzZSB9KS52YWx1ZXMoKSAtPiBbdHJ1ZSwgZmFsc2VdXG4gICAgICpcbiAgICAgKioqL1xuICAgICdleHRlbmRlZCc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG5ldyBIYXNoKG9iaik7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIG1lcmdlKDx0YXJnZXQ+LCA8c291cmNlPiwgW2RlZXBdID0gZmFsc2UsIFtyZXNvbHZlXSA9IHRydWUpXG4gICAgICogQHJldHVybnMgTWVyZ2VkIG9iamVjdFxuICAgICAqIEBzaG9ydCBNZXJnZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIDxzb3VyY2U+IGludG8gPHRhcmdldD4uXG4gICAgICogQGV4dHJhIE1lcmdlcyBhcmUgc2hhbGxvdyB1bmxlc3MgW2RlZXBdIGlzICV0cnVlJS4gUHJvcGVydGllcyBvZiA8c291cmNlPiB3aWxsIHdpbiBpbiB0aGUgY2FzZSBvZiBjb25mbGljdHMsIHVubGVzcyBbcmVzb2x2ZV0gaXMgJWZhbHNlJS4gW3Jlc29sdmVdIGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgY29uZmxpY3QuIEluIHRoaXMgY2FzZSBpdCB3aWxsIGJlIHBhc3NlZCAzIGFyZ3VtZW50cywgJWtleSUsICV0YXJnZXRWYWwlLCBhbmQgJXNvdXJjZVZhbCUsIHdpdGggdGhlIGNvbnRleHQgc2V0IHRvIDxzb3VyY2U+LiBUaGlzIHdpbGwgYWxsb3cgeW91IHRvIHNvbHZlIGNvbmZsaWN0IGFueSB3YXkgeW91IHdhbnQsIGllLiBhZGRpbmcgdHdvIG51bWJlcnMgdG9nZXRoZXIsIGV0Yy4gJW1lcmdlJSBpcyBhdmFpbGFibGUgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIG9uIGV4dGVuZGVkIG9iamVjdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgT2JqZWN0Lm1lcmdlKHthOjF9LHtiOjJ9KSAtPiB7IGE6MSwgYjoyIH1cbiAgICAgKiAgIE9iamVjdC5tZXJnZSh7YToxfSx7YToyfSwgZmFsc2UsIGZhbHNlKSAtPiB7IGE6MSB9XG4gICAgICsgICBPYmplY3QubWVyZ2Uoe2E6MX0se2E6Mn0sIGZhbHNlLCBmdW5jdGlvbihrZXksIGEsIGIpIHtcbiAgICAgKiAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAqICAgfSk7IC0+IHsgYTozIH1cbiAgICAgKiAgIE9iamVjdC5leHRlbmRlZCh7YToxfSkubWVyZ2Uoe2I6Mn0pIC0+IHsgYToxLCBiOjIgfVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnbWVyZ2UnOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSwgZGVlcCwgcmVzb2x2ZSkge1xuICAgICAgdmFyIGtleSwgc291cmNlSXNPYmplY3QsIHRhcmdldElzT2JqZWN0LCBzb3VyY2VWYWwsIHRhcmdldFZhbCwgY29uZmxpY3QsIHJlc3VsdDtcbiAgICAgIC8vIFN0cmluZ3MgY2Fubm90IGJlIHJlbGlhYmx5IG1lcmdlZCB0aGFua3MgdG9cbiAgICAgIC8vIHRoZWlyIHByb3BlcnRpZXMgbm90IGJlaW5nIGVudW1lcmFibGUgaW4gPCBJRTguXG4gICAgICBpZih0YXJnZXQgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZighaGFzT3duUHJvcGVydHkoc291cmNlLCBrZXkpIHx8ICF0YXJnZXQpIGNvbnRpbnVlO1xuICAgICAgICAgIHNvdXJjZVZhbCAgICAgID0gc291cmNlW2tleV07XG4gICAgICAgICAgdGFyZ2V0VmFsICAgICAgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICBjb25mbGljdCAgICAgICA9IGlzRGVmaW5lZCh0YXJnZXRWYWwpO1xuICAgICAgICAgIHNvdXJjZUlzT2JqZWN0ID0gaXNPYmplY3RUeXBlKHNvdXJjZVZhbCk7XG4gICAgICAgICAgdGFyZ2V0SXNPYmplY3QgPSBpc09iamVjdFR5cGUodGFyZ2V0VmFsKTtcbiAgICAgICAgICByZXN1bHQgICAgICAgICA9IGNvbmZsaWN0ICYmIHJlc29sdmUgPT09IGZhbHNlID8gdGFyZ2V0VmFsIDogc291cmNlVmFsO1xuXG4gICAgICAgICAgaWYoY29uZmxpY3QpIHtcbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24ocmVzb2x2ZSkpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrIGFzIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc29sdmUuY2FsbChzb3VyY2UsIGtleSwgdGFyZ2V0VmFsLCBzb3VyY2VWYWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR29pbmcgZGVlcFxuICAgICAgICAgIGlmKGRlZXAgJiYgKHNvdXJjZUlzT2JqZWN0IHx8IHRhcmdldElzT2JqZWN0KSkge1xuICAgICAgICAgICAgaWYoaXNEYXRlKHNvdXJjZVZhbCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGRhdGUoc291cmNlVmFsLmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoaXNSZWdFeHAoc291cmNlVmFsKSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgcmVnZXhwKHNvdXJjZVZhbC5zb3VyY2UsIGdldFJlZ0V4cEZsYWdzKHNvdXJjZVZhbCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYoIXRhcmdldElzT2JqZWN0KSB0YXJnZXRba2V5XSA9IGFycmF5LmlzQXJyYXkoc291cmNlVmFsKSA/IFtdIDoge307XG4gICAgICAgICAgICAgIG9iamVjdC5tZXJnZSh0YXJnZXRba2V5XSwgc291cmNlVmFsLCBkZWVwLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldFtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCB2YWx1ZXMoPG9iaj4sIFtmbl0pXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgaW4gPG9iaj4uIE9wdGlvbmFsbHkgY2FsbHMgW2ZuXSBmb3IgZWFjaCB2YWx1ZS5cbiAgICAgKiBAZXh0cmEgUmV0dXJuZWQgdmFsdWVzIGFyZSBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLiAldmFsdWVzJSBpcyBhdmFpbGFibGUgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIG9uIGV4dGVuZGVkIG9iamVjdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgT2JqZWN0LnZhbHVlcyh7IGJyb2tlbjogJ3dlYXInIH0pIC0+IFsnd2VhciddXG4gICAgICogICBPYmplY3QudmFsdWVzKHsgYnJva2VuOiAnd2VhcicgfSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgLy8gQ2FsbGVkIG9uY2UgZm9yIGVhY2ggdmFsdWUuXG4gICAgICogICB9KTtcbiAgICAgKiAgIE9iamVjdC5leHRlbmRlZCh7IGJyb2tlbjogJ3dlYXInIH0pLnZhbHVlcygpIC0+IFsnd2VhciddXG4gICAgICpcbiAgICAgKioqL1xuICAgICd2YWx1ZXMnOiBmdW5jdGlvbihvYmosIGZuKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICBpdGVyYXRlT3Zlck9iamVjdChvYmosIGZ1bmN0aW9uKGssdikge1xuICAgICAgICB2YWx1ZXMucHVzaCh2KTtcbiAgICAgICAgaWYoZm4pIGZuLmNhbGwob2JqLHYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBjbG9uZSg8b2JqPiA9IHt9LCBbZGVlcF0gPSBmYWxzZSlcbiAgICAgKiBAcmV0dXJucyBDbG9uZWQgb2JqZWN0XG4gICAgICogQHNob3J0IENyZWF0ZXMgYSBjbG9uZSAoY29weSkgb2YgPG9iaj4uXG4gICAgICogQGV4dHJhIERlZmF1bHQgaXMgYSBzaGFsbG93IGNsb25lLCB1bmxlc3MgW2RlZXBdIGlzIHRydWUuICVjbG9uZSUgaXMgYXZhaWxhYmxlIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBvbiBleHRlbmRlZCBvYmplY3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIE9iamVjdC5jbG9uZSh7Zm9vOidiYXInfSkgICAgICAgICAgICAtPiB7IGZvbzogJ2JhcicgfVxuICAgICAqICAgT2JqZWN0LmNsb25lKCkgICAgICAgICAgICAgICAgICAgICAgIC0+IHt9XG4gICAgICogICBPYmplY3QuZXh0ZW5kZWQoe2ZvbzonYmFyJ30pLmNsb25lKCkgLT4geyBmb286ICdiYXInIH1cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2Nsb25lJzogZnVuY3Rpb24ob2JqLCBkZWVwKSB7XG4gICAgICB2YXIgdGFyZ2V0LCBrbGFzcztcbiAgICAgIGlmKCFpc09iamVjdFR5cGUob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgICAga2xhc3MgPSBjbGFzc05hbWUob2JqKTtcbiAgICAgIGlmKGlzRGF0ZShvYmosIGtsYXNzKSAmJiBvYmouY2xvbmUpIHtcbiAgICAgICAgLy8gUHJlc2VydmUgaW50ZXJuYWwgVVRDIGZsYWcgd2hlbiBhcHBsaWNhYmxlLlxuICAgICAgICByZXR1cm4gb2JqLmNsb25lKCk7XG4gICAgICB9IGVsc2UgaWYoaXNEYXRlKG9iaiwga2xhc3MpIHx8IGlzUmVnRXhwKG9iaiwga2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBuZXcgb2JqLmNvbnN0cnVjdG9yKG9iaik7XG4gICAgICB9IGVsc2UgaWYob2JqIGluc3RhbmNlb2YgSGFzaCkge1xuICAgICAgICB0YXJnZXQgPSBuZXcgSGFzaDtcbiAgICAgIH0gZWxzZSBpZihpc0FycmF5KG9iaiwga2xhc3MpKSB7XG4gICAgICAgIHRhcmdldCA9IFtdO1xuICAgICAgfSBlbHNlIGlmKGlzUGxhaW5PYmplY3Qob2JqLCBrbGFzcykpIHtcbiAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDbG9uZSBtdXN0IGJlIGEgYmFzaWMgZGF0YSB0eXBlLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdC5tZXJnZSh0YXJnZXQsIG9iaiwgZGVlcCk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIE9iamVjdC5mcm9tUXVlcnlTdHJpbmcoPHN0cj4sIFtib29sZWFuc10gPSBmYWxzZSlcbiAgICAgKiBAcmV0dXJucyBPYmplY3RcbiAgICAgKiBAc2hvcnQgQ29udmVydHMgdGhlIHF1ZXJ5IHN0cmluZyBvZiBhIFVSTCBpbnRvIGFuIG9iamVjdC5cbiAgICAgKiBAZXh0cmEgSWYgW2Jvb2xlYW5zXSBpcyB0cnVlLCB0aGVuICVcInRydWVcIiUgYW5kICVcImZhbHNlXCIlIHdpbGwgYmUgY2FzdCBpbnRvIGJvb2xlYW5zLiBBbGwgb3RoZXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVtYmVycyB3aWxsIHJlbWFpbiB0aGVpciBzdHJpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIE9iamVjdC5mcm9tUXVlcnlTdHJpbmcoJ2Zvbz1iYXImYnJva2VuPXdlYXInKSAtPiB7IGZvbzogJ2JhcicsIGJyb2tlbjogJ3dlYXInIH1cbiAgICAgKiAgIE9iamVjdC5mcm9tUXVlcnlTdHJpbmcoJ2Zvb1tdPTEmZm9vW109MicpICAgICAtPiB7IGZvbzogWycxJywnMiddIH1cbiAgICAgKiAgIE9iamVjdC5mcm9tUXVlcnlTdHJpbmcoJ2Zvbz10cnVlJywgdHJ1ZSkgICAgICAtPiB7IGZvbzogdHJ1ZSB9XG4gICAgICpcbiAgICAgKioqL1xuICAgICdmcm9tUXVlcnlTdHJpbmcnOiBmdW5jdGlvbihzdHIsIGNhc3RCb29sZWFuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0LmV4dGVuZGVkKCksIHNwbGl0O1xuICAgICAgc3RyID0gc3RyICYmIHN0ci50b1N0cmluZyA/IHN0ci50b1N0cmluZygpIDogJyc7XG4gICAgICBzdHIucmVwbGFjZSgvXi4qP1xcPy8sICcnKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgc3BsaXQgPSBwLnNwbGl0KCc9Jyk7XG4gICAgICAgIGlmKHNwbGl0Lmxlbmd0aCAhPT0gMikgcmV0dXJuO1xuICAgICAgICBzZXRQYXJhbXNPYmplY3QocmVzdWx0LCBzcGxpdFswXSwgZGVjb2RlVVJJQ29tcG9uZW50KHNwbGl0WzFdKSwgY2FzdEJvb2xlYW4pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBPYmplY3QudG9RdWVyeVN0cmluZyg8b2JqPiwgW25hbWVzcGFjZV0gPSBudWxsKVxuICAgICAqIEByZXR1cm5zIE9iamVjdFxuICAgICAqIEBzaG9ydCBDb252ZXJ0cyB0aGUgb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcuXG4gICAgICogQGV4dHJhIEFjY2VwdHMgZGVlcCBuZXN0ZWQgb2JqZWN0cyBhbmQgYXJyYXlzLiBJZiBbbmFtZXNwYWNlXSBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgcHJlZml4ZWQgdG8gYWxsIHBhcmFtIG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgIE9iamVjdC50b1F1ZXJ5U3RyaW5nKHtmb286J2Jhcid9KSAgICAgICAgICAtPiAnZm9vPWJhcidcbiAgICAgKiAgIE9iamVjdC50b1F1ZXJ5U3RyaW5nKHtmb286WydhJywnYicsJ2MnXX0pICAtPiAnZm9vWzBdPWEmZm9vWzFdPWImZm9vWzJdPWMnXG4gICAgICogICBPYmplY3QudG9RdWVyeVN0cmluZyh7bmFtZTonQm9iJ30sICd1c2VyJykgLT4gJ3VzZXJbbmFtZV09Qm9iJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAndG9RdWVyeVN0cmluZyc6IGZ1bmN0aW9uKG9iaiwgbmFtZXNwYWNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0VG9RdWVyeVN0cmluZyhuYW1lc3BhY2UsIG9iaik7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHRhcCg8b2JqPiwgPGZuPilcbiAgICAgKiBAcmV0dXJucyBPYmplY3RcbiAgICAgKiBAc2hvcnQgUnVucyA8Zm4+IGFuZCByZXR1cm5zIDxvYmo+LlxuICAgICAqIEBleHRyYSAgQSBzdHJpbmcgY2FuIGFsc28gYmUgdXNlZCBhcyBhIHNob3J0Y3V0IHRvIGEgbWV0aG9kLiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHJ1biBhbiBpbnRlcm1lZGlhcnkgZnVuY3Rpb24gaW4gdGhlIG1pZGRsZSBvZiBtZXRob2QgY2hhaW5pbmcuIEFzIGEgc3RhbmRhbG9uZSBtZXRob2Qgb24gdGhlIE9iamVjdCBjbGFzcyBpdCBkb2Vzbid0IGhhdmUgdG9vIG11Y2ggdXNlLiBUaGUgcG93ZXIgb2YgJXRhcCUgY29tZXMgd2hlbiB1c2luZyBleHRlbmRlZCBvYmplY3RzIG9yIG1vZGlmeWluZyB0aGUgT2JqZWN0IHByb3RvdHlwZSB3aXRoIE9iamVjdC5leHRlbmQoKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBPYmplY3QuZXh0ZW5kKCk7XG4gICAgICogICBbMiw0LDZdLm1hcChNYXRoLmV4cCkudGFwKGZ1bmN0aW9uKGFycikge1xuICAgICAqICAgICBhcnIucG9wKClcbiAgICAgKiAgIH0pO1xuICAgICAqICAgWzIsNCw2XS5tYXAoTWF0aC5leHApLnRhcCgncG9wJykubWFwKE1hdGgucm91bmQpOyAtPiAgWzcsNTVdXG4gICAgICpcbiAgICAgKioqL1xuICAgICd0YXAnOiBmdW5jdGlvbihvYmosIGFyZykge1xuICAgICAgdmFyIGZuID0gYXJnO1xuICAgICAgaWYoIWlzRnVuY3Rpb24oYXJnKSkge1xuICAgICAgICBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGFyZykgb2JqW2FyZ10oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm4uY2FsbChvYmosIG9iaik7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBoYXMoPG9iaj4sIDxrZXk+KVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgQ2hlY2tzIGlmIDxvYmo+IGhhcyA8a2V5PiB1c2luZyBoYXNPd25Qcm9wZXJ0eSBmcm9tIE9iamVjdC5wcm90b3R5cGUuXG4gICAgICogQGV4dHJhIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyZWQgc2FmZXIgdGhhbiAlT2JqZWN0I2hhc093blByb3BlcnR5JSB3aGVuIHVzaW5nIG9iamVjdHMgYXMgaGFzaGVzLiBTZWUgaHR0cDovL3d3dy5kZXZ0aG91Z2h0LmNvbS8yMDEyLzAxLzE4L2FuLW9iamVjdC1pcy1ub3QtYS1oYXNoLyBmb3IgbW9yZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBPYmplY3QuaGFzKHsgZm9vOiAnYmFyJyB9LCAnZm9vJykgLT4gdHJ1ZVxuICAgICAqICAgT2JqZWN0Lmhhcyh7IGZvbzogJ2JhcicgfSwgJ2JheicpIC0+IGZhbHNlXG4gICAgICogICBPYmplY3QuaGFzKHsgaGFzT3duUHJvcGVydHk6IHRydWUgfSwgJ2ZvbycpIC0+IGZhbHNlXG4gICAgICpcbiAgICAgKioqL1xuICAgICdoYXMnOiBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHNlbGVjdCg8b2JqPiwgPGZpbmQ+LCAuLi4pXG4gICAgICogQHJldHVybnMgT2JqZWN0XG4gICAgICogQHNob3J0IEJ1aWxkcyBhIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWVzIHNwZWNpZmllZCBpbiA8ZmluZD4uXG4gICAgICogQGV4dHJhIFdoZW4gPGZpbmQ+IGlzIGEgc3RyaW5nLCB0aGF0IHNpbmdsZSBrZXkgd2lsbCBiZSBzZWxlY3RlZC4gSXQgY2FuIGFsc28gYmUgYSByZWdleCwgc2VsZWN0aW5nIGFueSBrZXkgdGhhdCBtYXRjaGVzLCBvciBhbiBvYmplY3Qgd2hpY2ggd2lsbCBtYXRjaCBpZiB0aGUga2V5IGFsc28gZXhpc3RzIGluIHRoYXQgb2JqZWN0LCBlZmZlY3RpdmVseSBkb2luZyBhbiBcImludGVyc2VjdFwiIG9wZXJhdGlvbiBvbiB0aGF0IG9iamVjdC4gTXVsdGlwbGUgc2VsZWN0aW9ucyBtYXkgYWxzbyBiZSBwYXNzZWQgYXMgYW4gYXJyYXkgb3IgZGlyZWN0bHkgYXMgZW51bWVyYXRlZCBhcmd1bWVudHMuICVzZWxlY3QlIGlzIGF2YWlsYWJsZSBhcyBhbiBpbnN0YW5jZSBtZXRob2Qgb24gZXh0ZW5kZWQgb2JqZWN0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICBPYmplY3Quc2VsZWN0KHthOjEsYjoyfSwgJ2EnKSAgICAgICAgLT4ge2E6MX1cbiAgICAgKiAgIE9iamVjdC5zZWxlY3Qoe2E6MSxiOjJ9LCAvW2Etel0vKSAgICAtPiB7YToxLGJhOjJ9XG4gICAgICogICBPYmplY3Quc2VsZWN0KHthOjEsYjoyfSwge2E6MX0pICAgICAgLT4ge2E6MX1cbiAgICAgKiAgIE9iamVjdC5zZWxlY3Qoe2E6MSxiOjJ9LCAnYScsICdiJykgICAtPiB7YToxLGI6Mn1cbiAgICAgKiAgIE9iamVjdC5zZWxlY3Qoe2E6MSxiOjJ9LCBbJ2EnLCAnYiddKSAtPiB7YToxLGI6Mn1cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3NlbGVjdCc6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBzZWxlY3RGcm9tT2JqZWN0KG9iaiwgYXJndW1lbnRzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmVqZWN0KDxvYmo+LCA8ZmluZD4sIC4uLilcbiAgICAgKiBAcmV0dXJucyBPYmplY3RcbiAgICAgKiBAc2hvcnQgQnVpbGRzIGEgbmV3IG9iamVjdCBjb250YWluaW5nIGFsbCB2YWx1ZXMgZXhjZXB0IHRob3NlIHNwZWNpZmllZCBpbiA8ZmluZD4uXG4gICAgICogQGV4dHJhIFdoZW4gPGZpbmQ+IGlzIGEgc3RyaW5nLCB0aGF0IHNpbmdsZSBrZXkgd2lsbCBiZSByZWplY3RlZC4gSXQgY2FuIGFsc28gYmUgYSByZWdleCwgcmVqZWN0aW5nIGFueSBrZXkgdGhhdCBtYXRjaGVzLCBvciBhbiBvYmplY3Qgd2hpY2ggd2lsbCBtYXRjaCBpZiB0aGUga2V5IGFsc28gZXhpc3RzIGluIHRoYXQgb2JqZWN0LCBlZmZlY3RpdmVseSBcInN1YnRyYWN0aW5nXCIgdGhhdCBvYmplY3QuIE11bHRpcGxlIHNlbGVjdGlvbnMgbWF5IGFsc28gYmUgcGFzc2VkIGFzIGFuIGFycmF5IG9yIGRpcmVjdGx5IGFzIGVudW1lcmF0ZWQgYXJndW1lbnRzLiAlcmVqZWN0JSBpcyBhdmFpbGFibGUgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIG9uIGV4dGVuZGVkIG9iamVjdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgT2JqZWN0LnJlamVjdCh7YToxLGI6Mn0sICdhJykgICAgICAgIC0+IHtiOjJ9XG4gICAgICogICBPYmplY3QucmVqZWN0KHthOjEsYjoyfSwgL1thLXpdLykgICAgLT4ge31cbiAgICAgKiAgIE9iamVjdC5yZWplY3Qoe2E6MSxiOjJ9LCB7YToxfSkgICAgICAtPiB7YjoyfVxuICAgICAqICAgT2JqZWN0LnJlamVjdCh7YToxLGI6Mn0sICdhJywgJ2InKSAgIC0+IHt9XG4gICAgICogICBPYmplY3QucmVqZWN0KHthOjEsYjoyfSwgWydhJywgJ2InXSkgLT4ge31cbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3JlamVjdCc6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBzZWxlY3RGcm9tT2JqZWN0KG9iaiwgYXJndW1lbnRzLCBmYWxzZSk7XG4gICAgfVxuXG4gIH0pO1xuXG5cbiAgYnVpbGRUeXBlTWV0aG9kcygpO1xuICBidWlsZE9iamVjdEV4dGVuZCgpO1xuICBidWlsZE9iamVjdEluc3RhbmNlTWV0aG9kcyhPYmplY3RIYXNoTWV0aG9kcywgSGFzaCk7XG5cbiAgLyoqKlxuICAgKiBAcGFja2FnZSBSZWdFeHBcbiAgICogQGRlcGVuZGVuY3kgY29yZVxuICAgKiBAZGVzY3JpcHRpb24gRXNjYXBpbmcgcmVnZXhlcyBhbmQgbWFuaXB1bGF0aW5nIHRoZWlyIGZsYWdzLlxuICAgKlxuICAgKiBOb3RlIGhlcmUgdGhhdCBtZXRob2RzIG9uIHRoZSBSZWdFeHAgY2xhc3MgbGlrZSAuZXhlYyBhbmQgLnRlc3Qgd2lsbCBmYWlsIGluIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgU3BpZGVyTW9ua2V5IGJlaW5nXG4gICAqIHVzZWQgYnkgQ291Y2hEQiB3aGVuIHVzaW5nIHNob3J0aGFuZCByZWdleCBub3RhdGlvbiBsaWtlIC9mb28vLiBUaGlzIGlzIHRoZSByZWFzb24gZm9yIHRoZSBpbnRlcm1peGVkIHVzZSBvZiBzaG9ydGhhbmRcbiAgICogYW5kIGNvbXBpbGVkIHJlZ2V4ZXMgaGVyZS4gSWYgeW91J3JlIHVzaW5nIEpTIGluIENvdWNoREIsIGl0IGlzIHNhZmVyIHRvIEFMV0FZUyBjb21waWxlIHlvdXIgcmVnZXhlcyBmcm9tIGEgc3RyaW5nLlxuICAgKlxuICAgKioqL1xuXG4gIGV4dGVuZChyZWdleHAsIGZhbHNlLCB0cnVlLCB7XG5cbiAgIC8qKipcbiAgICAqIEBtZXRob2QgUmVnRXhwLmVzY2FwZSg8c3RyPiA9ICcnKVxuICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgKiBAc2hvcnQgRXNjYXBlcyBhbGwgUmVnRXhwIHRva2VucyBpbiBhIHN0cmluZy5cbiAgICAqIEBleGFtcGxlXG4gICAgKlxuICAgICogICBSZWdFeHAuZXNjYXBlKCdyZWFsbHk/JykgICAgICAtPiAncmVhbGx5XFw/J1xuICAgICogICBSZWdFeHAuZXNjYXBlKCd5ZXMuJykgICAgICAgICAtPiAneWVzXFwuJ1xuICAgICogICBSZWdFeHAuZXNjYXBlKCcobm90IHJlYWxseSknKSAtPiAnXFwobm90IHJlYWxseVxcKSdcbiAgICAqXG4gICAgKioqL1xuICAgICdlc2NhcGUnOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBlc2NhcGVSZWdFeHAoc3RyKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZXh0ZW5kKHJlZ2V4cCwgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAvKioqXG4gICAgKiBAbWV0aG9kIGdldEZsYWdzKClcbiAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICogQHNob3J0IFJldHVybnMgdGhlIGZsYWdzIG9mIHRoZSByZWdleCBhcyBhIHN0cmluZy5cbiAgICAqIEBleGFtcGxlXG4gICAgKlxuICAgICogICAvdGV4dHkvZ2ltLmdldEZsYWdzKCd0ZXN0eScpIC0+ICdnaW0nXG4gICAgKlxuICAgICoqKi9cbiAgICAnZ2V0RmxhZ3MnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRSZWdFeHBGbGFncyh0aGlzKTtcbiAgICB9LFxuXG4gICAvKioqXG4gICAgKiBAbWV0aG9kIHNldEZsYWdzKDxmbGFncz4pXG4gICAgKiBAcmV0dXJucyBSZWdFeHBcbiAgICAqIEBzaG9ydCBTZXRzIHRoZSBmbGFncyBvbiBhIHJlZ2V4IGFuZCByZXR1bnMgYSBjb3B5LlxuICAgICogQGV4YW1wbGVcbiAgICAqXG4gICAgKiAgIC90ZXh0eS8uc2V0RmxhZ3MoJ2dpbScpIC0+IG5vdyBoYXMgZ2xvYmFsLCBpZ25vcmVDYXNlLCBhbmQgbXVsdGlsaW5lIHNldFxuICAgICpcbiAgICAqKiovXG4gICAgJ3NldEZsYWdzJzogZnVuY3Rpb24oZmxhZ3MpIHtcbiAgICAgIHJldHVybiByZWdleHAodGhpcy5zb3VyY2UsIGZsYWdzKTtcbiAgICB9LFxuXG4gICAvKioqXG4gICAgKiBAbWV0aG9kIGFkZEZsYWcoPGZsYWc+KVxuICAgICogQHJldHVybnMgUmVnRXhwXG4gICAgKiBAc2hvcnQgQWRkcyA8ZmxhZz4gdG8gdGhlIHJlZ2V4LlxuICAgICogQGV4YW1wbGVcbiAgICAqXG4gICAgKiAgIC90ZXh0eS8uYWRkRmxhZygnZycpIC0+IG5vdyBoYXMgZ2xvYmFsIGZsYWcgc2V0XG4gICAgKlxuICAgICoqKi9cbiAgICAnYWRkRmxhZyc6IGZ1bmN0aW9uKGZsYWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldEZsYWdzKGdldFJlZ0V4cEZsYWdzKHRoaXMsIGZsYWcpKTtcbiAgICB9LFxuXG4gICAvKioqXG4gICAgKiBAbWV0aG9kIHJlbW92ZUZsYWcoPGZsYWc+KVxuICAgICogQHJldHVybnMgUmVnRXhwXG4gICAgKiBAc2hvcnQgUmVtb3ZlcyA8ZmxhZz4gZnJvbSB0aGUgcmVnZXguXG4gICAgKiBAZXhhbXBsZVxuICAgICpcbiAgICAqICAgL3RleHR5L2cucmVtb3ZlRmxhZygnZycpIC0+IG5vdyBoYXMgZ2xvYmFsIGZsYWcgcmVtb3ZlZFxuICAgICpcbiAgICAqKiovXG4gICAgJ3JlbW92ZUZsYWcnOiBmdW5jdGlvbihmbGFnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRGbGFncyhnZXRSZWdFeHBGbGFncyh0aGlzKS5yZXBsYWNlKGZsYWcsICcnKSk7XG4gICAgfVxuXG4gIH0pO1xuXG5cblxuICAvKioqXG4gICAqIEBwYWNrYWdlIFN0cmluZ1xuICAgKiBAZGVwZW5kZW5jeSBjb3JlXG4gICAqIEBkZXNjcmlwdGlvbiBTdHJpbmcgbWFudXB1bGF0aW9uLCBlc2NhcGluZywgZW5jb2RpbmcsIHRydW5jYXRpb24sIGFuZDpjb252ZXJzaW9uLlxuICAgKlxuICAgKioqL1xuXG4gIGZ1bmN0aW9uIGdldEFjcm9ueW0od29yZCkge1xuICAgIHZhciBpbmZsZWN0b3IgPSBzdHJpbmcuSW5mbGVjdG9yO1xuICAgIHZhciB3b3JkID0gaW5mbGVjdG9yICYmIGluZmxlY3Rvci5hY3Jvbnltc1t3b3JkXTtcbiAgICBpZihpc1N0cmluZyh3b3JkKSkge1xuICAgICAgcmV0dXJuIHdvcmQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSZXBlYXRSYW5nZShudW0pIHtcbiAgICBudW0gPSArbnVtO1xuICAgIGlmKG51bSA8IDAgfHwgbnVtID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH1cblxuICBmdW5jdGlvbiBwYWRTdHJpbmcobnVtLCBwYWRkaW5nKSB7XG4gICAgcmV0dXJuIHJlcGVhdFN0cmluZyhpc0RlZmluZWQocGFkZGluZykgPyBwYWRkaW5nIDogJyAnLCBudW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ1bmNhdGVTdHJpbmcoc3RyLCBsZW5ndGgsIGZyb20sIGVsbGlwc2lzLCBzcGxpdCkge1xuICAgIHZhciBzdHIxLCBzdHIyLCBsZW4xLCBsZW4yO1xuICAgIGlmKHN0ci5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc3RyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsbGlwc2lzID0gaXNVbmRlZmluZWQoZWxsaXBzaXMpID8gJy4uLicgOiBlbGxpcHNpcztcbiAgICBzd2l0Y2goZnJvbSkge1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHN0cjIgPSBzcGxpdCA/IHRydW5jYXRlT25Xb3JkKHN0ciwgbGVuZ3RoLCB0cnVlKSA6IHN0ci5zbGljZShzdHIubGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGVsbGlwc2lzICsgc3RyMjtcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIGxlbjEgPSBjZWlsKGxlbmd0aCAvIDIpO1xuICAgICAgICBsZW4yID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICAgIHN0cjEgPSBzcGxpdCA/IHRydW5jYXRlT25Xb3JkKHN0ciwgbGVuMSkgOiBzdHIuc2xpY2UoMCwgbGVuMSk7XG4gICAgICAgIHN0cjIgPSBzcGxpdCA/IHRydW5jYXRlT25Xb3JkKHN0ciwgbGVuMiwgdHJ1ZSkgOiBzdHIuc2xpY2Uoc3RyLmxlbmd0aCAtIGxlbjIpO1xuICAgICAgICByZXR1cm4gc3RyMSArIGVsbGlwc2lzICsgc3RyMjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0cjEgPSBzcGxpdCA/IHRydW5jYXRlT25Xb3JkKHN0ciwgbGVuZ3RoKSA6IHN0ci5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gc3RyMSArIGVsbGlwc2lzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHN0ciwgbGltaXQsIGZyb21MZWZ0KSB7XG4gICAgaWYoZnJvbUxlZnQpIHtcbiAgICAgIHJldHVybiB0cnVuY2F0ZU9uV29yZChzdHIucmV2ZXJzZSgpLCBsaW1pdCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB2YXIgcmVnID0gcmVnZXhwKCcoPz1bJyArIGdldFRyaW1tYWJsZUNoYXJhY3RlcnMoKSArICddKScpO1xuICAgIHZhciB3b3JkcyA9IHN0ci5zcGxpdChyZWcpO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgcmV0dXJuIHdvcmRzLmZpbHRlcihmdW5jdGlvbih3b3JkKSB7XG4gICAgICBjb3VudCArPSB3b3JkLmxlbmd0aDtcbiAgICAgIHJldHVybiBjb3VudCA8PSBsaW1pdDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG51bWJlck9ySW5kZXgoc3RyLCBuLCBmcm9tKSB7XG4gICAgaWYoaXNTdHJpbmcobikpIHtcbiAgICAgIG4gPSBzdHIuaW5kZXhPZihuKTtcbiAgICAgIGlmKG4gPT09IC0xKSB7XG4gICAgICAgIG4gPSBmcm9tID8gc3RyLmxlbmd0aCA6IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgdmFyIGJ0b2EsIGF0b2I7XG5cbiAgZnVuY3Rpb24gYnVpbGRCYXNlNjQoa2V5KSB7XG4gICAgaWYoZ2xvYmFsQ29udGV4dC5idG9hKSB7XG4gICAgICBidG9hID0gZ2xvYmFsQ29udGV4dC5idG9hO1xuICAgICAgYXRvYiA9IGdsb2JhbENvbnRleHQuYXRvYjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJhc2U2NHJlZyA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZztcbiAgICBidG9hID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBjaHIxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgY2hyMiA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGNocjMgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBlbmMxID0gY2hyMSA+PiAyO1xuICAgICAgICBlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KTtcbiAgICAgICAgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xuICAgICAgICBlbmM0ID0gY2hyMyAmIDYzO1xuICAgICAgICBpZiAoaXNOYU4oY2hyMikpIHtcbiAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGNocjMpKSB7XG4gICAgICAgICAgZW5jNCA9IDY0O1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCA9IG91dHB1dCArIGtleS5jaGFyQXQoZW5jMSkgKyBrZXkuY2hhckF0KGVuYzIpICsga2V5LmNoYXJBdChlbmMzKSArIGtleS5jaGFyQXQoZW5jNCk7XG4gICAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnO1xuICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJyc7XG4gICAgICB9IHdoaWxlIChpIDwgc3RyLmxlbmd0aCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhdG9iID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBpZihpbnB1dC5tYXRjaChiYXNlNjRyZWcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIGNvbnRhaW5zIGludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMnKTtcbiAgICAgIH1cbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcbiAgICAgIGRvIHtcbiAgICAgICAgZW5jMSA9IGtleS5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMiA9IGtleS5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IGtleS5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IGtleS5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgY2hyKGNocjEpO1xuICAgICAgICBpZiAoZW5jMyAhPSA2NCkge1xuICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIGNocihjaHIyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPSA2NCkge1xuICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIGNocihjaHIzKTtcbiAgICAgICAgfVxuICAgICAgICBjaHIxID0gY2hyMiA9IGNocjMgPSAnJztcbiAgICAgICAgZW5jMSA9IGVuYzIgPSBlbmMzID0gZW5jNCA9ICcnO1xuICAgICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfVxuXG4gIGV4dGVuZChzdHJpbmcsIHRydWUsIGZhbHNlLCB7XG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmVwZWF0KFtudW1dID0gMClcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgc3RyaW5nIHJlcGVhdGVkIFtudW1dIHRpbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdqdW1weScucmVwZWF0KDIpIC0+ICdqdW1weWp1bXB5J1xuICAgICAqICAgJ2EnLnJlcGVhdCg1KSAgICAgLT4gJ2FhYWFhJ1xuICAgICAqICAgJ2EnLnJlcGVhdCgwKSAgICAgLT4gJydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3JlcGVhdCc6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgbnVtID0gY2hlY2tSZXBlYXRSYW5nZShudW0pO1xuICAgICAgcmV0dXJuIHJlcGVhdFN0cmluZyh0aGlzLCBudW0pO1xuICAgIH1cblxuICB9KTtcblxuICBleHRlbmQoc3RyaW5nLCB0cnVlLCBmdW5jdGlvbihyZWcpIHsgcmV0dXJuIGlzUmVnRXhwKHJlZykgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDI7IH0sIHtcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHN0YXJ0c1dpdGgoPGZpbmQ+LCBbcG9zXSA9IDAsIFtjYXNlXSA9IHRydWUpXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBzdGFydHMgd2l0aCA8ZmluZD4uXG4gICAgICogQGV4dHJhIDxmaW5kPiBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIHJlZ2V4LiBTZWFyY2ggYmVnaW5zIGF0IFtwb3NdLCB3aGljaCBkZWZhdWx0cyB0byB0aGUgZW50aXJlIHN0cmluZy4gQ2FzZSBzZW5zaXRpdmUgaWYgW2Nhc2VdIGlzIHRydWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ2hlbGxvJy5zdGFydHNXaXRoKCdoZWxsJykgICAgICAgICAgIC0+IHRydWVcbiAgICAgKiAgICdoZWxsbycuc3RhcnRzV2l0aCgvW2EtaF0vKSAgICAgICAgICAtPiB0cnVlXG4gICAgICogICAnaGVsbG8nLnN0YXJ0c1dpdGgoJ0hFTEwnKSAgICAgICAgICAgLT4gZmFsc2VcbiAgICAgKiAgICdoZWxsbycuc3RhcnRzV2l0aCgnZWxsJywgMSkgICAgICAgICAtPiB0cnVlXG4gICAgICogICAnaGVsbG8nLnN0YXJ0c1dpdGgoJ0hFTEwnLCAwLCBmYWxzZSkgLT4gdHJ1ZVxuICAgICAqXG4gICAgICoqKi9cbiAgICAnc3RhcnRzV2l0aCc6IGZ1bmN0aW9uKHJlZykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIHBvcyA9IGFyZ3NbMV0sIGMgPSBhcmdzWzJdLCBzdHIgPSB0aGlzLCBzb3VyY2U7XG4gICAgICBpZihwb3MpIHN0ciA9IHN0ci5zbGljZShwb3MpO1xuICAgICAgaWYoaXNVbmRlZmluZWQoYykpIGMgPSB0cnVlO1xuICAgICAgc291cmNlID0gaXNSZWdFeHAocmVnKSA/IHJlZy5zb3VyY2UucmVwbGFjZSgnXicsICcnKSA6IGVzY2FwZVJlZ0V4cChyZWcpO1xuICAgICAgcmV0dXJuIHJlZ2V4cCgnXicgKyBzb3VyY2UsIGMgPyAnJyA6ICdpJykudGVzdChzdHIpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBlbmRzV2l0aCg8ZmluZD4sIFtwb3NdID0gbGVuZ3RoLCBbY2FzZV0gPSB0cnVlKVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIDxmaW5kPi5cbiAgICAgKiBAZXh0cmEgPGZpbmQ+IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgcmVnZXguIFNlYXJjaCBlbmRzIGF0IFtwb3NdLCB3aGljaCBkZWZhdWx0cyB0byB0aGUgZW50aXJlIHN0cmluZy4gQ2FzZSBzZW5zaXRpdmUgaWYgW2Nhc2VdIGlzIHRydWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ2p1bXB5Jy5lbmRzV2l0aCgncHknKSAgICAgICAgICAgIC0+IHRydWVcbiAgICAgKiAgICdqdW1weScuZW5kc1dpdGgoL1txLXpdLykgICAgICAgICAtPiB0cnVlXG4gICAgICogICAnanVtcHknLmVuZHNXaXRoKCdNUFknKSAgICAgICAgICAgLT4gZmFsc2VcbiAgICAgKiAgICdqdW1weScuZW5kc1dpdGgoJ21wJywgNCkgICAgICAgICAtPiBmYWxzZVxuICAgICAqICAgJ2p1bXB5Jy5lbmRzV2l0aCgnTVBZJywgNSwgZmFsc2UpIC0+IHRydWVcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2VuZHNXaXRoJzogZnVuY3Rpb24ocmVnKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cywgcG9zID0gYXJnc1sxXSwgYyA9IGFyZ3NbMl0sIHN0ciA9IHRoaXMsIHNvdXJjZTtcbiAgICAgIGlmKGlzRGVmaW5lZChwb3MpKSBzdHIgPSBzdHIuc2xpY2UoMCwgcG9zKTtcbiAgICAgIGlmKGlzVW5kZWZpbmVkKGMpKSBjID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSA9IGlzUmVnRXhwKHJlZykgPyByZWcuc291cmNlLnJlcGxhY2UoJyQnLCAnJykgOiBlc2NhcGVSZWdFeHAocmVnKTtcbiAgICAgIHJldHVybiByZWdleHAoc291cmNlICsgJyQnLCBjID8gJycgOiAnaScpLnRlc3Qoc3RyKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZXh0ZW5kKHN0cmluZywgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAgIC8qKipcbiAgICAgICogQG1ldGhvZCBlc2NhcGVSZWdFeHAoKVxuICAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgICogQHNob3J0IEVzY2FwZXMgYWxsIFJlZ0V4cCB0b2tlbnMgaW4gdGhlIHN0cmluZy5cbiAgICAgICogQGV4YW1wbGVcbiAgICAgICpcbiAgICAgICogICAncmVhbGx5PycuZXNjYXBlUmVnRXhwKCkgICAgICAgLT4gJ3JlYWxseVxcPydcbiAgICAgICogICAneWVzLicuZXNjYXBlUmVnRXhwKCkgICAgICAgICAtPiAneWVzXFwuJ1xuICAgICAgKiAgICcobm90IHJlYWxseSknLmVzY2FwZVJlZ0V4cCgpIC0+ICdcXChub3QgcmVhbGx5XFwpJ1xuICAgICAgKlxuICAgICAgKioqL1xuICAgICdlc2NhcGVSZWdFeHAnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlc2NhcGVSZWdFeHAodGhpcyk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICAqIEBtZXRob2QgZXNjYXBlVVJMKFtwYXJhbV0gPSBmYWxzZSlcbiAgICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICAqIEBzaG9ydCBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcgdG8gbWFrZSBhIHZhbGlkIFVSTC5cbiAgICAgICogQGV4dHJhIElmIFtwYXJhbV0gaXMgdHJ1ZSwgaXQgd2lsbCBhbHNvIGVzY2FwZSB2YWxpZCBVUkwgY2hhcmFjdGVycyBmb3IgdXNlIGFzIGEgVVJMIHBhcmFtZXRlci5cbiAgICAgICogQGV4YW1wbGVcbiAgICAgICpcbiAgICAgICogICAnaHR0cDovL2Zvby5jb20vXCJiYXJcIicuZXNjYXBlVVJMKCkgICAgIC0+ICdodHRwOi8vZm9vLmNvbS8lMjJiYXIlMjInXG4gICAgICAqICAgJ2h0dHA6Ly9mb28uY29tL1wiYmFyXCInLmVzY2FwZVVSTCh0cnVlKSAtPiAnaHR0cCUzQSUyRiUyRmZvby5jb20lMkYlMjJiYXIlMjInXG4gICAgICAqXG4gICAgICAqKiovXG4gICAgJ2VzY2FwZVVSTCc6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICByZXR1cm4gcGFyYW0gPyBlbmNvZGVVUklDb21wb25lbnQodGhpcykgOiBlbmNvZGVVUkkodGhpcyk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICAqIEBtZXRob2QgdW5lc2NhcGVVUkwoW3BhcnRpYWxdID0gZmFsc2UpXG4gICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAgKiBAc2hvcnQgUmVzdG9yZXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGEgVVJMIGVzY2FwZWQgc3RyaW5nLlxuICAgICAgKiBAZXh0cmEgSWYgW3BhcnRpYWxdIGlzIHRydWUsIGl0IHdpbGwgb25seSB1bmVzY2FwZSBub24tdmFsaWQgVVJMIGNoYXJhY3RlcnMuIFtwYXJ0aWFsXSBpcyBpbmNsdWRlZCBoZXJlIGZvciBjb21wbGV0ZW5lc3MsIGJ1dCBzaG91bGQgdmVyeSByYXJlbHkgYmUgbmVlZGVkLlxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKlxuICAgICAgKiAgICdodHRwJTNBJTJGJTJGZm9vLmNvbSUyRnRoZSUyMGJhcicudW5lc2NhcGVVUkwoKSAgICAgLT4gJ2h0dHA6Ly9mb28uY29tL3RoZSBiYXInXG4gICAgICAqICAgJ2h0dHAlM0ElMkYlMkZmb28uY29tJTJGdGhlJTIwYmFyJy51bmVzY2FwZVVSTCh0cnVlKSAtPiAnaHR0cCUzQSUyRiUyRmZvby5jb20lMkZ0aGUgYmFyJ1xuICAgICAgKlxuICAgICAgKioqL1xuICAgICd1bmVzY2FwZVVSTCc6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUkkodGhpcykgOiBkZWNvZGVVUklDb21wb25lbnQodGhpcyk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICAqIEBtZXRob2QgZXNjYXBlSFRNTCgpXG4gICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAgKiBAc2hvcnQgQ29udmVydHMgSFRNTCBjaGFyYWN0ZXJzIHRvIHRoZWlyIGVudGl0eSBlcXVpdmFsZW50cy5cbiAgICAgICogQGV4YW1wbGVcbiAgICAgICpcbiAgICAgICogICAnPHA+c29tZSB0ZXh0PC9wPicuZXNjYXBlSFRNTCgpIC0+ICcmbHQ7cCZndDtzb21lIHRleHQmbHQ7L3AmZ3Q7J1xuICAgICAgKiAgICdvbmUgJiB0d28nLmVzY2FwZUhUTUwoKSAgICAgICAgLT4gJ29uZSAmYW1wOyB0d28nXG4gICAgICAqXG4gICAgICAqKiovXG4gICAgJ2VzY2FwZUhUTUwnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoLyYvZywgICcmYW1wOycgKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAgJyZsdDsnICApXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICAnJmd0OycgIClcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAnJnF1b3Q7JylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgICcmYXBvczsnKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICcmI3gyZjsnKTtcbiAgICB9LFxuXG4gICAgIC8qKipcbiAgICAgICogQG1ldGhvZCB1bmVzY2FwZUhUTUwoW3BhcnRpYWxdID0gZmFsc2UpXG4gICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAgKiBAc2hvcnQgUmVzdG9yZXMgZXNjYXBlZCBIVE1MIGNoYXJhY3RlcnMuXG4gICAgICAqIEBleGFtcGxlXG4gICAgICAqXG4gICAgICAqICAgJyZsdDtwJmd0O3NvbWUgdGV4dCZsdDsvcCZndDsnLnVuZXNjYXBlSFRNTCgpIC0+ICc8cD5zb21lIHRleHQ8L3A+J1xuICAgICAgKiAgICdvbmUgJmFtcDsgdHdvJy51bmVzY2FwZUhUTUwoKSAgICAgICAgICAgICAgICAtPiAnb25lICYgdHdvJ1xuICAgICAgKlxuICAgICAgKioqL1xuICAgICd1bmVzY2FwZUhUTUwnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoLyZsdDsvZywgICAnPCcpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csICAgJz4nKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mYXBvczsvZywgXCInXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mI3gyZjsvZywgJy8nKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJmFtcDsvZywgICcmJyk7XG4gICAgfSxcblxuICAgICAvKioqXG4gICAgICAqIEBtZXRob2QgZW5jb2RlQmFzZTY0KClcbiAgICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICAqIEBzaG9ydCBFbmNvZGVzIHRoZSBzdHJpbmcgaW50byBiYXNlNjQgZW5jb2RpbmcuXG4gICAgICAqIEBleHRyYSBUaGlzIG1ldGhvZCB3cmFwcyB0aGUgYnJvd3NlciBuYXRpdmUgJWJ0b2ElIHdoZW4gYXZhaWxhYmxlLCBhbmQgdXNlcyBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aGVuIG5vdCBhdmFpbGFibGUuIEl0IGNhbiBhbHNvIGhhbmRsZSBVbmljb2RlIHN0cmluZyBlbmNvZGluZ3MuXG4gICAgICAqIEBleGFtcGxlXG4gICAgICAqXG4gICAgICAqICAgJ2dvbm5hIGdldCBlbmNvZGVkIScuZW5jb2RlQmFzZTY0KCkgIC0+ICdaMjl1Ym1FZ1oyVjBJR1Z1WTI5a1pXUWgnXG4gICAgICAqICAgJ2h0dHA6Ly90d2l0dGVyLmNvbS8nLmVuY29kZUJhc2U2NCgpIC0+ICdhSFIwY0RvdkwzUjNhWFIwWlhJdVkyOXRMdz09J1xuICAgICAgKlxuICAgICAgKioqL1xuICAgICdlbmNvZGVCYXNlNjQnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0aGlzKSkpO1xuICAgIH0sXG5cbiAgICAgLyoqKlxuICAgICAgKiBAbWV0aG9kIGRlY29kZUJhc2U2NCgpXG4gICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAgKiBAc2hvcnQgRGVjb2RlcyB0aGUgc3RyaW5nIGZyb20gYmFzZTY0IGVuY29kaW5nLlxuICAgICAgKiBAZXh0cmEgVGhpcyBtZXRob2Qgd3JhcHMgdGhlIGJyb3dzZXIgbmF0aXZlICVhdG9iJSB3aGVuIGF2YWlsYWJsZSwgYW5kIHVzZXMgYSBjdXN0b20gaW1wbGVtZW50YXRpb24gd2hlbiBub3QgYXZhaWxhYmxlLiBJdCBjYW4gYWxzbyBoYW5kbGUgVW5pY29kZSBzdHJpbmcgZW5jb2RpbmdzLlxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKlxuICAgICAgKiAgICdhSFIwY0RvdkwzUjNhWFIwWlhJdVkyOXRMdz09Jy5kZWNvZGVCYXNlNjQoKSAtPiAnaHR0cDovL3R3aXR0ZXIuY29tLydcbiAgICAgICogICAnYW5WemRDQm5iM1FnWkdWamIyUmxaQT09Jy5kZWNvZGVCYXNlNjQoKSAgICAgLT4gJ2p1c3QgZ290IGRlY29kZWQhJ1xuICAgICAgKlxuICAgICAgKioqL1xuICAgICdkZWNvZGVCYXNlNjQnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGF0b2IodGhpcykpKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgZWFjaChbc2VhcmNoXSA9IHNpbmdsZSBjaGFyYWN0ZXIsIFtmbl0pXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgUnVucyBjYWxsYmFjayBbZm5dIGFnYWluc3QgZWFjaCBvY2N1cmVuY2Ugb2YgW3NlYXJjaF0uXG4gICAgICogQGV4dHJhIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlcy4gW3NlYXJjaF0gbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciByZWdleCwgYW5kIGRlZmF1bHRzIHRvIGV2ZXJ5IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdqdW1weScuZWFjaCgpIC0+IFsnaicsJ3UnLCdtJywncCcsJ3knXVxuICAgICAqICAgJ2p1bXB5Jy5lYWNoKC9bci16XS8pIC0+IFsndScsJ3knXVxuICAgICAqICAgJ2p1bXB5Jy5lYWNoKC9bci16XS8sIGZ1bmN0aW9uKG0pIHtcbiAgICAgKiAgICAgLy8gQ2FsbGVkIHR3aWNlOiBcInVcIiwgXCJ5XCJcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnZWFjaCc6IGZ1bmN0aW9uKHNlYXJjaCwgZm4pIHtcbiAgICAgIHZhciBtYXRjaCwgaSwgbGVuO1xuICAgICAgaWYoaXNGdW5jdGlvbihzZWFyY2gpKSB7XG4gICAgICAgIGZuID0gc2VhcmNoO1xuICAgICAgICBzZWFyY2ggPSAvW1xcc1xcU10vZztcbiAgICAgIH0gZWxzZSBpZighc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaCA9IC9bXFxzXFxTXS9nXG4gICAgICB9IGVsc2UgaWYoaXNTdHJpbmcoc2VhcmNoKSkge1xuICAgICAgICBzZWFyY2ggPSByZWdleHAoZXNjYXBlUmVnRXhwKHNlYXJjaCksICdnaScpO1xuICAgICAgfSBlbHNlIGlmKGlzUmVnRXhwKHNlYXJjaCkpIHtcbiAgICAgICAgc2VhcmNoID0gcmVnZXhwKHNlYXJjaC5zb3VyY2UsIGdldFJlZ0V4cEZsYWdzKHNlYXJjaCwgJ2cnKSk7XG4gICAgICB9XG4gICAgICBtYXRjaCA9IHRoaXMubWF0Y2goc2VhcmNoKSB8fCBbXTtcbiAgICAgIGlmKGZuKSB7XG4gICAgICAgIGZvcihpID0gMCwgbGVuID0gbWF0Y2gubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBtYXRjaFtpXSA9IGZuLmNhbGwodGhpcywgbWF0Y2hbaV0sIGksIG1hdGNoKSB8fCBtYXRjaFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBzaGlmdCg8bj4pXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgU2hpZnRzIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgPG4+IHBsYWNlcyBpbiB0aGUgY2hhcmFjdGVyIG1hcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnYScuc2hpZnQoMSkgIC0+ICdiJ1xuICAgICAqICAgJ+OCrycuc2hpZnQoMSkgLT4gJ+OCsCdcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3NoaWZ0JzogZnVuY3Rpb24obikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgbiA9IG4gfHwgMDtcbiAgICAgIHRoaXMuY29kZXMoZnVuY3Rpb24oYykge1xuICAgICAgICByZXN1bHQgKz0gY2hyKGMgKyBuKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgY29kZXMoW2ZuXSlcbiAgICAgKiBAcmV0dXJucyBBcnJheVxuICAgICAqIEBzaG9ydCBSdW5zIGNhbGxiYWNrIFtmbl0gYWdhaW5zdCBlYWNoIGNoYXJhY3RlciBjb2RlIGluIHRoZSBzdHJpbmcuIFJldHVybnMgYW4gYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdqdW1weScuY29kZXMoKSAtPiBbMTA2LDExNywxMDksMTEyLDEyMV1cbiAgICAgKiAgICdqdW1weScuY29kZXMoZnVuY3Rpb24oYykge1xuICAgICAqICAgICAvLyBDYWxsZWQgNSB0aW1lczogMTA2LCAxMTcsIDEwOSwgMTEyLCAxMjFcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnY29kZXMnOiBmdW5jdGlvbihmbikge1xuICAgICAgdmFyIGNvZGVzID0gW10sIGksIGxlbjtcbiAgICAgIGZvcihpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHRoaXMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgY29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgaWYoZm4pIGZuLmNhbGwodGhpcywgY29kZSwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZXM7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNoYXJzKFtmbl0pXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgUnVucyBjYWxsYmFjayBbZm5dIGFnYWluc3QgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gUmV0dXJucyBhbiBhcnJheSBvZiBjaGFyYWN0ZXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdqdW1weScuY2hhcnMoKSAtPiBbJ2onLCd1JywnbScsJ3AnLCd5J11cbiAgICAgKiAgICdqdW1weScuY2hhcnMoZnVuY3Rpb24oYykge1xuICAgICAqICAgICAvLyBDYWxsZWQgNSB0aW1lczogXCJqXCIsXCJ1XCIsXCJtXCIsXCJwXCIsXCJ5XCJcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnY2hhcnMnOiBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmbik7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHdvcmRzKFtmbl0pXG4gICAgICogQHJldHVybnMgQXJyYXlcbiAgICAgKiBAc2hvcnQgUnVucyBjYWxsYmFjayBbZm5dIGFnYWluc3QgZWFjaCB3b3JkIGluIHRoZSBzdHJpbmcuIFJldHVybnMgYW4gYXJyYXkgb2Ygd29yZHMuXG4gICAgICogQGV4dHJhIEEgXCJ3b3JkXCIgaGVyZSBpcyBkZWZpbmVkIGFzIGFueSBzZXF1ZW5jZSBvZiBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdicm9rZW4gd2Vhcicud29yZHMoKSAtPiBbJ2Jyb2tlbicsJ3dlYXInXVxuICAgICAqICAgJ2Jyb2tlbiB3ZWFyJy53b3JkcyhmdW5jdGlvbih3KSB7XG4gICAgICogICAgIC8vIENhbGxlZCB0d2ljZTogXCJicm9rZW5cIiwgXCJ3ZWFyXCJcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnd29yZHMnOiBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIHRoaXMudHJpbSgpLmVhY2goL1xcUysvZywgZm4pO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBsaW5lcyhbZm5dKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IFJ1bnMgY2FsbGJhY2sgW2ZuXSBhZ2FpbnN0IGVhY2ggbGluZSBpbiB0aGUgc3RyaW5nLiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpbmVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdicm9rZW4gd2VhclxcbmFuZFxcbmp1bXB5IGp1bXAnLmxpbmVzKCkgLT4gWydicm9rZW4gd2VhcicsJ2FuZCcsJ2p1bXB5IGp1bXAnXVxuICAgICAqICAgJ2Jyb2tlbiB3ZWFyXFxuYW5kXFxuanVtcHkganVtcCcubGluZXMoZnVuY3Rpb24obCkge1xuICAgICAqICAgICAvLyBDYWxsZWQgdGhyZWUgdGltZXM6IFwiYnJva2VuIHdlYXJcIiwgXCJhbmRcIiwgXCJqdW1weSBqdW1wXCJcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnbGluZXMnOiBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIHRoaXMudHJpbSgpLmVhY2goL14uKiQvZ20sIGZuKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcGFyYWdyYXBocyhbZm5dKVxuICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICogQHNob3J0IFJ1bnMgY2FsbGJhY2sgW2ZuXSBhZ2FpbnN0IGVhY2ggcGFyYWdyYXBoIGluIHRoZSBzdHJpbmcuIFJldHVybnMgYW4gYXJyYXkgb2YgcGFyYWdyYXBocy5cbiAgICAgKiBAZXh0cmEgQSBwYXJhZ3JhcGggaGVyZSBpcyBkZWZpbmVkIGFzIGEgYmxvY2sgb2YgdGV4dCBib3VuZGVkIGJ5IHR3byBvciBtb3JlIGxpbmUgYnJlYWtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdPbmNlIHVwb24gYSB0aW1lLlxcblxcbkluIHRoZSBsYW5kIG9mIG96Li4uJy5wYXJhZ3JhcGhzKCkgLT4gWydPbmNlIHVwb24gYSB0aW1lLicsJ0luIHRoZSBsYW5kIG9mIG96Li4uJ11cbiAgICAgKiAgICdPbmNlIHVwb24gYSB0aW1lLlxcblxcbkluIHRoZSBsYW5kIG9mIG96Li4uJy5wYXJhZ3JhcGhzKGZ1bmN0aW9uKHApIHtcbiAgICAgKiAgICAgLy8gQ2FsbGVkIHR3aWNlOiBcIk9uY2UgdXBvbiBhIHRpbWUuXCIsIFwiSW4gdGVoIGxhbmQgb2Ygb3ouLi5cIlxuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKioqL1xuICAgICdwYXJhZ3JhcGhzJzogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHZhciBwYXJhZ3JhcGhzID0gdGhpcy50cmltKCkuc3BsaXQoL1tcXHJcXG5dezIsfS8pO1xuICAgICAgcGFyYWdyYXBocyA9IHBhcmFncmFwaHMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgaWYoZm4pIHZhciBzID0gZm4uY2FsbChwKTtcbiAgICAgICAgcmV0dXJuIHMgPyBzIDogcDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcmFncmFwaHM7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGlzQmxhbmsoKVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaGFzIGEgbGVuZ3RoIG9mIDAgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICcnLmlzQmxhbmsoKSAgICAgIC0+IHRydWVcbiAgICAgKiAgICcgICAnLmlzQmxhbmsoKSAgIC0+IHRydWVcbiAgICAgKiAgICdub3dheScuaXNCbGFuaygpIC0+IGZhbHNlXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpc0JsYW5rJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmltKCkubGVuZ3RoID09PSAwO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBoYXMoPGZpbmQ+KVxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgbWF0Y2hlcyA8ZmluZD4uXG4gICAgICogQGV4dHJhIDxmaW5kPiBtYXkgYmUgYSBzdHJpbmcgb3IgcmVnZXguXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ2p1bXB5Jy5oYXMoJ3B5JykgICAgIC0+IHRydWVcbiAgICAgKiAgICdicm9rZW4nLmhhcygvW2Etbl0vKSAtPiB0cnVlXG4gICAgICogICAnYnJva2VuJy5oYXMoL1tzLXpdLykgLT4gZmFsc2VcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2hhcyc6IGZ1bmN0aW9uKGZpbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaChpc1JlZ0V4cChmaW5kKSA/IGZpbmQgOiBlc2NhcGVSZWdFeHAoZmluZCkpICE9PSAtMTtcbiAgICB9LFxuXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBhZGQoPHN0cj4sIFtpbmRleF0gPSBsZW5ndGgpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IEFkZHMgPHN0cj4gYXQgW2luZGV4XS4gTmVnYXRpdmUgdmFsdWVzIGFyZSBhbHNvIGFsbG93ZWQuXG4gICAgICogQGV4dHJhICVpbnNlcnQlIGlzIHByb3ZpZGVkIGFzIGFuIGFsaWFzLCBhbmQgaXMgZ2VuZXJhbGx5IG1vcmUgcmVhZGFibGUgd2hlbiB1c2luZyBhbiBpbmRleC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnc2NoZmlmdHknLmFkZCgnIGZpdmUnKSAgICAgIC0+IHNjaGZpZnR5IGZpdmVcbiAgICAgKiAgICdkb3BhbWluZScuaW5zZXJ0KCdlJywgMykgICAgICAgLT4gZG9wZWFtaW5lXG4gICAgICogICAnc3BlbGxpbmcgZXJvcicuaW5zZXJ0KCdyJywgLTMpIC0+IHNwZWxsaW5nIGVycm9yXG4gICAgICpcbiAgICAgKioqL1xuICAgICdhZGQnOiBmdW5jdGlvbihzdHIsIGluZGV4KSB7XG4gICAgICBpbmRleCA9IGlzVW5kZWZpbmVkKGluZGV4KSA/IHRoaXMubGVuZ3RoIDogaW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBpbmRleCkgKyBzdHIgKyB0aGlzLnNsaWNlKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlKDxmPilcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmVtb3ZlcyBhbnkgcGFydCBvZiB0aGUgc3RyaW5nIHRoYXQgbWF0Y2hlcyA8Zj4uXG4gICAgICogQGV4dHJhIDxmPiBjYW4gYmUgYSBzdHJpbmcgb3IgYSByZWdleC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnc2NoZmlmdHkgZml2ZScucmVtb3ZlKCdmJykgICAgIC0+ICdzY2hpdHkgaXZlJ1xuICAgICAqICAgJ3NjaGZpZnR5IGZpdmUnLnJlbW92ZSgvW2EtZl0vZykgLT4gJ3NoaXR5IGl2J1xuICAgICAqXG4gICAgICoqKi9cbiAgICAncmVtb3ZlJzogZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmLCAnJyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHJldmVyc2UoKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBSZXZlcnNlcyB0aGUgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdqdW1weScucmV2ZXJzZSgpICAgICAgICAtPiAneXBtdWonXG4gICAgICogICAnbHVja3kgY2hhcm1zJy5yZXZlcnNlKCkgLT4gJ3NtcmFoYyB5a2N1bCdcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3JldmVyc2UnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNvbXBhY3QoKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBDb21wYWN0cyBhbGwgd2hpdGUgc3BhY2UgaW4gdGhlIHN0cmluZyB0byBhIHNpbmdsZSBzcGFjZSBhbmQgdHJpbXMgdGhlIGVuZHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ3RvbyBcXG4gbXVjaCBcXG4gc3BhY2UnLmNvbXBhY3QoKSAtPiAndG9vIG11Y2ggc3BhY2UnXG4gICAgICogICAnZW5vdWdoIFxcbiAnLmNvbXBhY3QoKSAgICAgICAgICAgLT4gJ2Vub3VnaHQnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdjb21wYWN0JzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmltKCkucmVwbGFjZSgvKFtcXHJcXG5cXHPjgIBdKSsvZywgZnVuY3Rpb24obWF0Y2gsIHdoaXRlc3BhY2Upe1xuICAgICAgICByZXR1cm4gd2hpdGVzcGFjZSA9PT0gJ+OAgCcgPyB3aGl0ZXNwYWNlIDogJyAnO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGF0KDxpbmRleD4sIFtsb29wXSA9IHRydWUpXG4gICAgICogQHJldHVybnMgU3RyaW5nIG9yIEFycmF5XG4gICAgICogQHNob3J0IEdldHMgdGhlIGNoYXJhY3RlcihzKSBhdCBhIGdpdmVuIGluZGV4LlxuICAgICAqIEBleHRyYSBXaGVuIFtsb29wXSBpcyB0cnVlLCBvdmVyc2hvb3RpbmcgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIChvciB0aGUgYmVnaW5uaW5nKSB3aWxsIGJlZ2luIGNvdW50aW5nIGZyb20gdGhlIG90aGVyIGVuZC4gQXMgYW4gYWx0ZXJuYXRlIHN5bnRheCwgcGFzc2luZyBtdWx0aXBsZSBpbmRleGVzIHdpbGwgZ2V0IHRoZSBjaGFyYWN0ZXJzIGF0IHRob3NlIGluZGV4ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ2p1bXB5Jy5hdCgwKSAgICAgICAgICAgICAgIC0+ICdqJ1xuICAgICAqICAgJ2p1bXB5Jy5hdCgyKSAgICAgICAgICAgICAgIC0+ICdtJ1xuICAgICAqICAgJ2p1bXB5Jy5hdCg1KSAgICAgICAgICAgICAgIC0+ICdqJ1xuICAgICAqICAgJ2p1bXB5Jy5hdCg1LCBmYWxzZSkgICAgICAgIC0+ICcnXG4gICAgICogICAnanVtcHknLmF0KC0xKSAgICAgICAgICAgICAgLT4gJ3knXG4gICAgICogICAnbHVja3kgY2hhcm1zJy5hdCgyLDQsNiw4KSAtPiBbJ3UnLCdrJywneScsYyddXG4gICAgICpcbiAgICAgKioqL1xuICAgICdhdCc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldEVudHJpZXNGb3JJbmRleGVzKHRoaXMsIGFyZ3VtZW50cywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGZyb20oW2luZGV4XSA9IDApXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IFJldHVybnMgYSBzZWN0aW9uIG9mIHRoZSBzdHJpbmcgc3RhcnRpbmcgZnJvbSBbaW5kZXhdLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdsdWNreSBjaGFybXMnLmZyb20oKSAgIC0+ICdsdWNreSBjaGFybXMnXG4gICAgICogICAnbHVja3kgY2hhcm1zJy5mcm9tKDcpICAtPiAnaGFybXMnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdmcm9tJzogZnVuY3Rpb24oZnJvbSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UobnVtYmVyT3JJbmRleCh0aGlzLCBmcm9tLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHRvKFtpbmRleF0gPSBlbmQpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IFJldHVybnMgYSBzZWN0aW9uIG9mIHRoZSBzdHJpbmcgZW5kaW5nIGF0IFtpbmRleF0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ2x1Y2t5IGNoYXJtcycudG8oKSAgIC0+ICdsdWNreSBjaGFybXMnXG4gICAgICogICAnbHVja3kgY2hhcm1zJy50byg3KSAgLT4gJ2x1Y2t5IGNoJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAndG8nOiBmdW5jdGlvbih0bykge1xuICAgICAgaWYoaXNVbmRlZmluZWQodG8pKSB0byA9IHRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgbnVtYmVyT3JJbmRleCh0aGlzLCB0bykpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBkYXNoZXJpemUoKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBDb252ZXJ0cyB1bmRlcnNjb3JlcyBhbmQgY2FtZWwgY2FzaW5nIHRvIGh5cGVucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnYV9mYXJld2VsbF90b19hcm1zJy5kYXNoZXJpemUoKSAtPiAnYS1mYXJld2VsbC10by1hcm1zJ1xuICAgICAqICAgJ2NhcHNMb2NrJy5kYXNoZXJpemUoKSAgICAgICAgICAgLT4gJ2NhcHMtbG9jaydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2Rhc2hlcml6ZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudW5kZXJzY29yZSgpLnJlcGxhY2UoL18vZywgJy0nKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgdW5kZXJzY29yZSgpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IENvbnZlcnRzIGh5cGhlbnMgYW5kIGNhbWVsIGNhc2luZyB0byB1bmRlcnNjb3Jlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnYS1mYXJld2VsbC10by1hcm1zJy51bmRlcnNjb3JlKCkgLT4gJ2FfZmFyZXdlbGxfdG9fYXJtcydcbiAgICAgKiAgICdjYXBzTG9jaycudW5kZXJzY29yZSgpICAgICAgICAgICAtPiAnY2Fwc19sb2NrJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAndW5kZXJzY29yZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgLnJlcGxhY2UoL1stXFxzXSsvZywgJ18nKVxuICAgICAgICAucmVwbGFjZShzdHJpbmcuSW5mbGVjdG9yICYmIHN0cmluZy5JbmZsZWN0b3IuYWNyb255bVJlZ0V4cCwgZnVuY3Rpb24oYWNyb255bSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gKGluZGV4ID4gMCA/ICdfJyA6ICcnKSArIGFjcm9ueW0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlcGxhY2UoLyhbQS1aXFxkXSspKFtBLVpdW2Etel0pL2csJyQxXyQyJylcbiAgICAgICAgLnJlcGxhY2UoLyhbYS16XFxkXSkoW0EtWl0pL2csJyQxXyQyJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNhbWVsaXplKFtmaXJzdF0gPSB0cnVlKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBDb252ZXJ0cyB1bmRlcnNjb3JlcyBhbmQgaHlwaGVucyB0byBjYW1lbCBjYXNlLiBJZiBbZmlyc3RdIGlzIHRydWUgdGhlIGZpcnN0IGxldHRlciB3aWxsIGFsc28gYmUgY2FwaXRhbGl6ZWQuXG4gICAgICogQGV4dHJhIElmIHRoZSBJbmZsZWN0aW9ucyBwYWNrYWdlIGlzIGluY2x1ZGVkIGFjcnlvbnltcyBjYW4gYWxzbyBiZSBkZWZpbmVkIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gY2FtZWxpemluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnY2Fwc19sb2NrJy5jYW1lbGl6ZSgpICAgICAgICAgICAgICAtPiAnQ2Fwc0xvY2snXG4gICAgICogICAnbW96LWJvcmRlci1yYWRpdXMnLmNhbWVsaXplKCkgICAgICAtPiAnTW96Qm9yZGVyUmFkaXVzJ1xuICAgICAqICAgJ21vei1ib3JkZXItcmFkaXVzJy5jYW1lbGl6ZShmYWxzZSkgLT4gJ21vekJvcmRlclJhZGl1cydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2NhbWVsaXplJzogZnVuY3Rpb24oZmlyc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuZGVyc2NvcmUoKS5yZXBsYWNlKC8oXnxfKShbXl9dKykvZywgZnVuY3Rpb24obWF0Y2gsIHByZSwgd29yZCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGFjcm9ueW0gPSBnZXRBY3JvbnltKHdvcmQpLCBjYXBpdGFsaXplID0gZmlyc3QgIT09IGZhbHNlIHx8IGluZGV4ID4gMDtcbiAgICAgICAgaWYoYWNyb255bSkgcmV0dXJuIGNhcGl0YWxpemUgPyBhY3JvbnltIDogYWNyb255bS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gY2FwaXRhbGl6ZSA/IHdvcmQuY2FwaXRhbGl6ZSgpIDogd29yZDtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBzcGFjaWZ5KClcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgQ29udmVydHMgY2FtZWwgY2FzZSwgdW5kZXJzY29yZXMsIGFuZCBoeXBoZW5zIHRvIGEgcHJvcGVybHkgc3BhY2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnY2FtZWxDYXNlJy5zcGFjaWZ5KCkgICAgICAgICAgICAgICAgICAgICAgICAgLT4gJ2NhbWVsIGNhc2UnXG4gICAgICogICAnYW4tdWdseS1zdHJpbmcnLnNwYWNpZnkoKSAgICAgICAgICAgICAgICAgICAgLT4gJ2FuIHVnbHkgc3RyaW5nJ1xuICAgICAqICAgJ29oLW5vX3lvdURpZC1ub3QnLnNwYWNpZnkoKS5jYXBpdGFsaXplKHRydWUpIC0+ICdzb21ldGhpbmcgZWxzZSdcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3NwYWNpZnknOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuZGVyc2NvcmUoKS5yZXBsYWNlKC9fL2csICcgJyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHN0cmlwVGFncyhbdGFnMV0sIFt0YWcyXSwgLi4uKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBTdHJpcHMgYWxsIEhUTUwgdGFncyBmcm9tIHRoZSBzdHJpbmcuXG4gICAgICogQGV4dHJhIFRhZ3MgdG8gc3RyaXAgbWF5IGJlIGVudW1lcmF0ZWQgaW4gdGhlIHBhcmFtZXRlcnMsIG90aGVyd2lzZSB3aWxsIHN0cmlwIGFsbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnPHA+anVzdCA8Yj5zb21lPC9iPiB0ZXh0PC9wPicuc3RyaXBUYWdzKCkgICAgLT4gJ2p1c3Qgc29tZSB0ZXh0J1xuICAgICAqICAgJzxwPmp1c3QgPGI+c29tZTwvYj4gdGV4dDwvcD4nLnN0cmlwVGFncygncCcpIC0+ICdqdXN0IDxiPnNvbWU8L2I+IHRleHQnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdzdHJpcFRhZ3MnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHIgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHMgOiBbJyddO1xuICAgICAgZmxhdHRlbmVkQXJncyhhcmdzLCBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UocmVnZXhwKCc8XFwvPycgKyBlc2NhcGVSZWdFeHAodGFnKSArICdbXjw+XSo+JywgJ2dpJyksICcnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlVGFncyhbdGFnMV0sIFt0YWcyXSwgLi4uKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBSZW1vdmVzIGFsbCBIVE1MIHRhZ3MgYW5kIHRoZWlyIGNvbnRlbnRzIGZyb20gdGhlIHN0cmluZy5cbiAgICAgKiBAZXh0cmEgVGFncyB0byByZW1vdmUgbWF5IGJlIGVudW1lcmF0ZWQgaW4gdGhlIHBhcmFtZXRlcnMsIG90aGVyd2lzZSB3aWxsIHJlbW92ZSBhbGwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJzxwPmp1c3QgPGI+c29tZTwvYj4gdGV4dDwvcD4nLnJlbW92ZVRhZ3MoKSAgICAtPiAnJ1xuICAgICAqICAgJzxwPmp1c3QgPGI+c29tZTwvYj4gdGV4dDwvcD4nLnJlbW92ZVRhZ3MoJ2InKSAtPiAnPHA+anVzdCB0ZXh0PC9wPidcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3JlbW92ZVRhZ3MnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHIgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHMgOiBbJ1xcXFxTKyddO1xuICAgICAgZmxhdHRlbmVkQXJncyhhcmdzLCBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciByZWcgPSByZWdleHAoJzwoJyArIHQgKyAnKVtePD5dKig/OlxcXFwvPnw+Lio/PFxcXFwvXFxcXDE+KScsICdnaScpO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShyZWcsICcnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgdHJ1bmNhdGUoPGxlbmd0aD4sIFtmcm9tXSA9ICdyaWdodCcsIFtlbGxpcHNpc10gPSAnLi4uJylcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgVHJ1bmNhdGVzIGEgc3RyaW5nLlxuICAgICAqIEBleHRyYSBbZnJvbV0gY2FuIGJlICUncmlnaHQnJSwgJSdsZWZ0JyUsIG9yICUnbWlkZGxlJyUuIElmIHRoZSBzdHJpbmcgaXMgc2hvcnRlciB0aGFuIDxsZW5ndGg+LCBbZWxsaXBzaXNdIHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdzaXR0aW4gb24gdGhlIGRvY2sgb2YgdGhlIGJheScudHJ1bmNhdGUoMTgpICAgICAgICAgICAtPiAnanVzdCBzaXR0aW4gb24gdGhlIGRvLi4uJ1xuICAgICAqICAgJ3NpdHRpbiBvbiB0aGUgZG9jayBvZiB0aGUgYmF5Jy50cnVuY2F0ZSgxOCwgJ2xlZnQnKSAgIC0+ICcuLi50aGUgZG9jayBvZiB0aGUgYmF5J1xuICAgICAqICAgJ3NpdHRpbiBvbiB0aGUgZG9jayBvZiB0aGUgYmF5Jy50cnVuY2F0ZSgxOCwgJ21pZGRsZScpIC0+ICdqdXN0IHNpdHQuLi5vZiB0aGUgYmF5J1xuICAgICAqXG4gICAgICoqKi9cbiAgICAndHJ1bmNhdGUnOiBmdW5jdGlvbihsZW5ndGgsIGZyb20sIGVsbGlwc2lzKSB7XG4gICAgICByZXR1cm4gdHJ1bmNhdGVTdHJpbmcodGhpcywgbGVuZ3RoLCBmcm9tLCBlbGxpcHNpcyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHRydW5jYXRlT25Xb3JkKDxsZW5ndGg+LCBbZnJvbV0gPSAncmlnaHQnLCBbZWxsaXBzaXNdID0gJy4uLicpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IFRydW5jYXRlcyBhIHN0cmluZyB3aXRob3V0IHNwbGl0dGluZyB1cCB3b3Jkcy5cbiAgICAgKiBAZXh0cmEgW2Zyb21dIGNhbiBiZSAlJ3JpZ2h0JyUsICUnbGVmdCclLCBvciAlJ21pZGRsZSclLiBJZiB0aGUgc3RyaW5nIGlzIHNob3J0ZXIgdGhhbiA8bGVuZ3RoPiwgW2VsbGlwc2lzXSB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnaGVyZSB3ZSBnbycudHJ1bmNhdGVPbldvcmQoNSkgICAgICAgICAgICAgICAtPiAnaGVyZS4uLidcbiAgICAgKiAgICdoZXJlIHdlIGdvJy50cnVuY2F0ZU9uV29yZCg1LCAnbGVmdCcpICAgICAgIC0+ICcuLi53ZSBnbydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3RydW5jYXRlT25Xb3JkJzogZnVuY3Rpb24obGVuZ3RoLCBmcm9tLCBlbGxpcHNpcykge1xuICAgICAgcmV0dXJuIHRydW5jYXRlU3RyaW5nKHRoaXMsIGxlbmd0aCwgZnJvbSwgZWxsaXBzaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBwYWRbU2lkZV0oPG51bT4gPSBudWxsLCBbcGFkZGluZ10gPSAnICcpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IFBhZHMgdGhlIHN0cmluZyBvdXQgd2l0aCBbcGFkZGluZ10gdG8gYmUgZXhhY3RseSA8bnVtPiBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHNldFxuICAgICAqICAgcGFkXG4gICAgICogICBwYWRMZWZ0XG4gICAgICogICBwYWRSaWdodFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ3dhc2FiaScucGFkKDgpICAgICAgICAgICAtPiAnIHdhc2FiaSAnXG4gICAgICogICAnd2FzYWJpJy5wYWRMZWZ0KDgpICAgICAgIC0+ICcgIHdhc2FiaSdcbiAgICAgKiAgICd3YXNhYmknLnBhZFJpZ2h0KDgpICAgICAgLT4gJ3dhc2FiaSAgJ1xuICAgICAqICAgJ3dhc2FiaScucGFkUmlnaHQoOCwgJy0nKSAtPiAnd2FzYWJpLS0nXG4gICAgICpcbiAgICAgKioqL1xuICAgICdwYWQnOiBmdW5jdGlvbihudW0sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBoYWxmLCBmcm9udCwgYmFjaztcbiAgICAgIG51bSAgID0gY2hlY2tSZXBlYXRSYW5nZShudW0pO1xuICAgICAgaGFsZiAgPSBtYXgoMCwgbnVtIC0gdGhpcy5sZW5ndGgpIC8gMjtcbiAgICAgIGZyb250ID0gZmxvb3IoaGFsZik7XG4gICAgICBiYWNrICA9IGNlaWwoaGFsZik7XG4gICAgICByZXR1cm4gcGFkU3RyaW5nKGZyb250LCBwYWRkaW5nKSArIHRoaXMgKyBwYWRTdHJpbmcoYmFjaywgcGFkZGluZyk7XG4gICAgfSxcblxuICAgICdwYWRMZWZ0JzogZnVuY3Rpb24obnVtLCBwYWRkaW5nKSB7XG4gICAgICBudW0gPSBjaGVja1JlcGVhdFJhbmdlKG51bSk7XG4gICAgICByZXR1cm4gcGFkU3RyaW5nKG1heCgwLCBudW0gLSB0aGlzLmxlbmd0aCksIHBhZGRpbmcpICsgdGhpcztcbiAgICB9LFxuXG4gICAgJ3BhZFJpZ2h0JzogZnVuY3Rpb24obnVtLCBwYWRkaW5nKSB7XG4gICAgICBudW0gPSBjaGVja1JlcGVhdFJhbmdlKG51bSk7XG4gICAgICByZXR1cm4gdGhpcyArIHBhZFN0cmluZyhtYXgoMCwgbnVtIC0gdGhpcy5sZW5ndGgpLCBwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgZmlyc3QoW25dID0gMSlcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgZmlyc3QgW25dIGNoYXJhY3RlcnMgb2YgdGhlIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAnbHVja3kgY2hhcm1zJy5maXJzdCgpICAgLT4gJ2wnXG4gICAgICogICAnbHVja3kgY2hhcm1zJy5maXJzdCgzKSAgLT4gJ2x1YydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2ZpcnN0JzogZnVuY3Rpb24obnVtKSB7XG4gICAgICBpZihpc1VuZGVmaW5lZChudW0pKSBudW0gPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuc3Vic3RyKDAsIG51bSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGxhc3QoW25dID0gMSlcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgbGFzdCBbbl0gY2hhcmFjdGVycyBvZiB0aGUgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdsdWNreSBjaGFybXMnLmxhc3QoKSAgIC0+ICdzJ1xuICAgICAqICAgJ2x1Y2t5IGNoYXJtcycubGFzdCgzKSAgLT4gJ3JtcydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2xhc3QnOiBmdW5jdGlvbihudW0pIHtcbiAgICAgIGlmKGlzVW5kZWZpbmVkKG51bSkpIG51bSA9IDE7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIG51bSA8IDAgPyAwIDogdGhpcy5sZW5ndGggLSBudW07XG4gICAgICByZXR1cm4gdGhpcy5zdWJzdHIoc3RhcnQpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCB0b051bWJlcihbYmFzZV0gPSAxMClcbiAgICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICAgKiBAc2hvcnQgQ29udmVydHMgdGhlIHN0cmluZyBpbnRvIGEgbnVtYmVyLlxuICAgICAqIEBleHRyYSBBbnkgdmFsdWUgd2l0aCBhIFwiLlwiIGZpbGwgYmUgY29udmVydGVkIHRvIGEgZmxvYXRpbmcgcG9pbnQgdmFsdWUsIG90aGVyd2lzZSBhbiBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICcxNTMnLnRvTnVtYmVyKCkgICAgLT4gMTUzXG4gICAgICogICAnMTIsMDAwJy50b051bWJlcigpIC0+IDEyMDAwXG4gICAgICogICAnMTBweCcudG9OdW1iZXIoKSAgIC0+IDEwXG4gICAgICogICAnZmYnLnRvTnVtYmVyKDE2KSAgIC0+IDI1NVxuICAgICAqXG4gICAgICoqKi9cbiAgICAndG9OdW1iZXInOiBmdW5jdGlvbihiYXNlKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVG9OdW1iZXIodGhpcywgYmFzZSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGNhcGl0YWxpemUoW2FsbF0gPSBmYWxzZSlcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgQ2FwaXRhbGl6ZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGFuZCBkb3duY2FzZXMgYWxsIG90aGVyIGxldHRlcnMuXG4gICAgICogQGV4dHJhIElmIFthbGxdIGlzIHRydWUsIGFsbCB3b3JkcyBpbiB0aGUgc3RyaW5nIHdpbGwgYmUgY2FwaXRhbGl6ZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ2hlbGxvJy5jYXBpdGFsaXplKCkgICAgICAgICAgIC0+ICdIZWxsbydcbiAgICAgKiAgICdoZWxsbyBraXR0eScuY2FwaXRhbGl6ZSgpICAgICAtPiAnSGVsbG8ga2l0dHknXG4gICAgICogICAnaGVsbG8ga2l0dHknLmNhcGl0YWxpemUodHJ1ZSkgLT4gJ0hlbGxvIEtpdHR5J1xuICAgICAqXG4gICAgICpcbiAgICAgKioqL1xuICAgICdjYXBpdGFsaXplJzogZnVuY3Rpb24oYWxsKSB7XG4gICAgICB2YXIgbGFzdFJlc3BvbmRlZDtcbiAgICAgIHJldHVybiB0aGlzLnRvTG93ZXJDYXNlKCkucmVwbGFjZShhbGwgPyAvW14nXS9nIDogL15cXFMvLCBmdW5jdGlvbihsb3dlcikge1xuICAgICAgICB2YXIgdXBwZXIgPSBsb3dlci50b1VwcGVyQ2FzZSgpLCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IGxhc3RSZXNwb25kZWQgPyBsb3dlciA6IHVwcGVyO1xuICAgICAgICBsYXN0UmVzcG9uZGVkID0gdXBwZXIgIT09IGxvd2VyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGFzc2lnbig8b2JqMT4sIDxvYmoyPiwgLi4uKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBBc3NpZ25zIHZhcmlhYmxlcyB0byB0b2tlbnMgaW4gYSBzdHJpbmcsIGRlbWFyY2F0ZWQgd2l0aCBge31gLlxuICAgICAqIEBleHRyYSBJZiBhbiBvYmplY3QgaXMgcGFzc2VkLCBpdCdzIHByb3BlcnRpZXMgY2FuIGJlIGFzc2lnbmVkIHVzaW5nIHRoZSBvYmplY3QncyBrZXlzIChpLmUuIHtuYW1lfSkuIElmIGEgbm9uLW9iamVjdCAoc3RyaW5nLCBudW1iZXIsIGV0Yy4pIGlzIHBhc3NlZCBpdCBjYW4gYmUgYWNjZXNzZWQgYnkgdGhlIGFyZ3VtZW50IG51bWJlciBiZWdpbm5pbmcgd2l0aCB7MX0gKGFzIHdpdGggcmVnZXggdG9rZW5zKS4gTXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkIGFuZCB3aWxsIGJlIG1lcmdlZCB0b2dldGhlciAob3JpZ2luYWwgb2JqZWN0cyBhcmUgdW5hZmZlY3RlZCkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ1dlbGNvbWUsIE1yLiB7bmFtZX0uJy5hc3NpZ24oeyBuYW1lOiAnRnJhbmtsaW4nIH0pICAgLT4gJ1dlbGNvbWUsIE1yLiBGcmFua2xpbi4nXG4gICAgICogICAnWW91IGFyZSB7MX0geWVhcnMgb2xkIHRvZGF5LicuYXNzaWduKDE0KSAgICAgICAgICAgICAtPiAnWW91IGFyZSAxNCB5ZWFycyBvbGQgdG9kYXkuJ1xuICAgICAqICAgJ3tufSBhbmQge3J9Jy5hc3NpZ24oeyBuOiAnQ2hlZWNoJyB9LCB7IHI6ICdDaG9uZycgfSkgLT4gJ0NoZWVjaCBhbmQgQ2hvbmcnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdhc3NpZ24nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhc3NpZ24gPSB7fTtcbiAgICAgIGZsYXR0ZW5lZEFyZ3MoYXJndW1lbnRzLCBmdW5jdGlvbihhLCBpKSB7XG4gICAgICAgIGlmKGlzT2JqZWN0VHlwZShhKSkge1xuICAgICAgICAgIHNpbXBsZU1lcmdlKGFzc2lnbiwgYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduW2kgKyAxXSA9IGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXFx7KFtee10rPylcXH0vZywgZnVuY3Rpb24obSwga2V5KSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eShhc3NpZ24sIGtleSkgPyBhc3NpZ25ba2V5XSA6IG07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSk7XG5cblxuICAvLyBBbGlhc2VzXG5cbiAgZXh0ZW5kKHN0cmluZywgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgaW5zZXJ0KClcbiAgICAgKiBAYWxpYXMgYWRkXG4gICAgICpcbiAgICAgKioqL1xuICAgICdpbnNlcnQnOiBzdHJpbmcucHJvdG90eXBlLmFkZFxuICB9KTtcblxuICBidWlsZEJhc2U2NCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nKTtcblxuXG4gIC8qKipcbiAgICpcbiAgICogQHBhY2thZ2UgSW5mbGVjdGlvbnNcbiAgICogQGRlcGVuZGVuY3kgc3RyaW5nXG4gICAqIEBkZXNjcmlwdGlvbiBQbHVyYWxpemF0aW9uIHNpbWlsYXIgdG8gQWN0aXZlU3VwcG9ydCBpbmNsdWRpbmcgdW5jb3VudGFibGUgd29yZHMgYW5kIGFjcm9ueW1zLiBIdW1hbml6ZWQgYW5kIFVSTC1mcmllbmRseSBzdHJpbmdzLlxuICAgKlxuICAgKioqL1xuXG4gIC8qKipcbiAgICogU3RyaW5nIG1vZHVsZVxuICAgKlxuICAgKioqL1xuXG5cbiAgdmFyIHBsdXJhbHMgICAgICA9IFtdLFxuICAgICAgc2luZ3VsYXJzICAgID0gW10sXG4gICAgICB1bmNvdW50YWJsZXMgPSBbXSxcbiAgICAgIGh1bWFucyAgICAgICA9IFtdLFxuICAgICAgYWNyb255bXMgICAgID0ge30sXG4gICAgICBEb3duY2FzZWQsXG4gICAgICBJbmZsZWN0b3I7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFyciwgZmluZCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGZpbmQpO1xuICAgIGlmKGluZGV4ID4gLTEpIHtcbiAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21VbmNvdW50YWJsZXNBbmRBZGRUbyhhcnIsIHJ1bGUsIHJlcGxhY2VtZW50KSB7XG4gICAgaWYoaXNTdHJpbmcocnVsZSkpIHtcbiAgICAgIHJlbW92ZUZyb21BcnJheSh1bmNvdW50YWJsZXMsIHJ1bGUpO1xuICAgIH1cbiAgICByZW1vdmVGcm9tQXJyYXkodW5jb3VudGFibGVzLCByZXBsYWNlbWVudCk7XG4gICAgYXJyLnVuc2hpZnQoeyBydWxlOiBydWxlLCByZXBsYWNlbWVudDogcmVwbGFjZW1lbnQgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmFtTWF0Y2hlc1R5cGUocGFyYW0sIHR5cGUpIHtcbiAgICByZXR1cm4gcGFyYW0gPT0gdHlwZSB8fCBwYXJhbSA9PSAnYWxsJyB8fCAhcGFyYW07XG4gIH1cblxuICBmdW5jdGlvbiBpc1VuY291bnRhYmxlKHdvcmQpIHtcbiAgICByZXR1cm4gdW5jb3VudGFibGVzLnNvbWUoZnVuY3Rpb24odW5jb3VudGFibGUpIHtcbiAgICAgIHJldHVybiBuZXcgcmVnZXhwKCdcXFxcYicgKyB1bmNvdW50YWJsZSArICckJywgJ2knKS50ZXN0KHdvcmQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5mbGVjdCh3b3JkLCBwbHVyYWxpemUpIHtcbiAgICB3b3JkID0gaXNTdHJpbmcod29yZCkgPyB3b3JkLnRvU3RyaW5nKCkgOiAnJztcbiAgICBpZih3b3JkLmlzQmxhbmsoKSB8fCBpc1VuY291bnRhYmxlKHdvcmQpKSB7XG4gICAgICByZXR1cm4gd29yZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJ1blJlcGxhY2VtZW50cyh3b3JkLCBwbHVyYWxpemUgPyBwbHVyYWxzIDogc2luZ3VsYXJzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5SZXBsYWNlbWVudHMod29yZCwgdGFibGUpIHtcbiAgICBpdGVyYXRlT3Zlck9iamVjdCh0YWJsZSwgZnVuY3Rpb24oaSwgaW5mbGVjdGlvbikge1xuICAgICAgaWYod29yZC5tYXRjaChpbmZsZWN0aW9uLnJ1bGUpKSB7XG4gICAgICAgIHdvcmQgPSB3b3JkLnJlcGxhY2UoaW5mbGVjdGlvbi5ydWxlLCBpbmZsZWN0aW9uLnJlcGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3b3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZSh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQucmVwbGFjZSgvXlxcVypbYS16XS8sIGZ1bmN0aW9uKHcpe1xuICAgICAgcmV0dXJuIHcudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIEluZmxlY3RvciA9IHtcblxuICAgIC8qXG4gICAgICogU3BlY2lmaWVzIGEgbmV3IGFjcm9ueW0uIEFuIGFjcm9ueW0gbXVzdCBiZSBzcGVjaWZpZWQgYXMgaXQgd2lsbCBhcHBlYXIgaW4gYSBjYW1lbGl6ZWQgc3RyaW5nLiAgQW4gdW5kZXJzY29yZVxuICAgICAqIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBhY3JvbnltIHdpbGwgcmV0YWluIHRoZSBhY3JvbnltIHdoZW4gcGFzc2VkIHRvICVjYW1lbGl6ZSUsICVodW1hbml6ZSUsIG9yICV0aXRsZWl6ZSUuXG4gICAgICogQSBjYW1lbGl6ZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGFjcm9ueW0gd2lsbCBtYWludGFpbiB0aGUgYWNyb255bSB3aGVuIHRpdGxlaXplZCBvciBodW1hbml6ZWQsIGFuZCB3aWxsXG4gICAgICogY29udmVydCB0aGUgYWNyb255bSBpbnRvIGEgbm9uLWRlbGltaXRlZCBzaW5nbGUgbG93ZXJjYXNlIHdvcmQgd2hlbiBwYXNzZWQgdG8gU3RyaW5nI3VuZGVyc2NvcmUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKiAgIFN0cmluZy5JbmZsZWN0b3IuYWNyb255bSgnSFRNTCcpXG4gICAgICogICAnaHRtbCcudGl0bGVpemUoKSAgICAgLT4gJ0hUTUwnXG4gICAgICogICAnaHRtbCcuY2FtZWxpemUoKSAgICAgLT4gJ0hUTUwnXG4gICAgICogICAnTXlIVE1MJy51bmRlcnNjb3JlKCkgLT4gJ215X2h0bWwnXG4gICAgICpcbiAgICAgKiBUaGUgYWNyb255bSwgaG93ZXZlciwgbXVzdCBvY2N1ciBhcyBhIGRlbGltaXRlZCB1bml0IGFuZCBub3QgYmUgcGFydCBvZiBhbm90aGVyIHdvcmQgZm9yIGNvbnZlcnNpb25zIHRvIHJlY29nbml6ZSBpdDpcbiAgICAgKlxuICAgICAqICAgU3RyaW5nLkluZmxlY3Rvci5hY3JvbnltKCdIVFRQJylcbiAgICAgKiAgICdteV9odHRwX2RlbGltaXRlZCcuY2FtZWxpemUoKSAtPiAnTXlIVFRQRGVsaW1pdGVkJ1xuICAgICAqICAgJ2h0dHBzJy5jYW1lbGl6ZSgpICAgICAgICAgICAgIC0+ICdIdHRwcycsIG5vdCAnSFRUUHMnXG4gICAgICogICAnSFRUUFMnLnVuZGVyc2NvcmUoKSAgICAgICAgICAgLT4gJ2h0dHBfcycsIG5vdCAnaHR0cHMnXG4gICAgICpcbiAgICAgKiAgIFN0cmluZy5JbmZsZWN0b3IuYWNyb255bSgnSFRUUFMnKVxuICAgICAqICAgJ2h0dHBzJy5jYW1lbGl6ZSgpICAgLT4gJ0hUVFBTJ1xuICAgICAqICAgJ0hUVFBTJy51bmRlcnNjb3JlKCkgLT4gJ2h0dHBzJ1xuICAgICAqXG4gICAgICogTm90ZTogQWNyb255bXMgdGhhdCBhcmUgcGFzc2VkIHRvICVwbHVyYWxpemUlIHdpbGwgbm8gbG9uZ2VyIGJlIHJlY29nbml6ZWQsIHNpbmNlIHRoZSBhY3JvbnltIHdpbGwgbm90IG9jY3VyIGFzXG4gICAgICogYSBkZWxpbWl0ZWQgdW5pdCBpbiB0aGUgcGx1cmFsaXplZCByZXN1bHQuIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBtdXN0IHNwZWNpZnkgdGhlIHBsdXJhbGl6ZWQgZm9ybSBhcyBhblxuICAgICAqIGFjcm9ueW0gYXMgd2VsbDpcbiAgICAgKlxuICAgICAqICAgIFN0cmluZy5JbmZsZWN0b3IuYWNyb255bSgnQVBJJylcbiAgICAgKiAgICAnYXBpJy5wbHVyYWxpemUoKS5jYW1lbGl6ZSgpIC0+ICdBcGlzJ1xuICAgICAqXG4gICAgICogICAgU3RyaW5nLkluZmxlY3Rvci5hY3JvbnltKCdBUElzJylcbiAgICAgKiAgICAnYXBpJy5wbHVyYWxpemUoKS5jYW1lbGl6ZSgpIC0+ICdBUElzJ1xuICAgICAqXG4gICAgICogJWFjcm9ueW0lIG1heSBiZSB1c2VkIHRvIHNwZWNpZnkgYW55IHdvcmQgdGhhdCBjb250YWlucyBhbiBhY3JvbnltIG9yIG90aGVyd2lzZSBuZWVkcyB0byBtYWludGFpbiBhIG5vbi1zdGFuZGFyZFxuICAgICAqIGNhcGl0YWxpemF0aW9uLiBUaGUgb25seSByZXN0cmljdGlvbiBpcyB0aGF0IHRoZSB3b3JkIG11c3QgYmVnaW4gd2l0aCBhIGNhcGl0YWwgbGV0dGVyLlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICogICBTdHJpbmcuSW5mbGVjdG9yLmFjcm9ueW0oJ1JFU1RmdWwnKVxuICAgICAqICAgJ1JFU1RmdWwnLnVuZGVyc2NvcmUoKSAgICAgICAgICAgLT4gJ3Jlc3RmdWwnXG4gICAgICogICAnUkVTVGZ1bENvbnRyb2xsZXInLnVuZGVyc2NvcmUoKSAtPiAncmVzdGZ1bF9jb250cm9sbGVyJ1xuICAgICAqICAgJ1JFU1RmdWxDb250cm9sbGVyJy50aXRsZWl6ZSgpICAgLT4gJ1JFU1RmdWwgQ29udHJvbGxlcidcbiAgICAgKiAgICdyZXN0ZnVsJy5jYW1lbGl6ZSgpICAgICAgICAgICAgIC0+ICdSRVNUZnVsJ1xuICAgICAqICAgJ3Jlc3RmdWxfY29udHJvbGxlcicuY2FtZWxpemUoKSAgLT4gJ1JFU1RmdWxDb250cm9sbGVyJ1xuICAgICAqXG4gICAgICogICBTdHJpbmcuSW5mbGVjdG9yLmFjcm9ueW0oJ01jRG9uYWxkJylcbiAgICAgKiAgICdNY0RvbmFsZCcudW5kZXJzY29yZSgpIC0+ICdtY2RvbmFsZCdcbiAgICAgKiAgICdtY2RvbmFsZCcuY2FtZWxpemUoKSAgIC0+ICdNY0RvbmFsZCdcbiAgICAgKi9cbiAgICAnYWNyb255bSc6IGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgIGFjcm9ueW1zW3dvcmQudG9Mb3dlckNhc2UoKV0gPSB3b3JkO1xuICAgICAgdmFyIGFsbCA9IG9iamVjdC5rZXlzKGFjcm9ueW1zKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBhY3Jvbnltc1trZXldO1xuICAgICAgfSk7XG4gICAgICBJbmZsZWN0b3IuYWNyb255bVJlZ0V4cCA9IHJlZ2V4cChhbGwuam9pbignfCcpLCAnZycpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIFNwZWNpZmllcyBhIG5ldyBwbHVyYWxpemF0aW9uIHJ1bGUgYW5kIGl0cyByZXBsYWNlbWVudC4gVGhlIHJ1bGUgY2FuIGVpdGhlciBiZSBhIHN0cmluZyBvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKiBUaGUgcmVwbGFjZW1lbnQgc2hvdWxkIGFsd2F5cyBiZSBhIHN0cmluZyB0aGF0IG1heSBpbmNsdWRlIHJlZmVyZW5jZXMgdG8gdGhlIG1hdGNoZWQgZGF0YSBmcm9tIHRoZSBydWxlLlxuICAgICAqL1xuICAgICdwbHVyYWwnOiBmdW5jdGlvbihydWxlLCByZXBsYWNlbWVudCkge1xuICAgICAgcmVtb3ZlRnJvbVVuY291bnRhYmxlc0FuZEFkZFRvKHBsdXJhbHMsIHJ1bGUsIHJlcGxhY2VtZW50KTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBTcGVjaWZpZXMgYSBuZXcgc2luZ3VsYXJpemF0aW9uIHJ1bGUgYW5kIGl0cyByZXBsYWNlbWVudC4gVGhlIHJ1bGUgY2FuIGVpdGhlciBiZSBhIHN0cmluZyBvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKiBUaGUgcmVwbGFjZW1lbnQgc2hvdWxkIGFsd2F5cyBiZSBhIHN0cmluZyB0aGF0IG1heSBpbmNsdWRlIHJlZmVyZW5jZXMgdG8gdGhlIG1hdGNoZWQgZGF0YSBmcm9tIHRoZSBydWxlLlxuICAgICAqL1xuICAgICdzaW5ndWxhcic6IGZ1bmN0aW9uKHJ1bGUsIHJlcGxhY2VtZW50KSB7XG4gICAgICByZW1vdmVGcm9tVW5jb3VudGFibGVzQW5kQWRkVG8oc2luZ3VsYXJzLCBydWxlLCByZXBsYWNlbWVudCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogU3BlY2lmaWVzIGEgbmV3IGlycmVndWxhciB0aGF0IGFwcGxpZXMgdG8gYm90aCBwbHVyYWxpemF0aW9uIGFuZCBzaW5ndWxhcml6YXRpb24gYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBjYW4gb25seSBiZSB1c2VkXG4gICAgICogZm9yIHN0cmluZ3MsIG5vdCByZWd1bGFyIGV4cHJlc3Npb25zLiBZb3Ugc2ltcGx5IHBhc3MgdGhlIGlycmVndWxhciBpbiBzaW5ndWxhciBhbmQgcGx1cmFsIGZvcm0uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKiAgIFN0cmluZy5JbmZsZWN0b3IuaXJyZWd1bGFyKCdvY3RvcHVzJywgJ29jdG9waScpXG4gICAgICogICBTdHJpbmcuSW5mbGVjdG9yLmlycmVndWxhcigncGVyc29uJywgJ3Blb3BsZScpXG4gICAgICovXG4gICAgJ2lycmVndWxhcic6IGZ1bmN0aW9uKHNpbmd1bGFyLCBwbHVyYWwpIHtcbiAgICAgIHZhciBzaW5ndWxhckZpcnN0ICAgICAgPSBzaW5ndWxhci5maXJzdCgpLFxuICAgICAgICAgIHNpbmd1bGFyUmVzdCAgICAgICA9IHNpbmd1bGFyLmZyb20oMSksXG4gICAgICAgICAgcGx1cmFsRmlyc3QgICAgICAgID0gcGx1cmFsLmZpcnN0KCksXG4gICAgICAgICAgcGx1cmFsUmVzdCAgICAgICAgID0gcGx1cmFsLmZyb20oMSksXG4gICAgICAgICAgcGx1cmFsRmlyc3RVcHBlciAgID0gcGx1cmFsRmlyc3QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBwbHVyYWxGaXJzdExvd2VyICAgPSBwbHVyYWxGaXJzdC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHNpbmd1bGFyRmlyc3RVcHBlciA9IHNpbmd1bGFyRmlyc3QudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBzaW5ndWxhckZpcnN0TG93ZXIgPSBzaW5ndWxhckZpcnN0LnRvTG93ZXJDYXNlKCk7XG4gICAgICByZW1vdmVGcm9tQXJyYXkodW5jb3VudGFibGVzLCBzaW5ndWxhcik7XG4gICAgICByZW1vdmVGcm9tQXJyYXkodW5jb3VudGFibGVzLCBwbHVyYWwpO1xuICAgICAgaWYoc2luZ3VsYXJGaXJzdFVwcGVyID09IHBsdXJhbEZpcnN0VXBwZXIpIHtcbiAgICAgICAgSW5mbGVjdG9yLnBsdXJhbChuZXcgcmVnZXhwKCcoezF9KXsyfSQnLmFzc2lnbihzaW5ndWxhckZpcnN0LCBzaW5ndWxhclJlc3QpLCAnaScpLCAnJDEnICsgcGx1cmFsUmVzdCk7XG4gICAgICAgIEluZmxlY3Rvci5wbHVyYWwobmV3IHJlZ2V4cCgnKHsxfSl7Mn0kJy5hc3NpZ24ocGx1cmFsRmlyc3QsIHBsdXJhbFJlc3QpLCAnaScpLCAnJDEnICsgcGx1cmFsUmVzdCk7XG4gICAgICAgIEluZmxlY3Rvci5zaW5ndWxhcihuZXcgcmVnZXhwKCcoezF9KXsyfSQnLmFzc2lnbihwbHVyYWxGaXJzdCwgcGx1cmFsUmVzdCksICdpJyksICckMScgKyBzaW5ndWxhclJlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSW5mbGVjdG9yLnBsdXJhbChuZXcgcmVnZXhwKCd7MX17Mn0kJy5hc3NpZ24oc2luZ3VsYXJGaXJzdFVwcGVyLCBzaW5ndWxhclJlc3QpKSwgcGx1cmFsRmlyc3RVcHBlciArIHBsdXJhbFJlc3QpO1xuICAgICAgICBJbmZsZWN0b3IucGx1cmFsKG5ldyByZWdleHAoJ3sxfXsyfSQnLmFzc2lnbihzaW5ndWxhckZpcnN0TG93ZXIsIHNpbmd1bGFyUmVzdCkpLCBwbHVyYWxGaXJzdExvd2VyICsgcGx1cmFsUmVzdCk7XG4gICAgICAgIEluZmxlY3Rvci5wbHVyYWwobmV3IHJlZ2V4cCgnezF9ezJ9JCcuYXNzaWduKHBsdXJhbEZpcnN0VXBwZXIsIHBsdXJhbFJlc3QpKSwgcGx1cmFsRmlyc3RVcHBlciArIHBsdXJhbFJlc3QpO1xuICAgICAgICBJbmZsZWN0b3IucGx1cmFsKG5ldyByZWdleHAoJ3sxfXsyfSQnLmFzc2lnbihwbHVyYWxGaXJzdExvd2VyLCBwbHVyYWxSZXN0KSksIHBsdXJhbEZpcnN0TG93ZXIgKyBwbHVyYWxSZXN0KTtcbiAgICAgICAgSW5mbGVjdG9yLnNpbmd1bGFyKG5ldyByZWdleHAoJ3sxfXsyfSQnLmFzc2lnbihwbHVyYWxGaXJzdFVwcGVyLCBwbHVyYWxSZXN0KSksIHNpbmd1bGFyRmlyc3RVcHBlciArIHNpbmd1bGFyUmVzdCk7XG4gICAgICAgIEluZmxlY3Rvci5zaW5ndWxhcihuZXcgcmVnZXhwKCd7MX17Mn0kJy5hc3NpZ24ocGx1cmFsRmlyc3RMb3dlciwgcGx1cmFsUmVzdCkpLCBzaW5ndWxhckZpcnN0TG93ZXIgKyBzaW5ndWxhclJlc3QpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEFkZCB1bmNvdW50YWJsZSB3b3JkcyB0aGF0IHNob3VsZG4ndCBiZSBhdHRlbXB0ZWQgaW5mbGVjdGVkLlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICogICBTdHJpbmcuSW5mbGVjdG9yLnVuY291bnRhYmxlKCdtb25leScpXG4gICAgICogICBTdHJpbmcuSW5mbGVjdG9yLnVuY291bnRhYmxlKCdtb25leScsICdpbmZvcm1hdGlvbicpXG4gICAgICogICBTdHJpbmcuSW5mbGVjdG9yLnVuY291bnRhYmxlKFsnbW9uZXknLCAnaW5mb3JtYXRpb24nLCAncmljZSddKVxuICAgICAqL1xuICAgICd1bmNvdW50YWJsZSc6IGZ1bmN0aW9uKGZpcnN0KSB7XG4gICAgICB2YXIgYWRkID0gYXJyYXkuaXNBcnJheShmaXJzdCkgPyBmaXJzdCA6IG11bHRpQXJncyhhcmd1bWVudHMpO1xuICAgICAgdW5jb3VudGFibGVzID0gdW5jb3VudGFibGVzLmNvbmNhdChhZGQpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIFNwZWNpZmllcyBhIGh1bWFuaXplZCBmb3JtIG9mIGEgc3RyaW5nIGJ5IGEgcmVndWxhciBleHByZXNzaW9uIHJ1bGUgb3IgYnkgYSBzdHJpbmcgbWFwcGluZy5cbiAgICAgKiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNzaW9uIGJhc2VkIHJlcGxhY2VtZW50LCB0aGUgbm9ybWFsIGh1bWFuaXplIGZvcm1hdHRpbmcgaXMgY2FsbGVkIGFmdGVyIHRoZSByZXBsYWNlbWVudC5cbiAgICAgKiBXaGVuIGEgc3RyaW5nIGlzIHVzZWQsIHRoZSBodW1hbiBmb3JtIHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgZGVzaXJlZCAoZXhhbXBsZTogJ1RoZSBuYW1lJywgbm90ICd0aGVfbmFtZScpXG4gICAgICpcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKiAgIFN0cmluZy5JbmZsZWN0b3IuaHVtYW4oL19jbnQkL2ksICdfY291bnQnKVxuICAgICAqICAgU3RyaW5nLkluZmxlY3Rvci5odW1hbignbGVnYWN5X2NvbF9wZXJzb25fbmFtZScsICdOYW1lJylcbiAgICAgKi9cbiAgICAnaHVtYW4nOiBmdW5jdGlvbihydWxlLCByZXBsYWNlbWVudCkge1xuICAgICAgaHVtYW5zLnVuc2hpZnQoeyBydWxlOiBydWxlLCByZXBsYWNlbWVudDogcmVwbGFjZW1lbnQgfSlcbiAgICB9LFxuXG5cbiAgICAvKlxuICAgICAqIENsZWFycyB0aGUgbG9hZGVkIGluZmxlY3Rpb25zIHdpdGhpbiBhIGdpdmVuIHNjb3BlIChkZWZhdWx0IGlzICdhbGwnKS5cbiAgICAgKiBPcHRpb25zIGFyZTogJ2FsbCcsICdwbHVyYWxzJywgJ3Npbmd1bGFycycsICd1bmNvdW50YWJsZXMnLCAnaHVtYW5zJy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqICAgU3RyaW5nLkluZmxlY3Rvci5jbGVhcignYWxsJylcbiAgICAgKiAgIFN0cmluZy5JbmZsZWN0b3IuY2xlYXIoJ3BsdXJhbHMnKVxuICAgICAqL1xuICAgICdjbGVhcic6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmKHBhcmFtTWF0Y2hlc1R5cGUodHlwZSwgJ3Npbmd1bGFycycpKSAgICBzaW5ndWxhcnMgICAgPSBbXTtcbiAgICAgIGlmKHBhcmFtTWF0Y2hlc1R5cGUodHlwZSwgJ3BsdXJhbHMnKSkgICAgICBwbHVyYWxzICAgICAgPSBbXTtcbiAgICAgIGlmKHBhcmFtTWF0Y2hlc1R5cGUodHlwZSwgJ3VuY291bnRhYmxlcycpKSB1bmNvdW50YWJsZXMgPSBbXTtcbiAgICAgIGlmKHBhcmFtTWF0Y2hlc1R5cGUodHlwZSwgJ2h1bWFucycpKSAgICAgICBodW1hbnMgICAgICAgPSBbXTtcbiAgICAgIGlmKHBhcmFtTWF0Y2hlc1R5cGUodHlwZSwgJ2Fjcm9ueW1zJykpICAgICBhY3JvbnltcyAgICAgPSB7fTtcbiAgICB9XG5cbiAgfTtcblxuICBEb3duY2FzZWQgPSBbXG4gICAgJ2FuZCcsICdvcicsICdub3InLCAnYScsICdhbicsICd0aGUnLCAnc28nLCAnYnV0JywgJ3RvJywgJ29mJywgJ2F0JyxcbiAgICAnYnknLCAnZnJvbScsICdpbnRvJywgJ29uJywgJ29udG8nLCAnb2ZmJywgJ291dCcsICdpbicsICdvdmVyJyxcbiAgICAnd2l0aCcsICdmb3InXG4gIF07XG5cbiAgSW5mbGVjdG9yLnBsdXJhbCgvJC8sICdzJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoL3MkL2dpLCAncycpO1xuICBJbmZsZWN0b3IucGx1cmFsKC8oYXh8dGVzdClpcyQvZ2ksICckMWVzJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoLyhvY3RvcHx2aXJ8ZnVuZ3xmb2N8cmFkaXxhbHVtbikoaXx1cykkL2dpLCAnJDFpJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoLyhjZW5zdXN8YWxpYXN8c3RhdHVzKSQvZ2ksICckMWVzJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoLyhidSlzJC9naSwgJyQxc2VzJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoLyhidWZmYWx8dG9tYXQpbyQvZ2ksICckMW9lcycpO1xuICBJbmZsZWN0b3IucGx1cmFsKC8oW3RpXSl1bSQvZ2ksICckMWEnKTtcbiAgSW5mbGVjdG9yLnBsdXJhbCgvKFt0aV0pYSQvZ2ksICckMWEnKTtcbiAgSW5mbGVjdG9yLnBsdXJhbCgvc2lzJC9naSwgJ3NlcycpO1xuICBJbmZsZWN0b3IucGx1cmFsKC9mK2U/JC9naSwgJ3ZlcycpO1xuICBJbmZsZWN0b3IucGx1cmFsKC8oY3VmZnxyb29mKSQvZ2ksICckMXMnKTtcbiAgSW5mbGVjdG9yLnBsdXJhbCgvKFtodF1pdmUpJC9naSwgJyQxcycpO1xuICBJbmZsZWN0b3IucGx1cmFsKC8oW15hZWlvdXldbykkL2dpLCAnJDFlcycpO1xuICBJbmZsZWN0b3IucGx1cmFsKC8oW15hZWlvdXldfHF1KXkkL2dpLCAnJDFpZXMnKTtcbiAgSW5mbGVjdG9yLnBsdXJhbCgvKHh8Y2h8c3N8c2gpJC9naSwgJyQxZXMnKTtcbiAgSW5mbGVjdG9yLnBsdXJhbCgvKG1hdHJ8dmVydHxpbmQpKD86aXh8ZXgpJC9naSwgJyQxaWNlcycpO1xuICBJbmZsZWN0b3IucGx1cmFsKC8oW21sXSlvdXNlJC9naSwgJyQxaWNlJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoLyhbbWxdKWljZSQvZ2ksICckMWljZScpO1xuICBJbmZsZWN0b3IucGx1cmFsKC9eKG94KSQvZ2ksICckMWVuJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoL14ob3hlbikkL2dpLCAnJDEnKTtcbiAgSW5mbGVjdG9yLnBsdXJhbCgvKHF1aXopJC9naSwgJyQxemVzJyk7XG4gIEluZmxlY3Rvci5wbHVyYWwoLyhwaG90fGNhbnR8aG9tfHplcnxwaWFufHBvcnRpY3xwcnxxdWFydHxraW1vbilvJC9naSwgJyQxb3MnKTtcbiAgSW5mbGVjdG9yLnBsdXJhbCgvKGNyYWZ0KSQvZ2ksICckMScpO1xuICBJbmZsZWN0b3IucGx1cmFsKC8oW2Z0XSlbZW9dezJ9KHRoPykkL2dpLCAnJDFlZSQyJyk7XG5cbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC9zJC9naSwgJycpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyhbcHN0XVthaXVdcykkL2dpLCAnJDEnKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8oW2FlaW91eV0pc3MkL2dpLCAnJDFzcycpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyhuKWV3cyQvZ2ksICckMWV3cycpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyhbdGldKWEkL2dpLCAnJDF1bScpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLygoYSluYWx5fChiKWF8KGQpaWFnbm98KHApYXJlbnRoZXwocClyb2dub3wocyl5bm9wfCh0KWhlKXNlcyQvZ2ksICckMSQyc2lzJyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvKF5hbmFseSlzZXMkL2dpLCAnJDFzaXMnKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8oaSkoZnx2ZXMpJC9pLCAnJDFmZScpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyhbYWVvbHJdZj8pKGZ8dmVzKSQvaSwgJyQxZicpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyhbaHRdaXZlKXMkL2dpLCAnJDEnKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8oW15hZWlvdXldfHF1KWllcyQvZ2ksICckMXknKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8ocyllcmllcyQvZ2ksICckMWVyaWVzJyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvKG0pb3ZpZXMkL2dpLCAnJDFvdmllJyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvKHh8Y2h8c3N8c2gpZXMkL2dpLCAnJDEnKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8oW21sXSkob3VzfGljKWUkL2dpLCAnJDFvdXNlJyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvKGJ1cykoZXMpPyQvZ2ksICckMScpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyhvKWVzJC9naSwgJyQxJyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvKHNob2Upcz8kL2dpLCAnJDEnKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8oY3Jpc3xheHx0ZXN0KVtpZV1zJC9naSwgJyQxaXMnKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8ob2N0b3B8dmlyfGZ1bmd8Zm9jfHJhZGl8YWx1bW4pKGl8dXMpJC9naSwgJyQxdXMnKTtcbiAgSW5mbGVjdG9yLnNpbmd1bGFyKC8oY2Vuc3VzfGFsaWFzfHN0YXR1cykoZXMpPyQvZ2ksICckMScpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoL14ob3gpKGVuKT8vZ2ksICckMScpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyh2ZXJ0fGluZCkoZXh8aWNlcykkL2dpLCAnJDFleCcpO1xuICBJbmZsZWN0b3Iuc2luZ3VsYXIoLyhtYXRyKShpeHxpY2VzKSQvZ2ksICckMWl4Jyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvKHF1aXopKHplcyk/JC9naSwgJyQxJyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvKGRhdGFiYXNlKXM/JC9naSwgJyQxJyk7XG4gIEluZmxlY3Rvci5zaW5ndWxhcigvZWUodGg/KSQvZ2ksICdvbyQxJyk7XG5cbiAgSW5mbGVjdG9yLmlycmVndWxhcigncGVyc29uJywgJ3Blb3BsZScpO1xuICBJbmZsZWN0b3IuaXJyZWd1bGFyKCdtYW4nLCAnbWVuJyk7XG4gIEluZmxlY3Rvci5pcnJlZ3VsYXIoJ2NoaWxkJywgJ2NoaWxkcmVuJyk7XG4gIEluZmxlY3Rvci5pcnJlZ3VsYXIoJ3NleCcsICdzZXhlcycpO1xuICBJbmZsZWN0b3IuaXJyZWd1bGFyKCdtb3ZlJywgJ21vdmVzJyk7XG4gIEluZmxlY3Rvci5pcnJlZ3VsYXIoJ3NhdmUnLCAnc2F2ZXMnKTtcbiAgSW5mbGVjdG9yLmlycmVndWxhcignY293JywgJ2tpbmUnKTtcbiAgSW5mbGVjdG9yLmlycmVndWxhcignZ29vc2UnLCAnZ2Vlc2UnKTtcbiAgSW5mbGVjdG9yLmlycmVndWxhcignem9tYmllJywgJ3pvbWJpZXMnKTtcblxuICBJbmZsZWN0b3IudW5jb3VudGFibGUoJ2VxdWlwbWVudCxpbmZvcm1hdGlvbixyaWNlLG1vbmV5LHNwZWNpZXMsc2VyaWVzLGZpc2gsc2hlZXAsamVhbnMnLnNwbGl0KCcsJykpO1xuXG5cbiAgZXh0ZW5kKHN0cmluZywgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgcGx1cmFsaXplKClcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgUmV0dXJucyB0aGUgcGx1cmFsIGZvcm0gb2YgdGhlIHdvcmQgaW4gdGhlIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAncG9zdCcucGx1cmFsaXplKCkgICAgICAgICAtPiAncG9zdHMnXG4gICAgICogICAnb2N0b3B1cycucGx1cmFsaXplKCkgICAgICAtPiAnb2N0b3BpJ1xuICAgICAqICAgJ3NoZWVwJy5wbHVyYWxpemUoKSAgICAgICAgLT4gJ3NoZWVwJ1xuICAgICAqICAgJ3dvcmRzJy5wbHVyYWxpemUoKSAgICAgICAgLT4gJ3dvcmRzJ1xuICAgICAqICAgJ0NhbWVsT2N0b3B1cycucGx1cmFsaXplKCkgLT4gJ0NhbWVsT2N0b3BpJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAncGx1cmFsaXplJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaW5mbGVjdCh0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2Qgc2luZ3VsYXJpemUoKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBUaGUgcmV2ZXJzZSBvZiBTdHJpbmcjcGx1cmFsaXplLiBSZXR1cm5zIHRoZSBzaW5ndWxhciBmb3JtIG9mIGEgd29yZCBpbiBhIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAncG9zdHMnLnNpbmd1bGFyaXplKCkgICAgICAgLT4gJ3Bvc3QnXG4gICAgICogICAnb2N0b3BpJy5zaW5ndWxhcml6ZSgpICAgICAgLT4gJ29jdG9wdXMnXG4gICAgICogICAnc2hlZXAnLnNpbmd1bGFyaXplKCkgICAgICAgLT4gJ3NoZWVwJ1xuICAgICAqICAgJ3dvcmQnLnNpbmd1bGFyaXplKCkgICAgICAgIC0+ICd3b3JkJ1xuICAgICAqICAgJ0NhbWVsT2N0b3BpJy5zaW5ndWxhcml6ZSgpIC0+ICdDYW1lbE9jdG9wdXMnXG4gICAgICpcbiAgICAgKioqL1xuICAgICdzaW5ndWxhcml6ZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGluZmxlY3QodGhpcywgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCBodW1hbml6ZSgpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IENyZWF0ZXMgYSBodW1hbiByZWFkYWJsZSBzdHJpbmcuXG4gICAgICogQGV4dHJhIENhcGl0YWxpemVzIHRoZSBmaXJzdCB3b3JkIGFuZCB0dXJucyB1bmRlcnNjb3JlcyBpbnRvIHNwYWNlcyBhbmQgc3RyaXBzIGEgdHJhaWxpbmcgJ19pZCcsIGlmIGFueS4gTGlrZSBTdHJpbmcjdGl0bGVpemUsIHRoaXMgaXMgbWVhbnQgZm9yIGNyZWF0aW5nIHByZXR0eSBvdXRwdXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ2VtcGxveWVlX3NhbGFyeScuaHVtYW5pemUoKSAtPiAnRW1wbG95ZWUgc2FsYXJ5J1xuICAgICAqICAgJ2F1dGhvcl9pZCcuaHVtYW5pemUoKSAgICAgICAtPiAnQXV0aG9yJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnaHVtYW5pemUnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHIgPSBydW5SZXBsYWNlbWVudHModGhpcywgaHVtYW5zKSwgYWNyb255bTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9faWQkL2csICcnKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXyk/KFthLXpcXGRdKikvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBfLCB3b3JkKXtcbiAgICAgICAgYWNyb255bSA9IGhhc093blByb3BlcnR5KGFjcm9ueW1zLCB3b3JkKSA/IGFjcm9ueW1zW3dvcmRdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIChfID8gJyAnIDogJycpICsgKGFjcm9ueW0gfHwgd29yZC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhcGl0YWxpemUoc3RyKTtcbiAgICB9LFxuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgdGl0bGVpemUoKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBDcmVhdGVzIGEgdGl0bGUgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICAgICAqIEBleHRyYSBDYXBpdGFsaXplcyBhbGwgdGhlIHdvcmRzIGFuZCByZXBsYWNlcyBzb21lIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0byBjcmVhdGUgYSBuaWNlciBsb29raW5nIHRpdGxlLiBTdHJpbmcjdGl0bGVpemUgaXMgbWVhbnQgZm9yIGNyZWF0aW5nIHByZXR0eSBvdXRwdXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ21hbiBmcm9tIHRoZSBib29uZG9ja3MnLnRpdGxlaXplKCkgLT4gJ01hbiBmcm9tIHRoZSBCb29uZG9ja3MnXG4gICAgICogICAneC1tZW46IHRoZSBsYXN0IHN0YW5kJy50aXRsZWl6ZSgpIC0+ICdYIE1lbjogVGhlIExhc3QgU3RhbmQnXG4gICAgICogICAnVGhlTWFuV2l0aG91dEFQYXN0Jy50aXRsZWl6ZSgpIC0+ICdUaGUgTWFuIFdpdGhvdXQgYSBQYXN0J1xuICAgICAqICAgJ3JhaWRlcnNfb2ZfdGhlX2xvc3RfYXJrJy50aXRsZWl6ZSgpIC0+ICdSYWlkZXJzIG9mIHRoZSBMb3N0IEFyaydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ3RpdGxlaXplJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZnVsbFN0b3BQdW5jdHVhdGlvbiA9IC9bLjo7IV0kLywgaGFzUHVuY3R1YXRpb24sIGxhc3RIYWRQdW5jdHVhdGlvbiwgaXNGaXJzdE9yTGFzdDtcbiAgICAgIHJldHVybiB0aGlzLnNwYWNpZnkoKS5odW1hbml6ZSgpLndvcmRzKGZ1bmN0aW9uKHdvcmQsIGluZGV4LCB3b3Jkcykge1xuICAgICAgICBoYXNQdW5jdHVhdGlvbiA9IGZ1bGxTdG9wUHVuY3R1YXRpb24udGVzdCh3b3JkKTtcbiAgICAgICAgaXNGaXJzdE9yTGFzdCA9IGluZGV4ID09IDAgfHwgaW5kZXggPT0gd29yZHMubGVuZ3RoIC0gMSB8fCBoYXNQdW5jdHVhdGlvbiB8fCBsYXN0SGFkUHVuY3R1YXRpb247XG4gICAgICAgIGxhc3RIYWRQdW5jdHVhdGlvbiA9IGhhc1B1bmN0dWF0aW9uO1xuICAgICAgICBpZihpc0ZpcnN0T3JMYXN0IHx8IERvd25jYXNlZC5pbmRleE9mKHdvcmQpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjYXBpdGFsaXplKHdvcmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB3b3JkO1xuICAgICAgICB9XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIHBhcmFtZXRlcml6ZSgpXG4gICAgICogQHJldHVybnMgU3RyaW5nXG4gICAgICogQHNob3J0IFJlcGxhY2VzIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBhIHN0cmluZyBzbyB0aGF0IGl0IG1heSBiZSB1c2VkIGFzIHBhcnQgb2YgYSBwcmV0dHkgVVJMLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICdoZWxsLCBubyEnLnBhcmFtZXRlcml6ZSgpIC0+ICdoZWxsLW5vJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAncGFyYW1ldGVyaXplJzogZnVuY3Rpb24oc2VwYXJhdG9yKSB7XG4gICAgICB2YXIgc3RyID0gdGhpcztcbiAgICAgIGlmKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSBzZXBhcmF0b3IgPSAnLSc7XG4gICAgICBpZihzdHIubm9ybWFsaXplKSB7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXmEtejAtOVxcLV9dKy9naSwgc2VwYXJhdG9yKVxuICAgICAgaWYoc2VwYXJhdG9yKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyByZWdleHAoJ157c2VwfSt8e3NlcH0rJHwoe3NlcH0pe3NlcH0rJy5hc3NpZ24oeyAnc2VwJzogZXNjYXBlUmVnRXhwKHNlcGFyYXRvcikgfSksICdnJyksICckMScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kZVVSSShzdHIudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIHN0cmluZy5JbmZsZWN0b3IgPSBJbmZsZWN0b3I7XG4gIHN0cmluZy5JbmZsZWN0b3IuYWNyb255bXMgPSBhY3JvbnltcztcblxuXG4gIC8qKipcbiAgICpcbiAgICogQHBhY2thZ2UgTGFuZ3VhZ2VcbiAgICogQGRlcGVuZGVuY3kgc3RyaW5nXG4gICAqIEBkZXNjcmlwdGlvbiBEZXRlY3RpbmcgbGFuZ3VhZ2UgYnkgY2hhcmFjdGVyIGJsb2NrLiBGdWxsLXdpZHRoIDwtPiBoYWxmLXdpZHRoIGNoYXJhY3RlciBjb252ZXJzaW9uLiBIaXJhZ2FuYSBhbmQgS2F0YWthbmEgY29udmVyc2lvbnMuXG4gICAqXG4gICAqKiovXG5cbiAgLyoqKlxuICAgKiBTdHJpbmcgbW9kdWxlXG4gICAqXG4gICAqKiovXG5cblxuICAvKioqXG4gICAqIEBtZXRob2QgaGFzW1NjcmlwdF0oKVxuICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb250YWlucyBhbnkgY2hhcmFjdGVycyBpbiB0aGF0IHNjcmlwdC5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIGhhc0FyYWJpY1xuICAgKiAgIGhhc0N5cmlsbGljXG4gICAqICAgaGFzR3JlZWtcbiAgICogICBoYXNIYW5ndWxcbiAgICogICBoYXNIYW5cbiAgICogICBoYXNLYW5qaVxuICAgKiAgIGhhc0hlYnJld1xuICAgKiAgIGhhc0hpcmFnYW5hXG4gICAqICAgaGFzS2FuYVxuICAgKiAgIGhhc0thdGFrYW5hXG4gICAqICAgaGFzTGF0aW5cbiAgICogICBoYXNUaGFpXG4gICAqICAgaGFzRGV2YW5hZ2FyaVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICfYo9iq2YPZhNmFJy5oYXNBcmFiaWMoKSAgICAgICAgICAtPiB0cnVlXG4gICAqICAgJ9Cy0LjQt9C40YInLmhhc0N5cmlsbGljKCkgICAgICAgIC0+IHRydWVcbiAgICogICAn7J6YIOuoueqyoOyKteuLiOuLpCEnLmhhc0hhbmd1bCgpIC0+IHRydWVcbiAgICogICAn44Of44OD44Kv44K544Gn44GZJy5oYXNLYXRha2FuYSgpIC0+IHRydWVcbiAgICogICBcImwnYW5uw6llXCIuaGFzTGF0aW4oKSAgICAgICAgIC0+IHRydWVcbiAgICpcbiAgICoqKlxuICAgKiBAbWV0aG9kIGlzW1NjcmlwdF0oKVxuICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAqIEBzaG9ydCBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb250YWlucyBvbmx5IGNoYXJhY3RlcnMgaW4gdGhhdCBzY3JpcHQuIFdoaXRlc3BhY2UgaXMgaWdub3JlZC5cbiAgICpcbiAgICogQHNldFxuICAgKiAgIGlzQXJhYmljXG4gICAqICAgaXNDeXJpbGxpY1xuICAgKiAgIGlzR3JlZWtcbiAgICogICBpc0hhbmd1bFxuICAgKiAgIGlzSGFuXG4gICAqICAgaXNLYW5qaVxuICAgKiAgIGlzSGVicmV3XG4gICAqICAgaXNIaXJhZ2FuYVxuICAgKiAgIGlzS2FuYVxuICAgKiAgIGlzS2F0YWthbmFcbiAgICogICBpc0thdGFrYW5hXG4gICAqICAgaXNUaGFpXG4gICAqICAgaXNEZXZhbmFnYXJpXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgJ9ij2KrZg9mE2YUnLmlzQXJhYmljKCkgICAgICAgICAgLT4gdHJ1ZVxuICAgKiAgICfQstC40LfQuNGCJy5pc0N5cmlsbGljKCkgICAgICAgIC0+IHRydWVcbiAgICogICAn7J6YIOuoueqyoOyKteuLiOuLpCEnLmlzSGFuZ3VsKCkgLT4gdHJ1ZVxuICAgKiAgICfjg5/jg4Pjgq/jgrnjgafjgZknLmlzS2F0YWthbmEoKSAtPiBmYWxzZVxuICAgKiAgIFwibCdhbm7DqWVcIi5pc0xhdGluKCkgICAgICAgICAtPiB0cnVlXG4gICAqXG4gICAqKiovXG4gIHZhciB1bmljb2RlU2NyaXB0cyA9IFtcbiAgICB7IG5hbWVzOiBbJ0FyYWJpYyddLCAgICAgIHNvdXJjZTogJ1xcdTA2MDAtXFx1MDZGRicgfSxcbiAgICB7IG5hbWVzOiBbJ0N5cmlsbGljJ10sICAgIHNvdXJjZTogJ1xcdTA0MDAtXFx1MDRGRicgfSxcbiAgICB7IG5hbWVzOiBbJ0RldmFuYWdhcmknXSwgIHNvdXJjZTogJ1xcdTA5MDAtXFx1MDk3RicgfSxcbiAgICB7IG5hbWVzOiBbJ0dyZWVrJ10sICAgICAgIHNvdXJjZTogJ1xcdTAzNzAtXFx1MDNGRicgfSxcbiAgICB7IG5hbWVzOiBbJ0hhbmd1bCddLCAgICAgIHNvdXJjZTogJ1xcdUFDMDAtXFx1RDdBRlxcdTExMDAtXFx1MTFGRicgfSxcbiAgICB7IG5hbWVzOiBbJ0hhbicsJ0thbmppJ10sIHNvdXJjZTogJ1xcdTRFMDAtXFx1OUZGRlxcdUY5MDAtXFx1RkFGRicgfSxcbiAgICB7IG5hbWVzOiBbJ0hlYnJldyddLCAgICAgIHNvdXJjZTogJ1xcdTA1OTAtXFx1MDVGRicgfSxcbiAgICB7IG5hbWVzOiBbJ0hpcmFnYW5hJ10sICAgIHNvdXJjZTogJ1xcdTMwNDAtXFx1MzA5RlxcdTMwRkItXFx1MzBGQycgfSxcbiAgICB7IG5hbWVzOiBbJ0thbmEnXSwgICAgICAgIHNvdXJjZTogJ1xcdTMwNDAtXFx1MzBGRlxcdUZGNjEtXFx1RkY5RicgfSxcbiAgICB7IG5hbWVzOiBbJ0thdGFrYW5hJ10sICAgIHNvdXJjZTogJ1xcdTMwQTAtXFx1MzBGRlxcdUZGNjEtXFx1RkY5RicgfSxcbiAgICB7IG5hbWVzOiBbJ0xhdGluJ10sICAgICAgIHNvdXJjZTogJ1xcdTAwMDEtXFx1MDA3RlxcdTAwODAtXFx1MDBGRlxcdTAxMDAtXFx1MDE3RlxcdTAxODAtXFx1MDI0RicgfSxcbiAgICB7IG5hbWVzOiBbJ1RoYWknXSwgICAgICAgIHNvdXJjZTogJ1xcdTBFMDAtXFx1MEU3RicgfVxuICBdO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkVW5pY29kZVNjcmlwdHMoKSB7XG4gICAgdW5pY29kZVNjcmlwdHMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgaXMgPSByZWdleHAoJ15bJytzLnNvdXJjZSsnXFxcXHNdKyQnKTtcbiAgICAgIHZhciBoYXMgPSByZWdleHAoJ1snK3Muc291cmNlKyddJyk7XG4gICAgICBzLm5hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShzdHJpbmcucHJvdG90eXBlLCAnaXMnICsgbmFtZSwgZnVuY3Rpb24oKSB7IHJldHVybiBpcy50ZXN0KHRoaXMudHJpbSgpKTsgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHN0cmluZy5wcm90b3R5cGUsICdoYXMnICsgbmFtZSwgZnVuY3Rpb24oKSB7IHJldHVybiBoYXMudGVzdCh0aGlzKTsgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFN1cHBvcnQgZm9yIGNvbnZlcnRpbmcgY2hhcmFjdGVyIHdpZHRocyBhbmQga2F0YWthbmEgdG8gaGlyYWdhbmEuXG5cbiAgdmFyIEhBTEZfV0lEVEhfVE9fRlVMTF9XSURUSF9UUkFWRVJTQUwgPSA2NTI0ODtcblxuICB2YXIgd2lkdGhDb252ZXJzaW9uUmFuZ2VzID0gW1xuICAgIHsgdHlwZTogJ2EnLCBzdGFydDogNjUsICBlbmQ6IDkwICB9LFxuICAgIHsgdHlwZTogJ2EnLCBzdGFydDogOTcsICBlbmQ6IDEyMiB9LFxuICAgIHsgdHlwZTogJ24nLCBzdGFydDogNDgsICBlbmQ6IDU3ICB9LFxuICAgIHsgdHlwZTogJ3AnLCBzdGFydDogMzMsICBlbmQ6IDQ3ICB9LFxuICAgIHsgdHlwZTogJ3AnLCBzdGFydDogNTgsICBlbmQ6IDY0ICB9LFxuICAgIHsgdHlwZTogJ3AnLCBzdGFydDogOTEsICBlbmQ6IDk2ICB9LFxuICAgIHsgdHlwZTogJ3AnLCBzdGFydDogMTIzLCBlbmQ6IDEyNiB9XG4gIF07XG5cbiAgdmFyIFdpZHRoQ29udmVyc2lvblRhYmxlO1xuICB2YXIgYWxsSGFua2FrdSAgID0gL1tcXHUwMDIwLVxcdTAwQTVdfFtcXHVGRjYxLVxcdUZGOUZdW+++nu++n10/L2c7XG4gIHZhciBhbGxaZW5rYWt1ICAgPSAvW1xcdTMwMDAtXFx1MzAxQ118W1xcdTMwMUEtXFx1MzBGQ118W1xcdUZGMDEtXFx1RkY2MF18W1xcdUZGRTAtXFx1RkZFNl0vZztcbiAgdmFyIGhhbmtha3VQdW5jdHVhdGlvbiAgPSAn772h772k772i772jwqXCosKjJztcbiAgdmFyIHplbmtha3VQdW5jdHVhdGlvbiAgPSAn44CC44CB44CM44CN77+l77+g77+hJztcbiAgdmFyIHZvaWNlZEthdGFrYW5hICAgICAgPSAvW+OCq+OCreOCr+OCseOCs+OCteOCt+OCueOCu+OCveOCv+ODgeODhOODhuODiOODj+ODkuODleODmOODm10vO1xuICB2YXIgc2VtaVZvaWNlZEthdGFrYW5hICA9IC9b44OP44OS44OV44OY44Ob44OyXS87XG4gIHZhciBoYW5rYWt1S2F0YWthbmEgICAgID0gJ++9se+9su+9s++9tO+9te+9p++9qO+9qe+9qu+9q++9tu+9t++9uO+9ue+9uu+9u++9vO+9ve+9vu+9v+++gO++ge++gu+9r+++g+++hO++he++hu++h+++iO++ie++iu++i+++jO++je++ju++j+++kO++ke++ku++k+++lO+9rO++le+9re++lu+9ru++l+++mO++me++mu++m+++nO+9pu++ne+9sO+9pSc7XG4gIHZhciB6ZW5rYWt1S2F0YWthbmEgICAgID0gJ+OCouOCpOOCpuOCqOOCquOCoeOCo+OCpeOCp+OCqeOCq+OCreOCr+OCseOCs+OCteOCt+OCueOCu+OCveOCv+ODgeODhOODg+ODhuODiOODiuODi+ODjOODjeODjuODj+ODkuODleODmOODm+ODnuODn+ODoOODoeODouODpOODo+ODpuODpeODqOODp+ODqeODquODq+ODrOODreODr+ODsuODs+ODvOODuyc7XG5cbiAgZnVuY3Rpb24gY29udmVydENoYXJhY3RlcldpZHRoKHN0ciwgYXJncywgcmVnLCB0eXBlKSB7XG4gICAgaWYoIVdpZHRoQ29udmVyc2lvblRhYmxlKSB7XG4gICAgICBidWlsZFdpZHRoQ29udmVyc2lvblRhYmxlcygpO1xuICAgIH1cbiAgICB2YXIgbW9kZSA9IG11bHRpQXJncyhhcmdzKS5qb2luKCcnKSwgdGFibGUgPSBXaWR0aENvbnZlcnNpb25UYWJsZVt0eXBlXTtcbiAgICBtb2RlID0gbW9kZS5yZXBsYWNlKC9hbGwvLCAnJykucmVwbGFjZSgvKFxcdylscGhhYmV0fHVtYmVycz98YXRha2FuYXxwYWNlcz98dW5jdHVhdGlvbi9nLCAnJDEnKTtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnLCBmdW5jdGlvbihjKSB7XG4gICAgICBpZih0YWJsZVtjXSAmJiAoIW1vZGUgfHwgbW9kZS5oYXModGFibGVbY10udHlwZSkpKSB7XG4gICAgICAgIHJldHVybiB0YWJsZVtjXS50bztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRXaWR0aENvbnZlcnNpb25UYWJsZXMoKSB7XG4gICAgdmFyIGhhbmtha3U7XG4gICAgV2lkdGhDb252ZXJzaW9uVGFibGUgPSB7XG4gICAgICAnemVua2FrdSc6IHt9LFxuICAgICAgJ2hhbmtha3UnOiB7fVxuICAgIH07XG4gICAgd2lkdGhDb252ZXJzaW9uUmFuZ2VzLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgc2ltcGxlUmVwZWF0KHIuZW5kIC0gci5zdGFydCArIDEsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiArPSByLnN0YXJ0O1xuICAgICAgICBzZXRXaWR0aENvbnZlcnNpb24oci50eXBlLCBjaHIobiksIGNocihuICsgSEFMRl9XSURUSF9UT19GVUxMX1dJRFRIX1RSQVZFUlNBTCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgemVua2FrdUthdGFrYW5hLmVhY2goZnVuY3Rpb24oYywgaSkge1xuICAgICAgaGFua2FrdSA9IGhhbmtha3VLYXRha2FuYS5jaGFyQXQoaSk7XG4gICAgICBzZXRXaWR0aENvbnZlcnNpb24oJ2snLCBoYW5rYWt1LCBjKTtcbiAgICAgIGlmKGMubWF0Y2godm9pY2VkS2F0YWthbmEpKSB7XG4gICAgICAgIHNldFdpZHRoQ29udmVyc2lvbignaycsIGhhbmtha3UgKyAn776eJywgYy5zaGlmdCgxKSk7XG4gICAgICB9XG4gICAgICBpZihjLm1hdGNoKHNlbWlWb2ljZWRLYXRha2FuYSkpIHtcbiAgICAgICAgc2V0V2lkdGhDb252ZXJzaW9uKCdrJywgaGFua2FrdSArICfvvp8nLCBjLnNoaWZ0KDIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB6ZW5rYWt1UHVuY3R1YXRpb24uZWFjaChmdW5jdGlvbihjLCBpKSB7XG4gICAgICBzZXRXaWR0aENvbnZlcnNpb24oJ3AnLCBoYW5rYWt1UHVuY3R1YXRpb24uY2hhckF0KGkpLCBjKTtcbiAgICB9KTtcbiAgICBzZXRXaWR0aENvbnZlcnNpb24oJ2snLCAn772z776eJywgJ+ODtCcpO1xuICAgIHNldFdpZHRoQ29udmVyc2lvbignaycsICfvvabvvp4nLCAn44O6Jyk7XG4gICAgc2V0V2lkdGhDb252ZXJzaW9uKCdzJywgJyAnLCAn44CAJyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRXaWR0aENvbnZlcnNpb24odHlwZSwgaGFsZiwgZnVsbCkge1xuICAgIFdpZHRoQ29udmVyc2lvblRhYmxlWyd6ZW5rYWt1J11baGFsZl0gPSB7IHR5cGU6IHR5cGUsIHRvOiBmdWxsIH07XG4gICAgV2lkdGhDb252ZXJzaW9uVGFibGVbJ2hhbmtha3UnXVtmdWxsXSA9IHsgdHlwZTogdHlwZSwgdG86IGhhbGYgfTtcbiAgfVxuXG5cbiAgZXh0ZW5kKHN0cmluZywgdHJ1ZSwgdHJ1ZSwge1xuXG4gICAgLyoqKlxuICAgICAqIEBtZXRob2QgaGFua2FrdShbbW9kZV0gPSAnYWxsJylcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgQ29udmVydHMgZnVsbC13aWR0aCBjaGFyYWN0ZXJzICh6ZW5rYWt1KSB0byBoYWxmLXdpZHRoIChoYW5rYWt1KS5cbiAgICAgKiBAZXh0cmEgW21vZGVdIGFjY2VwdHMgYW55IGNvbWJpbmF0aW9uIG9mIFwiYVwiIChhbHBoYWJldCksIFwiblwiIChudW1iZXJzKSwgXCJrXCIgKGthdGFrYW5hKSwgXCJzXCIgKHNwYWNlcyksIFwicFwiIChwdW5jdHVhdGlvbiksIG9yIFwiYWxsXCIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgJ+OCv+ODreOCpuOAgO+8ue+8oe+8re+8oe+8pO+8oeOBp+OBme+8gScuaGFua2FrdSgpICAgICAgICAgICAgICAgICAgICAgIC0+ICfvvoDvvpvvvbMgWUFNQURB44Gn44GZISdcbiAgICAgKiAgICfjgr/jg63jgqbjgIDvvLnvvKHvvK3vvKHvvKTvvKHjgafjgZnvvIEnLmhhbmtha3UoJ2EnKSAgICAgICAgICAgICAgICAgICAtPiAn44K/44Ot44Km44CAWUFNQURB44Gn44GZ77yBJ1xuICAgICAqICAgJ+OCv+ODreOCpuOAgO+8ue+8oe+8re+8oe+8pO+8oeOBp+OBme+8gScuaGFua2FrdSgnYWxwaGFiZXQnKSAgICAgICAgICAgIC0+ICfjgr/jg63jgqbjgIBZQU1BREHjgafjgZnvvIEnXG4gICAgICogICAn44K/44Ot44Km44Gn44GZ77yB44CA77yS77yV5q2z44Gn44GZ77yBJy5oYW5rYWt1KCdrYXRha2FuYScsICdudW1iZXJzJykgLT4gJ+++gO++m++9s+OBp+OBme+8geOAgDI15q2z44Gn44GZ77yBJ1xuICAgICAqICAgJ+OCv+ODreOCpuOBp+OBme+8geOAgO+8ku+8leats+OBp+OBme+8gScuaGFua2FrdSgnaycsICduJykgICAgICAgICAgICAgIC0+ICfvvoDvvpvvvbPjgafjgZnvvIHjgIAyNeats+OBp+OBme+8gSdcbiAgICAgKiAgICfjgr/jg63jgqbjgafjgZnvvIHjgIDvvJLvvJXmrbPjgafjgZnvvIEnLmhhbmtha3UoJ2tuJykgICAgICAgICAgICAgICAgICAtPiAn776A776b772z44Gn44GZ77yB44CAMjXmrbPjgafjgZnvvIEnXG4gICAgICogICAn44K/44Ot44Km44Gn44GZ77yB44CA77yS77yV5q2z44Gn44GZ77yBJy5oYW5rYWt1KCdzcCcpICAgICAgICAgICAgICAgICAgLT4gJ+OCv+ODreOCpuOBp+OBmSEg77yS77yV5q2z44Gn44GZISdcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2hhbmtha3UnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb252ZXJ0Q2hhcmFjdGVyV2lkdGgodGhpcywgYXJndW1lbnRzLCBhbGxaZW5rYWt1LCAnaGFua2FrdScpO1xuICAgIH0sXG5cbiAgICAvKioqXG4gICAgICogQG1ldGhvZCB6ZW5rYWt1KFttb2RlXSA9ICdhbGwnKVxuICAgICAqIEByZXR1cm5zIFN0cmluZ1xuICAgICAqIEBzaG9ydCBDb252ZXJ0cyBoYWxmLXdpZHRoIGNoYXJhY3RlcnMgKGhhbmtha3UpIHRvIGZ1bGwtd2lkdGggKHplbmtha3UpLlxuICAgICAqIEBleHRyYSBbbW9kZV0gYWNjZXB0cyBhbnkgY29tYmluYXRpb24gb2YgXCJhXCIgKGFscGhhYmV0KSwgXCJuXCIgKG51bWJlcnMpLCBcImtcIiAoa2F0YWthbmEpLCBcInNcIiAoc3BhY2VzKSwgXCJwXCIgKHB1bmN0dWF0aW9uKSwgb3IgXCJhbGxcIi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAn776A776b772zIFlBTUFEQeOBp+OBmSEnLnplbmtha3UoKSAgICAgICAgICAgICAgICAgICAgICAgICAtPiAn44K/44Ot44Km44CA77y577yh77yt77yh77yk77yh44Gn44GZ77yBJ1xuICAgICAqICAgJ+++gO++m++9syBZQU1BREHjgafjgZkhJy56ZW5rYWt1KCdhJykgICAgICAgICAgICAgICAgICAgICAgLT4gJ+++gO++m++9syDvvLnvvKHvvK3vvKHvvKTvvKHjgafjgZkhJ1xuICAgICAqICAgJ+++gO++m++9syBZQU1BREHjgafjgZkhJy56ZW5rYWt1KCdhbHBoYWJldCcpICAgICAgICAgICAgICAgLT4gJ+++gO++m++9syDvvLnvvKHvvK3vvKHvvKTvvKHjgafjgZkhJ1xuICAgICAqICAgJ+++gO++m++9s+OBp+OBmSEgMjXmrbPjgafjgZkhJy56ZW5rYWt1KCdrYXRha2FuYScsICdudW1iZXJzJykgLT4gJ+OCv+ODreOCpuOBp+OBmSEg77yS77yV5q2z44Gn44GZISdcbiAgICAgKiAgICfvvoDvvpvvvbPjgafjgZkhIDI15q2z44Gn44GZIScuemVua2FrdSgnaycsICduJykgICAgICAgICAgICAgIC0+ICfjgr/jg63jgqbjgafjgZkhIO+8ku+8leats+OBp+OBmSEnXG4gICAgICogICAn776A776b772z44Gn44GZISAyNeats+OBp+OBmSEnLnplbmtha3UoJ2tuJykgICAgICAgICAgICAgICAgICAtPiAn44K/44Ot44Km44Gn44GZISDvvJLvvJXmrbPjgafjgZkhJ1xuICAgICAqICAgJ+++gO++m++9s+OBp+OBmSEgMjXmrbPjgafjgZkhJy56ZW5rYWt1KCdzcCcpICAgICAgICAgICAgICAgICAgLT4gJ+++gO++m++9s+OBp+OBme+8geOAgDI15q2z44Gn44GZ77yBJ1xuICAgICAqXG4gICAgICoqKi9cbiAgICAnemVua2FrdSc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRDaGFyYWN0ZXJXaWR0aCh0aGlzLCBhcmd1bWVudHMsIGFsbEhhbmtha3UsICd6ZW5rYWt1Jyk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGhpcmFnYW5hKFthbGxdID0gdHJ1ZSlcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgQ29udmVydHMga2F0YWthbmEgaW50byBoaXJhZ2FuYS5cbiAgICAgKiBAZXh0cmEgSWYgW2FsbF0gaXMgZmFsc2UsIG9ubHkgZnVsbC13aWR0aCBrYXRha2FuYSB3aWxsIGJlIGNvbnZlcnRlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAn44Kr44K/44Kr44OKJy5oaXJhZ2FuYSgpICAgLT4gJ+OBi+OBn+OBi+OBqidcbiAgICAgKiAgICfjgrPjg7Pjg4vjg4Hjg48nLmhpcmFnYW5hKCkgLT4gJ+OBk+OCk+OBq+OBoeOBrydcbiAgICAgKiAgICfvvbbvvoDvvbbvvoUnLmhpcmFnYW5hKCkgICAgICAgLT4gJ+OBi+OBn+OBi+OBqidcbiAgICAgKiAgICfvvbbvvoDvvbbvvoUnLmhpcmFnYW5hKGZhbHNlKSAgLT4gJ++9tu++gO+9tu++hSdcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2hpcmFnYW5hJzogZnVuY3Rpb24oYWxsKSB7XG4gICAgICB2YXIgc3RyID0gdGhpcztcbiAgICAgIGlmKGFsbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc3RyID0gc3RyLnplbmtha3UoJ2snKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdTMwQTEtXFx1MzBGNl0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYy5zaGlmdCgtOTYpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKipcbiAgICAgKiBAbWV0aG9kIGthdGFrYW5hKClcbiAgICAgKiBAcmV0dXJucyBTdHJpbmdcbiAgICAgKiBAc2hvcnQgQ29udmVydHMgaGlyYWdhbmEgaW50byBrYXRha2FuYS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAn44GL44Gf44GL44GqJy5rYXRha2FuYSgpICAgLT4gJ+OCq+OCv+OCq+ODiidcbiAgICAgKiAgICfjgZPjgpPjgavjgaHjga8nLmthdGFrYW5hKCkgLT4gJ+OCs+ODs+ODi+ODgeODjydcbiAgICAgKlxuICAgICAqKiovXG4gICAgJ2thdGFrYW5hJzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9bXFx1MzA0MS1cXHUzMDk2XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBjLnNoaWZ0KDk2KTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gIH0pO1xuXG4gIGJ1aWxkVW5pY29kZVNjcmlwdHMoKTtcblxuLypcbiAqXG4gKiBEYXRlLmFkZExvY2FsZSg8Y29kZT4pIGFkZHMgdGhpcyBsb2NhbGUgdG8gU3VnYXIuXG4gKiBUbyBzZXQgdGhlIGxvY2FsZSBnbG9iYWxseSwgc2ltcGx5IGNhbGw6XG4gKlxuICogRGF0ZS5zZXRMb2NhbGUoJ2RhJyk7XG4gKlxuICogdmFyIGxvY2FsZSA9IERhdGUuZ2V0TG9jYWxlKDxjb2RlPikgd2lsbCByZXR1cm4gdGhpcyBvYmplY3QsIHdoaWNoXG4gKiBjYW4gYmUgdHdlYWtlZCB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBpbiB0aGUgbG9jYWxlcy5cbiAqXG4gKiBsb2NhbGUuYWRkRm9ybWF0IGFkZHMgYSBkYXRlIGZvcm1hdCAoc2VlIHRoaXMgZmlsZSBmb3IgZXhhbXBsZXMpLlxuICogU3BlY2lhbCB0b2tlbnMgaW4gdGhlIGRhdGUgZm9ybWF0IHdpbGwgYmUgcGFyc2VkIG91dCBpbnRvIHJlZ2V4IHRva2VuczpcbiAqXG4gKiB7MH0gaXMgYSByZWZlcmVuY2UgdG8gYW4gZW50cnkgaW4gbG9jYWxlLnRva2Vucy4gT3V0cHV0OiAoPzp0aGUpP1xuICoge3VuaXR9IGlzIGEgcmVmZXJlbmNlIHRvIGFsbCB1bml0cy4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGh8Li4uKVxuICoge3VuaXQzfSBpcyBhIHJlZmVyZW5jZSB0byBhIHNwZWNpZmljIHVuaXQuIE91dHB1dDogKGhvdXIpXG4gKiB7dW5pdDMtNX0gaXMgYSByZWZlcmVuY2UgdG8gYSBzdWJzZXQgb2YgdGhlIHVuaXRzIGFycmF5LiBPdXRwdXQ6IChob3VyfGRheXx3ZWVrKVxuICoge3VuaXQ/fSBcIj9cIiBtYWtlcyB0aGF0IHRva2VuIG9wdGlvbmFsLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aCk/XG4gKlxuICoge2RheX0gQW55IHJlZmVyZW5jZSB0byB0b2tlbnMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSB3aWxsIGluY2x1ZGUgYWxsIHdpdGggdGhlIHNhbWUgbmFtZS4gT3V0cHV0OiAoeWVzdGVyZGF5fHRvZGF5fHRvbW9ycm93KVxuICpcbiAqIEFsbCBzcGFjZXMgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBcIlxccypcIlxuICpcbiAqIExvY2FsZSBhcnJheXMgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIG51bWJlcnMsIGFzIHdlbGwgYXMgdGhlIFwic3JjXCIgZmllbGQgZm9yXG4gKiBhbGwgZW50cmllcyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IGZvbGxvdyBhIHNwZWNpYWwgZm9ybWF0IGluZGljYXRlZCBieSBhIGNvbG9uOlxuICpcbiAqIG1pbnV0ZTp8cyAgPSBtaW51dGV8bWludXRlc1xuICogdGhpY2tlOm58ciA9IHRoaWNrZW58dGhpY2tlclxuICpcbiAqIEFkZGl0aW9uYWxseSBpbiB0aGUgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIGFuZCBudW1iZXJzIGFycmF5IHRoZXNlIHdpbGwgYmUgYWRkZWQgYXQgaW5kZXhlcyB0aGF0IGFyZSBtdWx0aXBsZXNcbiAqIG9mIHRoZSByZWxldmFudCBudW1iZXIgZm9yIHJldHJpZXZhbC4gRm9yIGV4YW1wbGUgaGF2aW5nIFwic3VuZGF5OnxzXCIgaW4gdGhlIHVuaXRzIGFycmF5IHdpbGwgcmVzdWx0IGluOlxuICpcbiAqIHVuaXRzOiBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5JywgJ3N1bmRheXMnXVxuICpcbiAqIFdoZW4gbWF0Y2hlZCwgdGhlIGluZGV4IHdpbGwgYmUgZm91bmQgdXNpbmc6XG4gKlxuICogdW5pdHMuaW5kZXhPZihtYXRjaCkgJSA3O1xuICpcbiAqIFJlc3VsdGluZyBpbiB0aGUgY29ycmVjdCBpbmRleCB3aXRoIGFueSBudW1iZXIgb2YgYWx0ZXJuYXRlcyBmb3IgdGhhdCBlbnRyeS5cbiAqXG4gKi9cblxuRGF0ZS5hZGRMb2NhbGUoJ2RhJywge1xuICAncGx1cmFsJzogdHJ1ZSxcbiAgJ21vbnRocyc6ICdqYW51YXIsZmVicnVhcixtYXJ0cyxhcHJpbCxtYWosanVuaSxqdWxpLGF1Z3VzdCxzZXB0ZW1iZXIsb2t0b2Jlcixub3ZlbWJlcixkZWNlbWJlcicsXG4gICd3ZWVrZGF5cyc6ICdzw7huZGFnfHNvbmRhZyxtYW5kYWcsdGlyc2RhZyxvbnNkYWcsdG9yc2RhZyxmcmVkYWcsbMO4cmRhZ3xsb3JkYWcnLFxuICAndW5pdHMnOiAnbWlsbGlzZWt1bmQ6fGVyLHNla3VuZDp8ZXIsbWludXQ6fHRlcix0aW06ZXxlcixkYWc6fGUsdWc6ZXxlcnxlbixtw6VuZWQ6fGVyfGVuK21hYW5lZDp8ZXJ8ZW4sw6VyOnx8ZXQrYWFyOnx8ZXQnLFxuICAnbnVtYmVycyc6ICdlbnxldCx0byx0cmUsZmlyZSxmZW0sc2VrcyxzeXYsb3R0ZSxuaSx0aScsXG4gICd0b2tlbnMnOiAnZGVuLGZvcicsXG4gICdhcnRpY2xlcyc6ICdkZW4nLFxuICAnc2hvcnQnOidkLiB7ZH0uIHttb250aH0ge3l5eXl9JyxcbiAgJ2xvbmcnOiAnZGVuIHtkfS4ge21vbnRofSB7eXl5eX0ge0h9OnttbX0nLFxuICAnZnVsbCc6ICd7V2Vla2RheX0gZGVuIHtkfS4ge21vbnRofSB7eXl5eX0ge0h9OnttbX06e3NzfScsXG4gICdwYXN0JzogJ3tudW19IHt1bml0fSB7c2lnbn0nLFxuICAnZnV0dXJlJzogJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAnZHVyYXRpb24nOiAne251bX0ge3VuaXR9JyxcbiAgJ2FtcG0nOiAnYW0scG0nLFxuICAnbW9kaWZpZXJzJzogW1xuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdmb3Jnw6Vyc3xpIGZvcmfDpXJzfGZvcmdhYXJzfGkgZm9yZ2FhcnMnLCAndmFsdWUnOiAtMiB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdpIGfDpXJ8aWfDpXJ8aSBnYWFyfGlnYWFyJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnaSBkYWd8aWRhZycsICd2YWx1ZSc6IDAgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnaSBtb3JnZW58aW1vcmdlbicsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnb3ZlciBtb3Jnb258b3Zlcm1vcmdlbnxpIG92ZXIgbW9yZ2VufGkgb3Zlcm1vcmdlbnxpb3Zlcm1vcmdlbicsICd2YWx1ZSc6IDIgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ3NpZGVuJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ29tJywgJ3ZhbHVlJzogIDEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICdpIHNpZHN0ZXxzaWRzdGUnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ2Rlbm5lJywgJ3ZhbHVlJzogMCB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ27DpnN0ZXxuYWVzdGUnLCAndmFsdWUnOiAxIH1cbiAgXSxcbiAgJ2RhdGVQYXJzZSc6IFtcbiAgICAne251bX0ge3VuaXR9IHtzaWdufScsXG4gICAgJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAgICd7MT99IHtudW19IHt1bml0fSB7c2lnbn0nLFxuICAgICd7c2hpZnR9IHt1bml0PTUtN30nXG4gIF0sXG4gICd0aW1lUGFyc2UnOiBbXG4gICAgJ3swP30ge3dlZWtkYXk/fSB7ZGF0ZT99IHttb250aH0ge3llYXJ9JyxcbiAgICAne2RhdGV9IHttb250aH0nLFxuICAgICd7c2hpZnR9IHt3ZWVrZGF5fSdcbiAgXVxufSk7XG5cbi8qXG4gKlxuICogRGF0ZS5hZGRMb2NhbGUoPGNvZGU+KSBhZGRzIHRoaXMgbG9jYWxlIHRvIFN1Z2FyLlxuICogVG8gc2V0IHRoZSBsb2NhbGUgZ2xvYmFsbHksIHNpbXBseSBjYWxsOlxuICpcbiAqIERhdGUuc2V0TG9jYWxlKCdkZScpO1xuICpcbiAqIHZhciBsb2NhbGUgPSBEYXRlLmdldExvY2FsZSg8Y29kZT4pIHdpbGwgcmV0dXJuIHRoaXMgb2JqZWN0LCB3aGljaFxuICogY2FuIGJlIHR3ZWFrZWQgdG8gY2hhbmdlIHRoZSBiZWhhdmlvciBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgaW4gdGhlIGxvY2FsZXMuXG4gKlxuICogbG9jYWxlLmFkZEZvcm1hdCBhZGRzIGEgZGF0ZSBmb3JtYXQgKHNlZSB0aGlzIGZpbGUgZm9yIGV4YW1wbGVzKS5cbiAqIFNwZWNpYWwgdG9rZW5zIGluIHRoZSBkYXRlIGZvcm1hdCB3aWxsIGJlIHBhcnNlZCBvdXQgaW50byByZWdleCB0b2tlbnM6XG4gKlxuICogezB9IGlzIGEgcmVmZXJlbmNlIHRvIGFuIGVudHJ5IGluIGxvY2FsZS50b2tlbnMuIE91dHB1dDogKD86dGhlKT9cbiAqIHt1bml0fSBpcyBhIHJlZmVyZW5jZSB0byBhbGwgdW5pdHMuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRofC4uLilcbiAqIHt1bml0M30gaXMgYSByZWZlcmVuY2UgdG8gYSBzcGVjaWZpYyB1bml0LiBPdXRwdXQ6IChob3VyKVxuICoge3VuaXQzLTV9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3Vic2V0IG9mIHRoZSB1bml0cyBhcnJheS4gT3V0cHV0OiAoaG91cnxkYXl8d2VlaylcbiAqIHt1bml0P30gXCI/XCIgbWFrZXMgdGhhdCB0b2tlbiBvcHRpb25hbC4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGgpP1xuICpcbiAqIHtkYXl9IEFueSByZWZlcmVuY2UgdG8gdG9rZW5zIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgd2lsbCBpbmNsdWRlIGFsbCB3aXRoIHRoZSBzYW1lIG5hbWUuIE91dHB1dDogKHllc3RlcmRheXx0b2RheXx0b21vcnJvdylcbiAqXG4gKiBBbGwgc3BhY2VzIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gXCJcXHMqXCJcbiAqXG4gKiBMb2NhbGUgYXJyYXlzIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBudW1iZXJzLCBhcyB3ZWxsIGFzIHRoZSBcInNyY1wiIGZpZWxkIGZvclxuICogYWxsIGVudHJpZXMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSBmb2xsb3cgYSBzcGVjaWFsIGZvcm1hdCBpbmRpY2F0ZWQgYnkgYSBjb2xvbjpcbiAqXG4gKiBtaW51dGU6fHMgID0gbWludXRlfG1pbnV0ZXNcbiAqIHRoaWNrZTpufHIgPSB0aGlja2VufHRoaWNrZXJcbiAqXG4gKiBBZGRpdGlvbmFsbHkgaW4gdGhlIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBhbmQgbnVtYmVycyBhcnJheSB0aGVzZSB3aWxsIGJlIGFkZGVkIGF0IGluZGV4ZXMgdGhhdCBhcmUgbXVsdGlwbGVzXG4gKiBvZiB0aGUgcmVsZXZhbnQgbnVtYmVyIGZvciByZXRyaWV2YWwuIEZvciBleGFtcGxlIGhhdmluZyBcInN1bmRheTp8c1wiIGluIHRoZSB1bml0cyBhcnJheSB3aWxsIHJlc3VsdCBpbjpcbiAqXG4gKiB1bml0czogWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheScsICdzdW5kYXlzJ11cbiAqXG4gKiBXaGVuIG1hdGNoZWQsIHRoZSBpbmRleCB3aWxsIGJlIGZvdW5kIHVzaW5nOlxuICpcbiAqIHVuaXRzLmluZGV4T2YobWF0Y2gpICUgNztcbiAqXG4gKiBSZXN1bHRpbmcgaW4gdGhlIGNvcnJlY3QgaW5kZXggd2l0aCBhbnkgbnVtYmVyIG9mIGFsdGVybmF0ZXMgZm9yIHRoYXQgZW50cnkuXG4gKlxuICovXG5cbkRhdGUuYWRkTG9jYWxlKCdkZScsIHtcbiAgJ3BsdXJhbCc6IHRydWUsXG4gICAnY2FwaXRhbGl6ZVVuaXQnOiB0cnVlLFxuICAnbW9udGhzJzogJ0phbnVhcixGZWJydWFyLE3DpHJ6fE1hcnosQXByaWwsTWFpLEp1bmksSnVsaSxBdWd1c3QsU2VwdGVtYmVyLE9rdG9iZXIsTm92ZW1iZXIsRGV6ZW1iZXInLFxuICAnd2Vla2RheXMnOiAnU29ubnRhZyxNb250YWcsRGllbnN0YWcsTWl0dHdvY2gsRG9ubmVyc3RhZyxGcmVpdGFnLFNhbXN0YWcnLFxuICAndW5pdHMnOiAnTWlsbGlzZWt1bmRlOnxuLFNla3VuZGU6fG4sTWludXRlOnxuLFN0dW5kZTp8bixUYWc6fGVuLFdvY2hlOnxuLE1vbmF0OnxlbixKYWhyOnxlbicsXG4gICdudW1iZXJzJzogJ2Vpbjp8ZXxlcnxlbnxlbSx6d2VpLGRyZWksdmllcixmdWVuZixzZWNocyxzaWViZW4sYWNodCxuZXVuLHplaG4nLFxuICAndG9rZW5zJzogJ2RlcicsXG4gICdzaG9ydCc6J3tkfS4ge01vbnRofSB7eXl5eX0nLFxuICAnbG9uZyc6ICd7ZH0uIHtNb250aH0ge3l5eXl9IHtIfTp7bW19JyxcbiAgJ2Z1bGwnOiAne1dlZWtkYXl9IHtkfS4ge01vbnRofSB7eXl5eX0ge0h9OnttbX06e3NzfScsXG4gICdwYXN0JzogJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAnZnV0dXJlJzogJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAnZHVyYXRpb24nOiAne251bX0ge3VuaXR9JyxcbiAgJ3RpbWVNYXJrZXInOiAndW0nLFxuICAnYW1wbSc6ICdhbSxwbScsXG4gICdtb2RpZmllcnMnOiBbXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ3Zvcmdlc3Rlcm4nLCAndmFsdWUnOiAtMiB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdnZXN0ZXJuJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnaGV1dGUnLCAndmFsdWUnOiAwIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ21vcmdlbicsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnw7xiZXJtb3JnZW58dWJlcm1vcmdlbnx1ZWJlcm1vcmdlbicsICd2YWx1ZSc6IDIgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ3Zvcjp8aGVyJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ2luJywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ2xldHp0ZTp8cnxufHMnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ27DpGNoc3RlOnxyfG58cytuYWNoc3RlOnxyfG58cytuYWVjaHN0ZTp8cnxufHMra29tbWVuZGU6bnxyJywgJ3ZhbHVlJzogMSB9XG4gIF0sXG4gICdkYXRlUGFyc2UnOiBbXG4gICAgJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAgICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgICAne3NoaWZ0fSB7dW5pdD01LTd9J1xuICBdLFxuICAndGltZVBhcnNlJzogW1xuICAgICd7d2Vla2RheT99IHtkYXRlP30ge21vbnRofSB7eWVhcj99JyxcbiAgICAne3NoaWZ0fSB7d2Vla2RheX0nXG4gIF1cbn0pO1xuXG4vKlxuICpcbiAqIERhdGUuYWRkTG9jYWxlKDxjb2RlPikgYWRkcyB0aGlzIGxvY2FsZSB0byBTdWdhci5cbiAqIFRvIHNldCB0aGUgbG9jYWxlIGdsb2JhbGx5LCBzaW1wbHkgY2FsbDpcbiAqXG4gKiBEYXRlLnNldExvY2FsZSgnZXMnKTtcbiAqXG4gKiB2YXIgbG9jYWxlID0gRGF0ZS5nZXRMb2NhbGUoPGNvZGU+KSB3aWxsIHJldHVybiB0aGlzIG9iamVjdCwgd2hpY2hcbiAqIGNhbiBiZSB0d2Vha2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgcGFyc2luZy9mb3JtYXR0aW5nIGluIHRoZSBsb2NhbGVzLlxuICpcbiAqIGxvY2FsZS5hZGRGb3JtYXQgYWRkcyBhIGRhdGUgZm9ybWF0IChzZWUgdGhpcyBmaWxlIGZvciBleGFtcGxlcykuXG4gKiBTcGVjaWFsIHRva2VucyBpbiB0aGUgZGF0ZSBmb3JtYXQgd2lsbCBiZSBwYXJzZWQgb3V0IGludG8gcmVnZXggdG9rZW5zOlxuICpcbiAqIHswfSBpcyBhIHJlZmVyZW5jZSB0byBhbiBlbnRyeSBpbiBsb2NhbGUudG9rZW5zLiBPdXRwdXQ6ICg/OnRoZSk/XG4gKiB7dW5pdH0gaXMgYSByZWZlcmVuY2UgdG8gYWxsIHVuaXRzLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aHwuLi4pXG4gKiB7dW5pdDN9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3BlY2lmaWMgdW5pdC4gT3V0cHV0OiAoaG91cilcbiAqIHt1bml0My01fSBpcyBhIHJlZmVyZW5jZSB0byBhIHN1YnNldCBvZiB0aGUgdW5pdHMgYXJyYXkuIE91dHB1dDogKGhvdXJ8ZGF5fHdlZWspXG4gKiB7dW5pdD99IFwiP1wiIG1ha2VzIHRoYXQgdG9rZW4gb3B0aW9uYWwuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRoKT9cbiAqXG4gKiB7ZGF5fSBBbnkgcmVmZXJlbmNlIHRvIHRva2VucyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IHdpbGwgaW5jbHVkZSBhbGwgd2l0aCB0aGUgc2FtZSBuYW1lLiBPdXRwdXQ6ICh5ZXN0ZXJkYXl8dG9kYXl8dG9tb3Jyb3cpXG4gKlxuICogQWxsIHNwYWNlcyBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIFwiXFxzKlwiXG4gKlxuICogTG9jYWxlIGFycmF5cyBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgbnVtYmVycywgYXMgd2VsbCBhcyB0aGUgXCJzcmNcIiBmaWVsZCBmb3JcbiAqIGFsbCBlbnRyaWVzIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgZm9sbG93IGEgc3BlY2lhbCBmb3JtYXQgaW5kaWNhdGVkIGJ5IGEgY29sb246XG4gKlxuICogbWludXRlOnxzICA9IG1pbnV0ZXxtaW51dGVzXG4gKiB0aGlja2U6bnxyID0gdGhpY2tlbnx0aGlja2VyXG4gKlxuICogQWRkaXRpb25hbGx5IGluIHRoZSBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgYW5kIG51bWJlcnMgYXJyYXkgdGhlc2Ugd2lsbCBiZSBhZGRlZCBhdCBpbmRleGVzIHRoYXQgYXJlIG11bHRpcGxlc1xuICogb2YgdGhlIHJlbGV2YW50IG51bWJlciBmb3IgcmV0cmlldmFsLiBGb3IgZXhhbXBsZSBoYXZpbmcgXCJzdW5kYXk6fHNcIiBpbiB0aGUgdW5pdHMgYXJyYXkgd2lsbCByZXN1bHQgaW46XG4gKlxuICogdW5pdHM6IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknLCAnc3VuZGF5cyddXG4gKlxuICogV2hlbiBtYXRjaGVkLCB0aGUgaW5kZXggd2lsbCBiZSBmb3VuZCB1c2luZzpcbiAqXG4gKiB1bml0cy5pbmRleE9mKG1hdGNoKSAlIDc7XG4gKlxuICogUmVzdWx0aW5nIGluIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggYW55IG51bWJlciBvZiBhbHRlcm5hdGVzIGZvciB0aGF0IGVudHJ5LlxuICpcbiAqL1xuXG5EYXRlLmFkZExvY2FsZSgnZXMnLCB7XG4gICdwbHVyYWwnOiB0cnVlLFxuICAnbW9udGhzJzogJ2VuZXJvLGZlYnJlcm8sbWFyem8sYWJyaWwsbWF5byxqdW5pbyxqdWxpbyxhZ29zdG8sc2VwdGllbWJyZSxvY3R1YnJlLG5vdmllbWJyZSxkaWNpZW1icmUnLFxuICAnd2Vla2RheXMnOiAnZG9taW5nbyxsdW5lcyxtYXJ0ZXMsbWnDqXJjb2xlc3xtaWVyY29sZXMsanVldmVzLHZpZXJuZXMsc8OhYmFkb3xzYWJhZG8nLFxuICAndW5pdHMnOiAnbWlsaXNlZ3VuZG86fHMsc2VndW5kbzp8cyxtaW51dG86fHMsaG9yYTp8cyxkw61hfGTDrWFzfGRpYXxkaWFzLHNlbWFuYTp8cyxtZXM6fGVzLGHDsW98YcOxb3N8YW5vfGFub3MnLFxuICAnbnVtYmVycyc6ICd1bm8sZG9zLHRyZXMsY3VhdHJvLGNpbmNvLHNlaXMsc2lldGUsb2NobyxudWV2ZSxkaWV6JyxcbiAgJ3Rva2Vucyc6ICdlbCxsYSxkZScsXG4gICdzaG9ydCc6J3tkfSB7bW9udGh9IHt5eXl5fScsXG4gICdsb25nJzogJ3tkfSB7bW9udGh9IHt5eXl5fSB7SH06e21tfScsXG4gICdmdWxsJzogJ3tXZWVrZGF5fSB7ZH0ge21vbnRofSB7eXl5eX0ge0h9OnttbX06e3NzfScsXG4gICdwYXN0JzogJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAnZnV0dXJlJzogJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAnZHVyYXRpb24nOiAne251bX0ge3VuaXR9JyxcbiAgJ3RpbWVNYXJrZXInOiAnYSBsYXMnLFxuICAnYW1wbSc6ICdhbSxwbScsXG4gICdtb2RpZmllcnMnOiBbXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ2FudGVheWVyJywgJ3ZhbHVlJzogLTIgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnYXllcicsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ2hveScsICd2YWx1ZSc6IDAgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnbWHDsWFuYXxtYW5hbmEnLCAndmFsdWUnOiAxIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICdoYWNlJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ2RlbnRybyBkZScsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICdwYXNhZDpvfGEnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ3Byw7N4aW1vfHByw7N4aW1hfHByb3hpbW98cHJveGltYScsICd2YWx1ZSc6IDEgfVxuICBdLFxuICAnZGF0ZVBhcnNlJzogW1xuICAgICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgICAne251bX0ge3VuaXR9IHtzaWdufScsXG4gICAgJ3swP317MT99IHt1bml0PTUtN30ge3NoaWZ0fScsXG4gICAgJ3swP317MT99IHtzaGlmdH0ge3VuaXQ9NS03fSdcbiAgXSxcbiAgJ3RpbWVQYXJzZSc6IFtcbiAgICAne3NoaWZ0fSB7d2Vla2RheX0nLFxuICAgICd7d2Vla2RheX0ge3NoaWZ0fScsXG4gICAgJ3tkYXRlP30gezI/fSB7bW9udGh9IHsyP30ge3llYXI/fSdcbiAgXVxufSk7XG5EYXRlLmFkZExvY2FsZSgnZmknLCB7XG4gICAgJ3BsdXJhbCc6ICAgICB0cnVlLFxuICAgICd0aW1lTWFya2VyJzogJ2tlbGxvJyxcbiAgICAnYW1wbSc6ICAgICAgICcsJyxcbiAgICAnbW9udGhzJzogICAgICd0YW1taWt1dSxoZWxtaWt1dSxtYWFsaXNrdXUsaHVodGlrdXUsdG91a29rdXUsa2Vzw6RrdXUsaGVpbsOka3V1LGVsb2t1dSxzeXlza3V1LGxva2FrdXUsbWFycmFza3V1LGpvdWx1a3V1JyxcbiAgICAnd2Vla2RheXMnOiAgICdzdW5udW50YWksbWFhbmFudGFpLHRpaXN0YWksa2Vza2l2aWlra28sdG9yc3RhaSxwZXJqYW50YWksbGF1YW50YWknLFxuICAgICd1bml0cyc6ICAgICAgJ21pbGxpc2VrdW46dGl8dGlhfHRlamF8dGluYXxuaW4sc2VrdW46dGl8dGlhfHRlamF8dGluYXxuaW4sbWludXV0OnRpfHRpYXx0ZWphfHRpbmF8aW4sdHVuOnRpfHRpYXx0ZWphfHRpbmF8bmluLHDDpGl2OsOkfMOkw6R8acOkfMOkbsOkfMOkbix2aWlrOmtvfGtvYXxrb2phfG9ufGtvbmEsa3V1a2F1OnNpfHNpYXx0dGF8ZGVufHRlbmEsdnVvOnNpfHNpYXx0dGF8ZGVufHRlbmEnLFxuICAgICdudW1iZXJzJzogICAgJ3lrc2l8ZW5zaW1tw6RpbmVuLGtha3NpfHRvaW5lbixrb2xtOmV8YXMsbmVsasOkOnMsdmlpOnNpfGRlcyxrdXU6c2l8ZGVzLHNlaXRzZW3DpDpufHMsa2FoZGVrc2E6bnxzLHloZGVrc8OkOm58cyxreW1tZW5lOm58cycsXG4gICAgJ2FydGljbGVzJzogICAnJyxcbiAgICAnb3B0aW9uYWxzJzogICcnLFxuICAgICdzaG9ydCc6ICAgICAgJ3tkfS4ge21vbnRofXRhIHt5eXl5fScsXG4gICAgJ2xvbmcnOiAgICAgICAne2R9LiB7bW9udGh9dGEge3l5eXl9IGtlbGxvIHtIfS57bW19JyxcbiAgICAnZnVsbCc6ICAgICAgICd7V2Vla2RheX1uYSB7ZH0uIHttb250aH10YSB7eXl5eX0ga2VsbG8ge0h9LnttbX0nLFxuICAgICdyZWxhdGl2ZSc6ICAgICAgIGZ1bmN0aW9uKG51bSwgdW5pdCwgbXMsIGZvcm1hdCkge1xuICAgICAgdmFyIHVuaXRzID0gdGhpc1sndW5pdHMnXTtcbiAgICAgIGZ1bmN0aW9uIG51bWJlcldpdGhVbml0KG11bHQpIHtcbiAgICAgICAgcmV0dXJuIChudW0gPT09IDEgPyAnJyA6IG51bSArICcgJykgKyB1bml0c1soOCAqIG11bHQpICsgdW5pdF07XG4gICAgICB9XG4gICAgICBzd2l0Y2goZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ2R1cmF0aW9uJzogIHJldHVybiBudW1iZXJXaXRoVW5pdCgwKTtcbiAgICAgICAgY2FzZSAncGFzdCc6ICAgICAgcmV0dXJuIG51bWJlcldpdGhVbml0KG51bSA+IDEgPyAxIDogMCkgKyAnIHNpdHRlbic7XG4gICAgICAgIGNhc2UgJ2Z1dHVyZSc6ICAgIHJldHVybiBudW1iZXJXaXRoVW5pdCg0KSArICcgcMOkw6RzdMOkJztcbiAgICAgIH1cbiAgICB9LFxuICAgICdtb2RpZmllcnMnOiBbXG4gICAgICAgIHsgJ25hbWUnOiAnZGF5JywgICAnc3JjJzogJ3RvaXNzYSBww6RpdsOkbsOkfHRvaXNzYSBww6RpdsOkaXN0w6QnLCAndmFsdWUnOiAtMiB9LFxuICAgICAgICB7ICduYW1lJzogJ2RheScsICAgJ3NyYyc6ICdlaWxlbnxlaWxpc3TDpCcsICd2YWx1ZSc6IC0xIH0sXG4gICAgICAgIHsgJ25hbWUnOiAnZGF5JywgICAnc3JjJzogJ3TDpG7DpMOkbicsICd2YWx1ZSc6IDAgfSxcbiAgICAgICAgeyAnbmFtZSc6ICdkYXknLCAgICdzcmMnOiAnaHVvbWVubmF8aHVvbWlzdGEnLCAndmFsdWUnOiAxIH0sXG4gICAgICAgIHsgJ25hbWUnOiAnZGF5JywgICAnc3JjJzogJ3lsaWh1b21lbm5hfHlsaWh1b21pc3RhJywgJ3ZhbHVlJzogMiB9LFxuICAgICAgICB7ICduYW1lJzogJ3NpZ24nLCAgJ3NyYyc6ICdzaXR0ZW58YWllbW1pbicsICd2YWx1ZSc6IC0xIH0sXG4gICAgICAgIHsgJ25hbWUnOiAnc2lnbicsICAnc3JjJzogJ3DDpMOkc3TDpHxrdWx1dHR1YXxtecO2aGVtbWluJywgJ3ZhbHVlJzogMSB9LFxuICAgICAgICB7ICduYW1lJzogJ2VkZ2UnLCAgJ3NyYyc6ICd2aWltZWluZW58dmlpbWVpc2Vuw6QnLCAndmFsdWUnOiAtMiB9LFxuICAgICAgICB7ICduYW1lJzogJ2VkZ2UnLCAgJ3NyYyc6ICdsb3B1c3NhJywgJ3ZhbHVlJzogLTEgfSxcbiAgICAgICAgeyAnbmFtZSc6ICdlZGdlJywgICdzcmMnOiAnZW5zaW1tw6RpbmVufGVuc2ltbcOkaXNlbsOkJywgJ3ZhbHVlJzogMSB9LFxuICAgICAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICdlZGVsbGluZW58ZWRlbGxpc2Vuw6R8ZWRlbHTDpHbDpHxlZGVsdMOkdsOkbsOkfHZpaW1lfHRvaXNzYScsICd2YWx1ZSc6IC0xIH0sXG4gICAgICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ3TDpG7DpHx0w6Rtw6RuJywgJ3ZhbHVlJzogMCB9LFxuICAgICAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICdzZXVyYWF2YXxzZXVyYWF2YW5hfHR1bGV2YXx0dWxldmFuYXxlbnNpJywgJ3ZhbHVlJzogMSB9XG4gICAgXSxcbiAgICAnZGF0ZVBhcnNlJzogW1xuICAgICAgICAne251bX0ge3VuaXR9IHtzaWdufScsXG4gICAgICAgICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgICAgICAgJ3tudW19IHt1bml0PTQtNX0ge3NpZ259IHtkYXl9JyxcbiAgICAgICAgJ3ttb250aH0ge3llYXJ9JyxcbiAgICAgICAgJ3tzaGlmdH0ge3VuaXQ9NS03fSdcbiAgICBdLFxuICAgICd0aW1lUGFyc2UnOiBbXG4gICAgICAgICd7MH0ge251bX17MX0ge2RheX0gb2Yge21vbnRofSB7eWVhcj99JyxcbiAgICAgICAgJ3t3ZWVrZGF5P30ge21vbnRofSB7ZGF0ZX17MX0ge3llYXI/fScsXG4gICAgICAgICd7ZGF0ZX0ge21vbnRofSB7eWVhcn0nLFxuICAgICAgICAne3NoaWZ0fSB7d2Vla2RheX0nLFxuICAgICAgICAne3NoaWZ0fSB3ZWVrIHt3ZWVrZGF5fScsXG4gICAgICAgICd7d2Vla2RheX0gezJ9IHtzaGlmdH0gd2VlaycsXG4gICAgICAgICd7MH0ge2RhdGV9ezF9IG9mIHttb250aH0nLFxuICAgICAgICAnezB9e21vbnRoP30ge2RhdGU/fXsxfSBvZiB7c2hpZnR9IHt1bml0PTYtN30nXG4gICAgXVxufSk7XG4vKlxuICpcbiAqIERhdGUuYWRkTG9jYWxlKDxjb2RlPikgYWRkcyB0aGlzIGxvY2FsZSB0byBTdWdhci5cbiAqIFRvIHNldCB0aGUgbG9jYWxlIGdsb2JhbGx5LCBzaW1wbHkgY2FsbDpcbiAqXG4gKiBEYXRlLnNldExvY2FsZSgnZnInKTtcbiAqXG4gKiB2YXIgbG9jYWxlID0gRGF0ZS5nZXRMb2NhbGUoPGNvZGU+KSB3aWxsIHJldHVybiB0aGlzIG9iamVjdCwgd2hpY2hcbiAqIGNhbiBiZSB0d2Vha2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgcGFyc2luZy9mb3JtYXR0aW5nIGluIHRoZSBsb2NhbGVzLlxuICpcbiAqIGxvY2FsZS5hZGRGb3JtYXQgYWRkcyBhIGRhdGUgZm9ybWF0IChzZWUgdGhpcyBmaWxlIGZvciBleGFtcGxlcykuXG4gKiBTcGVjaWFsIHRva2VucyBpbiB0aGUgZGF0ZSBmb3JtYXQgd2lsbCBiZSBwYXJzZWQgb3V0IGludG8gcmVnZXggdG9rZW5zOlxuICpcbiAqIHswfSBpcyBhIHJlZmVyZW5jZSB0byBhbiBlbnRyeSBpbiBsb2NhbGUudG9rZW5zLiBPdXRwdXQ6ICg/OnRoZSk/XG4gKiB7dW5pdH0gaXMgYSByZWZlcmVuY2UgdG8gYWxsIHVuaXRzLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aHwuLi4pXG4gKiB7dW5pdDN9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3BlY2lmaWMgdW5pdC4gT3V0cHV0OiAoaG91cilcbiAqIHt1bml0My01fSBpcyBhIHJlZmVyZW5jZSB0byBhIHN1YnNldCBvZiB0aGUgdW5pdHMgYXJyYXkuIE91dHB1dDogKGhvdXJ8ZGF5fHdlZWspXG4gKiB7dW5pdD99IFwiP1wiIG1ha2VzIHRoYXQgdG9rZW4gb3B0aW9uYWwuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRoKT9cbiAqXG4gKiB7ZGF5fSBBbnkgcmVmZXJlbmNlIHRvIHRva2VucyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IHdpbGwgaW5jbHVkZSBhbGwgd2l0aCB0aGUgc2FtZSBuYW1lLiBPdXRwdXQ6ICh5ZXN0ZXJkYXl8dG9kYXl8dG9tb3Jyb3cpXG4gKlxuICogQWxsIHNwYWNlcyBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIFwiXFxzKlwiXG4gKlxuICogTG9jYWxlIGFycmF5cyBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgbnVtYmVycywgYXMgd2VsbCBhcyB0aGUgXCJzcmNcIiBmaWVsZCBmb3JcbiAqIGFsbCBlbnRyaWVzIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgZm9sbG93IGEgc3BlY2lhbCBmb3JtYXQgaW5kaWNhdGVkIGJ5IGEgY29sb246XG4gKlxuICogbWludXRlOnxzICA9IG1pbnV0ZXxtaW51dGVzXG4gKiB0aGlja2U6bnxyID0gdGhpY2tlbnx0aGlja2VyXG4gKlxuICogQWRkaXRpb25hbGx5IGluIHRoZSBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgYW5kIG51bWJlcnMgYXJyYXkgdGhlc2Ugd2lsbCBiZSBhZGRlZCBhdCBpbmRleGVzIHRoYXQgYXJlIG11bHRpcGxlc1xuICogb2YgdGhlIHJlbGV2YW50IG51bWJlciBmb3IgcmV0cmlldmFsLiBGb3IgZXhhbXBsZSBoYXZpbmcgXCJzdW5kYXk6fHNcIiBpbiB0aGUgdW5pdHMgYXJyYXkgd2lsbCByZXN1bHQgaW46XG4gKlxuICogdW5pdHM6IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknLCAnc3VuZGF5cyddXG4gKlxuICogV2hlbiBtYXRjaGVkLCB0aGUgaW5kZXggd2lsbCBiZSBmb3VuZCB1c2luZzpcbiAqXG4gKiB1bml0cy5pbmRleE9mKG1hdGNoKSAlIDc7XG4gKlxuICogUmVzdWx0aW5nIGluIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggYW55IG51bWJlciBvZiBhbHRlcm5hdGVzIGZvciB0aGF0IGVudHJ5LlxuICpcbiAqL1xuXG5EYXRlLmFkZExvY2FsZSgnZnInLCB7XG4gICdwbHVyYWwnOiB0cnVlLFxuICAnbW9udGhzJzogJ2phbnZpZXIsZsOpdnJpZXJ8ZmV2cmllcixtYXJzLGF2cmlsLG1haSxqdWluLGp1aWxsZXQsYW/Du3Qsc2VwdGVtYnJlLG9jdG9icmUsbm92ZW1icmUsZMOpY2VtYnJlfGRlY2VtYnJlJyxcbiAgJ3dlZWtkYXlzJzogJ2RpbWFuY2hlLGx1bmRpLG1hcmRpLG1lcmNyZWRpLGpldWRpLHZlbmRyZWRpLHNhbWVkaScsXG4gICd1bml0cyc6ICdtaWxsaXNlY29uZGU6fHMsc2Vjb25kZTp8cyxtaW51dGU6fHMsaGV1cmU6fHMsam91cjp8cyxzZW1haW5lOnxzLG1vaXMsYW46fHN8bsOpZXxuZWUnLFxuICAnbnVtYmVycyc6ICd1bjp8ZSxkZXV4LHRyb2lzLHF1YXRyZSxjaW5xLHNpeCxzZXB0LGh1aXQsbmV1ZixkaXgnLFxuICAndG9rZW5zJzogXCJsJ3xsYXxsZVwiLFxuICAnc2hvcnQnOid7ZH0ge21vbnRofSB7eXl5eX0nLFxuICAnbG9uZyc6ICd7ZH0ge21vbnRofSB7eXl5eX0ge0h9OnttbX0nLFxuICAnZnVsbCc6ICd7V2Vla2RheX0ge2R9IHttb250aH0ge3l5eXl9IHtIfTp7bW19Ontzc30nLFxuICAncGFzdCc6ICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgJ2Z1dHVyZSc6ICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgJ2R1cmF0aW9uJzogJ3tudW19IHt1bml0fScsXG4gICd0aW1lTWFya2VyJzogJ8OgJyxcbiAgJ2FtcG0nOiAnYW0scG0nLFxuICAnbW9kaWZpZXJzJzogW1xuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdoaWVyJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiBcImF1am91cmQnaHVpXCIsICd2YWx1ZSc6IDAgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnZGVtYWluJywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAnaWwgeSBhJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogXCJkYW5zfGQnaWNpXCIsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICdkZXJuaTrDqHJ8ZXJ8w6hyZXxlcmUnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ3Byb2NoYWluOnxlJywgJ3ZhbHVlJzogMSB9XG4gIF0sXG4gICdkYXRlUGFyc2UnOiBbXG4gICAgJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAgICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgICAnezA/fSB7dW5pdD01LTd9IHtzaGlmdH0nXG4gIF0sXG4gICd0aW1lUGFyc2UnOiBbXG4gICAgJ3t3ZWVrZGF5P30gezA/fSB7ZGF0ZT99IHttb250aH0ge3llYXI/fScsXG4gICAgJ3swP30ge3dlZWtkYXl9IHtzaGlmdH0nXG4gIF1cbn0pO1xuXG4vKlxuICpcbiAqIERhdGUuYWRkTG9jYWxlKDxjb2RlPikgYWRkcyB0aGlzIGxvY2FsZSB0byBTdWdhci5cbiAqIFRvIHNldCB0aGUgbG9jYWxlIGdsb2JhbGx5LCBzaW1wbHkgY2FsbDpcbiAqXG4gKiBEYXRlLnNldExvY2FsZSgnaXQnKTtcbiAqXG4gKiB2YXIgbG9jYWxlID0gRGF0ZS5nZXRMb2NhbGUoPGNvZGU+KSB3aWxsIHJldHVybiB0aGlzIG9iamVjdCwgd2hpY2hcbiAqIGNhbiBiZSB0d2Vha2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgcGFyc2luZy9mb3JtYXR0aW5nIGluIHRoZSBsb2NhbGVzLlxuICpcbiAqIGxvY2FsZS5hZGRGb3JtYXQgYWRkcyBhIGRhdGUgZm9ybWF0IChzZWUgdGhpcyBmaWxlIGZvciBleGFtcGxlcykuXG4gKiBTcGVjaWFsIHRva2VucyBpbiB0aGUgZGF0ZSBmb3JtYXQgd2lsbCBiZSBwYXJzZWQgb3V0IGludG8gcmVnZXggdG9rZW5zOlxuICpcbiAqIHswfSBpcyBhIHJlZmVyZW5jZSB0byBhbiBlbnRyeSBpbiBsb2NhbGUudG9rZW5zLiBPdXRwdXQ6ICg/OnRoZSk/XG4gKiB7dW5pdH0gaXMgYSByZWZlcmVuY2UgdG8gYWxsIHVuaXRzLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aHwuLi4pXG4gKiB7dW5pdDN9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3BlY2lmaWMgdW5pdC4gT3V0cHV0OiAoaG91cilcbiAqIHt1bml0My01fSBpcyBhIHJlZmVyZW5jZSB0byBhIHN1YnNldCBvZiB0aGUgdW5pdHMgYXJyYXkuIE91dHB1dDogKGhvdXJ8ZGF5fHdlZWspXG4gKiB7dW5pdD99IFwiP1wiIG1ha2VzIHRoYXQgdG9rZW4gb3B0aW9uYWwuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRoKT9cbiAqXG4gKiB7ZGF5fSBBbnkgcmVmZXJlbmNlIHRvIHRva2VucyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IHdpbGwgaW5jbHVkZSBhbGwgd2l0aCB0aGUgc2FtZSBuYW1lLiBPdXRwdXQ6ICh5ZXN0ZXJkYXl8dG9kYXl8dG9tb3Jyb3cpXG4gKlxuICogQWxsIHNwYWNlcyBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIFwiXFxzKlwiXG4gKlxuICogTG9jYWxlIGFycmF5cyBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgbnVtYmVycywgYXMgd2VsbCBhcyB0aGUgXCJzcmNcIiBmaWVsZCBmb3JcbiAqIGFsbCBlbnRyaWVzIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgZm9sbG93IGEgc3BlY2lhbCBmb3JtYXQgaW5kaWNhdGVkIGJ5IGEgY29sb246XG4gKlxuICogbWludXRlOnxzICA9IG1pbnV0ZXxtaW51dGVzXG4gKiB0aGlja2U6bnxyID0gdGhpY2tlbnx0aGlja2VyXG4gKlxuICogQWRkaXRpb25hbGx5IGluIHRoZSBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgYW5kIG51bWJlcnMgYXJyYXkgdGhlc2Ugd2lsbCBiZSBhZGRlZCBhdCBpbmRleGVzIHRoYXQgYXJlIG11bHRpcGxlc1xuICogb2YgdGhlIHJlbGV2YW50IG51bWJlciBmb3IgcmV0cmlldmFsLiBGb3IgZXhhbXBsZSBoYXZpbmcgXCJzdW5kYXk6fHNcIiBpbiB0aGUgdW5pdHMgYXJyYXkgd2lsbCByZXN1bHQgaW46XG4gKlxuICogdW5pdHM6IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknLCAnc3VuZGF5cyddXG4gKlxuICogV2hlbiBtYXRjaGVkLCB0aGUgaW5kZXggd2lsbCBiZSBmb3VuZCB1c2luZzpcbiAqXG4gKiB1bml0cy5pbmRleE9mKG1hdGNoKSAlIDc7XG4gKlxuICogUmVzdWx0aW5nIGluIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggYW55IG51bWJlciBvZiBhbHRlcm5hdGVzIGZvciB0aGF0IGVudHJ5LlxuICpcbiAqL1xuXG5EYXRlLmFkZExvY2FsZSgnaXQnLCB7XG4gICdwbHVyYWwnOiB0cnVlLFxuICAnbW9udGhzJzogJ0dlbm5haW8sRmViYnJhaW8sTWFyem8sQXByaWxlLE1hZ2dpbyxHaXVnbm8sTHVnbGlvLEFnb3N0byxTZXR0ZW1icmUsT3R0b2JyZSxOb3ZlbWJyZSxEaWNlbWJyZScsXG4gICd3ZWVrZGF5cyc6ICdEb21lbmljYSxMdW5lZDrDrHxpLE1hcnRlZDrDrHxpLE1lcmNvbGVkOsOsfGksR2lvdmVkOsOsfGksVmVuZXJkOsOsfGksU2FiYXRvJyxcbiAgJ3VuaXRzJzogJ21pbGxpc2Vjb25kOm98aSxzZWNvbmQ6b3xpLG1pbnV0Om98aSxvcjphfGUsZ2lvcm46b3xpLHNldHRpbWFuOmF8ZSxtZXM6ZXxpLGFubjpvfGknLFxuICAnbnVtYmVycyc6IFwidW46fGF8b3wnLGR1ZSx0cmUscXVhdHRybyxjaW5xdWUsc2VpLHNldHRlLG90dG8sbm92ZSxkaWVjaVwiLFxuICAndG9rZW5zJzogXCJsJ3xsYXxpbFwiLFxuICAnc2hvcnQnOid7ZH0ge01vbnRofSB7eXl5eX0nLFxuICAnbG9uZyc6ICd7ZH0ge01vbnRofSB7eXl5eX0ge0h9OnttbX0nLFxuICAnZnVsbCc6ICd7V2Vla2RheX0ge2R9IHtNb250aH0ge3l5eXl9IHtIfTp7bW19Ontzc30nLFxuICAncGFzdCc6ICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgJ2Z1dHVyZSc6ICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgJ2R1cmF0aW9uJzogJ3tudW19IHt1bml0fScsXG4gICd0aW1lTWFya2VyJzogJ2FsbGUnLFxuICAnYW1wbSc6ICdhbSxwbScsXG4gICdtb2RpZmllcnMnOiBbXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ2llcmknLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdvZ2dpJywgJ3ZhbHVlJzogMCB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdkb21hbmknLCAndmFsdWUnOiAxIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ2RvcG9kb21hbmknLCAndmFsdWUnOiAyIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICdmYScsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICdkYSBhZGVzc28nLCAndmFsdWUnOiAxIH0sXG4gICAgeyAnbmFtZSc6ICdzaGlmdCcsICdzcmMnOiAnc2NvcnM6b3xhJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICdwcm9zc2ltOm98YScsICd2YWx1ZSc6IDEgfVxuICBdLFxuICAnZGF0ZVBhcnNlJzogW1xuICAgICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgICAnezA/fSB7dW5pdD01LTd9IHtzaGlmdH0nLFxuICAgICd7MD99IHtzaGlmdH0ge3VuaXQ9NS03fSdcbiAgXSxcbiAgJ3RpbWVQYXJzZSc6IFtcbiAgICAne3dlZWtkYXk/fSB7ZGF0ZT99IHttb250aH0ge3llYXI/fScsXG4gICAgJ3tzaGlmdH0ge3dlZWtkYXl9J1xuICBdXG59KTtcblxuLypcbiAqXG4gKiBEYXRlLmFkZExvY2FsZSg8Y29kZT4pIGFkZHMgdGhpcyBsb2NhbGUgdG8gU3VnYXIuXG4gKiBUbyBzZXQgdGhlIGxvY2FsZSBnbG9iYWxseSwgc2ltcGx5IGNhbGw6XG4gKlxuICogRGF0ZS5zZXRMb2NhbGUoJ2phJyk7XG4gKlxuICogdmFyIGxvY2FsZSA9IERhdGUuZ2V0TG9jYWxlKDxjb2RlPikgd2lsbCByZXR1cm4gdGhpcyBvYmplY3QsIHdoaWNoXG4gKiBjYW4gYmUgdHdlYWtlZCB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBpbiB0aGUgbG9jYWxlcy5cbiAqXG4gKiBsb2NhbGUuYWRkRm9ybWF0IGFkZHMgYSBkYXRlIGZvcm1hdCAoc2VlIHRoaXMgZmlsZSBmb3IgZXhhbXBsZXMpLlxuICogU3BlY2lhbCB0b2tlbnMgaW4gdGhlIGRhdGUgZm9ybWF0IHdpbGwgYmUgcGFyc2VkIG91dCBpbnRvIHJlZ2V4IHRva2VuczpcbiAqXG4gKiB7MH0gaXMgYSByZWZlcmVuY2UgdG8gYW4gZW50cnkgaW4gbG9jYWxlLnRva2Vucy4gT3V0cHV0OiAoPzp0aGUpP1xuICoge3VuaXR9IGlzIGEgcmVmZXJlbmNlIHRvIGFsbCB1bml0cy4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGh8Li4uKVxuICoge3VuaXQzfSBpcyBhIHJlZmVyZW5jZSB0byBhIHNwZWNpZmljIHVuaXQuIE91dHB1dDogKGhvdXIpXG4gKiB7dW5pdDMtNX0gaXMgYSByZWZlcmVuY2UgdG8gYSBzdWJzZXQgb2YgdGhlIHVuaXRzIGFycmF5LiBPdXRwdXQ6IChob3VyfGRheXx3ZWVrKVxuICoge3VuaXQ/fSBcIj9cIiBtYWtlcyB0aGF0IHRva2VuIG9wdGlvbmFsLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aCk/XG4gKlxuICoge2RheX0gQW55IHJlZmVyZW5jZSB0byB0b2tlbnMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSB3aWxsIGluY2x1ZGUgYWxsIHdpdGggdGhlIHNhbWUgbmFtZS4gT3V0cHV0OiAoeWVzdGVyZGF5fHRvZGF5fHRvbW9ycm93KVxuICpcbiAqIEFsbCBzcGFjZXMgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBcIlxccypcIlxuICpcbiAqIExvY2FsZSBhcnJheXMgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIG51bWJlcnMsIGFzIHdlbGwgYXMgdGhlIFwic3JjXCIgZmllbGQgZm9yXG4gKiBhbGwgZW50cmllcyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IGZvbGxvdyBhIHNwZWNpYWwgZm9ybWF0IGluZGljYXRlZCBieSBhIGNvbG9uOlxuICpcbiAqIG1pbnV0ZTp8cyAgPSBtaW51dGV8bWludXRlc1xuICogdGhpY2tlOm58ciA9IHRoaWNrZW58dGhpY2tlclxuICpcbiAqIEFkZGl0aW9uYWxseSBpbiB0aGUgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIGFuZCBudW1iZXJzIGFycmF5IHRoZXNlIHdpbGwgYmUgYWRkZWQgYXQgaW5kZXhlcyB0aGF0IGFyZSBtdWx0aXBsZXNcbiAqIG9mIHRoZSByZWxldmFudCBudW1iZXIgZm9yIHJldHJpZXZhbC4gRm9yIGV4YW1wbGUgaGF2aW5nIFwic3VuZGF5OnxzXCIgaW4gdGhlIHVuaXRzIGFycmF5IHdpbGwgcmVzdWx0IGluOlxuICpcbiAqIHVuaXRzOiBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5JywgJ3N1bmRheXMnXVxuICpcbiAqIFdoZW4gbWF0Y2hlZCwgdGhlIGluZGV4IHdpbGwgYmUgZm91bmQgdXNpbmc6XG4gKlxuICogdW5pdHMuaW5kZXhPZihtYXRjaCkgJSA3O1xuICpcbiAqIFJlc3VsdGluZyBpbiB0aGUgY29ycmVjdCBpbmRleCB3aXRoIGFueSBudW1iZXIgb2YgYWx0ZXJuYXRlcyBmb3IgdGhhdCBlbnRyeS5cbiAqXG4gKi9cblxuRGF0ZS5hZGRMb2NhbGUoJ2phJywge1xuICAnbW9udGhTdWZmaXgnOiAn5pyIJyxcbiAgJ3dlZWtkYXlzJzogJ+aXpeabnOaXpSzmnIjmm5zml6Us54Gr5puc5pelLOawtOabnOaXpSzmnKjmm5zml6Us6YeR5puc5pelLOWcn+abnOaXpScsXG4gICd1bml0cyc6ICfjg5/jg6rnp5Is56eSLOWIhizmmYLplpMs5pelLOmAsemWk3zpgLEs44O25pyIfOODteaciHzmnIgs5bm0JyxcbiAgJ3Nob3J0JzogJ3t5eXl5feW5tHtNfeaciHtkfeaXpScsXG4gICdsb25nJzogJ3t5eXl5feW5tHtNfeaciHtkfeaXpSB7SH3mmYJ7bW195YiGJyxcbiAgJ2Z1bGwnOiAne3l5eXl95bm0e0195pyIe2R95pelIHtXZWVrZGF5fSB7SH3mmYJ7bW195YiGe3NzfeenkicsXG4gICdwYXN0JzogJ3tudW19e3VuaXR9e3NpZ259JyxcbiAgJ2Z1dHVyZSc6ICd7bnVtfXt1bml0fXtzaWdufScsXG4gICdkdXJhdGlvbic6ICd7bnVtfXt1bml0fScsXG4gICd0aW1lU3VmZml4ZXMnOiAn5pmCLOWIhiznp5InLFxuICAnYW1wbSc6ICfljYjliY0s5Y2I5b6MJyxcbiAgJ21vZGlmaWVycyc6IFtcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAn5LiA5pio5pelJywgJ3ZhbHVlJzogLTIgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAn5pio5pelJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAn5LuK5pelJywgJ3ZhbHVlJzogMCB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfmmI7ml6UnLCAndmFsdWUnOiAxIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ+aYjuW+jOaXpScsICd2YWx1ZSc6IDIgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ+WJjScsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICflvownLCAndmFsdWUnOiAgMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ+WOu3zlhYgnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ+adpScsICd2YWx1ZSc6ICAxIH1cbiAgXSxcbiAgJ2RhdGVQYXJzZSc6IFtcbiAgICAne251bX17dW5pdH17c2lnbn0nXG4gIF0sXG4gICd0aW1lUGFyc2UnOiBbXG4gICAgJ3tzaGlmdH17dW5pdD01LTd9e3dlZWtkYXk/fScsXG4gICAgJ3t5ZWFyfeW5tHttb250aD995pyIP3tkYXRlP33ml6U/JyxcbiAgICAne21vbnRofeaciHtkYXRlP33ml6U/JyxcbiAgICAne2RhdGV95pelJ1xuICBdXG59KTtcblxuLypcbiAqXG4gKiBEYXRlLmFkZExvY2FsZSg8Y29kZT4pIGFkZHMgdGhpcyBsb2NhbGUgdG8gU3VnYXIuXG4gKiBUbyBzZXQgdGhlIGxvY2FsZSBnbG9iYWxseSwgc2ltcGx5IGNhbGw6XG4gKlxuICogRGF0ZS5zZXRMb2NhbGUoJ2tvJyk7XG4gKlxuICogdmFyIGxvY2FsZSA9IERhdGUuZ2V0TG9jYWxlKDxjb2RlPikgd2lsbCByZXR1cm4gdGhpcyBvYmplY3QsIHdoaWNoXG4gKiBjYW4gYmUgdHdlYWtlZCB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBpbiB0aGUgbG9jYWxlcy5cbiAqXG4gKiBsb2NhbGUuYWRkRm9ybWF0IGFkZHMgYSBkYXRlIGZvcm1hdCAoc2VlIHRoaXMgZmlsZSBmb3IgZXhhbXBsZXMpLlxuICogU3BlY2lhbCB0b2tlbnMgaW4gdGhlIGRhdGUgZm9ybWF0IHdpbGwgYmUgcGFyc2VkIG91dCBpbnRvIHJlZ2V4IHRva2VuczpcbiAqXG4gKiB7MH0gaXMgYSByZWZlcmVuY2UgdG8gYW4gZW50cnkgaW4gbG9jYWxlLnRva2Vucy4gT3V0cHV0OiAoPzp0aGUpP1xuICoge3VuaXR9IGlzIGEgcmVmZXJlbmNlIHRvIGFsbCB1bml0cy4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGh8Li4uKVxuICoge3VuaXQzfSBpcyBhIHJlZmVyZW5jZSB0byBhIHNwZWNpZmljIHVuaXQuIE91dHB1dDogKGhvdXIpXG4gKiB7dW5pdDMtNX0gaXMgYSByZWZlcmVuY2UgdG8gYSBzdWJzZXQgb2YgdGhlIHVuaXRzIGFycmF5LiBPdXRwdXQ6IChob3VyfGRheXx3ZWVrKVxuICoge3VuaXQ/fSBcIj9cIiBtYWtlcyB0aGF0IHRva2VuIG9wdGlvbmFsLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aCk/XG4gKlxuICoge2RheX0gQW55IHJlZmVyZW5jZSB0byB0b2tlbnMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSB3aWxsIGluY2x1ZGUgYWxsIHdpdGggdGhlIHNhbWUgbmFtZS4gT3V0cHV0OiAoeWVzdGVyZGF5fHRvZGF5fHRvbW9ycm93KVxuICpcbiAqIEFsbCBzcGFjZXMgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBcIlxccypcIlxuICpcbiAqIExvY2FsZSBhcnJheXMgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIG51bWJlcnMsIGFzIHdlbGwgYXMgdGhlIFwic3JjXCIgZmllbGQgZm9yXG4gKiBhbGwgZW50cmllcyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IGZvbGxvdyBhIHNwZWNpYWwgZm9ybWF0IGluZGljYXRlZCBieSBhIGNvbG9uOlxuICpcbiAqIG1pbnV0ZTp8cyAgPSBtaW51dGV8bWludXRlc1xuICogdGhpY2tlOm58ciA9IHRoaWNrZW58dGhpY2tlclxuICpcbiAqIEFkZGl0aW9uYWxseSBpbiB0aGUgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIGFuZCBudW1iZXJzIGFycmF5IHRoZXNlIHdpbGwgYmUgYWRkZWQgYXQgaW5kZXhlcyB0aGF0IGFyZSBtdWx0aXBsZXNcbiAqIG9mIHRoZSByZWxldmFudCBudW1iZXIgZm9yIHJldHJpZXZhbC4gRm9yIGV4YW1wbGUgaGF2aW5nIFwic3VuZGF5OnxzXCIgaW4gdGhlIHVuaXRzIGFycmF5IHdpbGwgcmVzdWx0IGluOlxuICpcbiAqIHVuaXRzOiBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5JywgJ3N1bmRheXMnXVxuICpcbiAqIFdoZW4gbWF0Y2hlZCwgdGhlIGluZGV4IHdpbGwgYmUgZm91bmQgdXNpbmc6XG4gKlxuICogdW5pdHMuaW5kZXhPZihtYXRjaCkgJSA3O1xuICpcbiAqIFJlc3VsdGluZyBpbiB0aGUgY29ycmVjdCBpbmRleCB3aXRoIGFueSBudW1iZXIgb2YgYWx0ZXJuYXRlcyBmb3IgdGhhdCBlbnRyeS5cbiAqXG4gKi9cblxuRGF0ZS5hZGRMb2NhbGUoJ2tvJywge1xuICAnZGlnaXREYXRlJzogdHJ1ZSxcbiAgJ21vbnRoU3VmZml4JzogJ+yblCcsXG4gICd3ZWVrZGF5cyc6ICfsnbzsmpTsnbws7JuU7JqU7J28LO2ZlOyalOydvCzsiJjsmpTsnbws66qp7JqU7J28LOq4iOyalOydvCzthqDsmpTsnbwnLFxuICAndW5pdHMnOiAn67CA66as7LSILOy0iCzrtoQs7Iuc6rCELOydvCzso7ws6rCc7JuUfOuLrCzrhYQnLFxuICAnbnVtYmVycyc6ICfsnbx87ZWcLOydtCzsgrws7IKsLOyYpCzsnKEs7LmgLO2MlCzqtaws7IutJyxcbiAgJ3Nob3J0JzogJ3t5eXl5feuFhHtNfeyblHtkfeydvCcsXG4gICdsb25nJzogJ3t5eXl5feuFhHtNfeyblHtkfeydvCB7SH3si5x7bW1967aEJyxcbiAgJ2Z1bGwnOiAne3l5eXl964WEe0197JuUe2R97J28IHtXZWVrZGF5fSB7SH3si5x7bW1967aEe3Nzfey0iCcsXG4gICdwYXN0JzogJ3tudW19e3VuaXR9IHtzaWdufScsXG4gICdmdXR1cmUnOiAne251bX17dW5pdH0ge3NpZ259JyxcbiAgJ2R1cmF0aW9uJzogJ3tudW19e3VuaXR9JyxcbiAgJ3RpbWVTdWZmaXhlcyc6ICfsi5ws67aELOy0iCcsXG4gICdhbXBtJzogJ+yYpOyghCzsmKTtm4QnLFxuICAnbW9kaWZpZXJzJzogW1xuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfqt7jsoIDqu5gnLCAndmFsdWUnOiAtMiB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfslrTsoJwnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfsmKTripgnLCAndmFsdWUnOiAwIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ+uCtOydvCcsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAn66qo66CIJywgJ3ZhbHVlJzogMiB9LFxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAn7KCEJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ+2bhCcsICd2YWx1ZSc6ICAxIH0sXG4gICAgeyAnbmFtZSc6ICdzaGlmdCcsICdzcmMnOiAn7KeA64KcfOyekScsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdzaGlmdCcsICdzcmMnOiAn7J2067KIJywgJ3ZhbHVlJzogMCB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ+uLpOydjHzrgrQnLCAndmFsdWUnOiAxIH1cbiAgXSxcbiAgJ2RhdGVQYXJzZSc6IFtcbiAgICAne251bX17dW5pdH0ge3NpZ259JyxcbiAgICAne3NoaWZ0P30ge3VuaXQ9NS03fSdcbiAgXSxcbiAgJ3RpbWVQYXJzZSc6IFtcbiAgICAne3NoaWZ0fSB7dW5pdD01P30ge3dlZWtkYXl9JyxcbiAgICAne3llYXJ964WEe21vbnRoP33sm5Q/e2RhdGU/feydvD8nLFxuICAgICd7bW9udGh97JuUe2RhdGU/feydvD8nLFxuICAgICd7ZGF0ZX3snbwnXG4gIF1cbn0pO1xuXG4vKlxuICpcbiAqIERhdGUuYWRkTG9jYWxlKDxjb2RlPikgYWRkcyB0aGlzIGxvY2FsZSB0byBTdWdhci5cbiAqIFRvIHNldCB0aGUgbG9jYWxlIGdsb2JhbGx5LCBzaW1wbHkgY2FsbDpcbiAqXG4gKiBEYXRlLnNldExvY2FsZSgnbmwnKTtcbiAqXG4gKiB2YXIgbG9jYWxlID0gRGF0ZS5nZXRMb2NhbGUoPGNvZGU+KSB3aWxsIHJldHVybiB0aGlzIG9iamVjdCwgd2hpY2hcbiAqIGNhbiBiZSB0d2Vha2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgcGFyc2luZy9mb3JtYXR0aW5nIGluIHRoZSBsb2NhbGVzLlxuICpcbiAqIGxvY2FsZS5hZGRGb3JtYXQgYWRkcyBhIGRhdGUgZm9ybWF0IChzZWUgdGhpcyBmaWxlIGZvciBleGFtcGxlcykuXG4gKiBTcGVjaWFsIHRva2VucyBpbiB0aGUgZGF0ZSBmb3JtYXQgd2lsbCBiZSBwYXJzZWQgb3V0IGludG8gcmVnZXggdG9rZW5zOlxuICpcbiAqIHswfSBpcyBhIHJlZmVyZW5jZSB0byBhbiBlbnRyeSBpbiBsb2NhbGUudG9rZW5zLiBPdXRwdXQ6ICg/OnRoZSk/XG4gKiB7dW5pdH0gaXMgYSByZWZlcmVuY2UgdG8gYWxsIHVuaXRzLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aHwuLi4pXG4gKiB7dW5pdDN9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3BlY2lmaWMgdW5pdC4gT3V0cHV0OiAoaG91cilcbiAqIHt1bml0My01fSBpcyBhIHJlZmVyZW5jZSB0byBhIHN1YnNldCBvZiB0aGUgdW5pdHMgYXJyYXkuIE91dHB1dDogKGhvdXJ8ZGF5fHdlZWspXG4gKiB7dW5pdD99IFwiP1wiIG1ha2VzIHRoYXQgdG9rZW4gb3B0aW9uYWwuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRoKT9cbiAqXG4gKiB7ZGF5fSBBbnkgcmVmZXJlbmNlIHRvIHRva2VucyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IHdpbGwgaW5jbHVkZSBhbGwgd2l0aCB0aGUgc2FtZSBuYW1lLiBPdXRwdXQ6ICh5ZXN0ZXJkYXl8dG9kYXl8dG9tb3Jyb3cpXG4gKlxuICogQWxsIHNwYWNlcyBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIFwiXFxzKlwiXG4gKlxuICogTG9jYWxlIGFycmF5cyBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgbnVtYmVycywgYXMgd2VsbCBhcyB0aGUgXCJzcmNcIiBmaWVsZCBmb3JcbiAqIGFsbCBlbnRyaWVzIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgZm9sbG93IGEgc3BlY2lhbCBmb3JtYXQgaW5kaWNhdGVkIGJ5IGEgY29sb246XG4gKlxuICogbWludXRlOnxzICA9IG1pbnV0ZXxtaW51dGVzXG4gKiB0aGlja2U6bnxyID0gdGhpY2tlbnx0aGlja2VyXG4gKlxuICogQWRkaXRpb25hbGx5IGluIHRoZSBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgYW5kIG51bWJlcnMgYXJyYXkgdGhlc2Ugd2lsbCBiZSBhZGRlZCBhdCBpbmRleGVzIHRoYXQgYXJlIG11bHRpcGxlc1xuICogb2YgdGhlIHJlbGV2YW50IG51bWJlciBmb3IgcmV0cmlldmFsLiBGb3IgZXhhbXBsZSBoYXZpbmcgXCJzdW5kYXk6fHNcIiBpbiB0aGUgdW5pdHMgYXJyYXkgd2lsbCByZXN1bHQgaW46XG4gKlxuICogdW5pdHM6IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknLCAnc3VuZGF5cyddXG4gKlxuICogV2hlbiBtYXRjaGVkLCB0aGUgaW5kZXggd2lsbCBiZSBmb3VuZCB1c2luZzpcbiAqXG4gKiB1bml0cy5pbmRleE9mKG1hdGNoKSAlIDc7XG4gKlxuICogUmVzdWx0aW5nIGluIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggYW55IG51bWJlciBvZiBhbHRlcm5hdGVzIGZvciB0aGF0IGVudHJ5LlxuICpcbiAqL1xuXG5EYXRlLmFkZExvY2FsZSgnbmwnLCB7XG4gICdwbHVyYWwnOiB0cnVlLFxuICAnbW9udGhzJzogJ2phbnVhcmksZmVicnVhcmksbWFhcnQsYXByaWwsbWVpLGp1bmksanVsaSxhdWd1c3R1cyxzZXB0ZW1iZXIsb2t0b2Jlcixub3ZlbWJlcixkZWNlbWJlcicsXG4gICd3ZWVrZGF5cyc6ICd6b25kYWd8em8sbWFhbmRhZ3xtYSxkaW5zZGFnfGRpLHdvZW5zZGFnfHdvZXx3byxkb25kZXJkYWd8ZG8sdnJpamRhZ3x2cmlqfHZyLHphdGVyZGFnfHphJyxcbiAgJ3VuaXRzJzogJ21pbGxpc2Vjb25kZTp8bixzZWNvbmRlOnxuLG1pbnU6dXR8dGVuLHV1cixkYWc6fGVuLHdlOmVrfGtlbixtYWFuZDp8ZW4samFhcicsXG4gICdudW1iZXJzJzogJ2Vlbix0d2VlLGRyaWUsdmllcix2aWpmLHplcyx6ZXZlbixhY2h0LG5lZ2VuJyxcbiAgJ3Rva2Vucyc6ICcnLFxuICAnc2hvcnQnOid7ZH0ge01vbnRofSB7eXl5eX0nLFxuICAnbG9uZyc6ICd7ZH0ge01vbnRofSB7eXl5eX0ge0h9OnttbX0nLFxuICAnZnVsbCc6ICd7V2Vla2RheX0ge2R9IHtNb250aH0ge3l5eXl9IHtIfTp7bW19Ontzc30nLFxuICAncGFzdCc6ICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgJ2Z1dHVyZSc6ICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgJ2R1cmF0aW9uJzogJ3tudW19IHt1bml0fScsXG4gICd0aW1lTWFya2VyJzogXCInc3xvbVwiLFxuICAnbW9kaWZpZXJzJzogW1xuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdnaXN0ZXJlbicsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ3ZhbmRhYWcnLCAndmFsdWUnOiAwIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ21vcmdlbicsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnb3Zlcm1vcmdlbicsICd2YWx1ZSc6IDIgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ2dlbGVkZW4nLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAndmFuYWYgbnUnLCAndmFsdWUnOiAxIH0sXG4gICAgeyAnbmFtZSc6ICdzaGlmdCcsICdzcmMnOiAnbGFhdHN0ZXx2b3JpZ2V8YWZnZWxvcGVuJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICd2b2xnZW5kOnxlJywgJ3ZhbHVlJzogMSB9XG4gIF0sXG4gICdkYXRlUGFyc2UnOiBbXG4gICAgJ3tudW19IHt1bml0fSB7c2lnbn0nLFxuICAgICd7MD99IHt1bml0PTUtN30ge3NoaWZ0fScsXG4gICAgJ3swP30ge3NoaWZ0fSB7dW5pdD01LTd9J1xuICBdLFxuICAndGltZVBhcnNlJzogW1xuICAgICd7d2Vla2RheT99IHtkYXRlP30ge21vbnRofSB7eWVhcj99JyxcbiAgICAne3NoaWZ0fSB7d2Vla2RheX0nXG4gIF1cbn0pO1xuLypcclxuICpcclxuICogRGF0ZS5hZGRMb2NhbGUoPGNvZGU+KSBhZGRzIHRoaXMgbG9jYWxlIHRvIFN1Z2FyLlxyXG4gKiBUbyBzZXQgdGhlIGxvY2FsZSBnbG9iYWxseSwgc2ltcGx5IGNhbGw6XHJcbiAqXHJcbiAqIERhdGUuc2V0TG9jYWxlKCdwbCcpO1xyXG4gKlxyXG4gKiB2YXIgbG9jYWxlID0gRGF0ZS5nZXRMb2NhbGUoPGNvZGU+KSB3aWxsIHJldHVybiB0aGlzIG9iamVjdCwgd2hpY2hcclxuICogY2FuIGJlIHR3ZWFrZWQgdG8gY2hhbmdlIHRoZSBiZWhhdmlvciBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgaW4gdGhlIGxvY2FsZXMuXHJcbiAqXHJcbiAqIGxvY2FsZS5hZGRGb3JtYXQgYWRkcyBhIGRhdGUgZm9ybWF0IChzZWUgdGhpcyBmaWxlIGZvciBleGFtcGxlcykuXHJcbiAqIFNwZWNpYWwgdG9rZW5zIGluIHRoZSBkYXRlIGZvcm1hdCB3aWxsIGJlIHBhcnNlZCBvdXQgaW50byByZWdleCB0b2tlbnM6XHJcbiAqXHJcbiAqIHswfSBpcyBhIHJlZmVyZW5jZSB0byBhbiBlbnRyeSBpbiBsb2NhbGUub3B0aW9uYWxzLiBPdXRwdXQ6ICg/OnRoZSk/XHJcbiAqIHt1bml0fSBpcyBhIHJlZmVyZW5jZSB0byBhbGwgdW5pdHMuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRofC4uLilcclxuICoge3VuaXQzfSBpcyBhIHJlZmVyZW5jZSB0byBhIHNwZWNpZmljIHVuaXQuIE91dHB1dDogKGhvdXIpXHJcbiAqIHt1bml0My01fSBpcyBhIHJlZmVyZW5jZSB0byBhIHN1YnNldCBvZiB0aGUgdW5pdHMgYXJyYXkuIE91dHB1dDogKGhvdXJ8ZGF5fHdlZWspXHJcbiAqIHt1bml0P30gXCI/XCIgbWFrZXMgdGhhdCB0b2tlbiBvcHRpb25hbC4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGgpP1xyXG4gKlxyXG4gKiB7ZGF5fSBBbnkgcmVmZXJlbmNlIHRvIHRva2VucyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IHdpbGwgaW5jbHVkZSBhbGwgd2l0aCB0aGUgc2FtZSBuYW1lLiBPdXRwdXQ6ICh5ZXN0ZXJkYXl8dG9kYXl8dG9tb3Jyb3cpXHJcbiAqXHJcbiAqIEFsbCBzcGFjZXMgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBcIlxccypcIlxyXG4gKlxyXG4gKiBMb2NhbGUgYXJyYXlzIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBudW1iZXJzLCBhcyB3ZWxsIGFzIHRoZSBcInNyY1wiIGZpZWxkIGZvclxyXG4gKiBhbGwgZW50cmllcyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IGZvbGxvdyBhIHNwZWNpYWwgZm9ybWF0IGluZGljYXRlZCBieSBhIGNvbG9uOlxyXG4gKlxyXG4gKiBtaW51dGU6fHMgID0gbWludXRlfG1pbnV0ZXNcclxuICogdGhpY2tlOm58ciA9IHRoaWNrZW58dGhpY2tlclxyXG4gKlxyXG4gKiBBZGRpdGlvbmFsbHkgaW4gdGhlIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBhbmQgbnVtYmVycyBhcnJheSB0aGVzZSB3aWxsIGJlIGFkZGVkIGF0IGluZGV4ZXMgdGhhdCBhcmUgbXVsdGlwbGVzXHJcbiAqIG9mIHRoZSByZWxldmFudCBudW1iZXIgZm9yIHJldHJpZXZhbC4gRm9yIGV4YW1wbGUgaGF2aW5nIFwic3VuZGF5OnxzXCIgaW4gdGhlIHVuaXRzIGFycmF5IHdpbGwgcmVzdWx0IGluOlxyXG4gKlxyXG4gKiB1bml0czogWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheScsICdzdW5kYXlzJ11cclxuICpcclxuICogV2hlbiBtYXRjaGVkLCB0aGUgaW5kZXggd2lsbCBiZSBmb3VuZCB1c2luZzpcclxuICpcclxuICogdW5pdHMuaW5kZXhPZihtYXRjaCkgJSA3O1xyXG4gKlxyXG4gKiBSZXN1bHRpbmcgaW4gdGhlIGNvcnJlY3QgaW5kZXggd2l0aCBhbnkgbnVtYmVyIG9mIGFsdGVybmF0ZXMgZm9yIHRoYXQgZW50cnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuRGF0ZS5hZGRMb2NhbGUoJ3BsJywge1xyXG4gICdwbHVyYWwnOiAgICB0cnVlLFxyXG4gICdtb250aHMnOiAgICAnU3R5Y3plxYR8U3R5Y3puaWEsTHV0eXxMdXRlZ28sTWFyemVjfE1hcmNhLEt3aWVjaWXFhHxLd2lldG5pYSxNYWp8TWFqYSxDemVyd2llY3xDemVyd2NhLExpcGllY3xMaXBjYSxTaWVycGllxYR8U2llcnBuaWEsV3J6ZXNpZcWEfFdyemXFm25pYSxQYcW6ZHppZXJuaWt8UGHFumR6aWVybmlrYSxMaXN0b3BhZHxMaXN0b3BhZGEsR3J1ZHppZcWEfEdydWRuaWEnLFxyXG4gICd3ZWVrZGF5cyc6ICAnTmllZHppZWxhfE5pZWR6aWVsxJksUG9uaWVkemlhxYJlayxXdG9yZWssxZpyb2Q6YXzEmSxDendhcnRlayxQacSFdGVrLFNvYm90YXxTb2JvdMSZJyxcclxuICAndW5pdHMnOiAgICAgJ21pbGlzZWt1bmQ6YXx5fCxzZWt1bmQ6YXx5fCxtaW51dDphfHl8LGdvZHppbjphfHl8LGR6aWXFhHxkbmksdHlkemllxYR8dHlnb2RuaWV8dHlnb2RuaSxtaWVzacSFY2V8bWllc2nEhWNlfG1pZXNpxJljeSxyb2t8bGF0YXxsYXQnLFxyXG4gICdudW1iZXJzJzogICAnamVkZW58amVkbsSFLGR3YXxkd2llLHRyenksY3p0ZXJ5LHBpxJnEhyxzemXFm8SHLHNpZWRlbSxvc2llbSxkemlld2nEmcSHLGR6aWVzacSZxIcnLFxyXG4gICdvcHRpb25hbHMnOiAnd3x3ZSxyb2t1JyxcclxuICAnc2hvcnQnOiAgICAgJ3tkfSB7TW9udGh9IHt5eXl5fScsXHJcbiAgJ2xvbmcnOiAgICAgICd7ZH0ge01vbnRofSB7eXl5eX0ge0h9OnttbX0nLFxyXG4gICdmdWxsJyA6ICAgICAne1dlZWtkYXl9LCB7ZH0ge01vbnRofSB7eXl5eX0ge0h9OnttbX06e3NzfScsXHJcbiAgJ3Bhc3QnOiAgICAgICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcclxuICAnZnV0dXJlJzogICAgJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxyXG4gICdkdXJhdGlvbic6ICAne251bX0ge3VuaXR9JyxcclxuICAndGltZU1hcmtlcic6J28nLFxyXG4gICdhbXBtJzogICAgICAnYW0scG0nLFxyXG4gICdtb2RpZmllcnMnOiBbXHJcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAncHJ6ZWR3Y3pvcmFqJywgJ3ZhbHVlJzogLTIgfSxcclxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICd3Y3pvcmFqJywgJ3ZhbHVlJzogLTEgfSxcclxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdkemlzaWFqfGR6acWbJywgJ3ZhbHVlJzogMCB9LFxyXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ2p1dHJvJywgJ3ZhbHVlJzogMSB9LFxyXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ3BvanV0cnplJywgJ3ZhbHVlJzogMiB9LFxyXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICd0ZW11fHByemVkJywgJ3ZhbHVlJzogLTEgfSxcclxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAnemEnLCAndmFsdWUnOiAxIH0sXHJcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICd6ZXN6xYJ5fHplc3rFgmF8b3N0YXRuaXxvc3RhdG5pYScsICd2YWx1ZSc6IC0xIH0sXHJcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICduYXN0xJlwbnl8bmFzdMSZcG5hfG5hc3TEmXBuZWdvfHByenlzesWCeXxwcnp5c3rFgmF8cHJ6eXN6xYJlZ28nLCAndmFsdWUnOiAxIH1cclxuICBdLFxyXG4gICdkYXRlUGFyc2UnOiBbXHJcbiAgICAne251bX0ge3VuaXR9IHtzaWdufScsXHJcbiAgICAne3NpZ259IHtudW19IHt1bml0fScsXHJcbiAgICAne21vbnRofSB7eWVhcn0nLFxyXG4gICAgJ3tzaGlmdH0ge3VuaXQ9NS03fScsXHJcbiAgICAnezB9IHtzaGlmdD99IHt3ZWVrZGF5fSdcclxuICBdLFxyXG4gICd0aW1lUGFyc2UnOiBbXHJcbiAgICAne2RhdGV9IHttb250aH0ge3llYXI/fSB7MX0nLFxyXG4gICAgJ3swfSB7c2hpZnQ/fSB7d2Vla2RheX0nXHJcbiAgXVxyXG59KTtcclxuXHJcbi8qXG4gKlxuICogRGF0ZS5hZGRMb2NhbGUoPGNvZGU+KSBhZGRzIHRoaXMgbG9jYWxlIHRvIFN1Z2FyLlxuICogVG8gc2V0IHRoZSBsb2NhbGUgZ2xvYmFsbHksIHNpbXBseSBjYWxsOlxuICpcbiAqIERhdGUuc2V0TG9jYWxlKCdwdCcpO1xuICpcbiAqIHZhciBsb2NhbGUgPSBEYXRlLmdldExvY2FsZSg8Y29kZT4pIHdpbGwgcmV0dXJuIHRoaXMgb2JqZWN0LCB3aGljaFxuICogY2FuIGJlIHR3ZWFrZWQgdG8gY2hhbmdlIHRoZSBiZWhhdmlvciBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgaW4gdGhlIGxvY2FsZXMuXG4gKlxuICogbG9jYWxlLmFkZEZvcm1hdCBhZGRzIGEgZGF0ZSBmb3JtYXQgKHNlZSB0aGlzIGZpbGUgZm9yIGV4YW1wbGVzKS5cbiAqIFNwZWNpYWwgdG9rZW5zIGluIHRoZSBkYXRlIGZvcm1hdCB3aWxsIGJlIHBhcnNlZCBvdXQgaW50byByZWdleCB0b2tlbnM6XG4gKlxuICogezB9IGlzIGEgcmVmZXJlbmNlIHRvIGFuIGVudHJ5IGluIGxvY2FsZS50b2tlbnMuIE91dHB1dDogKD86dGhlKT9cbiAqIHt1bml0fSBpcyBhIHJlZmVyZW5jZSB0byBhbGwgdW5pdHMuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRofC4uLilcbiAqIHt1bml0M30gaXMgYSByZWZlcmVuY2UgdG8gYSBzcGVjaWZpYyB1bml0LiBPdXRwdXQ6IChob3VyKVxuICoge3VuaXQzLTV9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3Vic2V0IG9mIHRoZSB1bml0cyBhcnJheS4gT3V0cHV0OiAoaG91cnxkYXl8d2VlaylcbiAqIHt1bml0P30gXCI/XCIgbWFrZXMgdGhhdCB0b2tlbiBvcHRpb25hbC4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGgpP1xuICpcbiAqIHtkYXl9IEFueSByZWZlcmVuY2UgdG8gdG9rZW5zIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgd2lsbCBpbmNsdWRlIGFsbCB3aXRoIHRoZSBzYW1lIG5hbWUuIE91dHB1dDogKHllc3RlcmRheXx0b2RheXx0b21vcnJvdylcbiAqXG4gKiBBbGwgc3BhY2VzIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gXCJcXHMqXCJcbiAqXG4gKiBMb2NhbGUgYXJyYXlzIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBudW1iZXJzLCBhcyB3ZWxsIGFzIHRoZSBcInNyY1wiIGZpZWxkIGZvclxuICogYWxsIGVudHJpZXMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSBmb2xsb3cgYSBzcGVjaWFsIGZvcm1hdCBpbmRpY2F0ZWQgYnkgYSBjb2xvbjpcbiAqXG4gKiBtaW51dGU6fHMgID0gbWludXRlfG1pbnV0ZXNcbiAqIHRoaWNrZTpufHIgPSB0aGlja2VufHRoaWNrZXJcbiAqXG4gKiBBZGRpdGlvbmFsbHkgaW4gdGhlIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBhbmQgbnVtYmVycyBhcnJheSB0aGVzZSB3aWxsIGJlIGFkZGVkIGF0IGluZGV4ZXMgdGhhdCBhcmUgbXVsdGlwbGVzXG4gKiBvZiB0aGUgcmVsZXZhbnQgbnVtYmVyIGZvciByZXRyaWV2YWwuIEZvciBleGFtcGxlIGhhdmluZyBcInN1bmRheTp8c1wiIGluIHRoZSB1bml0cyBhcnJheSB3aWxsIHJlc3VsdCBpbjpcbiAqXG4gKiB1bml0czogWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheScsICdzdW5kYXlzJ11cbiAqXG4gKiBXaGVuIG1hdGNoZWQsIHRoZSBpbmRleCB3aWxsIGJlIGZvdW5kIHVzaW5nOlxuICpcbiAqIHVuaXRzLmluZGV4T2YobWF0Y2gpICUgNztcbiAqXG4gKiBSZXN1bHRpbmcgaW4gdGhlIGNvcnJlY3QgaW5kZXggd2l0aCBhbnkgbnVtYmVyIG9mIGFsdGVybmF0ZXMgZm9yIHRoYXQgZW50cnkuXG4gKlxuICovXG5cbkRhdGUuYWRkTG9jYWxlKCdwdCcsIHtcbiAgJ3BsdXJhbCc6IHRydWUsXG4gICdtb250aHMnOiAnamFuZWlybyxmZXZlcmVpcm8sbWFyw6dvLGFicmlsLG1haW8sanVuaG8sanVsaG8sYWdvc3RvLHNldGVtYnJvLG91dHVicm8sbm92ZW1icm8sZGV6ZW1icm8nLFxuICAnd2Vla2RheXMnOiAnZG9taW5nbyxzZWd1bmRhLWZlaXJhLHRlcsOnYS1mZWlyYSxxdWFydGEtZmVpcmEscXVpbnRhLWZlaXJhLHNleHRhLWZlaXJhLHPDoWJhZG98c2FiYWRvJyxcbiAgJ3VuaXRzJzogJ21pbGlzZWd1bmRvOnxzLHNlZ3VuZG86fHMsbWludXRvOnxzLGhvcmE6fHMsZGlhOnxzLHNlbWFuYTp8cyxtw6pzfG3DqnNlc3xtZXN8bWVzZXMsYW5vOnxzJyxcbiAgJ251bWJlcnMnOiAndW0sZG9pcyx0csOqc3x0cmVzLHF1YXRybyxjaW5jbyxzZWlzLHNldGUsb2l0byxub3ZlLGRleix1bWEsZHVhcycsXG4gICd0b2tlbnMnOiAnYSxkZScsXG4gICdzaG9ydCc6J3tkfSBkZSB7bW9udGh9IGRlIHt5eXl5fScsXG4gICdsb25nJzogJ3tkfSBkZSB7bW9udGh9IGRlIHt5eXl5fSB7SH06e21tfScsXG4gICdmdWxsJzogJ3tXZWVrZGF5fSwge2R9IGRlIHttb250aH0gZGUge3l5eXl9IHtIfTp7bW19Ontzc30nLFxuICAncGFzdCc6ICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgJ2Z1dHVyZSc6ICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgJ2R1cmF0aW9uJzogJ3tudW19IHt1bml0fScsXG4gICd0aW1lTWFya2VyJzogJ8OgcycsXG4gICdhbXBtJzogJ2FtLHBtJyxcbiAgJ21vZGlmaWVycyc6IFtcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnYW50ZW9udGVtJywgJ3ZhbHVlJzogLTIgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnb250ZW0nLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdob2plJywgJ3ZhbHVlJzogMCB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdhbWFuaDrDo3xhJywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAnYXRyw6FzfGF0cmFzfGjDoXxoYScsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICdkYXF1aSBhJywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ3Bhc3NhZDpvfGEnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ3Byw7N4aW1vfHByw7N4aW1hfHByb3hpbW98cHJveGltYScsICd2YWx1ZSc6IDEgfVxuICBdLFxuICAnZGF0ZVBhcnNlJzogW1xuICAgICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgICAne3NpZ259IHtudW19IHt1bml0fScsXG4gICAgJ3swP30ge3VuaXQ9NS03fSB7c2hpZnR9JyxcbiAgICAnezA/fSB7c2hpZnR9IHt1bml0PTUtN30nXG4gIF0sXG4gICd0aW1lUGFyc2UnOiBbXG4gICAgJ3tkYXRlP30gezE/fSB7bW9udGh9IHsxP30ge3llYXI/fScsXG4gICAgJ3swP30ge3NoaWZ0fSB7d2Vla2RheX0nXG4gIF1cbn0pO1xuXG4vKlxuICpcbiAqIERhdGUuYWRkTG9jYWxlKDxjb2RlPikgYWRkcyB0aGlzIGxvY2FsZSB0byBTdWdhci5cbiAqIFRvIHNldCB0aGUgbG9jYWxlIGdsb2JhbGx5LCBzaW1wbHkgY2FsbDpcbiAqXG4gKiBEYXRlLnNldExvY2FsZSgncnUnKTtcbiAqXG4gKiB2YXIgbG9jYWxlID0gRGF0ZS5nZXRMb2NhbGUoPGNvZGU+KSB3aWxsIHJldHVybiB0aGlzIG9iamVjdCwgd2hpY2hcbiAqIGNhbiBiZSB0d2Vha2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgcGFyc2luZy9mb3JtYXR0aW5nIGluIHRoZSBsb2NhbGVzLlxuICpcbiAqIGxvY2FsZS5hZGRGb3JtYXQgYWRkcyBhIGRhdGUgZm9ybWF0IChzZWUgdGhpcyBmaWxlIGZvciBleGFtcGxlcykuXG4gKiBTcGVjaWFsIHRva2VucyBpbiB0aGUgZGF0ZSBmb3JtYXQgd2lsbCBiZSBwYXJzZWQgb3V0IGludG8gcmVnZXggdG9rZW5zOlxuICpcbiAqIHswfSBpcyBhIHJlZmVyZW5jZSB0byBhbiBlbnRyeSBpbiBsb2NhbGUudG9rZW5zLiBPdXRwdXQ6ICg/OnRoZSk/XG4gKiB7dW5pdH0gaXMgYSByZWZlcmVuY2UgdG8gYWxsIHVuaXRzLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aHwuLi4pXG4gKiB7dW5pdDN9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3BlY2lmaWMgdW5pdC4gT3V0cHV0OiAoaG91cilcbiAqIHt1bml0My01fSBpcyBhIHJlZmVyZW5jZSB0byBhIHN1YnNldCBvZiB0aGUgdW5pdHMgYXJyYXkuIE91dHB1dDogKGhvdXJ8ZGF5fHdlZWspXG4gKiB7dW5pdD99IFwiP1wiIG1ha2VzIHRoYXQgdG9rZW4gb3B0aW9uYWwuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRoKT9cbiAqXG4gKiB7ZGF5fSBBbnkgcmVmZXJlbmNlIHRvIHRva2VucyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IHdpbGwgaW5jbHVkZSBhbGwgd2l0aCB0aGUgc2FtZSBuYW1lLiBPdXRwdXQ6ICh5ZXN0ZXJkYXl8dG9kYXl8dG9tb3Jyb3cpXG4gKlxuICogQWxsIHNwYWNlcyBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIFwiXFxzKlwiXG4gKlxuICogTG9jYWxlIGFycmF5cyBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgbnVtYmVycywgYXMgd2VsbCBhcyB0aGUgXCJzcmNcIiBmaWVsZCBmb3JcbiAqIGFsbCBlbnRyaWVzIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgZm9sbG93IGEgc3BlY2lhbCBmb3JtYXQgaW5kaWNhdGVkIGJ5IGEgY29sb246XG4gKlxuICogbWludXRlOnxzICA9IG1pbnV0ZXxtaW51dGVzXG4gKiB0aGlja2U6bnxyID0gdGhpY2tlbnx0aGlja2VyXG4gKlxuICogQWRkaXRpb25hbGx5IGluIHRoZSBtb250aHMsIHdlZWtkYXlzLCB1bml0cywgYW5kIG51bWJlcnMgYXJyYXkgdGhlc2Ugd2lsbCBiZSBhZGRlZCBhdCBpbmRleGVzIHRoYXQgYXJlIG11bHRpcGxlc1xuICogb2YgdGhlIHJlbGV2YW50IG51bWJlciBmb3IgcmV0cmlldmFsLiBGb3IgZXhhbXBsZSBoYXZpbmcgXCJzdW5kYXk6fHNcIiBpbiB0aGUgdW5pdHMgYXJyYXkgd2lsbCByZXN1bHQgaW46XG4gKlxuICogdW5pdHM6IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknLCAnc3VuZGF5cyddXG4gKlxuICogV2hlbiBtYXRjaGVkLCB0aGUgaW5kZXggd2lsbCBiZSBmb3VuZCB1c2luZzpcbiAqXG4gKiB1bml0cy5pbmRleE9mKG1hdGNoKSAlIDc7XG4gKlxuICogUmVzdWx0aW5nIGluIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggYW55IG51bWJlciBvZiBhbHRlcm5hdGVzIGZvciB0aGF0IGVudHJ5LlxuICpcbiAqL1xuXG5EYXRlLmFkZExvY2FsZSgncnUnLCB7XG4gICdtb250aHMnOiAn0K/QvdCy0LDRgDrRj3zRjCzQpNC10LLRgNCw0Ls60Y980Yws0JzQsNGA0YI60LB8LNCQ0L/RgNC10Ls60Y980Yws0JzQsDrRj3zQuSzQmNGO0L060Y980Yws0JjRjtC7OtGPfNGMLNCQ0LLQs9GD0YHRgjrQsHws0KHQtdC90YLRj9Cx0YA60Y980Yws0J7QutGC0Y/QsdGAOtGPfNGMLNCd0L7Rj9Cx0YA60Y980Yws0JTQtdC60LDQsdGAOtGPfNGMJyxcbiAgJ3dlZWtkYXlzJzogJ9CS0L7RgdC60YDQtdGB0LXQvdGM0LUs0J/QvtC90LXQtNC10LvRjNC90LjQuizQktGC0L7RgNC90LjQuizQodGA0LXQtNCwLNCn0LXRgtCy0LXRgNCzLNCf0Y/RgtC90LjRhtCwLNCh0YPQsdCx0L7RgtCwJyxcbiAgJ3VuaXRzJzogJ9C80LjQu9C70LjRgdC10LrRg9C90LQ60LB80YN80Yt8LNGB0LXQutGD0L3QtDrQsHzRg3zRi3ws0LzQuNC90YPRgjrQsHzRg3zRi3ws0YfQsNGBOnx80LB80L7QsizQtNC10L3RjHzQtNC10L3RjHzQtNC90Y980LTQvdC10Lks0L3QtdC00LXQuzrRj3zRjnzQuHzRjHzQtSzQvNC10YHRj9GGOnx80LB80LXQsnzQtSzQs9C+0LR80LPQvtC0fNCz0L7QtNCwfNC70LXRgnzQs9C+0LTRgycsXG4gICdudW1iZXJzJzogJ9C+0LQ60LjQvXzQvdGDLNC00LI60LB80LUs0YLRgNC4LNGH0LXRgtGL0YDQtSzQv9GP0YLRjCzRiNC10YHRgtGMLNGB0LXQvNGMLNCy0L7RgdC10LzRjCzQtNC10LLRj9GC0Yws0LTQtdGB0Y/RgtGMJyxcbiAgJ3Rva2Vucyc6ICfQsnzQvdCwLNCz0L7QtNCwJyxcbiAgJ3Nob3J0Jzone2R9IHttb250aH0ge3l5eXl9INCz0L7QtNCwJyxcbiAgJ2xvbmcnOiAne2R9IHttb250aH0ge3l5eXl9INCz0L7QtNCwIHtIfTp7bW19JyxcbiAgJ2Z1bGwnOiAne1dlZWtkYXl9IHtkfSB7bW9udGh9IHt5eXl5fSDQs9C+0LTQsCB7SH06e21tfTp7c3N9JyxcbiAgJ3JlbGF0aXZlJzogZnVuY3Rpb24obnVtLCB1bml0LCBtcywgZm9ybWF0KSB7XG4gICAgdmFyIG51bWJlcldpdGhVbml0LCBsYXN0ID0gbnVtLnRvU3RyaW5nKCkuc2xpY2UoLTEpLCBtdWx0O1xuICAgIHN3aXRjaCh0cnVlKSB7XG4gICAgICBjYXNlIG51bSA+PSAxMSAmJiBudW0gPD0gMTU6IG11bHQgPSAzOyBicmVhaztcbiAgICAgIGNhc2UgbGFzdCA9PSAxOiBtdWx0ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIGxhc3QgPj0gMiAmJiBsYXN0IDw9IDQ6IG11bHQgPSAyOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IG11bHQgPSAzO1xuICAgIH1cbiAgICBudW1iZXJXaXRoVW5pdCA9IG51bSArICcgJyArIHRoaXNbJ3VuaXRzJ11bKG11bHQgKiA4KSArIHVuaXRdO1xuICAgIHN3aXRjaChmb3JtYXQpIHtcbiAgICAgIGNhc2UgJ2R1cmF0aW9uJzogIHJldHVybiBudW1iZXJXaXRoVW5pdDtcbiAgICAgIGNhc2UgJ3Bhc3QnOiAgICAgIHJldHVybiBudW1iZXJXaXRoVW5pdCArICcg0L3QsNC30LDQtCc7XG4gICAgICBjYXNlICdmdXR1cmUnOiAgICByZXR1cm4gJ9GH0LXRgNC10LcgJyArIG51bWJlcldpdGhVbml0O1xuICAgIH1cbiAgfSxcbiAgJ3RpbWVNYXJrZXInOiAn0LInLFxuICAnYW1wbSc6ICcg0YPRgtGA0LAsINCy0LXRh9C10YDQsCcsXG4gICdtb2RpZmllcnMnOiBbXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ9C/0L7Qt9Cw0LLRh9C10YDQsCcsICd2YWx1ZSc6IC0yIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ9Cy0YfQtdGA0LAnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfRgdC10LPQvtC00L3RjycsICd2YWx1ZSc6IDAgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAn0LfQsNCy0YLRgNCwJywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfQv9C+0YHQu9C10LfQsNCy0YLRgNCwJywgJ3ZhbHVlJzogMiB9LFxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAn0L3QsNC30LDQtCcsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICfRh9C10YDQtdC3JywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ9C/0YDQvtGI0Ls60YvQuXzQvtC5fNC+0LwnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ9GB0LvQtdC00YPRjtGJOtC40Ll80LXQuXzQtdC8JywgJ3ZhbHVlJzogMSB9XG4gIF0sXG4gICdkYXRlUGFyc2UnOiBbXG4gICAgJ3tudW19IHt1bml0fSB7c2lnbn0nLFxuICAgICd7c2lnbn0ge251bX0ge3VuaXR9JyxcbiAgICAne21vbnRofSB7eWVhcn0nLFxuICAgICd7MD99IHtzaGlmdH0ge3VuaXQ9NS03fSdcbiAgXSxcbiAgJ3RpbWVQYXJzZSc6IFtcbiAgICAne2RhdGV9IHttb250aH0ge3llYXI/fSB7MT99JyxcbiAgICAnezA/fSB7c2hpZnR9IHt3ZWVrZGF5fSdcbiAgXVxufSk7XG5cbi8qXG4gKlxuICogRGF0ZS5hZGRMb2NhbGUoPGNvZGU+KSBhZGRzIHRoaXMgbG9jYWxlIHRvIFN1Z2FyLlxuICogVG8gc2V0IHRoZSBsb2NhbGUgZ2xvYmFsbHksIHNpbXBseSBjYWxsOlxuICpcbiAqIERhdGUuc2V0TG9jYWxlKCdzdicpO1xuICpcbiAqIHZhciBsb2NhbGUgPSBEYXRlLmdldExvY2FsZSg8Y29kZT4pIHdpbGwgcmV0dXJuIHRoaXMgb2JqZWN0LCB3aGljaFxuICogY2FuIGJlIHR3ZWFrZWQgdG8gY2hhbmdlIHRoZSBiZWhhdmlvciBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgaW4gdGhlIGxvY2FsZXMuXG4gKlxuICogbG9jYWxlLmFkZEZvcm1hdCBhZGRzIGEgZGF0ZSBmb3JtYXQgKHNlZSB0aGlzIGZpbGUgZm9yIGV4YW1wbGVzKS5cbiAqIFNwZWNpYWwgdG9rZW5zIGluIHRoZSBkYXRlIGZvcm1hdCB3aWxsIGJlIHBhcnNlZCBvdXQgaW50byByZWdleCB0b2tlbnM6XG4gKlxuICogezB9IGlzIGEgcmVmZXJlbmNlIHRvIGFuIGVudHJ5IGluIGxvY2FsZS50b2tlbnMuIE91dHB1dDogKD86dGhlKT9cbiAqIHt1bml0fSBpcyBhIHJlZmVyZW5jZSB0byBhbGwgdW5pdHMuIE91dHB1dDogKGRheXx3ZWVrfG1vbnRofC4uLilcbiAqIHt1bml0M30gaXMgYSByZWZlcmVuY2UgdG8gYSBzcGVjaWZpYyB1bml0LiBPdXRwdXQ6IChob3VyKVxuICoge3VuaXQzLTV9IGlzIGEgcmVmZXJlbmNlIHRvIGEgc3Vic2V0IG9mIHRoZSB1bml0cyBhcnJheS4gT3V0cHV0OiAoaG91cnxkYXl8d2VlaylcbiAqIHt1bml0P30gXCI/XCIgbWFrZXMgdGhhdCB0b2tlbiBvcHRpb25hbC4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGgpP1xuICpcbiAqIHtkYXl9IEFueSByZWZlcmVuY2UgdG8gdG9rZW5zIGluIHRoZSBtb2RpZmllcnMgYXJyYXkgd2lsbCBpbmNsdWRlIGFsbCB3aXRoIHRoZSBzYW1lIG5hbWUuIE91dHB1dDogKHllc3RlcmRheXx0b2RheXx0b21vcnJvdylcbiAqXG4gKiBBbGwgc3BhY2VzIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gXCJcXHMqXCJcbiAqXG4gKiBMb2NhbGUgYXJyYXlzIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBudW1iZXJzLCBhcyB3ZWxsIGFzIHRoZSBcInNyY1wiIGZpZWxkIGZvclxuICogYWxsIGVudHJpZXMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSBmb2xsb3cgYSBzcGVjaWFsIGZvcm1hdCBpbmRpY2F0ZWQgYnkgYSBjb2xvbjpcbiAqXG4gKiBtaW51dGU6fHMgID0gbWludXRlfG1pbnV0ZXNcbiAqIHRoaWNrZTpufHIgPSB0aGlja2VufHRoaWNrZXJcbiAqXG4gKiBBZGRpdGlvbmFsbHkgaW4gdGhlIG1vbnRocywgd2Vla2RheXMsIHVuaXRzLCBhbmQgbnVtYmVycyBhcnJheSB0aGVzZSB3aWxsIGJlIGFkZGVkIGF0IGluZGV4ZXMgdGhhdCBhcmUgbXVsdGlwbGVzXG4gKiBvZiB0aGUgcmVsZXZhbnQgbnVtYmVyIGZvciByZXRyaWV2YWwuIEZvciBleGFtcGxlIGhhdmluZyBcInN1bmRheTp8c1wiIGluIHRoZSB1bml0cyBhcnJheSB3aWxsIHJlc3VsdCBpbjpcbiAqXG4gKiB1bml0czogWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheScsICdzdW5kYXlzJ11cbiAqXG4gKiBXaGVuIG1hdGNoZWQsIHRoZSBpbmRleCB3aWxsIGJlIGZvdW5kIHVzaW5nOlxuICpcbiAqIHVuaXRzLmluZGV4T2YobWF0Y2gpICUgNztcbiAqXG4gKiBSZXN1bHRpbmcgaW4gdGhlIGNvcnJlY3QgaW5kZXggd2l0aCBhbnkgbnVtYmVyIG9mIGFsdGVybmF0ZXMgZm9yIHRoYXQgZW50cnkuXG4gKlxuICovXG5cbkRhdGUuYWRkTG9jYWxlKCdzdicsIHtcbiAgJ3BsdXJhbCc6IHRydWUsXG4gICdtb250aHMnOiAnamFudWFyaSxmZWJydWFyaSxtYXJzLGFwcmlsLG1haixqdW5pLGp1bGksYXVndXN0aSxzZXB0ZW1iZXIsb2t0b2Jlcixub3ZlbWJlcixkZWNlbWJlcicsXG4gICd3ZWVrZGF5cyc6ICdzw7ZuZGFnfHNvbmRhZyxtw6VuZGFnOnxlbittYW5kYWc6fGVuLHRpc2RhZyxvbnNkYWcsdG9yc2RhZyxmcmVkYWcsbMO2cmRhZ3xsb3JkYWcnLFxuICAndW5pdHMnOiAnbWlsbGlzZWt1bmQ6fGVyLHNla3VuZDp8ZXIsbWludXQ6fGVyLHRpbW06ZXxhcixkYWc6fGFyLHZlY2s6YXxvcnxhbixtw6VuYWQ6fGVyfGVuK21hbmFkOnxlcnxlbizDpXI6fHxldCthcjp8fGV0JyxcbiAgJ251bWJlcnMnOiAnZW58ZXR0LHR2w6V8dHZhLHRyZSxmeXJhLGZlbSxzZXgsc2p1LMOldHRhfGF0dGEsbmlvLHRpbycsXG4gICd0b2tlbnMnOiAnZGVuLGbDtnJ8Zm9yJyxcbiAgJ2FydGljbGVzJzogJ2RlbicsXG4gICdzaG9ydCc6J2RlbiB7ZH0ge21vbnRofSB7eXl5eX0nLFxuICAnbG9uZyc6ICdkZW4ge2R9IHttb250aH0ge3l5eXl9IHtIfTp7bW19JyxcbiAgJ2Z1bGwnOiAne1dlZWtkYXl9IGRlbiB7ZH0ge21vbnRofSB7eXl5eX0ge0h9OnttbX06e3NzfScsXG4gICdwYXN0JzogJ3tudW19IHt1bml0fSB7c2lnbn0nLFxuICAnZnV0dXJlJzogJ3tzaWdufSB7bnVtfSB7dW5pdH0nLFxuICAnZHVyYXRpb24nOiAne251bX0ge3VuaXR9JyxcbiAgJ2FtcG0nOiAnYW0scG0nLFxuICAnbW9kaWZpZXJzJzogW1xuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICdmw7ZycmfDpXJ8aSBmw7ZycmfDpXJ8aWbDtnJyZ8Olcnxmb3JyZ2FyfGkgZm9ycmdhcnxpZm9ycmdhcicsICd2YWx1ZSc6IC0yIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ2fDpXJ8aSBnw6VyfGlnw6VyfGdhcnxpIGdhcnxpZ2FyJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAnZGFnfGkgZGFnfGlkYWcnLCAndmFsdWUnOiAwIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ21vcmdvbnxpIG1vcmdvbnxpbW9yZ29uJywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfDtnZlciBtb3Jnb258w7Z2ZXJtb3Jnb258aSDDtnZlciBtb3Jnb258aSDDtnZlcm1vcmdvbnxpw7Z2ZXJtb3Jnb258b3ZlciBtb3Jnb258b3Zlcm1vcmdvbnxpIG92ZXIgbW9yZ29ufGkgb3Zlcm1vcmdvbnxpb3Zlcm1vcmdvbicsICd2YWx1ZSc6IDIgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ3NlZGFufHNlbicsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICdvbScsICd2YWx1ZSc6ICAxIH0sXG4gICAgeyAnbmFtZSc6ICdzaGlmdCcsICdzcmMnOiAnaSBmw7ZycmF8ZsO2cnJhfGkgZm9ycmF8Zm9ycmEnLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ2Rlbm5hJywgJ3ZhbHVlJzogMCB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ27DpHN0YXxuYXN0YScsICd2YWx1ZSc6IDEgfVxuICBdLFxuICAnZGF0ZVBhcnNlJzogW1xuICAgICd7bnVtfSB7dW5pdH0ge3NpZ259JyxcbiAgICAne3NpZ259IHtudW19IHt1bml0fScsXG4gICAgJ3sxP30ge251bX0ge3VuaXR9IHtzaWdufScsXG4gICAgJ3tzaGlmdH0ge3VuaXQ9NS03fSdcbiAgXSxcbiAgJ3RpbWVQYXJzZSc6IFtcbiAgICAnezA/fSB7d2Vla2RheT99IHtkYXRlP30ge21vbnRofSB7eWVhcn0nLFxuICAgICd7ZGF0ZX0ge21vbnRofScsXG4gICAgJ3tzaGlmdH0ge3dlZWtkYXl9J1xuICBdXG59KTtcblxuLypcbiAqXG4gKiBEYXRlLmFkZExvY2FsZSg8Y29kZT4pIGFkZHMgdGhpcyBsb2NhbGUgdG8gU3VnYXIuXG4gKiBUbyBzZXQgdGhlIGxvY2FsZSBnbG9iYWxseSwgc2ltcGx5IGNhbGw6XG4gKlxuICogRGF0ZS5zZXRMb2NhbGUoJ3poLUNOJyk7XG4gKlxuICogdmFyIGxvY2FsZSA9IERhdGUuZ2V0TG9jYWxlKDxjb2RlPikgd2lsbCByZXR1cm4gdGhpcyBvYmplY3QsIHdoaWNoXG4gKiBjYW4gYmUgdHdlYWtlZCB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBpbiB0aGUgbG9jYWxlcy5cbiAqXG4gKiBsb2NhbGUuYWRkRm9ybWF0IGFkZHMgYSBkYXRlIGZvcm1hdCAoc2VlIHRoaXMgZmlsZSBmb3IgZXhhbXBsZXMpLlxuICogU3BlY2lhbCB0b2tlbnMgaW4gdGhlIGRhdGUgZm9ybWF0IHdpbGwgYmUgcGFyc2VkIG91dCBpbnRvIHJlZ2V4IHRva2VuczpcbiAqXG4gKiB7MH0gaXMgYSByZWZlcmVuY2UgdG8gYW4gZW50cnkgaW4gbG9jYWxlLnRva2Vucy4gT3V0cHV0OiAoPzp0aGUpP1xuICoge3VuaXR9IGlzIGEgcmVmZXJlbmNlIHRvIGFsbCB1bml0cy4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGh8Li4uKVxuICoge3VuaXQzfSBpcyBhIHJlZmVyZW5jZSB0byBhIHNwZWNpZmljIHVuaXQuIE91dHB1dDogKGhvdXIpXG4gKiB7dW5pdDMtNX0gaXMgYSByZWZlcmVuY2UgdG8gYSBzdWJzZXQgb2YgdGhlIHVuaXRzIGFycmF5LiBPdXRwdXQ6IChob3VyfGRheXx3ZWVrKVxuICoge3VuaXQ/fSBcIj9cIiBtYWtlcyB0aGF0IHRva2VuIG9wdGlvbmFsLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aCk/XG4gKlxuICoge2RheX0gQW55IHJlZmVyZW5jZSB0byB0b2tlbnMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSB3aWxsIGluY2x1ZGUgYWxsIHdpdGggdGhlIHNhbWUgbmFtZS4gT3V0cHV0OiAoeWVzdGVyZGF5fHRvZGF5fHRvbW9ycm93KVxuICpcbiAqIEFsbCBzcGFjZXMgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBcIlxccypcIlxuICpcbiAqIExvY2FsZSBhcnJheXMgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIG51bWJlcnMsIGFzIHdlbGwgYXMgdGhlIFwic3JjXCIgZmllbGQgZm9yXG4gKiBhbGwgZW50cmllcyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IGZvbGxvdyBhIHNwZWNpYWwgZm9ybWF0IGluZGljYXRlZCBieSBhIGNvbG9uOlxuICpcbiAqIG1pbnV0ZTp8cyAgPSBtaW51dGV8bWludXRlc1xuICogdGhpY2tlOm58ciA9IHRoaWNrZW58dGhpY2tlclxuICpcbiAqIEFkZGl0aW9uYWxseSBpbiB0aGUgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIGFuZCBudW1iZXJzIGFycmF5IHRoZXNlIHdpbGwgYmUgYWRkZWQgYXQgaW5kZXhlcyB0aGF0IGFyZSBtdWx0aXBsZXNcbiAqIG9mIHRoZSByZWxldmFudCBudW1iZXIgZm9yIHJldHJpZXZhbC4gRm9yIGV4YW1wbGUgaGF2aW5nIFwic3VuZGF5OnxzXCIgaW4gdGhlIHVuaXRzIGFycmF5IHdpbGwgcmVzdWx0IGluOlxuICpcbiAqIHVuaXRzOiBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5JywgJ3N1bmRheXMnXVxuICpcbiAqIFdoZW4gbWF0Y2hlZCwgdGhlIGluZGV4IHdpbGwgYmUgZm91bmQgdXNpbmc6XG4gKlxuICogdW5pdHMuaW5kZXhPZihtYXRjaCkgJSA3O1xuICpcbiAqIFJlc3VsdGluZyBpbiB0aGUgY29ycmVjdCBpbmRleCB3aXRoIGFueSBudW1iZXIgb2YgYWx0ZXJuYXRlcyBmb3IgdGhhdCBlbnRyeS5cbiAqXG4gKi9cblxuRGF0ZS5hZGRMb2NhbGUoJ3poLUNOJywge1xuICAndmFyaWFudCc6IHRydWUsXG4gICdtb250aFN1ZmZpeCc6ICfmnIgnLFxuICAnd2Vla2RheXMnOiAn5pif5pyf5pelfOWRqOaXpSzmmJ/mnJ/kuIB85ZGo5LiALOaYn+acn+S6jHzlkajkuows5pif5pyf5LiJfOWRqOS4iSzmmJ/mnJ/lm5t85ZGo5ZubLOaYn+acn+S6lHzlkajkupQs5pif5pyf5YWtfOWRqOWFrScsXG4gICd1bml0cyc6ICfmr6vnp5Is56eS6ZKfLOWIhumSnyzlsI/ml7Ys5aSpLOS4quaYn+acn3zlkags5Liq5pyILOW5tCcsXG4gICd0b2tlbnMnOiAn5pelfOWPtycsXG4gICdzaG9ydCc6J3t5eXl5feW5tHtNfeaciHtkfeaXpScsXG4gICdsb25nJzogJ3t5eXl5feW5tHtNfeaciHtkfeaXpSB7dHR9e2h9OnttbX0nLFxuICAnZnVsbCc6ICd7eXl5eX3lubR7TX3mnIh7ZH3ml6Uge3dlZWtkYXl9IHt0dH17aH06e21tfTp7c3N9JyxcbiAgJ3Bhc3QnOiAne251bX17dW5pdH17c2lnbn0nLFxuICAnZnV0dXJlJzogJ3tudW19e3VuaXR9e3NpZ259JyxcbiAgJ2R1cmF0aW9uJzogJ3tudW19e3VuaXR9JyxcbiAgJ3RpbWVTdWZmaXhlcyc6ICfngrl85pe2LOWIhumSnz8s56eSJyxcbiAgJ2FtcG0nOiAn5LiK5Y2ILOS4i+WNiCcsXG4gICdtb2RpZmllcnMnOiBbXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ+WJjeWkqScsICd2YWx1ZSc6IC0yIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ+aYqOWkqScsICd2YWx1ZSc6IC0xIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ+S7iuWkqScsICd2YWx1ZSc6IDAgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAn5piO5aSpJywgJ3ZhbHVlJzogMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICflkI7lpKknLCAndmFsdWUnOiAyIH0sXG4gICAgeyAnbmFtZSc6ICdzaWduJywgJ3NyYyc6ICfliY0nLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAn5ZCOJywgJ3ZhbHVlJzogIDEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICfkuIp85Y67JywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICfov5knLCAndmFsdWUnOiAgMCB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ+S4i3zmmI4nLCAndmFsdWUnOiAgMSB9XG4gIF0sXG4gICdkYXRlUGFyc2UnOiBbXG4gICAgJ3tudW19e3VuaXR9e3NpZ259JyxcbiAgICAne3NoaWZ0fXt1bml0PTUtN30nXG4gIF0sXG4gICd0aW1lUGFyc2UnOiBbXG4gICAgJ3tzaGlmdH17d2Vla2RheX0nLFxuICAgICd7eWVhcn3lubR7bW9udGg/feaciD97ZGF0ZT99ezA/fScsXG4gICAgJ3ttb250aH3mnIh7ZGF0ZT99ezA/fScsXG4gICAgJ3tkYXRlfVvml6Xlj7ddJ1xuICBdXG59KTtcblxuLypcbiAqXG4gKiBEYXRlLmFkZExvY2FsZSg8Y29kZT4pIGFkZHMgdGhpcyBsb2NhbGUgdG8gU3VnYXIuXG4gKiBUbyBzZXQgdGhlIGxvY2FsZSBnbG9iYWxseSwgc2ltcGx5IGNhbGw6XG4gKlxuICogRGF0ZS5zZXRMb2NhbGUoJ3poLVRXJyk7XG4gKlxuICogdmFyIGxvY2FsZSA9IERhdGUuZ2V0TG9jYWxlKDxjb2RlPikgd2lsbCByZXR1cm4gdGhpcyBvYmplY3QsIHdoaWNoXG4gKiBjYW4gYmUgdHdlYWtlZCB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBpbiB0aGUgbG9jYWxlcy5cbiAqXG4gKiBsb2NhbGUuYWRkRm9ybWF0IGFkZHMgYSBkYXRlIGZvcm1hdCAoc2VlIHRoaXMgZmlsZSBmb3IgZXhhbXBsZXMpLlxuICogU3BlY2lhbCB0b2tlbnMgaW4gdGhlIGRhdGUgZm9ybWF0IHdpbGwgYmUgcGFyc2VkIG91dCBpbnRvIHJlZ2V4IHRva2VuczpcbiAqXG4gKiB7MH0gaXMgYSByZWZlcmVuY2UgdG8gYW4gZW50cnkgaW4gbG9jYWxlLnRva2Vucy4gT3V0cHV0OiAoPzp0aGUpP1xuICoge3VuaXR9IGlzIGEgcmVmZXJlbmNlIHRvIGFsbCB1bml0cy4gT3V0cHV0OiAoZGF5fHdlZWt8bW9udGh8Li4uKVxuICoge3VuaXQzfSBpcyBhIHJlZmVyZW5jZSB0byBhIHNwZWNpZmljIHVuaXQuIE91dHB1dDogKGhvdXIpXG4gKiB7dW5pdDMtNX0gaXMgYSByZWZlcmVuY2UgdG8gYSBzdWJzZXQgb2YgdGhlIHVuaXRzIGFycmF5LiBPdXRwdXQ6IChob3VyfGRheXx3ZWVrKVxuICoge3VuaXQ/fSBcIj9cIiBtYWtlcyB0aGF0IHRva2VuIG9wdGlvbmFsLiBPdXRwdXQ6IChkYXl8d2Vla3xtb250aCk/XG4gKlxuICoge2RheX0gQW55IHJlZmVyZW5jZSB0byB0b2tlbnMgaW4gdGhlIG1vZGlmaWVycyBhcnJheSB3aWxsIGluY2x1ZGUgYWxsIHdpdGggdGhlIHNhbWUgbmFtZS4gT3V0cHV0OiAoeWVzdGVyZGF5fHRvZGF5fHRvbW9ycm93KVxuICpcbiAqIEFsbCBzcGFjZXMgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBcIlxccypcIlxuICpcbiAqIExvY2FsZSBhcnJheXMgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIG51bWJlcnMsIGFzIHdlbGwgYXMgdGhlIFwic3JjXCIgZmllbGQgZm9yXG4gKiBhbGwgZW50cmllcyBpbiB0aGUgbW9kaWZpZXJzIGFycmF5IGZvbGxvdyBhIHNwZWNpYWwgZm9ybWF0IGluZGljYXRlZCBieSBhIGNvbG9uOlxuICpcbiAqIG1pbnV0ZTp8cyAgPSBtaW51dGV8bWludXRlc1xuICogdGhpY2tlOm58ciA9IHRoaWNrZW58dGhpY2tlclxuICpcbiAqIEFkZGl0aW9uYWxseSBpbiB0aGUgbW9udGhzLCB3ZWVrZGF5cywgdW5pdHMsIGFuZCBudW1iZXJzIGFycmF5IHRoZXNlIHdpbGwgYmUgYWRkZWQgYXQgaW5kZXhlcyB0aGF0IGFyZSBtdWx0aXBsZXNcbiAqIG9mIHRoZSByZWxldmFudCBudW1iZXIgZm9yIHJldHJpZXZhbC4gRm9yIGV4YW1wbGUgaGF2aW5nIFwic3VuZGF5OnxzXCIgaW4gdGhlIHVuaXRzIGFycmF5IHdpbGwgcmVzdWx0IGluOlxuICpcbiAqIHVuaXRzOiBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5JywgJ3N1bmRheXMnXVxuICpcbiAqIFdoZW4gbWF0Y2hlZCwgdGhlIGluZGV4IHdpbGwgYmUgZm91bmQgdXNpbmc6XG4gKlxuICogdW5pdHMuaW5kZXhPZihtYXRjaCkgJSA3O1xuICpcbiAqIFJlc3VsdGluZyBpbiB0aGUgY29ycmVjdCBpbmRleCB3aXRoIGFueSBudW1iZXIgb2YgYWx0ZXJuYXRlcyBmb3IgdGhhdCBlbnRyeS5cbiAqXG4gKi9cblxuICAvLyd6aC1UVyc6ICcxO+aciDvlubQ7O+aYn+acn+aXpXzpgLHml6Us5pif5pyf5LiAfOmAseS4gCzmmJ/mnJ/kuox86YCx5LqMLOaYn+acn+S4iXzpgLHkuIks5pif5pyf5ZubfOmAseWbmyzmmJ/mnJ/kupR86YCx5LqULOaYn+acn+WFrXzpgLHlha075q+r56eSLOenkumQmCzliIbpkJgs5bCP5pmCLOWkqSzlgIvmmJ/mnJ986YCxLOWAi+aciCzlubQ7Ozvml6V86JmfOzvkuIrljYgs5LiL5Y2IO+m7nnzmmYIs5YiG6ZCYPyznp5I7e251bX17dW5pdH17c2lnbn0se3NoaWZ0fXt1bml0PTUtN307e3NoaWZ0fXt3ZWVrZGF5fSx7eWVhcn3lubR7bW9udGg/feaciD97ZGF0ZT99ezB9LHttb250aH3mnIh7ZGF0ZT99ezB9LHtkYXRlfXswfTt7eXl5eX3lubR7TX3mnIh7ZH3ml6Uge1dlZWtkYXl9O3t0dH17aH06e21tfTp7c3N9O+WJjeWkqSzmmKjlpKks5LuK5aSpLOaYjuWkqSzlvozlpKk7LOWJjSws5b6MOyzkuIp85Y67LOmAmSzkuIt85piOJyxcblxuRGF0ZS5hZGRMb2NhbGUoJ3poLVRXJywge1xuICAnbW9udGhTdWZmaXgnOiAn5pyIJyxcbiAgJ3dlZWtkYXlzJzogJ+aYn+acn+aXpXzpgLHml6Us5pif5pyf5LiAfOmAseS4gCzmmJ/mnJ/kuox86YCx5LqMLOaYn+acn+S4iXzpgLHkuIks5pif5pyf5ZubfOmAseWbmyzmmJ/mnJ/kupR86YCx5LqULOaYn+acn+WFrXzpgLHlha0nLFxuICAndW5pdHMnOiAn5q+r56eSLOenkumQmCzliIbpkJgs5bCP5pmCLOWkqSzlgIvmmJ/mnJ986YCxLOWAi+aciCzlubQnLFxuICAndG9rZW5zJzogJ+aXpXzomZ8nLFxuICAnc2hvcnQnOid7eXl5eX3lubR7TX3mnIh7ZH3ml6UnLFxuICAnbG9uZyc6ICd7eXl5eX3lubR7TX3mnIh7ZH3ml6Uge3R0fXtofTp7bW19JyxcbiAgJ2Z1bGwnOiAne3l5eXl95bm0e0195pyIe2R95pelIHtXZWVrZGF5fSB7dHR9e2h9OnttbX06e3NzfScsXG4gICdwYXN0JzogJ3tudW19e3VuaXR9e3NpZ259JyxcbiAgJ2Z1dHVyZSc6ICd7bnVtfXt1bml0fXtzaWdufScsXG4gICdkdXJhdGlvbic6ICd7bnVtfXt1bml0fScsXG4gICd0aW1lU3VmZml4ZXMnOiAn6buefOaZgizliIbpkJg/LOenkicsXG4gICdhbXBtJzogJ+S4iuWNiCzkuIvljYgnLFxuICAnbW9kaWZpZXJzJzogW1xuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfliY3lpKknLCAndmFsdWUnOiAtMiB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfmmKjlpKknLCAndmFsdWUnOiAtMSB9LFxuICAgIHsgJ25hbWUnOiAnZGF5JywgJ3NyYyc6ICfku4rlpKknLCAndmFsdWUnOiAwIH0sXG4gICAgeyAnbmFtZSc6ICdkYXknLCAnc3JjJzogJ+aYjuWkqScsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ2RheScsICdzcmMnOiAn5b6M5aSpJywgJ3ZhbHVlJzogMiB9LFxuICAgIHsgJ25hbWUnOiAnc2lnbicsICdzcmMnOiAn5YmNJywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NpZ24nLCAnc3JjJzogJ+W+jCcsICd2YWx1ZSc6IDEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICfkuIp85Y67JywgJ3ZhbHVlJzogLTEgfSxcbiAgICB7ICduYW1lJzogJ3NoaWZ0JywgJ3NyYyc6ICfpgJknLCAndmFsdWUnOiAgMCB9LFxuICAgIHsgJ25hbWUnOiAnc2hpZnQnLCAnc3JjJzogJ+S4i3zmmI4nLCAndmFsdWUnOiAgMSB9XG4gIF0sXG4gICdkYXRlUGFyc2UnOiBbXG4gICAgJ3tudW19e3VuaXR9e3NpZ259JyxcbiAgICAne3NoaWZ0fXt1bml0PTUtN30nXG4gIF0sXG4gICd0aW1lUGFyc2UnOiBbXG4gICAgJ3tzaGlmdH17d2Vla2RheX0nLFxuICAgICd7eWVhcn3lubR7bW9udGg/feaciD97ZGF0ZT99ezA/fScsXG4gICAgJ3ttb250aH3mnIh7ZGF0ZT99ezA/fScsXG4gICAgJ3tkYXRlfVvml6XomZ9dJ1xuICBdXG59KTtcblxuXG59KS5jYWxsKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8vIHJlcXVpcmUoJ2FuZ3VsYXItYXJpYScpO1xuLy8gcmVxdWlyZSgnYW5ndWxhci1tZXNzYWdlcycpO1xucmVxdWlyZSgnbmctYW5ub3RhdGUnKTtcbnJlcXVpcmUoJ2ZpcmViYXNlJyk7XG5yZXF1aXJlKCdhbmd1bGFyZmlyZS9kaXN0L2FuZ3VsYXJmaXJlJyk7XG5yZXF1aXJlKCdzdWdhci9yZWxlYXNlL3N1Z2FyLWZ1bGwuZGV2ZWxvcG1lbnQnKTtcblxuLy8gSW9uaWMgU3RhcnRlciBBcHBcblxuLy8gYW5ndWxhci5tb2R1bGUgaXMgYSBnbG9iYWwgcGxhY2UgZm9yIGNyZWF0aW5nLCByZWdpc3RlcmluZyBhbmQgcmV0cmlldmluZyBBbmd1bGFyIG1vZHVsZXNcbi8vICdzdGFydGVyJyBpcyB0aGUgbmFtZSBvZiB0aGlzIGFuZ3VsYXIgbW9kdWxlIGV4YW1wbGUgKGFsc28gc2V0IGluIGEgPGJvZHk+IGF0dHJpYnV0ZSBpbiBpbmRleC5odG1sKVxuLy8gdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2YgJ3JlcXVpcmVzJ1xuLy8gJ3N0YXJ0ZXIuc2VydmljZXMnIGlzIGZvdW5kIGluIHNlcnZpY2VzLmpzXG4vLyAnc3RhcnRlci5jb250cm9sbGVycycgaXMgZm91bmQgaW4gY29udHJvbGxlcnMuanNcbmFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbXG4gICdpb25pYycsXG4gICdmaXJlYmFzZScsXG4gIHJlcXVpcmUoJy4vY29udHJvbGxlcnMnKS5uYW1lLFxuICByZXF1aXJlKCcuL3JvdXRlcycpLm5hbWUsXG4gIC8vICdhcHAuc2VydmljZXMnLFxuICAvLyAnYXBwLmRpcmVjdGl2ZXMnXG5dKVxuXG4ucnVuKGZ1bmN0aW9uKCRpb25pY1BsYXRmb3JtKSB7XG4gICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgIC8vIEhpZGUgdGhlIGFjY2Vzc29yeSBiYXIgYnkgZGVmYXVsdCAocmVtb3ZlIHRoaXMgdG8gc2hvdyB0aGUgYWNjZXNzb3J5IGJhciBhYm92ZSB0aGUga2V5Ym9hcmRcbiAgICAvLyBmb3IgZm9ybSBpbnB1dHMpXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMgJiYgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCkge1xuICAgICAgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmhpZGVLZXlib2FyZEFjY2Vzc29yeUJhcih0cnVlKTtcbiAgICAgIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5kaXNhYmxlU2Nyb2xsKHRydWUpO1xuICAgIH1cbiAgICBpZiAod2luZG93LlN0YXR1c0Jhcikge1xuICAgICAgLy8gb3JnLmFwYWNoZS5jb3Jkb3ZhLnN0YXR1c2JhciByZXF1aXJlZFxuICAgICAgU3RhdHVzQmFyLnN0eWxlRGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG59KSIsIm1vZHVsZS5leHBvcnRzID0gYW5ndWxhci5tb2R1bGUoJ2FwcC5jb250cm9sbGVycycsIFtdKVxuICBcbi5jb250cm9sbGVyKCdoYXNobm90ZUN0cmwnLCBmdW5jdGlvbigkc2NvcGUpIHtcblxufSlcbiAgIFxuLmNvbnRyb2xsZXIoJ25ld05vdGVDdHJsJywgZnVuY3Rpb24oJHNjb3BlKSB7XG5cbn0pXG4gICBcbi5jb250cm9sbGVyKCdteVRhZ3NDdHJsJywgZnVuY3Rpb24oJHNjb3BlKSB7XG5cbn0pXG5cbi5jb250cm9sbGVyKCdsb2dpbkN0cmwnLCBmdW5jdGlvbigkc2NvcGUpIHtcblxufSlcbiAgICAiLCJtb2R1bGUuZXhwb3J0cyA9IGFuZ3VsYXIubW9kdWxlKCdhcHAucm91dGVzJywgW10pXG5cbi5jb25maWcoZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICR1cmxSb3V0ZXJQcm92aWRlcikge1xuXG4gIC8vIElvbmljIHVzZXMgQW5ndWxhclVJIFJvdXRlciB3aGljaCB1c2VzIHRoZSBjb25jZXB0IG9mIHN0YXRlc1xuICAvLyBMZWFybiBtb3JlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlclxuICAvLyBTZXQgdXAgdGhlIHZhcmlvdXMgc3RhdGVzIHdoaWNoIHRoZSBhcHAgY2FuIGJlIGluLlxuICAvLyBFYWNoIHN0YXRlJ3MgY29udHJvbGxlciBjYW4gYmUgZm91bmQgaW4gY29udHJvbGxlcnMuanNcbiAgJHN0YXRlUHJvdmlkZXJcbiAgLnN0YXRlKCdtZW51LmxvZ2luJywge1xuICAgIHVybDogJy9sb2dpbicsXG4gICAgdmlld3M6IHtcbiAgICAgICdsb2dpbic6IHtcbiAgICAgICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvbG9naW4uaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdsb2dpbkN0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuICAuc3RhdGUoJ21lbnUuaGFzaG5vdGUnLCB7XG4gICAgdXJsOiAnL3BhZ2UxJyxcbiAgICB2aWV3czoge1xuICAgICAgJ3NpZGUtbWVudTIxJzoge1xuICAgICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9oYXNobm90ZS5odG1sJyxcbiAgICAgICAgY29udHJvbGxlcjogJ2hhc2hub3RlQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdtZW51Lm5ld05vdGUnLCB7XG4gICAgdXJsOiAnL3BhZ2UyJyxcbiAgICB2aWV3czoge1xuICAgICAgJ3NpZGUtbWVudTIxJzoge1xuICAgICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9uZXdOb3RlLmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyOiAnbmV3Tm90ZUN0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC5zdGF0ZSgnbWVudS5teVRhZ3MnLCB7XG4gICAgdXJsOiAnL3BhZ2UzJyxcbiAgICB2aWV3czoge1xuICAgICAgJ3NpZGUtbWVudTIxJzoge1xuICAgICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9teVRhZ3MuaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdteVRhZ3NDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAuc3RhdGUoJ21lbnUnLCB7XG4gICAgdXJsOiAnL3NpZGUtbWVudTIxJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9tZW51Lmh0bWwnLFxuICAgIGFic3RyYWN0OnRydWVcbiAgfSlcblxuJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL2xvZ2luL2xvZ2luJylcblxufSk7Il19
